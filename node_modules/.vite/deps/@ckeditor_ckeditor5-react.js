import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __commonJS
} from "./chunk-DC5AMYBS.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/@ckeditor/ckeditor5-react/dist/index.js
var require_dist = __commonJS({
  "node_modules/@ckeditor/ckeditor5-react/dist/index.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(require_react(), require_prop_types()) : "function" == typeof define && define.amd ? define(["react", "prop-types"], e) : "object" == typeof exports ? exports.CKEditor = e(require_react(), require_prop_types()) : t.CKEditor = e(t.react, t["prop-types"]);
    }(self, (t, e) => (() => {
      "use strict";
      var o = { 949: (t2) => {
        t2.exports = e;
      }, 155: (e2) => {
        e2.exports = t;
      } }, r = {};
      function n(t2) {
        var e2 = r[t2];
        if (void 0 !== e2) return e2.exports;
        var a2 = r[t2] = { exports: {} };
        return o[t2](a2, a2.exports, n), a2.exports;
      }
      n.n = (t2) => {
        var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
        return n.d(e2, { a: e2 }), e2;
      }, n.d = (t2, e2) => {
        for (var o2 in e2) n.o(e2, o2) && !n.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: e2[o2] });
      }, n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), n.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var a = {};
      return (() => {
        n.r(a), n.d(a, { CKEditor: () => l, CKEditorContext: () => c, useMultiRootEditor: () => R });
        var t2 = n(155), e2 = n.n(t2), o2 = n(949), r2 = n.n(o2);
        const i = new Array(256).fill("").map((t3, e3) => ("0" + e3.toString(16)).slice(-2));
        const s = e2().createContext("contextWatchdog");
        class c extends e2().Component {
          constructor(t3, e3) {
            super(t3, e3), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);
          }
          shouldComponentUpdate(t3) {
            return this._shouldComponentUpdate(t3);
          }
          async _shouldComponentUpdate(t3) {
            return t3.id !== this.props.id && (this.contextWatchdog && await this.contextWatchdog.destroy(), await this._initializeContextWatchdog(t3.config)), t3.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t3.config), true) : this.props.children !== t3.children;
          }
          render() {
            return e2().createElement(s.Provider, { value: this.contextWatchdog }, this.props.children);
          }
          componentWillUnmount() {
            this._destroyContext();
          }
          async _initializeContextWatchdog(t3) {
            this.contextWatchdog = new this.props.contextWatchdog(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on("error", (t4, e3) => {
              this.props.onError(e3.error, { phase: "runtime", willContextRestart: e3.causesRestart });
            }), this.contextWatchdog.on("stateChange", () => {
              "ready" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);
            }), await this.contextWatchdog.create(t3).catch((t4) => {
              this.props.onError(t4, { phase: "initialization", willContextRestart: false });
            });
          }
          async _destroyContext() {
            this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);
          }
        }
        c.defaultProps = { isLayoutReady: true, onError: (t3, e3) => console.error(t3, e3) }, c.propTypes = { id: r2().string, isLayoutReady: r2().bool, context: r2().func, watchdogConfig: r2().object, config: r2().object, onReady: r2().func, onError: r2().func };
        class u {
          constructor(t3, e3) {
            this._releaseLock = null, this._value = null, this._afterMountCallbacks = [], this._state = { destroyedBeforeInitialization: false, mountingInProgress: null }, this.release = /* @__PURE__ */ function(t4) {
              let e4 = null;
              return (...o3) => (e4 || (e4 = { current: t4(...o3) }), e4.current);
            }(() => {
              const { _releaseLock: t4, _state: e4, _element: o3, _lifecycle: r3 } = this;
              e4.mountingInProgress ? e4.mountingInProgress.then(() => r3.unmount({ element: o3, mountResult: this.value })).catch((t5) => {
                console.error("Semaphore unmounting error:", t5);
              }).then(t4.resolve).then(() => {
                this._value = null;
              }) : (e4.destroyedBeforeInitialization = true, t4.resolve());
            }), this._element = t3, this._lifecycle = e3, this._lock();
          }
          get value() {
            return this._value;
          }
          unsafeSetValue(t3) {
            this._value = t3, this._afterMountCallbacks.forEach((e3) => e3(t3)), this._afterMountCallbacks = [];
          }
          runAfterMount(t3) {
            const { _value: e3, _afterMountCallbacks: o3 } = this;
            e3 ? t3(e3) : o3.push(t3);
          }
          _lock() {
            const { _semaphores: t3 } = u, { _state: e3, _element: o3, _lifecycle: r3 } = this, n2 = t3.get(o3) || Promise.resolve(null), a2 = function() {
              const t4 = { resolve: null, promise: null };
              return t4.promise = new Promise((e4) => {
                t4.resolve = e4;
              }), t4;
            }();
            this._releaseLock = a2;
            const i2 = n2.then(() => e3.destroyedBeforeInitialization ? Promise.resolve(void 0) : (e3.mountingInProgress = r3.mount().then((t4) => (t4 && this.unsafeSetValue(t4), t4)), e3.mountingInProgress)).then(async (t4) => {
              t4 && r3.afterMount && await r3.afterMount({ element: o3, mountResult: t4 });
            }).then(() => a2.promise).catch((t4) => {
              console.error("Semaphore mounting error:", t4);
            }).then(() => {
              t3.get(o3) === i2 && t3.delete(o3);
            });
            t3.set(o3, i2);
          }
        }
        u._semaphores = /* @__PURE__ */ new Map();
        const d = "Lock from React integration (@ckeditor/ckeditor5-react)";
        class l extends e2().Component {
          constructor(t3) {
            super(t3), this.domContainer = e2().createRef(), this.editorSemaphore = null, this._checkVersion();
          }
          _checkVersion() {
            const { CKEDITOR_VERSION: t3 } = window;
            if (!t3) return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
            const [e3] = t3.split(".").map(Number);
            e3 >= 42 || t3.startsWith("0.0.0") || console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.");
          }
          get _semaphoreValue() {
            const { editorSemaphore: t3 } = this;
            return t3 ? t3.value : null;
          }
          get watchdog() {
            const { _semaphoreValue: t3 } = this;
            return t3 ? t3.watchdog : null;
          }
          get editor() {
            const { _semaphoreValue: t3 } = this;
            return t3 ? t3.instance : null;
          }
          shouldComponentUpdate(t3) {
            const { props: e3, editorSemaphore: o3 } = this;
            return t3.id !== e3.id || (t3.disableWatchdog !== e3.disableWatchdog || (o3 && (o3.runAfterMount(({ instance: o4 }) => {
              this._shouldUpdateEditorData(e3, t3, o4) && o4.data.set(t3.data);
            }), "disabled" in t3 && o3.runAfterMount(({ instance: e4 }) => {
              t3.disabled ? e4.enableReadOnlyMode(d) : e4.disableReadOnlyMode(d);
            })), false));
          }
          componentDidMount() {
            this._initLifeCycleSemaphore();
          }
          componentDidUpdate() {
            this._initLifeCycleSemaphore();
          }
          componentWillUnmount() {
            this._unlockLifeCycleSemaphore();
          }
          _unlockLifeCycleSemaphore() {
            this.editorSemaphore && (this.editorSemaphore.release(), this.editorSemaphore = null);
          }
          _initLifeCycleSemaphore() {
            this._unlockLifeCycleSemaphore(), this.editorSemaphore = new u(this.domContainer.current, { mount: async () => this._initializeEditor(), afterMount: ({ mountResult: t3 }) => {
              const { onReady: e3 } = this.props;
              e3 && null !== this.domContainer.current && e3(t3.instance);
            }, unmount: async ({ element: t3, mountResult: e3 }) => {
              const { onAfterDestroy: o3 } = this.props;
              try {
                await this._destroyEditor(e3), t3.innerHTML = "";
              } finally {
                o3 && o3(e3.instance);
              }
            } });
          }
          render() {
            return e2().createElement("div", { ref: this.domContainer });
          }
          async _initializeEditor() {
            if (this.props.disableWatchdog) {
              return { instance: await this._createEditor(this.domContainer.current, this._getConfig()), watchdog: null };
            }
            const t3 = (() => this.context instanceof this.props.editor.ContextWatchdog ? new h(this.context) : new this.props.editor.EditorWatchdog(this.props.editor, this.props.watchdogConfig))(), e3 = { current: 0 };
            return t3.setCreator(async (o3, r3) => {
              const { editorSemaphore: n2 } = this, { onAfterDestroy: a2 } = this.props;
              e3.current > 0 && a2 && n2 && n2.value && n2.value.instance && a2(n2.value.instance);
              const i2 = await this._createEditor(o3, r3);
              return e3.current > 0 && (n2.unsafeSetValue({ instance: i2, watchdog: t3 }), setTimeout(() => {
                this.props.onReady && this.props.onReady(t3.editor);
              })), e3.current++, i2;
            }), t3.on("error", (t4, { error: e4, causesRestart: o3 }) => {
              (this.props.onError || console.error)(e4, { phase: "runtime", willEditorRestart: o3 });
            }), await t3.create(this.domContainer.current, this._getConfig()).catch((t4) => {
              (this.props.onError || console.error)(t4, { phase: "initialization", willEditorRestart: false });
            }), { watchdog: t3, instance: t3.editor };
          }
          _createEditor(t3, e3) {
            return this.props.editor.create(t3, e3).then((t4) => {
              "disabled" in this.props && this.props.disabled && t4.enableReadOnlyMode(d);
              const e4 = t4.model.document, o3 = t4.editing.view.document;
              return e4.on("change:data", (e5) => {
                this.props.onChange && this.props.onChange(e5, t4);
              }), o3.on("focus", (e5) => {
                this.props.onFocus && this.props.onFocus(e5, t4);
              }), o3.on("blur", (e5) => {
                this.props.onBlur && this.props.onBlur(e5, t4);
              }), t4;
            });
          }
          async _destroyEditor(t3) {
            const { watchdog: e3, instance: o3 } = t3;
            return new Promise((t4, r3) => {
              setTimeout(async () => {
                try {
                  if (e3) return await e3.destroy(), t4();
                  if (o3) return await o3.destroy(), t4();
                  t4();
                } catch (t5) {
                  console.error(t5), r3(t5);
                }
              });
            });
          }
          _shouldUpdateEditorData(t3, e3, o3) {
            return t3.data !== e3.data && o3.data.get() !== e3.data;
          }
          _getConfig() {
            const t3 = this.props.config || {};
            return this.props.data && t3.initialData && console.warn("Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified."), { ...t3, initialData: t3.initialData || this.props.data || "" };
          }
        }
        l.contextType = s, l.propTypes = { editor: r2().func.isRequired, data: r2().string, config: r2().object, disableWatchdog: r2().bool, watchdogConfig: r2().object, onChange: r2().func, onReady: r2().func, onFocus: r2().func, onBlur: r2().func, onError: r2().func, disabled: r2().bool, id: r2().any };
        class h {
          constructor(t3) {
            this._contextWatchdog = t3, this._id = function() {
              const t4 = 4294967296 * Math.random() >>> 0, e3 = 4294967296 * Math.random() >>> 0, o3 = 4294967296 * Math.random() >>> 0, r3 = 4294967296 * Math.random() >>> 0;
              return "e" + i[255 & t4] + i[t4 >> 8 & 255] + i[t4 >> 16 & 255] + i[t4 >> 24 & 255] + i[255 & e3] + i[e3 >> 8 & 255] + i[e3 >> 16 & 255] + i[e3 >> 24 & 255] + i[255 & o3] + i[o3 >> 8 & 255] + i[o3 >> 16 & 255] + i[o3 >> 24 & 255] + i[255 & r3] + i[r3 >> 8 & 255] + i[r3 >> 16 & 255] + i[r3 >> 24 & 255];
            }();
          }
          setCreator(t3) {
            this._creator = t3;
          }
          create(t3, e3) {
            return this._contextWatchdog.add({ sourceElementOrData: t3, config: e3, creator: this._creator, id: this._id, type: "editor" });
          }
          on(t3, e3) {
            this._contextWatchdog.on("itemError", (t4, { itemId: o3, error: r3 }) => {
              o3 === this._id && e3(null, { error: r3, causesRestart: void 0 });
            });
          }
          destroy() {
            return "ready" === this._contextWatchdog.state ? this._contextWatchdog.remove(this._id) : Promise.resolve();
          }
          get editor() {
            return this._contextWatchdog.getItem(this._id);
          }
        }
        function p(...t3) {
          return (e3) => {
            t3.forEach((t4) => {
              "function" == typeof t4 ? t4(e3) : null != t4 && (t4.current = e3);
            });
          };
        }
        function f(t3, e3) {
          for (const t4 of Object.getOwnPropertyNames(e3)) delete e3[t4];
          for (const [o3, r3] of Object.entries(t3)) r3 !== e3 && "prototype" !== o3 && "__proto__" !== o3 && (e3[o3] = r3);
          return e3;
        }
        const m = (e3) => {
          const o3 = (0, t2.useRef)();
          return o3.current = e3, (0, t2.useCallback)((...t3) => o3.current(...t3), []);
        };
        function g(t3, e3) {
          return e3.length = 0, e3.push(...t3), e3;
        }
        const y = (e3, o3, r3) => {
          ((e4, o4) => {
            const r4 = (0, t2.useRef)(null);
            ((t3, e5) => {
              if (t3 === e5) return true;
              if (!t3 || !e5) return false;
              for (let o5 = 0; o5 < t3.length; ++o5) if (t3[o5] !== e5[o5]) return false;
              return true;
            })(r4.current, o4) || (r4.current = [...o4], e4());
          })(() => {
            e3 && e3.runAfterMount(o3);
          }, [e3, ...r3]);
        }, b = "Lock from React integration (@ckeditor/ckeditor5-react)", w = (0, t2.memo)((0, t2.forwardRef)(({ id: o3, semaphore: r3, rootName: n2 }, a2) => {
          const i2 = (0, t2.useRef)(null);
          return (0, t2.useEffect)(() => {
            let t3, e3;
            return r3.runAfterMount(({ instance: o4 }) => {
              i2.current && (e3 = o4, t3 = o4.ui.view.createEditable(n2, i2.current), o4.ui.addEditable(t3), o4.editing.view.forceRender());
            }), () => {
              t3 && i2.current && e3 && "destroyed" !== e3.state && e3.ui.removeEditable(t3);
            };
          }, [r3.revision]), e2().createElement("div", { key: r3.revision, id: o3, ref: p(a2, i2) });
        }));
        w.displayName = "EditorEditable";
        const _ = (0, t2.forwardRef)(({ editor: o3 }, r3) => {
          const n2 = (0, t2.useRef)(null);
          return (0, t2.useEffect)(() => {
            const t3 = n2.current;
            if (!o3 || !t3) return;
            const e3 = o3.ui.view.toolbar.element;
            return t3 && t3.appendChild(e3), () => {
              t3 && t3.removeChild(e3);
            };
          }, [o3 && o3.id]), e2().createElement("div", { ref: p(n2, r3) });
        });
        _.displayName = "EditorToolbarWrapper";
        const R = (o3) => {
          const r3 = (0, t2.useRef)(o3.semaphoreElement || null), n2 = (() => {
            const e3 = (0, t2.useRef)(null), [o4, r4] = (0, t2.useState)(() => Date.now()), n3 = () => {
              r4(Date.now());
            }, a3 = (t3 = true) => {
              e3.current && (e3.current.release(), e3.current = null), t3 && r4(Date.now());
            }, i3 = (t3) => {
              e3.current && e3.current.runAfterMount(t3);
            };
            return { get current() {
              return e3.current;
            }, revision: o4, createAttributeRef: (t3) => ({ get current() {
              return e3.current && e3.current.value ? e3.current.value[t3] : null;
            } }), unsafeSetValue: (t3) => {
              var o5;
              null === (o5 = e3.current) || void 0 === o5 || o5.unsafeSetValue(t3), n3();
            }, release: a3, replace: (t3) => {
              a3(false), e3.current = t3(), n3(), i3(n3);
            }, runAfterMount: i3 };
          })(), a2 = { watchdog: n2.createAttributeRef("watchdog"), instance: n2.createAttributeRef("instance") }, i2 = (0, t2.useContext)(s), [c2, d2] = (0, t2.useState)(() => Object.keys(o3.data)), [l2, p2] = (0, t2.useState)({ ...o3.data }), [R2, C] = (0, t2.useState)({ ...o3.rootsAttributes }), v = (0, t2.useRef)(true);
          (0, t2.useEffect)(() => {
            const t3 = r3.current;
            if (t3 && false !== o3.isLayoutReady) return n2.replace(() => new u(t3, { mount: O, afterMount: ({ mountResult: t4 }) => {
              const { onReady: e3 } = o3;
              e3 && null !== r3.current && e3(t4.instance);
            }, unmount: async ({ element: t4, mountResult: e3 }) => {
              const { onAfterDestroy: r4 } = o3;
              try {
                await M(e3), t4.innerHTML = "";
              } finally {
                r4 && r4(e3.instance);
              }
            } })), () => {
              n2.release(false);
            };
          }, [o3.id, o3.isLayoutReady]);
          const E = () => {
            const t3 = o3.config || {};
            return o3.data && t3.initialData && console.warn("Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified."), { ...t3, rootsAttributes: R2 };
          }, x = m((t3, e3) => {
            const r4 = t3.model.document;
            if (!o3.disableTwoWayDataBinding) {
              const e4 = {}, o4 = {};
              r4.differ.getChanges().forEach((o5) => {
                let r5;
                if (r5 = "insert" == o5.type || "remove" == o5.type ? o5.position.root : o5.range.root, !r5.isAttached()) return;
                const { rootName: n3 } = r5;
                e4[n3] = t3.getData({ rootName: n3 });
              }), r4.differ.getChangedRoots().forEach((r5) => {
                if (r5.state) return void (void 0 !== e4[r5.name] && delete e4[r5.name]);
                const n3 = r5.name;
                o4[n3] = t3.getRootAttributes(n3);
              }), Object.keys(e4).length && p2((t4) => ({ ...t4, ...e4 })), Object.keys(o4).length && C((t4) => ({ ...t4, ...o4 }));
            }
            o3.onChange && o3.onChange(e3, t3);
          }), W = m((t3, e3, r4) => {
            const n3 = r4.rootName;
            o3.disableTwoWayDataBinding || (p2((e4) => ({ ...e4, [n3]: t3.getData({ rootName: n3 }) })), C((e4) => ({ ...e4, [n3]: t3.getRootAttributes(n3) }))), d2((t4) => {
              return e4 = [...t4, r4.rootName], Array.from(new Set(e4));
              var e4;
            });
          }), k = m((t3, e3, r4) => {
            const n3 = r4.rootName;
            o3.disableTwoWayDataBinding || (p2((t4) => {
              const { [n3]: e4, ...o4 } = t4;
              return { ...o4 };
            }), C((t4) => {
              const { [n3]: e4, ...o4 } = t4;
              return { ...o4 };
            })), d2((t4) => t4.filter((t5) => t5 !== n3));
          }), S = m((t3, e3) => (f({ ...o3.rootsAttributes }, R2), f({ ...o3.data }, l2), g(Object.keys(o3.data), c2), o3.editor.create(t3, e3).then((t4) => {
            const e4 = t4.getFullData();
            f({ ...e4 }, l2), f({ ...t4.getRootsAttributes() }, R2), g(Object.keys(e4), c2), o3.disabled && t4.enableReadOnlyMode(b);
            const r4 = t4.model.document, n3 = t4.editing.view.document;
            return r4.on("change:data", (e5) => x(t4, e5)), t4.on("addRoot", (e5, o4) => W(t4, e5, o4)), t4.on("detachRoot", (e5, o4) => k(t4, e5, o4)), n3.on("focus", (e5) => {
              o3.onFocus && o3.onFocus(e5, t4);
            }), n3.on("blur", (e5) => {
              o3.onBlur && o3.onBlur(e5, t4);
            }), t4;
          }))), M = (t3) => {
            const { watchdog: e3, instance: o4 } = t3;
            return new Promise((t4, r4) => {
              setTimeout(async () => {
                try {
                  if (e3) return await e3.destroy(), t4();
                  if (o4) return await o4.destroy(), t4();
                  t4();
                } catch (t5) {
                  console.error(t5), r4(t5);
                }
              });
            });
          }, O = async () => {
            if (o3.disableWatchdog) {
              return { instance: await S(o3.data, E()), watchdog: null };
            }
            const t3 = i2 instanceof o3.editor.ContextWatchdog ? new h(i2) : new o3.editor.EditorWatchdog(o3.editor, o3.watchdogConfig), e3 = { current: 0 };
            return t3.setCreator(async (r4, i3) => {
              const { onAfterDestroy: s2 } = o3;
              e3.current > 0 && s2 && a2.instance.current && s2(a2.instance.current);
              const c3 = await S(r4, i3);
              return e3.current > 0 && (n2.unsafeSetValue({ instance: c3, watchdog: t3 }), setTimeout(() => {
                o3.onReady && o3.onReady(t3.editor);
              })), e3.current++, c3;
            }), t3.on("error", (t4, { error: e4, causesRestart: r4 }) => {
              (o3.onError || console.error)(e4, { phase: "runtime", willEditorRestart: r4 });
            }), await t3.create(l2, E()).catch((t4) => {
              throw (o3.onError || console.error)(t4, { phase: "initialization", willEditorRestart: false }), t4;
            }), { watchdog: t3, instance: t3.editor };
          }, A = (0, t2.useCallback)((t3) => {
            n2.runAfterMount(() => {
              v.current = true, p2(t3);
            });
          }, [p2]), D = (0, t2.useCallback)((t3) => {
            n2.runAfterMount(() => {
              v.current = true, C(t3);
            });
          }, [C]), j = e2().createElement(_, { ref: r3, editor: a2.instance.current });
          y(n2.current, ({ instance: t3 }) => {
            o3.disabled ? t3.enableReadOnlyMode(b) : t3.disableReadOnlyMode(b);
          }, [o3.disabled]), y(n2.current, ({ instance: t3 }) => {
            if (v.current) {
              v.current = false;
              const e3 = Object.keys(l2), o4 = Object.keys(R2);
              if (!e3.every((t4) => o4.includes(t4))) throw console.error("`data` and `attributes` objects must have the same keys (roots)."), new Error("`data` and `attributes` objects must have the same keys (roots).");
              const r4 = t3.getFullData(), n3 = t3.getRootsAttributes(), { addedKeys: a3, removedKeys: i3 } = ((t4, e4) => {
                const o5 = Object.keys(t4), r5 = Object.keys(e4);
                return { addedKeys: r5.filter((t5) => !o5.includes(t5)), removedKeys: o5.filter((t5) => !r5.includes(t5)) };
              })(r4, l2 || {}), s2 = e3.some((t4) => void 0 !== r4[t4] && JSON.stringify(r4[t4]) !== JSON.stringify(l2[t4])), c3 = o4.filter((t4) => JSON.stringify(n3[t4]) !== JSON.stringify(R2[t4])), u2 = (e4) => {
                e4.forEach((e5) => {
                  t3.addRoot(e5, { data: l2[e5] || "", attributes: (null == R2 ? void 0 : R2[e5]) || {}, isUndoable: true });
                });
              }, d3 = (e4) => {
                e4.forEach((e5) => {
                  t3.detachRoot(e5, true);
                });
              }, h2 = () => {
                t3.data.set(l2, { suppressErrorInCollaboration: true });
              }, p3 = (e4, o5) => {
                o5.forEach((o6) => {
                  Object.keys(R2[o6]).forEach((e5) => {
                    t3.registerRootAttribute(e5);
                  }), e4.clearAttributes(t3.model.document.getRoot(o6)), e4.setAttributes(R2[o6], t3.model.document.getRoot(o6));
                });
              };
              setTimeout(() => {
                t3.model.change((t4) => {
                  u2(a3), d3(i3), s2 && h2(), c3.length && p3(t4, c3);
                });
              });
            }
          }, [l2, R2]);
          const T = c2.map((t3) => e2().createElement(w, { key: t3, id: t3, rootName: t3, semaphore: n2 }));
          return { editor: a2.instance.current, editableElements: T, toolbarElement: j, data: l2, setData: A, attributes: R2, setAttributes: D };
        };
      })(), a;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@ckeditor/ckeditor5-react/dist/index.js:
  (*!
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-react.js.map
