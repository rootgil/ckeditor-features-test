import {
  AccessibilityHelp,
  AttributeElement,
  AttributeOperation,
  AutocompleteView,
  BalloonPanelView,
  BalloonToolbar,
  BlockToolbar,
  BodyCollection,
  BoxedEditorUIView,
  BubblingEventInfo,
  ButtonLabelView,
  ButtonLabelWithHighlightView,
  ButtonView,
  CKEditorError,
  ClickObserver,
  Clipboard,
  ClipboardMarkersUtils,
  ClipboardPipeline,
  CollapsibleView,
  Collection,
  ColorGridView,
  ColorPickerView,
  ColorSelectorView,
  ColorTileView,
  Command,
  ComponentFactory,
  Config,
  ContainerElement,
  Context,
  ContextPlugin,
  ContextWatchdog,
  ContextualBalloon,
  Conversion,
  CssTransitionDisablerMixin,
  DataApiMixin,
  DataController,
  DataTransfer,
  DefaultMenuBarItems,
  Delete,
  Dialog,
  DialogView,
  DialogViewPosition,
  Document$1,
  DocumentFragment,
  DocumentFragment$1,
  DocumentSelection,
  DomConverter,
  DomEmitterMixin,
  DomEventData,
  DomEventObserver,
  DowncastWriter,
  DragDrop,
  DragDropBlockToolbar,
  DragDropTarget,
  DropdownButtonView,
  DropdownMenuListItemButtonView,
  DropdownMenuListItemView,
  DropdownMenuListView,
  DropdownMenuNestedMenuView,
  DropdownMenuPanelPositioningFunctions,
  DropdownMenuRootListView,
  DropdownPanelView,
  DropdownView,
  EditableElement,
  EditingController,
  Editor,
  EditorUI,
  EditorUIView,
  EditorWatchdog,
  Element,
  Element$1,
  ElementApiMixin,
  ElementReplacer,
  EmitterMixin,
  EmptyElement,
  Enter,
  EventInfo,
  FileDialogButtonView,
  FileDialogListItemButtonView,
  FocusCycler,
  FocusObserver,
  FocusTracker,
  FormHeaderView,
  HighlightedTextView,
  History,
  HtmlDataProcessor,
  IconView,
  IframeView,
  InlineEditableUIView,
  Input,
  InputNumberView,
  InputTextView,
  InputView,
  InsertOperation,
  InsertTextCommand,
  KeystrokeHandler,
  LabelView,
  LabelWithHighlightView,
  LabeledFieldView,
  ListItemButtonView,
  ListItemGroupView,
  ListItemView,
  ListSeparatorView,
  ListView,
  LivePosition,
  LiveRange,
  Locale,
  MSWordNormalizer,
  MarkerOperation,
  Matcher,
  MenuBarMenuListItemButtonView,
  MenuBarMenuListItemFileDialogButtonView,
  MenuBarMenuListItemView,
  MenuBarMenuListView,
  MenuBarMenuView,
  MenuBarView,
  MergeOperation,
  Model,
  Model2,
  MouseObserver,
  MoveOperation,
  MultiCommand,
  NoOperation,
  Notification,
  ObservableMixin,
  Observer,
  OperationFactory,
  Paragraph,
  ParagraphButtonUI,
  PasteFromOffice,
  PastePlainText,
  PendingActions,
  Plugin,
  Position,
  Range,
  RawElement,
  Rect,
  RenameOperation,
  Renderer,
  ResizeObserver,
  RootAttributeOperation,
  RootEditableElement,
  RootOperation,
  SearchInfoView,
  SearchTextView,
  SelectAll,
  SelectAllEditing,
  SelectAllUI,
  ShiftEnter,
  SpinnerView,
  SplitButtonView,
  SplitOperation,
  StickyPanelView,
  StylesMap,
  StylesProcessor,
  SwitchButtonView,
  TabObserver,
  Template,
  Text,
  Text$1,
  TextProxy,
  TextTransformation,
  TextWatcher,
  TextareaView,
  ToolbarLineBreakView,
  ToolbarSeparatorView,
  ToolbarView,
  TooltipManager,
  TreeWalker,
  TreeWalker$1,
  TwoStepCaretMovement,
  Typing,
  UIElement,
  Undo,
  UndoEditing,
  UndoUI,
  UpcastWriter,
  View,
  View2,
  ViewCollection,
  WIDGET_CLASS_NAME,
  WIDGET_SELECTED_CLASS_NAME,
  Watchdog,
  Widget,
  WidgetResize,
  WidgetToolbarRepository,
  WidgetTypeAround,
  XmlDataProcessor,
  abortableDebounce,
  addBackgroundRules,
  addBorderRules,
  addKeyboardHandlingForGrid,
  addListToDropdown,
  addMarginRules,
  addMenuToDropdown,
  addPaddingRules,
  addToolbarToDropdown,
  attachToForm,
  autoParagraphEmptyRoots,
  calculateResizeHostAncestorWidth,
  calculateResizeHostPercentageWidth,
  clickOutsideHandler,
  cloneDeep_default,
  compareArrays,
  count,
  createDropdown,
  createElement,
  createLabeledDropdown,
  createLabeledInputNumber,
  createLabeledInputText,
  createLabeledTextarea,
  debounce_default,
  delay,
  diff,
  diffToChanges,
  disablePlaceholder,
  enablePlaceholder,
  env,
  escapeRegExp_default,
  exponentialDelay,
  fastDiff,
  filterGroupAndItemNames,
  findAttributeRange,
  findAttributeRangeBound,
  findClosestScrollableAncestor,
  findOptimalInsertionRange,
  first,
  focusChildOnDropdownOpen,
  getAncestors,
  getBorderWidths,
  getBoxSidesShorthandValue,
  getBoxSidesValueReducer,
  getBoxSidesValues,
  getCode,
  getData,
  getData$1,
  getDataFromElement,
  getEnvKeystrokeText,
  getFillerOffset$4,
  getLabel,
  getLanguageDirection,
  getLastTextLine,
  getLocalizedArrowKeyCodeDirection,
  getLocalizedColorOptions,
  getOptimalPosition,
  getPositionShorthandNormalizer,
  getRangeFromMouseEvent,
  getShorthandValues,
  global,
  hidePlaceholder,
  icons,
  identity_default,
  indexOf,
  injectCssTransitionDisabler,
  inlineHighlight,
  insertAt,
  insertToPriorityArray,
  isArrowKeyCode,
  isAttachment,
  isColor,
  isCombiningMark,
  isComment,
  isElement_default,
  isEqual_default,
  isFocusable,
  isForwardArrowKeyCode,
  isHighSurrogateHalf,
  isInsideCombinedSymbol,
  isInsideEmojiSequence,
  isInsideSurrogatePair,
  isIterable,
  isLength,
  isLineStyle,
  isLowSurrogateHalf,
  isNode,
  isObject_default,
  isParagraphable,
  isPercentage,
  isPlainObject_default,
  isPosition,
  isRange,
  isRepeat,
  isText,
  isURL,
  isValidAttributeName,
  isViewWithFocusCycler,
  isViewWithFocusTracker,
  isVisible,
  isWidget,
  keyCodes,
  logError,
  logWarning,
  map_default,
  mergeWith_default,
  mix,
  needsPlaceholder,
  normalizeColorOptions,
  normalizeMenuBarConfig,
  normalizeSingleColorDefinition,
  normalizeToolbarConfig,
  parse,
  parse$1,
  parseHtml,
  parseKeystroke,
  plainTextToHtml,
  priorities,
  releaseDate,
  remove,
  retry,
  scrollAncestorsToShowTarget,
  scrollViewportToShowTarget,
  secureSourceElement,
  setData,
  setData$1,
  setDataInElement,
  setHighlightHandling,
  setLabel,
  showPlaceholder,
  spliceArray,
  startCase_default,
  stringify,
  stringify$1,
  submitHandler,
  throttle_default,
  toArray,
  toMap,
  toUnit,
  toWidget,
  toWidgetEditable,
  transformSets,
  uid,
  upperFirst_default,
  verifyLicense,
  version,
  viewToModelPositionOutsideModelElement,
  wait,
  wrapInParagraph
} from "./chunk-YDM2RKF6.js";
import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/@ckeditor/ckeditor5-upload/dist/index.js
var FileReader = class extends ObservableMixin() {
  /**
  * Creates an instance of the FileReader.
  */
  constructor() {
    super();
    __publicField(this, "total");
    /**
    * Instance of native FileReader.
    */
    __publicField(this, "_reader");
    /**
    * Holds the data of an already loaded file. The file must be first loaded
    * by using {@link module:upload/filereader~FileReader#read `read()`}.
    */
    __publicField(this, "_data");
    const reader = new window.FileReader();
    this._reader = reader;
    this._data = void 0;
    this.set("loaded", 0);
    reader.onprogress = (evt) => {
      this.loaded = evt.loaded;
    };
  }
  /**
  * Returns error that occurred during file reading.
  */
  get error() {
    return this._reader.error;
  }
  /**
  * Holds the data of an already loaded file. The file must be first loaded
  * by using {@link module:upload/filereader~FileReader#read `read()`}.
  */
  get data() {
    return this._data;
  }
  /**
  * Reads the provided file.
  *
  * @param file Native File object.
  * @returns Returns a promise that will be resolved with file's content.
  * The promise will be rejected in case of an error or when the reading process is aborted.
  */
  read(file) {
    const reader = this._reader;
    this.total = file.size;
    return new Promise((resolve, reject) => {
      reader.onload = () => {
        const result = reader.result;
        this._data = result;
        resolve(result);
      };
      reader.onerror = () => {
        reject("error");
      };
      reader.onabort = () => {
        reject("aborted");
      };
      this._reader.readAsDataURL(file);
    });
  }
  /**
  * Aborts file reader.
  */
  abort() {
    this._reader.abort();
  }
};
var FileRepository = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * Collection of loaders associated with this repository.
    */
    __publicField(this, "loaders", new Collection());
    /**
    * Loaders mappings used to retrieve loaders references.
    */
    __publicField(this, "_loadersMap", /* @__PURE__ */ new Map());
    /**
    * Reference to a pending action registered in a {@link module:core/pendingactions~PendingActions} plugin
    * while upload is in progress. When there is no upload then value is `null`.
    */
    __publicField(this, "_pendingAction", null);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FileRepository";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      PendingActions
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    this.loaders.on("change", () => this._updatePendingAction());
    this.set("uploaded", 0);
    this.set("uploadTotal", null);
    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (uploaded, total) => {
      return total ? uploaded / total * 100 : 0;
    });
  }
  /**
  * Returns the loader associated with specified file or promise.
  *
  * To get loader by id use `fileRepository.loaders.get( id )`.
  *
  * @param fileOrPromise Native file or promise handle.
  */
  getLoader(fileOrPromise) {
    return this._loadersMap.get(fileOrPromise) || null;
  }
  /**
  * Creates a loader instance for the given file.
  *
  * Requires {@link #createUploadAdapter} factory to be defined.
  *
  * @param fileOrPromise Native File object or native Promise object which resolves to a File.
  */
  createLoader(fileOrPromise) {
    if (!this.createUploadAdapter) {
      logWarning("filerepository-no-upload-adapter");
      return null;
    }
    const loader = new FileLoader(Promise.resolve(fileOrPromise), this.createUploadAdapter);
    this.loaders.add(loader);
    this._loadersMap.set(fileOrPromise, loader);
    if (fileOrPromise instanceof Promise) {
      loader.file.then((file) => {
        this._loadersMap.set(file, loader);
      }).catch(() => {
      });
    }
    loader.on("change:uploaded", () => {
      let aggregatedUploaded = 0;
      for (const loader2 of this.loaders) {
        aggregatedUploaded += loader2.uploaded;
      }
      this.uploaded = aggregatedUploaded;
    });
    loader.on("change:uploadTotal", () => {
      let aggregatedTotal = 0;
      for (const loader2 of this.loaders) {
        if (loader2.uploadTotal) {
          aggregatedTotal += loader2.uploadTotal;
        }
      }
      this.uploadTotal = aggregatedTotal;
    });
    return loader;
  }
  /**
  * Destroys the given loader.
  *
  * @param fileOrPromiseOrLoader File or Promise associated with that loader or loader itself.
  */
  destroyLoader(fileOrPromiseOrLoader) {
    const loader = fileOrPromiseOrLoader instanceof FileLoader ? fileOrPromiseOrLoader : this.getLoader(fileOrPromiseOrLoader);
    loader._destroy();
    this.loaders.remove(loader);
    this._loadersMap.forEach((value, key) => {
      if (value === loader) {
        this._loadersMap.delete(key);
      }
    });
  }
  /**
  * Registers or deregisters pending action bound with upload progress.
  */
  _updatePendingAction() {
    const pendingActions = this.editor.plugins.get(PendingActions);
    if (this.loaders.length) {
      if (!this._pendingAction) {
        const t = this.editor.t;
        const getMessage = (value) => `${t("Upload in progress")} ${parseInt(value)}%.`;
        this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));
        this._pendingAction.bind("message").to(this, "uploadedPercent", getMessage);
      }
    } else {
      pendingActions.remove(this._pendingAction);
      this._pendingAction = null;
    }
  }
};
var FileLoader = class extends ObservableMixin() {
  /**
  * Creates a new instance of `FileLoader`.
  *
  * @param filePromise A promise which resolves to a file instance.
  * @param uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.
  */
  constructor(filePromise, uploadAdapterCreator) {
    super();
    /**
    * Unique id of FileLoader instance.
    *
    * @readonly
    */
    __publicField(this, "id");
    /**
    * Additional wrapper over the initial file promise passed to this loader.
    */
    __publicField(this, "_filePromiseWrapper");
    /**
    * Adapter instance associated with this file loader.
    */
    __publicField(this, "_adapter");
    /**
    * FileReader used by FileLoader.
    */
    __publicField(this, "_reader");
    this.id = uid();
    this._filePromiseWrapper = this._createFilePromiseWrapper(filePromise);
    this._adapter = uploadAdapterCreator(this);
    this._reader = new FileReader();
    this.set("status", "idle");
    this.set("uploaded", 0);
    this.set("uploadTotal", null);
    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (uploaded, total) => {
      return total ? uploaded / total * 100 : 0;
    });
    this.set("uploadResponse", null);
  }
  /**
  * A `Promise` which resolves to a `File` instance associated with this file loader.
  */
  get file() {
    if (!this._filePromiseWrapper) {
      return Promise.resolve(null);
    } else {
      return this._filePromiseWrapper.promise.then((file) => this._filePromiseWrapper ? file : null);
    }
  }
  /**
  * Returns the file data. To read its data, you need for first load the file
  * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.
  */
  get data() {
    return this._reader.data;
  }
  /**
  * Reads file using {@link module:upload/filereader~FileReader}.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status
  * is different than `idle`.
  *
  * Example usage:
  *
  * ```ts
  * fileLoader.read()
  * 	.then( data => { ... } )
  * 	.catch( err => {
  * 		if ( err === 'aborted' ) {
  * 			console.log( 'Reading aborted.' );
  * 		} else {
  * 			console.log( 'Reading error.', err );
  * 		}
  * 	} );
  * ```
  *
  * @returns Returns promise that will be resolved with read data. Promise will be rejected if error
  * occurs or if read process is aborted.
  */
  read() {
    if (this.status != "idle") {
      throw new CKEditorError("filerepository-read-wrong-status", this);
    }
    this.status = "reading";
    return this.file.then((file) => this._reader.read(file)).then((data) => {
      if (this.status !== "reading") {
        throw this.status;
      }
      this.status = "idle";
      return data;
    }).catch((err) => {
      if (err === "aborted") {
        this.status = "aborted";
        throw "aborted";
      }
      this.status = "error";
      throw this._reader.error ? this._reader.error : err;
    });
  }
  /**
  * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.
  *
  * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status
  * is different than `idle`.
  * Example usage:
  *
  * ```ts
  * fileLoader.upload()
  * 	.then( data => { ... } )
  * 	.catch( e => {
  * 		if ( e === 'aborted' ) {
  * 			console.log( 'Uploading aborted.' );
  * 		} else {
  * 			console.log( 'Uploading error.', e );
  * 		}
  * 	} );
  * ```
  *
  * @returns Returns promise that will be resolved with response data. Promise will be rejected if error
  * occurs or if read process is aborted.
  */
  upload() {
    if (this.status != "idle") {
      throw new CKEditorError("filerepository-upload-wrong-status", this);
    }
    this.status = "uploading";
    return this.file.then(() => this._adapter.upload()).then((data) => {
      this.uploadResponse = data;
      this.status = "idle";
      return data;
    }).catch((err) => {
      if (this.status === "aborted") {
        throw "aborted";
      }
      this.status = "error";
      throw err;
    });
  }
  /**
  * Aborts loading process.
  */
  abort() {
    const status = this.status;
    this.status = "aborted";
    if (!this._filePromiseWrapper.isFulfilled) {
      this._filePromiseWrapper.promise.catch(() => {
      });
      this._filePromiseWrapper.rejecter("aborted");
    } else if (status == "reading") {
      this._reader.abort();
    } else if (status == "uploading" && this._adapter.abort) {
      this._adapter.abort();
    }
    this._destroy();
  }
  /**
  * Performs cleanup.
  *
  * @internal
  */
  _destroy() {
    this._filePromiseWrapper = void 0;
    this._reader = void 0;
    this._adapter = void 0;
    this.uploadResponse = void 0;
  }
  /**
  * Wraps a given file promise into another promise giving additional
  * control (resolving, rejecting, checking if fulfilled) over it.
  *
  * @param filePromise The initial file promise to be wrapped.
  */
  _createFilePromiseWrapper(filePromise) {
    const wrapper = {};
    wrapper.promise = new Promise((resolve, reject) => {
      wrapper.rejecter = reject;
      wrapper.isFulfilled = false;
      filePromise.then((file) => {
        wrapper.isFulfilled = true;
        resolve(file);
      }).catch((err) => {
        wrapper.isFulfilled = true;
        reject(err);
      });
    });
    return wrapper;
  }
};
var Base64UploadAdapter = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FileRepository
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Base64UploadAdapter";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this.editor.plugins.get(FileRepository).createUploadAdapter = (loader) => new Adapter$1(loader);
  }
};
var Adapter$1 = class Adapter {
  /**
  * Creates a new adapter instance.
  */
  constructor(loader) {
    /**
    * `FileLoader` instance to use during the upload.
    */
    __publicField(this, "loader");
    __publicField(this, "reader");
    this.loader = loader;
  }
  /**
  * Starts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#upload
  */
  upload() {
    return new Promise((resolve, reject) => {
      const reader = this.reader = new window.FileReader();
      reader.addEventListener("load", () => {
        resolve({
          default: reader.result
        });
      });
      reader.addEventListener("error", (err) => {
        reject(err);
      });
      reader.addEventListener("abort", () => {
        reject();
      });
      this.loader.file.then((file) => {
        reader.readAsDataURL(file);
      });
    });
  }
  /**
  * Aborts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#abort
  */
  abort() {
    this.reader.abort();
  }
};
var SimpleUploadAdapter = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FileRepository
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SimpleUploadAdapter";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const options2 = this.editor.config.get("simpleUpload");
    if (!options2) {
      return;
    }
    if (!options2.uploadUrl) {
      logWarning("simple-upload-adapter-missing-uploadurl");
      return;
    }
    this.editor.plugins.get(FileRepository).createUploadAdapter = (loader) => {
      return new Adapter2(loader, options2);
    };
  }
};
var Adapter2 = class {
  /**
  * Creates a new adapter instance.
  */
  constructor(loader, options2) {
    /**
    * FileLoader instance to use during the upload.
    */
    __publicField(this, "loader");
    /**
    * The configuration of the adapter.
    */
    __publicField(this, "options");
    __publicField(this, "xhr");
    this.loader = loader;
    this.options = options2;
  }
  /**
  * Starts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#upload
  */
  upload() {
    return this.loader.file.then((file) => new Promise((resolve, reject) => {
      this._initRequest();
      this._initListeners(resolve, reject, file);
      this._sendRequest(file);
    }));
  }
  /**
  * Aborts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#abort
  */
  abort() {
    if (this.xhr) {
      this.xhr.abort();
    }
  }
  /**
  * Initializes the `XMLHttpRequest` object using the URL specified as
  * {@link module:upload/uploadconfig~SimpleUploadConfig#uploadUrl `simpleUpload.uploadUrl`} in the editor's
  * configuration.
  */
  _initRequest() {
    const xhr = this.xhr = new XMLHttpRequest();
    xhr.open("POST", this.options.uploadUrl, true);
    xhr.responseType = "json";
  }
  /**
  * Initializes XMLHttpRequest listeners
  *
  * @param resolve Callback function to be called when the request is successful.
  * @param reject Callback function to be called when the request cannot be completed.
  * @param file Native File object.
  */
  _initListeners(resolve, reject, file) {
    const xhr = this.xhr;
    const loader = this.loader;
    const genericErrorText = `Couldn't upload file: ${file.name}.`;
    xhr.addEventListener("error", () => reject(genericErrorText));
    xhr.addEventListener("abort", () => reject());
    xhr.addEventListener("load", () => {
      const response = xhr.response;
      if (!response || response.error) {
        return reject(response && response.error && response.error.message ? response.error.message : genericErrorText);
      }
      const urls = response.url ? {
        default: response.url
      } : response.urls;
      resolve({
        ...response,
        urls
      });
    });
    if (xhr.upload) {
      xhr.upload.addEventListener("progress", (evt) => {
        if (evt.lengthComputable) {
          loader.uploadTotal = evt.total;
          loader.uploaded = evt.loaded;
        }
      });
    }
  }
  /**
  * Prepares the data and sends the request.
  *
  * @param file File instance to be uploaded.
  */
  _sendRequest(file) {
    const headers = this.options.headers || {};
    const withCredentials = this.options.withCredentials || false;
    for (const headerName of Object.keys(headers)) {
      this.xhr.setRequestHeader(headerName, headers[headerName]);
    }
    this.xhr.withCredentials = withCredentials;
    const data = new FormData();
    data.append("upload", file);
    this.xhr.send(data);
  }
};

// node_modules/@ckeditor/ckeditor5-adapter-ckfinder/dist/index.js
var TOKEN_COOKIE_NAME = "ckCsrfToken";
var TOKEN_LENGTH = 40;
var tokenCharset = "abcdefghijklmnopqrstuvwxyz0123456789";
function getCsrfToken() {
  let token = getCookie(TOKEN_COOKIE_NAME);
  if (!token || token.length != TOKEN_LENGTH) {
    token = generateToken(TOKEN_LENGTH);
    setCookie(TOKEN_COOKIE_NAME, token);
  }
  return token;
}
function getCookie(name) {
  name = name.toLowerCase();
  const parts = document.cookie.split(";");
  for (const part of parts) {
    const pair = part.split("=");
    const key = decodeURIComponent(pair[0].trim().toLowerCase());
    if (key === name) {
      return decodeURIComponent(pair[1]);
    }
  }
  return null;
}
function setCookie(name, value) {
  document.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + ";path=/";
}
function generateToken(length) {
  let result = "";
  const randValues = new Uint8Array(length);
  window.crypto.getRandomValues(randValues);
  for (let j2 = 0; j2 < randValues.length; j2++) {
    const character = tokenCharset.charAt(randValues[j2] % tokenCharset.length);
    result += Math.random() > 0.5 ? character.toUpperCase() : character;
  }
  return result;
}
var CKFinderUploadAdapter = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FileRepository
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKFinderUploadAdapter";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const url = this.editor.config.get("ckfinder.uploadUrl");
    if (!url) {
      return;
    }
    this.editor.plugins.get(FileRepository).createUploadAdapter = (loader) => new UploadAdapter(loader, url, this.editor.t);
  }
};
var UploadAdapter = class {
  /**
  * Creates a new adapter instance.
  */
  constructor(loader, url, t) {
    /**
    * FileLoader instance to use during the upload.
    */
    __publicField(this, "loader");
    /**
    * Upload URL.
    */
    __publicField(this, "url");
    /**
    * Locale translation method.
    */
    __publicField(this, "t");
    __publicField(this, "xhr");
    this.loader = loader;
    this.url = url;
    this.t = t;
  }
  /**
  * Starts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#upload
  */
  upload() {
    return this.loader.file.then((file) => {
      return new Promise((resolve, reject) => {
        this._initRequest();
        this._initListeners(resolve, reject, file);
        this._sendRequest(file);
      });
    });
  }
  /**
  * Aborts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#abort
  */
  abort() {
    if (this.xhr) {
      this.xhr.abort();
    }
  }
  /**
  * Initializes the XMLHttpRequest object.
  */
  _initRequest() {
    const xhr = this.xhr = new XMLHttpRequest();
    xhr.open("POST", this.url, true);
    xhr.responseType = "json";
  }
  /**
  * Initializes XMLHttpRequest listeners.
  *
  * @param resolve Callback function to be called when the request is successful.
  * @param reject Callback function to be called when the request cannot be completed.
  * @param file File instance to be uploaded.
  */
  _initListeners(resolve, reject, file) {
    const xhr = this.xhr;
    const loader = this.loader;
    const t = this.t;
    const genericError = t("Cannot upload file:") + ` ${file.name}.`;
    xhr.addEventListener("error", () => reject(genericError));
    xhr.addEventListener("abort", () => reject());
    xhr.addEventListener("load", () => {
      const response = xhr.response;
      if (!response || !response.uploaded) {
        return reject(response && response.error && response.error.message ? response.error.message : genericError);
      }
      resolve({
        default: response.url
      });
    });
    if (xhr.upload) {
      xhr.upload.addEventListener("progress", (evt) => {
        if (evt.lengthComputable) {
          loader.uploadTotal = evt.total;
          loader.uploaded = evt.loaded;
        }
      });
    }
  }
  /**
  * Prepares the data and sends the request.
  *
  * @param file File instance to be uploaded.
  */
  _sendRequest(file) {
    const data = new FormData();
    data.append("upload", file);
    data.append("ckCsrfToken", getCsrfToken());
    this.xhr.send(data);
  }
};

// node_modules/@ckeditor/ckeditor5-alignment/dist/index.js
var supportedOptions = [
  "left",
  "right",
  "center",
  "justify"
];
function isSupported(option) {
  return supportedOptions.includes(option);
}
function isDefault(alignment, locale) {
  if (locale.contentLanguageDirection == "rtl") {
    return alignment === "right";
  } else {
    return alignment === "left";
  }
}
function normalizeAlignmentOptions(configuredOptions) {
  const normalizedOptions = configuredOptions.map((option) => {
    let result;
    if (typeof option == "string") {
      result = {
        name: option
      };
    } else {
      result = option;
    }
    return result;
  }).filter((option) => {
    const isNameValid = supportedOptions.includes(option.name);
    if (!isNameValid) {
      logWarning("alignment-config-name-not-recognized", {
        option
      });
    }
    return isNameValid;
  });
  const classNameCount = normalizedOptions.filter((option) => Boolean(option.className)).length;
  if (classNameCount && classNameCount < normalizedOptions.length) {
    throw new CKEditorError("alignment-config-classnames-are-missing", {
      configuredOptions
    });
  }
  normalizedOptions.forEach((option, index, allOptions) => {
    const succeedingOptions = allOptions.slice(index + 1);
    const nameAlreadyExists = succeedingOptions.some((item) => item.name == option.name);
    if (nameAlreadyExists) {
      throw new CKEditorError("alignment-config-name-already-defined", {
        option,
        configuredOptions
      });
    }
    if (option.className) {
      const classNameAlreadyExists = succeedingOptions.some((item) => item.className == option.className);
      if (classNameAlreadyExists) {
        throw new CKEditorError("alignment-config-classname-already-defined", {
          option,
          configuredOptions
        });
      }
    }
  });
  return normalizedOptions;
}
var ALIGNMENT = "alignment";
var AlignmentCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const locale = editor.locale;
    const firstBlock = first(this.editor.model.document.selection.getSelectedBlocks());
    this.isEnabled = Boolean(firstBlock) && this._canBeAligned(firstBlock);
    if (this.isEnabled && firstBlock.hasAttribute("alignment")) {
      this.value = firstBlock.getAttribute("alignment");
    } else {
      this.value = locale.contentLanguageDirection === "rtl" ? "right" : "left";
    }
  }
  /**
  * Executes the command. Applies the alignment `value` to the selected blocks.
  * If no `value` is passed, the `value` is the default one or it is equal to the currently selected block's alignment attribute,
  * the command will remove the attribute from the selected blocks.
  *
  * @param options Options for the executed command.
  * @param options.value The value to apply.
  * @fires execute
  */
  execute(options2 = {}) {
    const editor = this.editor;
    const locale = editor.locale;
    const model = editor.model;
    const doc = model.document;
    const value = options2.value;
    model.change((writer) => {
      const blocks = Array.from(doc.selection.getSelectedBlocks()).filter((block2) => this._canBeAligned(block2));
      const currentAlignment = blocks[0].getAttribute("alignment");
      const removeAlignment = isDefault(value, locale) || currentAlignment === value || !value;
      if (removeAlignment) {
        removeAlignmentFromSelection(blocks, writer);
      } else {
        setAlignmentOnSelection(blocks, writer, value);
      }
    });
  }
  /**
  * Checks whether a block can have alignment set.
  *
  * @param block The block to be checked.
  */
  _canBeAligned(block2) {
    return this.editor.model.schema.checkAttribute(block2, ALIGNMENT);
  }
};
function removeAlignmentFromSelection(blocks, writer) {
  for (const block2 of blocks) {
    writer.removeAttribute(ALIGNMENT, block2);
  }
}
function setAlignmentOnSelection(blocks, writer, alignment) {
  for (const block2 of blocks) {
    writer.setAttribute(ALIGNMENT, alignment, block2);
  }
}
var AlignmentEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "AlignmentEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("alignment", {
      options: supportedOptions.map((option) => ({
        name: option
      }))
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const schema = editor.model.schema;
    const options2 = normalizeAlignmentOptions(editor.config.get("alignment.options"));
    const optionsToConvert = options2.filter((option) => isSupported(option.name) && !isDefault(option.name, locale));
    const shouldUseClasses = optionsToConvert.some((option) => !!option.className);
    schema.extend("$block", {
      allowAttributes: "alignment"
    });
    editor.model.schema.setAttributeProperties("alignment", {
      isFormatting: true
    });
    if (shouldUseClasses) {
      editor.conversion.attributeToAttribute(buildClassDefinition(optionsToConvert));
    } else {
      editor.conversion.for("downcast").attributeToAttribute(buildDowncastInlineDefinition(optionsToConvert));
    }
    const upcastInlineDefinitions = buildUpcastInlineDefinitions(optionsToConvert);
    for (const definition of upcastInlineDefinitions) {
      editor.conversion.for("upcast").attributeToAttribute(definition);
    }
    const upcastCompatibilityDefinitions = buildUpcastCompatibilityDefinitions(optionsToConvert);
    for (const definition of upcastCompatibilityDefinitions) {
      editor.conversion.for("upcast").attributeToAttribute(definition);
    }
    editor.commands.add("alignment", new AlignmentCommand(editor));
  }
};
function buildDowncastInlineDefinition(options2) {
  const view = {};
  for (const { name } of options2) {
    view[name] = {
      key: "style",
      value: {
        "text-align": name
      }
    };
  }
  const definition = {
    model: {
      key: "alignment",
      values: options2.map((option) => option.name)
    },
    view
  };
  return definition;
}
function buildUpcastInlineDefinitions(options2) {
  const definitions = [];
  for (const { name } of options2) {
    definitions.push({
      view: {
        key: "style",
        value: {
          "text-align": name
        }
      },
      model: {
        key: "alignment",
        value: name
      }
    });
  }
  return definitions;
}
function buildUpcastCompatibilityDefinitions(options2) {
  const definitions = [];
  for (const { name } of options2) {
    definitions.push({
      view: {
        key: "align",
        value: name
      },
      model: {
        key: "alignment",
        value: name
      }
    });
  }
  return definitions;
}
function buildClassDefinition(options2) {
  const view = {};
  for (const option of options2) {
    view[option.name] = {
      key: "class",
      value: option.className
    };
  }
  const definition = {
    model: {
      key: "alignment",
      values: options2.map((option) => option.name)
    },
    view
  };
  return definition;
}
var iconsMap = (() => /* @__PURE__ */ new Map([
  [
    "left",
    icons.alignLeft
  ],
  [
    "right",
    icons.alignRight
  ],
  [
    "center",
    icons.alignCenter
  ],
  [
    "justify",
    icons.alignJustify
  ]
]))();
var AlignmentUI = class extends Plugin {
  /**
  * Returns the localized option titles provided by the plugin.
  *
  * The following localized titles corresponding with
  * {@link module:alignment/alignmentconfig~AlignmentConfig#options} are available:
  *
  * * `'left'`,
  * * `'right'`,
  * * `'center'`,
  * * `'justify'`.
  *
  * @readonly
  */
  get localizedOptionTitles() {
    const t = this.editor.t;
    return {
      "left": t("Align left"),
      "right": t("Align right"),
      "center": t("Align center"),
      "justify": t("Justify")
    };
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "AlignmentUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const options2 = normalizeAlignmentOptions(editor.config.get("alignment.options"));
    options2.map((option) => option.name).filter(isSupported).forEach((option) => this._addButton(option));
    this._addToolbarDropdown(options2);
    this._addMenuBarMenu(options2);
  }
  /**
  * Helper method for initializing the button and linking it with an appropriate command.
  *
  * @param option The name of the alignment option for which the button is added.
  */
  _addButton(option) {
    const editor = this.editor;
    editor.ui.componentFactory.add(`alignment:${option}`, (locale) => this._createButton(locale, option));
  }
  /**
  * Helper method for creating the button view element.
  *
  * @param locale Editor locale.
  * @param option The name of the alignment option for which the button is added.
  * @param buttonAttrs Optional parameters passed to button view instance.
  */
  _createButton(locale, option, buttonAttrs = {}) {
    const editor = this.editor;
    const command = editor.commands.get("alignment");
    const buttonView = new ButtonView(locale);
    buttonView.set({
      label: this.localizedOptionTitles[option],
      icon: iconsMap.get(option),
      tooltip: true,
      isToggleable: true,
      ...buttonAttrs
    });
    buttonView.bind("isEnabled").to(command);
    buttonView.bind("isOn").to(command, "value", (value) => value === option);
    this.listenTo(buttonView, "execute", () => {
      editor.execute("alignment", {
        value: option
      });
      editor.editing.view.focus();
    });
    return buttonView;
  }
  /**
  * Helper method for initializing the toolnar dropdown and linking it with an appropriate command.
  *
  * @param option The name of the alignment option for which the button is added.
  */
  _addToolbarDropdown(options2) {
    const editor = this.editor;
    const factory = editor.ui.componentFactory;
    factory.add("alignment", (locale) => {
      const dropdownView = createDropdown(locale);
      const tooltipPosition = locale.uiLanguageDirection === "rtl" ? "w" : "e";
      const t = locale.t;
      addToolbarToDropdown(dropdownView, () => options2.map((option) => this._createButton(locale, option.name, {
        tooltipPosition
      })), {
        enableActiveItemFocusOnDropdownOpen: true,
        isVertical: true,
        ariaLabel: t("Text alignment toolbar")
      });
      dropdownView.buttonView.set({
        label: t("Text alignment"),
        tooltip: true
      });
      dropdownView.extendTemplate({
        attributes: {
          class: "ck-alignment-dropdown"
        }
      });
      const defaultIcon = locale.contentLanguageDirection === "rtl" ? iconsMap.get("right") : iconsMap.get("left");
      const command = editor.commands.get("alignment");
      dropdownView.buttonView.bind("icon").to(command, "value", (value) => iconsMap.get(value) || defaultIcon);
      dropdownView.bind("isEnabled").to(command, "isEnabled");
      this.listenTo(dropdownView, "execute", () => {
        editor.editing.view.focus();
      });
      return dropdownView;
    });
  }
  /**
  * Creates a menu for all alignment options to use either in menu bar.
  *
  * @param options Normalized alignment options from config.
  */
  _addMenuBarMenu(options2) {
    const editor = this.editor;
    editor.ui.componentFactory.add("menuBar:alignment", (locale) => {
      const command = editor.commands.get("alignment");
      const t = locale.t;
      const menuView = new MenuBarMenuView(locale);
      const listView = new MenuBarMenuListView(locale);
      menuView.bind("isEnabled").to(command);
      listView.set({
        ariaLabel: t("Text alignment"),
        role: "menu"
      });
      menuView.buttonView.set({
        label: t("Text alignment")
      });
      for (const option of options2) {
        const listItemView = new MenuBarMenuListItemView(locale, menuView);
        const buttonView = new MenuBarMenuListItemButtonView(locale);
        buttonView.delegate("execute").to(menuView);
        buttonView.set({
          label: this.localizedOptionTitles[option.name],
          icon: iconsMap.get(option.name),
          role: "menuitemcheckbox",
          isToggleable: true
        });
        buttonView.on("execute", () => {
          editor.execute("alignment", {
            value: option.name
          });
          editor.editing.view.focus();
        });
        buttonView.bind("isOn").to(command, "value", (value) => value === option.name);
        buttonView.bind("isEnabled").to(command, "isEnabled");
        listItemView.children.add(buttonView);
        listView.items.add(listItemView);
      }
      menuView.panelView.children.add(listView);
      return menuView;
    });
  }
};
var Alignment = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      AlignmentEditing,
      AlignmentUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Alignment";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-autoformat/dist/index.js
function blockAutoformatEditing(editor, plugin, pattern, callbackOrCommand) {
  let callback;
  let command = null;
  if (typeof callbackOrCommand == "function") {
    callback = callbackOrCommand;
  } else {
    command = editor.commands.get(callbackOrCommand);
    callback = () => {
      editor.execute(callbackOrCommand);
    };
  }
  editor.model.document.on("change:data", (evt, batch) => {
    if (command && !command.isEnabled || !plugin.isEnabled) {
      return;
    }
    const range = first(editor.model.document.selection.getRanges());
    if (!range.isCollapsed) {
      return;
    }
    if (batch.isUndo || !batch.isLocal) {
      return;
    }
    const changes = Array.from(editor.model.document.differ.getChanges());
    const entry = changes[0];
    if (changes.length != 1 || entry.type !== "insert" || entry.name != "$text" || entry.length != 1) {
      return;
    }
    const blockToFormat = entry.position.parent;
    if (blockToFormat.is("element", "codeBlock")) {
      return;
    }
    if (blockToFormat.is("element", "listItem") && typeof callbackOrCommand !== "function" && ![
      "numberedList",
      "bulletedList",
      "todoList"
    ].includes(callbackOrCommand)) {
      return;
    }
    if (command && command.value === true) {
      return;
    }
    const firstNode = blockToFormat.getChild(0);
    const firstNodeRange = editor.model.createRangeOn(firstNode);
    if (!firstNodeRange.containsRange(range) && !range.end.isEqual(firstNodeRange.end)) {
      return;
    }
    const match = pattern.exec(firstNode.data.substr(0, range.end.offset));
    if (!match) {
      return;
    }
    editor.model.enqueueChange((writer) => {
      const start = writer.createPositionAt(blockToFormat, 0);
      const end = writer.createPositionAt(blockToFormat, match[0].length);
      const range2 = new LiveRange(start, end);
      const wasChanged = callback({
        match
      });
      if (wasChanged !== false) {
        writer.remove(range2);
        const selectionRange = editor.model.document.selection.getFirstRange();
        const blockRange = writer.createRangeIn(blockToFormat);
        if (blockToFormat.isEmpty && !blockRange.isEqual(selectionRange) && !blockRange.containsRange(selectionRange, true)) {
          writer.remove(blockToFormat);
        }
      }
      range2.detach();
      editor.model.enqueueChange(() => {
        const deletePlugin = editor.plugins.get("Delete");
        deletePlugin.requestUndoOnBackspace();
      });
    });
  });
}
function inlineAutoformatEditing(editor, plugin, testRegexpOrCallback, formatCallback) {
  let regExp;
  let testCallback;
  if (testRegexpOrCallback instanceof RegExp) {
    regExp = testRegexpOrCallback;
  } else {
    testCallback = testRegexpOrCallback;
  }
  testCallback = testCallback || ((text) => {
    let result;
    const remove3 = [];
    const format = [];
    while ((result = regExp.exec(text)) !== null) {
      if (result && result.length < 4) {
        break;
      }
      let { index, "1": leftDel, "2": content, "3": rightDel } = result;
      const found = leftDel + content + rightDel;
      index += result[0].length - found.length;
      const delStart = [
        index,
        index + leftDel.length
      ];
      const delEnd = [
        index + leftDel.length + content.length,
        index + leftDel.length + content.length + rightDel.length
      ];
      remove3.push(delStart);
      remove3.push(delEnd);
      format.push([
        index + leftDel.length,
        index + leftDel.length + content.length
      ]);
    }
    return {
      remove: remove3,
      format
    };
  });
  editor.model.document.on("change:data", (evt, batch) => {
    if (batch.isUndo || !batch.isLocal || !plugin.isEnabled) {
      return;
    }
    const model = editor.model;
    const selection = model.document.selection;
    if (!selection.isCollapsed) {
      return;
    }
    const changes = Array.from(model.document.differ.getChanges());
    const entry = changes[0];
    if (changes.length != 1 || entry.type !== "insert" || entry.name != "$text" || entry.length != 1) {
      return;
    }
    const focus = selection.focus;
    const block2 = focus.parent;
    const { text, range } = getTextAfterCode(model.createRange(model.createPositionAt(block2, 0), focus), model);
    const testOutput = testCallback(text);
    const rangesToFormat = testOutputToRanges(range.start, testOutput.format, model);
    const rangesToRemove = testOutputToRanges(range.start, testOutput.remove, model);
    if (!(rangesToFormat.length && rangesToRemove.length)) {
      return;
    }
    model.enqueueChange((writer) => {
      const hasChanged = formatCallback(writer, rangesToFormat);
      if (hasChanged === false) {
        return;
      }
      for (const range2 of rangesToRemove.reverse()) {
        writer.remove(range2);
      }
      model.enqueueChange(() => {
        const deletePlugin = editor.plugins.get("Delete");
        deletePlugin.requestUndoOnBackspace();
      });
    });
  });
}
function testOutputToRanges(start, arrays, model) {
  return arrays.filter((array) => array[0] !== void 0 && array[1] !== void 0).map((array) => {
    return model.createRange(start.getShiftedBy(array[0]), start.getShiftedBy(array[1]));
  });
}
function getTextAfterCode(range, model) {
  let start = range.start;
  const text = Array.from(range.getItems()).reduce((rangeText, node) => {
    if (!(node.is("$text") || node.is("$textProxy")) || node.getAttribute("code")) {
      start = model.createPositionAfter(node);
      return "";
    }
    return rangeText + node.data;
  }, "");
  return {
    text,
    range: model.createRange(start, range.end)
  };
}
var Autoformat = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Delete
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Autoformat";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const t = this.editor.t;
    this._addListAutoformats();
    this._addBasicStylesAutoformats();
    this._addHeadingAutoformats();
    this._addBlockQuoteAutoformats();
    this._addCodeBlockAutoformats();
    this._addHorizontalLineAutoformats();
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Revert autoformatting action"),
          keystroke: "Backspace"
        }
      ]
    });
  }
  /**
  * Adds autoformatting related to the {@link module:list/list~List}.
  *
  * When typed:
  * - `* ` or `- ` &ndash; A paragraph will be changed into a bulleted list.
  * - `1. ` or `1) ` &ndash; A paragraph will be changed into a numbered list ("1" can be any digit or a list of digits).
  * - `[] ` or `[ ] ` &ndash; A paragraph will be changed into a to-do list.
  * - `[x] ` or `[ x ] ` &ndash; A paragraph will be changed into a checked to-do list.
  */
  _addListAutoformats() {
    const commands = this.editor.commands;
    if (commands.get("bulletedList")) {
      blockAutoformatEditing(this.editor, this, /^[*-]\s$/, "bulletedList");
    }
    if (commands.get("numberedList")) {
      blockAutoformatEditing(this.editor, this, /^1[.|)]\s$/, "numberedList");
    }
    if (commands.get("todoList")) {
      blockAutoformatEditing(this.editor, this, /^\[\s?\]\s$/, "todoList");
    }
    if (commands.get("checkTodoList")) {
      blockAutoformatEditing(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
        this.editor.execute("todoList");
        this.editor.execute("checkTodoList");
      });
    }
  }
  /**
  * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},
  * {@link module:basic-styles/italic~Italic}, {@link module:basic-styles/code~Code}
  * and {@link module:basic-styles/strikethrough~Strikethrough}
  *
  * When typed:
  * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,
  * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,
  * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,
  * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,
  * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code,
  * - `~~foobar~~` &ndash; `~~` characters are removed and `foobar` is set to strikethrough.
  */
  _addBasicStylesAutoformats() {
    const commands = this.editor.commands;
    if (commands.get("bold")) {
      const boldCallback = getCallbackFunctionForInlineAutoformat(this.editor, "bold");
      inlineAutoformatEditing(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, boldCallback);
      inlineAutoformatEditing(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, boldCallback);
    }
    if (commands.get("italic")) {
      const italicCallback = getCallbackFunctionForInlineAutoformat(this.editor, "italic");
      inlineAutoformatEditing(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, italicCallback);
      inlineAutoformatEditing(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, italicCallback);
    }
    if (commands.get("code")) {
      const codeCallback = getCallbackFunctionForInlineAutoformat(this.editor, "code");
      inlineAutoformatEditing(this.editor, this, /(`)([^`]+)(`)$/g, codeCallback);
    }
    if (commands.get("strikethrough")) {
      const strikethroughCallback = getCallbackFunctionForInlineAutoformat(this.editor, "strikethrough");
      inlineAutoformatEditing(this.editor, this, /(~~)([^~]+)(~~)$/g, strikethroughCallback);
    }
  }
  /**
  * Adds autoformatting related to {@link module:heading/heading~Heading}.
  *
  * It is using a number at the end of the command name to associate it with the proper trigger:
  *
  * * `heading` with a `heading1` value will be executed when typing `#`,
  * * `heading` with a `heading2` value will be executed when typing `##`,
  * * ... up to `heading6` for `######`.
  */
  _addHeadingAutoformats() {
    const command = this.editor.commands.get("heading");
    if (command) {
      command.modelElements.filter((name) => name.match(/^heading[1-6]$/)).forEach((modelName) => {
        const level = modelName[7];
        const pattern = new RegExp(`^(#{${level}})\\s$`);
        blockAutoformatEditing(this.editor, this, pattern, () => {
          if (!command.isEnabled || command.value === modelName) {
            return false;
          }
          this.editor.execute("heading", {
            value: modelName
          });
        });
      });
    }
  }
  /**
  * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.
  *
  * When typed:
  * * `> ` &ndash; A paragraph will be changed to a block quote.
  */
  _addBlockQuoteAutoformats() {
    if (this.editor.commands.get("blockQuote")) {
      blockAutoformatEditing(this.editor, this, /^>\s$/, "blockQuote");
    }
  }
  /**
  * Adds autoformatting related to {@link module:code-block/codeblock~CodeBlock}.
  *
  * When typed:
  * - `` ``` `` &ndash; A paragraph will be changed to a code block.
  */
  _addCodeBlockAutoformats() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    if (editor.commands.get("codeBlock")) {
      blockAutoformatEditing(editor, this, /^```$/, () => {
        if (selection.getFirstPosition().parent.is("element", "listItem")) {
          return false;
        }
        this.editor.execute("codeBlock", {
          usePreviousLanguageChoice: true
        });
      });
    }
  }
  /**
  * Adds autoformatting related to {@link module:horizontal-line/horizontalline~HorizontalLine}.
  *
  * When typed:
  * - `` --- `` &ndash; Will be replaced with a horizontal line.
  */
  _addHorizontalLineAutoformats() {
    if (this.editor.commands.get("horizontalLine")) {
      blockAutoformatEditing(this.editor, this, /^---$/, "horizontalLine");
    }
  }
};
function getCallbackFunctionForInlineAutoformat(editor, attributeKey2) {
  return (writer, rangesToFormat) => {
    const command = editor.commands.get(attributeKey2);
    if (!command.isEnabled) {
      return false;
    }
    const validRanges = editor.model.schema.getValidRanges(rangesToFormat, attributeKey2);
    for (const range of validRanges) {
      writer.setAttribute(attributeKey2, true, range);
    }
    writer.removeSelectionAttribute(attributeKey2);
  };
}

// node_modules/@ckeditor/ckeditor5-autosave/dist/index.js
var Autosave = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The adapter is an object with a `save()` method. That method will be called whenever
    * the data changes. It might be called some time after the change,
    * since the event is throttled for performance reasons.
    */
    __publicField(this, "adapter");
    /**
    * Debounced save method. The `save()` method is called the specified `waitingTime` after `debouncedSave()` is called,
    * unless a new action happens in the meantime.
    */
    __publicField(this, "_debouncedSave");
    /**
    * The last saved document version.
    */
    __publicField(this, "_lastDocumentVersion");
    /**
    * Promise used for asynchronous save calls.
    *
    * Created to handle the autosave call to an external data source. It resolves when that call is finished. It is re-used if
    * save is called before the promise has been resolved. It is set to `null` if there is no call in progress.
    */
    __publicField(this, "_savePromise");
    /**
    * DOM emitter.
    */
    __publicField(this, "_domEmitter");
    /**
    * The configuration of this plugins.
    */
    __publicField(this, "_config");
    /**
    * Editor's pending actions manager.
    */
    __publicField(this, "_pendingActions");
    /**
    * Informs whether there should be another autosave callback performed, immediately after current autosave callback finishes.
    *
    * This is set to `true` when there is a save request while autosave callback is already being processed
    * and the model has changed since the last save.
    */
    __publicField(this, "_makeImmediateSave");
    /**
    * An action that will be added to the pending action manager for actions happening in that plugin.
    */
    __publicField(this, "_action", null);
    const config = editor.config.get("autosave") || {};
    const waitingTime = config.waitingTime || 1e3;
    this.set("state", "synchronized");
    this._debouncedSave = debounce_default(this._save.bind(this), waitingTime);
    this._lastDocumentVersion = editor.model.document.version;
    this._savePromise = null;
    this._domEmitter = new (DomEmitterMixin())();
    this._config = config;
    this._pendingActions = editor.plugins.get(PendingActions);
    this._makeImmediateSave = false;
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Autosave";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      PendingActions
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const doc = editor.model.document;
    this.listenTo(editor, "ready", () => {
      this.listenTo(doc, "change:data", (evt, batch) => {
        if (!this._saveCallbacks.length) {
          return;
        }
        if (!batch.isLocal) {
          return;
        }
        if (this.state === "synchronized") {
          this.state = "waiting";
          this._setPendingAction();
        }
        if (this.state === "waiting") {
          this._debouncedSave();
        }
      });
    });
    this.listenTo(editor, "destroy", () => this._flush(), {
      priority: "highest"
    });
    this._domEmitter.listenTo(window, "beforeunload", (evtInfo, domEvt) => {
      if (this._pendingActions.hasAny) {
        domEvt.returnValue = this._pendingActions.first.message;
      }
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._domEmitter.stopListening();
    super.destroy();
  }
  /**
  * Immediately calls autosave callback. All previously queued (debounced) callbacks are cleared. If there is already an autosave
  * callback in progress, then the requested save will be performed immediately after the current callback finishes.
  *
  * @returns A promise that will be resolved when the autosave callback is finished.
  */
  save() {
    this._debouncedSave.cancel();
    return this._save();
  }
  /**
  * Invokes the remaining `_save()` method call.
  */
  _flush() {
    this._debouncedSave.flush();
  }
  /**
  * If the adapter is set and a new document version exists,
  * the `_save()` method creates a pending action and calls the `adapter.save()` method.
  * It waits for the result and then removes the created pending action.
  *
  * @returns A promise that will be resolved when the autosave callback is finished.
  */
  _save() {
    if (this._savePromise) {
      this._makeImmediateSave = this.editor.model.document.version > this._lastDocumentVersion;
      return this._savePromise;
    }
    this._setPendingAction();
    this.state = "saving";
    this._lastDocumentVersion = this.editor.model.document.version;
    this._savePromise = Promise.resolve().then(() => Promise.all(this._saveCallbacks.map((cb) => cb(this.editor)))).finally(() => {
      this._savePromise = null;
    }).then(() => {
      if (this._makeImmediateSave) {
        this._makeImmediateSave = false;
        return this._save();
      } else {
        if (this.editor.model.document.version > this._lastDocumentVersion) {
          this.state = "waiting";
          this._debouncedSave();
        } else {
          this.state = "synchronized";
          this._pendingActions.remove(this._action);
          this._action = null;
        }
      }
    }).catch((err) => {
      this.state = "error";
      this.state = "saving";
      this._debouncedSave();
      throw err;
    });
    return this._savePromise;
  }
  /**
  * Creates a pending action if it is not set already.
  */
  _setPendingAction() {
    const t = this.editor.t;
    if (!this._action) {
      this._action = this._pendingActions.add(t("Saving changes"));
    }
  }
  /**
  * Saves callbacks.
  */
  get _saveCallbacks() {
    const saveCallbacks = [];
    if (this.adapter && this.adapter.save) {
      saveCallbacks.push(this.adapter.save);
    }
    if (this._config.save) {
      saveCallbacks.push(this._config.save);
    }
    return saveCallbacks;
  }
};

// node_modules/@ckeditor/ckeditor5-basic-styles/dist/index.js
var AttributeCommand = class extends Command {
  /**
  * @param attributeKey Attribute that will be set by the command.
  */
  constructor(editor, attributeKey2) {
    super(editor);
    /**
    * The attribute that will be set by the command.
    */
    __publicField(this, "attributeKey");
    this.attributeKey = attributeKey2;
  }
  /**
  * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
  */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.value = this._getValueFromFirstAllowedNode();
    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
  }
  /**
  * Executes the command &ndash; applies the attribute to the selection or removes it from the selection.
  *
  * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
  *
  * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
  *
  * * If the selection is on a range, the command applies the attribute to all nodes in that range
  * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
  * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
  * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
  * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
  * that the selection inherits all attributes from a node if it is in an empty node).
  *
  * @fires execute
  * @param options Command options.
  * @param options.forceValue If set, it will force the command behavior. If `true`,
  * the command will apply the attribute, otherwise the command will remove the attribute.
  * If not set, the command will look for its current value to decide what it should do.
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const doc = model.document;
    const selection = doc.selection;
    const value = options2.forceValue === void 0 ? !this.value : options2.forceValue;
    model.change((writer) => {
      if (selection.isCollapsed) {
        if (value) {
          writer.setSelectionAttribute(this.attributeKey, true);
        } else {
          writer.removeSelectionAttribute(this.attributeKey);
        }
      } else {
        const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);
        for (const range of ranges) {
          if (value) {
            writer.setAttribute(this.attributeKey, value, range);
          } else {
            writer.removeAttribute(this.attributeKey, range);
          }
        }
      }
    });
  }
  /**
  * Checks the attribute value of the first node in the selection that allows the attribute.
  * For the collapsed selection returns the selection attribute.
  *
  * @returns The attribute value.
  */
  _getValueFromFirstAllowedNode() {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    if (selection.isCollapsed) {
      return selection.hasAttribute(this.attributeKey);
    }
    for (const range of selection.getRanges()) {
      for (const item of range.getItems()) {
        if (schema.checkAttribute(item, this.attributeKey)) {
          return item.hasAttribute(this.attributeKey);
        }
      }
    }
    return false;
  }
};
var BOLD$1 = "bold";
var BoldEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "BoldEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    editor.model.schema.extend("$text", {
      allowAttributes: BOLD$1
    });
    editor.model.schema.setAttributeProperties(BOLD$1, {
      isFormatting: true,
      copyOnEnter: true
    });
    editor.conversion.attributeToElement({
      model: BOLD$1,
      view: "strong",
      upcastAlso: [
        "b",
        (viewElement) => {
          const fontWeight = viewElement.getStyle("font-weight");
          if (!fontWeight) {
            return null;
          }
          if (fontWeight == "bold" || Number(fontWeight) >= 600) {
            return {
              name: true,
              styles: [
                "font-weight"
              ]
            };
          }
          return null;
        }
      ]
    });
    editor.commands.add(BOLD$1, new AttributeCommand(editor, BOLD$1));
    editor.keystrokes.set("CTRL+B", BOLD$1);
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Bold text"),
          keystroke: "CTRL+B"
        }
      ]
    });
  }
};
function getButtonCreator({ editor, commandName, plugin, icon, label, keystroke }) {
  return (ButtonClass) => {
    const command = editor.commands.get(commandName);
    const view = new ButtonClass(editor.locale);
    view.set({
      label,
      icon,
      keystroke,
      isToggleable: true
    });
    view.bind("isEnabled").to(command, "isEnabled");
    view.bind("isOn").to(command, "value");
    if (view instanceof MenuBarMenuListItemButtonView) {
      view.set({
        role: "menuitemcheckbox"
      });
    } else {
      view.set({
        tooltip: true
      });
    }
    plugin.listenTo(view, "execute", () => {
      editor.execute(commandName);
      editor.editing.view.focus();
    });
    return view;
  };
}
var BOLD = "bold";
var BoldUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "BoldUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const createButton = getButtonCreator({
      editor,
      commandName: BOLD,
      plugin: this,
      icon: icons.bold,
      label: t("Bold"),
      keystroke: "CTRL+B"
    });
    editor.ui.componentFactory.add(BOLD, () => createButton(ButtonView));
    editor.ui.componentFactory.add("menuBar:" + BOLD, () => createButton(MenuBarMenuListItemButtonView));
  }
};
var Bold = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      BoldEditing,
      BoldUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Bold";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var CODE$1 = "code";
var HIGHLIGHT_CLASS = "ck-code_selected";
var CodeEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CodeEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TwoStepCaretMovement
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    editor.model.schema.extend("$text", {
      allowAttributes: CODE$1
    });
    editor.model.schema.setAttributeProperties(CODE$1, {
      isFormatting: true,
      copyOnEnter: false
    });
    editor.conversion.attributeToElement({
      model: CODE$1,
      view: "code",
      upcastAlso: {
        styles: {
          "word-wrap": "break-word"
        }
      }
    });
    editor.commands.add(CODE$1, new AttributeCommand(editor, CODE$1));
    editor.plugins.get(TwoStepCaretMovement).registerAttribute(CODE$1);
    inlineHighlight(editor, CODE$1, "code", HIGHLIGHT_CLASS);
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Move out of an inline code style"),
          keystroke: [
            [
              "arrowleft",
              "arrowleft"
            ],
            [
              "arrowright",
              "arrowright"
            ]
          ]
        }
      ]
    });
  }
};
var codeIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>';
var CODE = "code";
var CodeUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CodeUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const createButton = getButtonCreator({
      editor,
      commandName: CODE,
      plugin: this,
      icon: codeIcon,
      label: t("Code")
    });
    editor.ui.componentFactory.add(CODE, () => createButton(ButtonView));
    editor.ui.componentFactory.add("menuBar:" + CODE, () => createButton(MenuBarMenuListItemButtonView));
  }
};
var Code = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      CodeEditing,
      CodeUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Code";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var ITALIC$1 = "italic";
var ItalicEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ItalicEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    editor.model.schema.extend("$text", {
      allowAttributes: ITALIC$1
    });
    editor.model.schema.setAttributeProperties(ITALIC$1, {
      isFormatting: true,
      copyOnEnter: true
    });
    editor.conversion.attributeToElement({
      model: ITALIC$1,
      view: "i",
      upcastAlso: [
        "em",
        {
          styles: {
            "font-style": "italic"
          }
        }
      ]
    });
    editor.commands.add(ITALIC$1, new AttributeCommand(editor, ITALIC$1));
    editor.keystrokes.set("CTRL+I", ITALIC$1);
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Italic text"),
          keystroke: "CTRL+I"
        }
      ]
    });
  }
};
var italicIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
var ITALIC = "italic";
var ItalicUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ItalicUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const createButton = getButtonCreator({
      editor,
      commandName: ITALIC,
      plugin: this,
      icon: italicIcon,
      keystroke: "CTRL+I",
      label: t("Italic")
    });
    editor.ui.componentFactory.add(ITALIC, () => createButton(ButtonView));
    editor.ui.componentFactory.add("menuBar:" + ITALIC, () => createButton(MenuBarMenuListItemButtonView));
  }
};
var Italic = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ItalicEditing,
      ItalicUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Italic";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var STRIKETHROUGH$1 = "strikethrough";
var StrikethroughEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StrikethroughEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    editor.model.schema.extend("$text", {
      allowAttributes: STRIKETHROUGH$1
    });
    editor.model.schema.setAttributeProperties(STRIKETHROUGH$1, {
      isFormatting: true,
      copyOnEnter: true
    });
    editor.conversion.attributeToElement({
      model: STRIKETHROUGH$1,
      view: "s",
      upcastAlso: [
        "del",
        "strike",
        {
          styles: {
            "text-decoration": "line-through"
          }
        }
      ]
    });
    editor.commands.add(STRIKETHROUGH$1, new AttributeCommand(editor, STRIKETHROUGH$1));
    editor.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Strikethrough text"),
          keystroke: "CTRL+SHIFT+X"
        }
      ]
    });
  }
};
var strikethroughIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
var STRIKETHROUGH = "strikethrough";
var StrikethroughUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StrikethroughUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const createButton = getButtonCreator({
      editor,
      commandName: STRIKETHROUGH,
      plugin: this,
      icon: strikethroughIcon,
      keystroke: "CTRL+SHIFT+X",
      label: t("Strikethrough")
    });
    editor.ui.componentFactory.add(STRIKETHROUGH, () => createButton(ButtonView));
    editor.ui.componentFactory.add("menuBar:" + STRIKETHROUGH, () => createButton(MenuBarMenuListItemButtonView));
  }
};
var Strikethrough = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      StrikethroughEditing,
      StrikethroughUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Strikethrough";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var SUBSCRIPT$1 = "subscript";
var SubscriptEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SubscriptEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", {
      allowAttributes: SUBSCRIPT$1
    });
    editor.model.schema.setAttributeProperties(SUBSCRIPT$1, {
      isFormatting: true,
      copyOnEnter: true
    });
    editor.conversion.attributeToElement({
      model: SUBSCRIPT$1,
      view: "sub",
      upcastAlso: [
        {
          styles: {
            "vertical-align": "sub"
          }
        }
      ]
    });
    editor.commands.add(SUBSCRIPT$1, new AttributeCommand(editor, SUBSCRIPT$1));
  }
};
var subscriptIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
var SUBSCRIPT = "subscript";
var SubscriptUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SubscriptUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const createButton = getButtonCreator({
      editor,
      commandName: SUBSCRIPT,
      plugin: this,
      icon: subscriptIcon,
      label: t("Subscript")
    });
    editor.ui.componentFactory.add(SUBSCRIPT, () => createButton(ButtonView));
    editor.ui.componentFactory.add("menuBar:" + SUBSCRIPT, () => createButton(MenuBarMenuListItemButtonView));
  }
};
var Subscript = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      SubscriptEditing,
      SubscriptUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Subscript";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var SUPERSCRIPT$1 = "superscript";
var SuperscriptEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SuperscriptEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", {
      allowAttributes: SUPERSCRIPT$1
    });
    editor.model.schema.setAttributeProperties(SUPERSCRIPT$1, {
      isFormatting: true,
      copyOnEnter: true
    });
    editor.conversion.attributeToElement({
      model: SUPERSCRIPT$1,
      view: "sup",
      upcastAlso: [
        {
          styles: {
            "vertical-align": "super"
          }
        }
      ]
    });
    editor.commands.add(SUPERSCRIPT$1, new AttributeCommand(editor, SUPERSCRIPT$1));
  }
};
var superscriptIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
var SUPERSCRIPT = "superscript";
var SuperscriptUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SuperscriptUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const createButton = getButtonCreator({
      editor,
      commandName: SUPERSCRIPT,
      plugin: this,
      icon: superscriptIcon,
      label: t("Superscript")
    });
    editor.ui.componentFactory.add(SUPERSCRIPT, () => createButton(ButtonView));
    editor.ui.componentFactory.add("menuBar:" + SUPERSCRIPT, () => createButton(MenuBarMenuListItemButtonView));
  }
};
var Superscript = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      SuperscriptEditing,
      SuperscriptUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Superscript";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var UNDERLINE$1 = "underline";
var UnderlineEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "UnderlineEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    editor.model.schema.extend("$text", {
      allowAttributes: UNDERLINE$1
    });
    editor.model.schema.setAttributeProperties(UNDERLINE$1, {
      isFormatting: true,
      copyOnEnter: true
    });
    editor.conversion.attributeToElement({
      model: UNDERLINE$1,
      view: "u",
      upcastAlso: {
        styles: {
          "text-decoration": "underline"
        }
      }
    });
    editor.commands.add(UNDERLINE$1, new AttributeCommand(editor, UNDERLINE$1));
    editor.keystrokes.set("CTRL+U", "underline");
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Underline text"),
          keystroke: "CTRL+U"
        }
      ]
    });
  }
};
var underlineIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
var UNDERLINE = "underline";
var UnderlineUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "UnderlineUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const createButton = getButtonCreator({
      editor,
      commandName: UNDERLINE,
      plugin: this,
      icon: underlineIcon,
      label: t("Underline"),
      keystroke: "CTRL+U"
    });
    editor.ui.componentFactory.add(UNDERLINE, () => createButton(ButtonView));
    editor.ui.componentFactory.add("menuBar:" + UNDERLINE, () => createButton(MenuBarMenuListItemButtonView));
  }
};
var Underline = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      UnderlineEditing,
      UnderlineUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Underline";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-block-quote/dist/index.js
var BlockQuoteCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the command. When the command {@link #value is on}, all top-most block quotes within
  * the selection will be removed. If it is off, all selected blocks will be wrapped with
  * a block quote.
  *
  * @fires execute
  * @param options Command options.
  * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a block quote,
  * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    const blocks = Array.from(selection.getSelectedBlocks());
    const value = options2.forceValue === void 0 ? !this.value : options2.forceValue;
    model.change((writer) => {
      if (!value) {
        this._removeQuote(writer, blocks.filter(findQuote));
      } else {
        const blocksToQuote = blocks.filter((block2) => {
          return findQuote(block2) || checkCanBeQuoted(schema, block2);
        });
        this._applyQuote(writer, blocksToQuote);
      }
    });
  }
  /**
  * Checks the command's {@link #value}.
  */
  _getValue() {
    const selection = this.editor.model.document.selection;
    const firstBlock = first(selection.getSelectedBlocks());
    return !!(firstBlock && findQuote(firstBlock));
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    if (this.value) {
      return true;
    }
    const selection = this.editor.model.document.selection;
    const schema = this.editor.model.schema;
    const firstBlock = first(selection.getSelectedBlocks());
    if (!firstBlock) {
      return false;
    }
    return checkCanBeQuoted(schema, firstBlock);
  }
  /**
  * Removes the quote from given blocks.
  *
  * If blocks which are supposed to be "unquoted" are in the middle of a quote,
  * start it or end it, then the quote will be split (if needed) and the blocks
  * will be moved out of it, so other quoted blocks remained quoted.
  */
  _removeQuote(writer, blocks) {
    getRangesOfBlockGroups(writer, blocks).reverse().forEach((groupRange) => {
      if (groupRange.start.isAtStart && groupRange.end.isAtEnd) {
        writer.unwrap(groupRange.start.parent);
        return;
      }
      if (groupRange.start.isAtStart) {
        const positionBefore = writer.createPositionBefore(groupRange.start.parent);
        writer.move(groupRange, positionBefore);
        return;
      }
      if (!groupRange.end.isAtEnd) {
        writer.split(groupRange.end);
      }
      const positionAfter = writer.createPositionAfter(groupRange.end.parent);
      writer.move(groupRange, positionAfter);
    });
  }
  /**
  * Applies the quote to given blocks.
  */
  _applyQuote(writer, blocks) {
    const quotesToMerge = [];
    getRangesOfBlockGroups(writer, blocks).reverse().forEach((groupRange) => {
      let quote = findQuote(groupRange.start);
      if (!quote) {
        quote = writer.createElement("blockQuote");
        writer.wrap(groupRange, quote);
      }
      quotesToMerge.push(quote);
    });
    quotesToMerge.reverse().reduce((currentQuote, nextQuote) => {
      if (currentQuote.nextSibling == nextQuote) {
        writer.merge(writer.createPositionAfter(currentQuote));
        return currentQuote;
      }
      return nextQuote;
    });
  }
};
function findQuote(elementOrPosition) {
  return elementOrPosition.parent.name == "blockQuote" ? elementOrPosition.parent : null;
}
function getRangesOfBlockGroups(writer, blocks) {
  let startPosition;
  let i = 0;
  const ranges = [];
  while (i < blocks.length) {
    const block2 = blocks[i];
    const nextBlock = blocks[i + 1];
    if (!startPosition) {
      startPosition = writer.createPositionBefore(block2);
    }
    if (!nextBlock || block2.nextSibling != nextBlock) {
      ranges.push(writer.createRange(startPosition, writer.createPositionAfter(block2)));
      startPosition = null;
    }
    i++;
  }
  return ranges;
}
function checkCanBeQuoted(schema, block2) {
  const isBQAllowed = schema.checkChild(block2.parent, "blockQuote");
  const isBlockAllowedInBQ = schema.checkChild([
    "$root",
    "blockQuote"
  ], block2);
  return isBQAllowed && isBlockAllowedInBQ;
}
var BlockQuoteEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "BlockQuoteEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Enter,
      Delete
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    editor.commands.add("blockQuote", new BlockQuoteCommand(editor));
    schema.register("blockQuote", {
      inheritAllFrom: "$container"
    });
    editor.conversion.elementToElement({
      model: "blockQuote",
      view: "blockquote"
    });
    editor.model.document.registerPostFixer((writer) => {
      const changes = editor.model.document.differ.getChanges();
      for (const entry of changes) {
        if (entry.type == "insert") {
          const element = entry.position.nodeAfter;
          if (!element) {
            continue;
          }
          if (element.is("element", "blockQuote") && element.isEmpty) {
            writer.remove(element);
            return true;
          } else if (element.is("element", "blockQuote") && !schema.checkChild(entry.position, element)) {
            writer.unwrap(element);
            return true;
          } else if (element.is("element")) {
            const range = writer.createRangeIn(element);
            for (const child of range.getItems()) {
              if (child.is("element", "blockQuote") && !schema.checkChild(writer.createPositionBefore(child), child)) {
                writer.unwrap(child);
                return true;
              }
            }
          }
        } else if (entry.type == "remove") {
          const parent = entry.position.parent;
          if (parent.is("element", "blockQuote") && parent.isEmpty) {
            writer.remove(parent);
            return true;
          }
        }
      }
      return false;
    });
    const viewDocument = this.editor.editing.view.document;
    const selection = editor.model.document.selection;
    const blockQuoteCommand = editor.commands.get("blockQuote");
    this.listenTo(viewDocument, "enter", (evt, data) => {
      if (!selection.isCollapsed || !blockQuoteCommand.value) {
        return;
      }
      const positionParent = selection.getLastPosition().parent;
      if (positionParent.isEmpty) {
        editor.execute("blockQuote");
        editor.editing.view.scrollToTheSelection();
        data.preventDefault();
        evt.stop();
      }
    }, {
      context: "blockquote"
    });
    this.listenTo(viewDocument, "delete", (evt, data) => {
      if (data.direction != "backward" || !selection.isCollapsed || !blockQuoteCommand.value) {
        return;
      }
      const positionParent = selection.getLastPosition().parent;
      if (positionParent.isEmpty && !positionParent.previousSibling) {
        editor.execute("blockQuote");
        editor.editing.view.scrollToTheSelection();
        data.preventDefault();
        evt.stop();
      }
    }, {
      context: "blockquote"
    });
  }
};
var BlockQuoteUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "BlockQuoteUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("blockQuote", () => {
      const buttonView = this._createButton(ButtonView);
      buttonView.set({
        tooltip: true
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:blockQuote", () => {
      const buttonView = this._createButton(MenuBarMenuListItemButtonView);
      buttonView.set({
        role: "menuitemcheckbox"
      });
      return buttonView;
    });
  }
  /**
  * Creates a button for block quote command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get("blockQuote");
    const view = new ButtonClass(editor.locale);
    const t = locale.t;
    view.set({
      label: t("Block quote"),
      icon: icons.quote,
      isToggleable: true
    });
    view.bind("isEnabled").to(command, "isEnabled");
    view.bind("isOn").to(command, "value");
    this.listenTo(view, "execute", () => {
      editor.execute("blockQuote");
      editor.editing.view.focus();
    });
    return view;
  }
};
var BlockQuote = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      BlockQuoteEditing,
      BlockQuoteUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "BlockQuote";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/blurhash/dist/esm/index.js
var q = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "#", "$", "%", "*", "+", ",", "-", ".", ":", ";", "=", "?", "@", "[", "]", "^", "_", "{", "|", "}", "~"];
var x = (t) => {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    let n = t[r], l = q.indexOf(n);
    e = e * 83 + l;
  }
  return e;
};
var f = (t) => {
  let e = t / 255;
  return e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
};
var h = (t) => {
  let e = Math.max(0, Math.min(1, t));
  return e <= 31308e-7 ? Math.trunc(e * 12.92 * 255 + 0.5) : Math.trunc((1.055 * Math.pow(e, 0.4166666666666667) - 0.055) * 255 + 0.5);
};
var F = (t) => t < 0 ? -1 : 1;
var M = (t, e) => F(t) * Math.pow(Math.abs(t), e);
var d = class extends Error {
  constructor(e) {
    super(e), this.name = "ValidationError", this.message = e;
  }
};
var C = (t) => {
  if (!t || t.length < 6) throw new d("The blurhash string must be at least 6 characters");
  let e = x(t[0]), r = Math.floor(e / 9) + 1, n = e % 9 + 1;
  if (t.length !== 4 + 2 * n * r) throw new d(`blurhash length mismatch: length is ${t.length} but it should be ${4 + 2 * n * r}`);
};
var z = (t) => {
  let e = t >> 16, r = t >> 8 & 255, n = t & 255;
  return [f(e), f(r), f(n)];
};
var L = (t, e) => {
  let r = Math.floor(t / 361), n = Math.floor(t / 19) % 19, l = t % 19;
  return [M((r - 9) / 9, 2) * e, M((n - 9) / 9, 2) * e, M((l - 9) / 9, 2) * e];
};
var U = (t, e, r, n) => {
  C(t), n = n | 1;
  let l = x(t[0]), m = Math.floor(l / 9) + 1, b = l % 9 + 1, i = (x(t[1]) + 1) / 166, u = new Array(b * m);
  for (let o = 0; o < u.length; o++) if (o === 0) {
    let a = x(t.substring(2, 6));
    u[o] = z(a);
  } else {
    let a = x(t.substring(4 + o * 2, 6 + o * 2));
    u[o] = L(a, i * n);
  }
  let c = e * 4, s = new Uint8ClampedArray(c * r);
  for (let o = 0; o < r; o++) for (let a = 0; a < e; a++) {
    let y = 0, B = 0, R = 0;
    for (let w = 0; w < m; w++) for (let P = 0; P < b; P++) {
      let G = Math.cos(Math.PI * a * P / e) * Math.cos(Math.PI * o * w / r), T = u[P + w * b];
      y += T[0] * G, B += T[1] * G, R += T[2] * G;
    }
    let V = h(y), I = h(B), E = h(R);
    s[4 * a + 0 + o * c] = V, s[4 * a + 1 + o * c] = I, s[4 * a + 2 + o * c] = E, s[4 * a + 3 + o * c] = 255;
  }
  return s;
};
var j = U;

// node_modules/@ckeditor/ckeditor5-ckbox/dist/index.js
var CKBoxUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKBoxUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    if (!editor.commands.get("ckbox")) {
      return;
    }
    editor.ui.componentFactory.add("ckbox", () => this._createFileToolbarButton());
    editor.ui.componentFactory.add("menuBar:ckbox", () => this._createFileMenuBarButton());
    if (editor.plugins.has("ImageInsertUI")) {
      editor.plugins.get("ImageInsertUI").registerIntegration({
        name: "assetManager",
        observable: () => editor.commands.get("ckbox"),
        buttonViewCreator: () => this._createImageToolbarButton(),
        formViewCreator: () => this._createImageDropdownButton(),
        menuBarButtonViewCreator: (isOnly) => this._createImageMenuBarButton(isOnly ? "insertOnly" : "insertNested")
      });
    }
  }
  /**
  * Creates the base for various kinds of the button component provided by this feature.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const view = new ButtonClass(locale);
    const command = editor.commands.get("ckbox");
    view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
    view.on("execute", () => {
      editor.execute("ckbox");
    });
    return view;
  }
  /**
  * Creates a simple toolbar button for files management, with an icon and a tooltip.
  */
  _createFileToolbarButton() {
    const t = this.editor.locale.t;
    const button = this._createButton(ButtonView);
    button.icon = icons.browseFiles;
    button.label = t("Open file manager");
    button.tooltip = true;
    return button;
  }
  /**
  * Creates a simple toolbar button for images management, with an icon and a tooltip.
  */
  _createImageToolbarButton() {
    const t = this.editor.locale.t;
    const imageInsertUI = this.editor.plugins.get("ImageInsertUI");
    const button = this._createButton(ButtonView);
    button.icon = icons.imageAssetManager;
    button.bind("label").to(imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace image with file manager") : t("Insert image with file manager"));
    button.tooltip = true;
    return button;
  }
  /**
  * Creates a button for images management for the dropdown view, with an icon, text and no tooltip.
  */
  _createImageDropdownButton() {
    const t = this.editor.locale.t;
    const imageInsertUI = this.editor.plugins.get("ImageInsertUI");
    const button = this._createButton(ButtonView);
    button.icon = icons.imageAssetManager;
    button.withText = true;
    button.bind("label").to(imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace with file manager") : t("Insert with file manager"));
    button.on("execute", () => {
      imageInsertUI.dropdownView.isOpen = false;
    });
    return button;
  }
  /**
  * Creates a button for files management for the menu bar.
  */
  _createFileMenuBarButton() {
    const t = this.editor.locale.t;
    const button = this._createButton(MenuBarMenuListItemButtonView);
    button.icon = icons.browseFiles;
    button.withText = true;
    button.label = t("File");
    return button;
  }
  /**
  * Creates a button for images management for the menu bar.
  */
  _createImageMenuBarButton(type) {
    const translateVariableKey = this.editor.locale.t;
    const t = this.editor.locale.t;
    const button = this._createButton(MenuBarMenuListItemButtonView);
    button.icon = icons.imageAssetManager;
    button.withText = true;
    switch (type) {
      case "insertOnly":
        button.label = translateVariableKey("Image");
        break;
      case "insertNested":
        button.label = t("With file manager");
        break;
    }
    return button;
  }
};
function getImageUrls(imageUrls) {
  const responsiveUrls = [];
  let maxWidth = 0;
  for (const key in imageUrls) {
    const width = parseInt(key, 10);
    if (!isNaN(width)) {
      if (width > maxWidth) {
        maxWidth = width;
      }
      responsiveUrls.push(`${imageUrls[key]} ${key}w`);
    }
  }
  const imageSources = [
    {
      srcset: responsiveUrls.join(","),
      sizes: `(max-width: ${maxWidth}px) 100vw, ${maxWidth}px`,
      type: "image/webp"
    }
  ];
  return {
    imageFallbackUrl: imageUrls.default,
    imageSources
  };
}
function getWorkspaceId(token, defaultWorkspaceId) {
  const [, binaryTokenPayload] = token.value.split(".");
  const payload = JSON.parse(atob(binaryTokenPayload));
  const workspaces = payload.auth && payload.auth.ckbox && payload.auth.ckbox.workspaces || [
    payload.aud
  ];
  if (!defaultWorkspaceId) {
    return workspaces[0];
  }
  const role = payload.auth && payload.auth.ckbox && payload.auth.ckbox.role;
  if (role == "superadmin" || workspaces.includes(defaultWorkspaceId)) {
    return defaultWorkspaceId;
  }
  return null;
}
var BLUR_RESOLUTION = 32;
function blurHashToDataUrl(hash) {
  if (!hash) {
    return;
  }
  try {
    const resolutionInPx = `${BLUR_RESOLUTION}px`;
    const canvas = document.createElement("canvas");
    canvas.setAttribute("width", resolutionInPx);
    canvas.setAttribute("height", resolutionInPx);
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      return;
    }
    const imageData = ctx.createImageData(BLUR_RESOLUTION, BLUR_RESOLUTION);
    const decoded = j(hash, BLUR_RESOLUTION, BLUR_RESOLUTION);
    imageData.data.set(decoded);
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  } catch (e) {
    return void 0;
  }
}
function sendHttpRequest({ url, method = "GET", data, onUploadProgress, signal, authorization }) {
  const xhr = new XMLHttpRequest();
  xhr.open(method, url.toString());
  xhr.setRequestHeader("Authorization", authorization);
  xhr.setRequestHeader("CKBox-Version", "CKEditor 5");
  xhr.responseType = "json";
  const abortCallback = () => {
    xhr.abort();
  };
  return new Promise((resolve, reject) => {
    signal.throwIfAborted();
    signal.addEventListener("abort", abortCallback);
    xhr.addEventListener("loadstart", () => {
      signal.addEventListener("abort", abortCallback);
    });
    xhr.addEventListener("loadend", () => {
      signal.removeEventListener("abort", abortCallback);
    });
    xhr.addEventListener("error", () => {
      reject();
    });
    xhr.addEventListener("abort", () => {
      reject();
    });
    xhr.addEventListener("load", () => {
      const response = xhr.response;
      if (!response || response.statusCode >= 400) {
        return reject(response && response.message);
      }
      resolve(response);
    });
    if (onUploadProgress) {
      xhr.upload.addEventListener("progress", (evt) => {
        onUploadProgress(evt);
      });
    }
    xhr.send(data);
  });
}
var MIME_TO_EXTENSION = {
  "image/gif": "gif",
  "image/jpeg": "jpg",
  "image/png": "png",
  "image/webp": "webp",
  "image/bmp": "bmp",
  "image/tiff": "tiff"
};
function convertMimeTypeToExtension(mimeType) {
  return MIME_TO_EXTENSION[mimeType];
}
async function getContentTypeOfUrl(url, options2) {
  try {
    const response = await fetch(url, {
      method: "HEAD",
      cache: "force-cache",
      ...options2
    });
    if (!response.ok) {
      return "";
    }
    return response.headers.get("content-type") || "";
  } catch {
    return "";
  }
}
function getFileExtension(file) {
  const fileName = file.name;
  const extensionRegExp = /\.(?<ext>[^.]+)$/;
  const match = fileName.match(extensionRegExp);
  return match.groups.ext.toLowerCase();
}
var ASSET_INSERTION_WAIT_TIMEOUT = 1e3;
var CKBoxCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * A set of all chosen assets. They are stored temporarily and they are automatically removed 1 second after being chosen.
    * Chosen assets have to be "remembered" for a while to be able to map the given asset with the element inserted into the model.
    * This association map is then used to set the ID on the model element.
    *
    * All chosen assets are automatically removed after the timeout, because (theoretically) it may happen that they will never be
    * inserted into the model, even if the {@link module:link/linkcommand~LinkCommand `'link'`} command or the
    * {@link module:image/image/insertimagecommand~InsertImageCommand `'insertImage'`} command is enabled. Such a case may arise when
    * another plugin blocks the command execution. Then, in order not to keep the chosen (but not inserted) assets forever, we delete
    * them automatically to prevent memory leakage. The 1 second timeout is enough to insert the asset into the model and extract the
    * ID from the chosen asset.
    *
    * The assets are stored only if
    * the {@link module:ckbox/ckboxconfig~CKBoxConfig#ignoreDataId `config.ckbox.ignoreDataId`} option is set to `false` (by default).
    *
    * @internal
    */
    __publicField(this, "_chosenAssets", /* @__PURE__ */ new Set());
    /**
    * The DOM element that acts as a mounting point for the CKBox dialog.
    */
    __publicField(this, "_wrapper", null);
    this._initListeners();
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
  * @inheritDoc
  */
  execute() {
    this.fire("ckbox:open");
  }
  /**
  * Indicates if the CKBox dialog is already opened.
  *
  * @protected
  * @returns {Boolean}
  */
  _getValue() {
    return this._wrapper !== null;
  }
  /**
  * Checks whether the command can be enabled in the current context.
  */
  _checkEnabled() {
    const imageCommand = this.editor.commands.get("insertImage");
    const linkCommand = this.editor.commands.get("link");
    if (!imageCommand.isEnabled && !linkCommand.isEnabled) {
      return false;
    }
    return true;
  }
  /**
  * Creates the options object for the CKBox dialog.
  *
  * @returns The object with properties:
  * - theme The theme for CKBox dialog.
  * - language The language for CKBox dialog.
  * - tokenUrl The token endpoint URL.
  * - serviceOrigin The base URL of the API service.
  * - forceDemoLabel Whether to force "Powered by CKBox" link.
  * - assets.onChoose The callback function invoked after choosing the assets.
  * - dialog.onClose The callback function invoked after closing the CKBox dialog.
  * - dialog.width The dialog width in pixels.
  * - dialog.height The dialog height in pixels.
  * - categories.icons Allows setting custom icons for categories.
  * - view.openLastView Sets if the last view visited by the user will be reopened
  * on the next startup.
  * - view.startupFolderId Sets the ID of the folder that will be opened on startup.
  * - view.startupCategoryId Sets the ID of the category that will be opened on startup.
  * - view.hideMaximizeButton Sets whether to hide the Maximize button.
  * - view.componentsHideTimeout Sets timeout after which upload components are hidden
  * after completed upload.
  * - view.dialogMinimizeTimeout Sets timeout after which upload dialog is minimized
  * after completed upload.
  */
  _prepareOptions() {
    const editor = this.editor;
    const ckboxConfig = editor.config.get("ckbox");
    const dialog = ckboxConfig.dialog;
    const categories = ckboxConfig.categories;
    const view = ckboxConfig.view;
    const upload = ckboxConfig.upload;
    return {
      theme: ckboxConfig.theme,
      language: ckboxConfig.language,
      tokenUrl: ckboxConfig.tokenUrl,
      serviceOrigin: ckboxConfig.serviceOrigin,
      forceDemoLabel: ckboxConfig.forceDemoLabel,
      choosableFileExtensions: ckboxConfig.choosableFileExtensions,
      assets: {
        onChoose: (assets) => this.fire("ckbox:choose", assets)
      },
      dialog: {
        onClose: () => this.fire("ckbox:close"),
        width: dialog && dialog.width,
        height: dialog && dialog.height
      },
      categories: categories && {
        icons: categories.icons
      },
      view: view && {
        openLastView: view.openLastView,
        startupFolderId: view.startupFolderId,
        startupCategoryId: view.startupCategoryId,
        hideMaximizeButton: view.hideMaximizeButton
      },
      upload: upload && {
        componentsHideTimeout: upload.componentsHideTimeout,
        dialogMinimizeTimeout: upload.dialogMinimizeTimeout
      }
    };
  }
  /**
  * Initializes various event listeners for the `ckbox:*` events, because all functionality of the `ckbox` command is event-based.
  */
  _initListeners() {
    const editor = this.editor;
    const model = editor.model;
    const shouldInsertDataId = !editor.config.get("ckbox.ignoreDataId");
    this.on("ckbox", () => {
      this.refresh();
    }, {
      priority: "low"
    });
    this.on("ckbox:open", () => {
      if (!this.isEnabled || this.value) {
        return;
      }
      this._wrapper = createElement(document, "div", {
        class: "ck ckbox-wrapper"
      });
      document.body.appendChild(this._wrapper);
      window.CKBox.mount(this._wrapper, this._prepareOptions());
    });
    this.on("ckbox:close", () => {
      if (!this.value) {
        return;
      }
      this._wrapper.remove();
      this._wrapper = null;
      editor.editing.view.focus();
    });
    this.on("ckbox:choose", (evt, assets) => {
      if (!this.isEnabled) {
        return;
      }
      const imageCommand = editor.commands.get("insertImage");
      const linkCommand = editor.commands.get("link");
      const assetsToProcess = prepareAssets({
        assets,
        isImageAllowed: imageCommand.isEnabled,
        isLinkAllowed: linkCommand.isEnabled
      });
      const assetsCount = assetsToProcess.length;
      if (assetsCount === 0) {
        return;
      }
      model.change((writer) => {
        for (const asset of assetsToProcess) {
          const isLastAsset = asset === assetsToProcess[assetsCount - 1];
          const isSingleAsset = assetsCount === 1;
          this._insertAsset(asset, isLastAsset, writer, isSingleAsset);
          if (shouldInsertDataId) {
            setTimeout(() => this._chosenAssets.delete(asset), ASSET_INSERTION_WAIT_TIMEOUT);
            this._chosenAssets.add(asset);
          }
        }
      });
      editor.editing.view.focus();
    });
    this.listenTo(editor, "destroy", () => {
      this.fire("ckbox:close");
      this._chosenAssets.clear();
    });
  }
  /**
  * Inserts the asset into the model.
  *
  * @param asset The asset to be inserted.
  * @param isLastAsset Indicates if the current asset is the last one from the chosen set.
  * @param writer An instance of the model writer.
  * @param isSingleAsset It's true when only one asset is processed.
  */
  _insertAsset(asset, isLastAsset, writer, isSingleAsset) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    writer.removeSelectionAttribute("linkHref");
    if (asset.type === "image") {
      this._insertImage(asset);
    } else {
      this._insertLink(asset, writer, isSingleAsset);
    }
    if (!isLastAsset) {
      writer.setSelection(selection.getLastPosition());
    }
  }
  /**
  * Inserts the image by calling the `insertImage` command.
  *
  * @param asset The asset to be inserted.
  */
  _insertImage(asset) {
    const editor = this.editor;
    const { imageFallbackUrl, imageSources, imageTextAlternative, imageWidth, imageHeight, imagePlaceholder } = asset.attributes;
    editor.execute("insertImage", {
      source: {
        src: imageFallbackUrl,
        sources: imageSources,
        alt: imageTextAlternative,
        width: imageWidth,
        height: imageHeight,
        ...imagePlaceholder ? {
          placeholder: imagePlaceholder
        } : null
      }
    });
  }
  /**
  * Inserts the link to the asset by calling the `link` command.
  *
  * @param asset The asset to be inserted.
  * @param writer An instance of the model writer.
  * @param isSingleAsset It's true when only one asset is processed.
  */
  _insertLink(asset, writer, isSingleAsset) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const { linkName, linkHref } = asset.attributes;
    if (selection.isCollapsed) {
      const selectionAttributes = toMap(selection.getAttributes());
      const textNode = writer.createText(linkName, selectionAttributes);
      if (!isSingleAsset) {
        const selectionLastPosition = selection.getLastPosition();
        const parentElement = selectionLastPosition.parent;
        if (!(parentElement.name === "paragraph" && parentElement.isEmpty)) {
          editor.execute("insertParagraph", {
            position: selectionLastPosition
          });
        }
        const range2 = model.insertContent(textNode);
        writer.setSelection(range2);
        editor.execute("link", linkHref);
        return;
      }
      const range = model.insertContent(textNode);
      writer.setSelection(range);
    }
    editor.execute("link", linkHref);
  }
};
function prepareAssets({ assets, isImageAllowed, isLinkAllowed }) {
  return assets.map((asset) => isImage(asset) ? {
    id: asset.data.id,
    type: "image",
    attributes: prepareImageAssetAttributes(asset)
  } : {
    id: asset.data.id,
    type: "link",
    attributes: prepareLinkAssetAttributes(asset)
  }).filter((asset) => asset.type === "image" ? isImageAllowed : isLinkAllowed);
}
function prepareImageAssetAttributes(asset) {
  const { imageFallbackUrl, imageSources } = getImageUrls(asset.data.imageUrls);
  const { description, width, height, blurHash } = asset.data.metadata;
  const imagePlaceholder = blurHashToDataUrl(blurHash);
  return {
    imageFallbackUrl,
    imageSources,
    imageTextAlternative: description || "",
    imageWidth: width,
    imageHeight: height,
    ...imagePlaceholder ? {
      imagePlaceholder
    } : null
  };
}
function prepareLinkAssetAttributes(asset) {
  return {
    linkName: asset.data.name,
    linkHref: getAssetUrl(asset)
  };
}
function isImage(asset) {
  const metadata = asset.data.metadata;
  if (!metadata) {
    return false;
  }
  return metadata.width && metadata.height;
}
function getAssetUrl(asset) {
  const url = new URL(asset.data.url);
  url.searchParams.set("download", "true");
  return url.toString();
}
var DEFAULT_CKBOX_THEME_NAME = "lark";
var CKBoxUtils = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * CKEditor Cloud Services access token.
    */
    __publicField(this, "_token");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKBoxUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "CloudServices"
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const hasConfiguration = !!editor.config.get("ckbox");
    const isLibraryLoaded2 = !!window.CKBox;
    if (!hasConfiguration && !isLibraryLoaded2) {
      return;
    }
    editor.config.define("ckbox", {
      serviceOrigin: "https://api.ckbox.io",
      defaultUploadCategories: null,
      ignoreDataId: false,
      language: editor.locale.uiLanguage,
      theme: DEFAULT_CKBOX_THEME_NAME,
      tokenUrl: editor.config.get("cloudServices.tokenUrl")
    });
    const cloudServices = editor.plugins.get("CloudServices");
    const cloudServicesTokenUrl = editor.config.get("cloudServices.tokenUrl");
    const ckboxTokenUrl = editor.config.get("ckbox.tokenUrl");
    if (!ckboxTokenUrl) {
      throw new CKEditorError("ckbox-plugin-missing-token-url", this);
    }
    if (ckboxTokenUrl == cloudServicesTokenUrl) {
      this._token = Promise.resolve(cloudServices.token);
    } else {
      this._token = cloudServices.registerTokenUrl(ckboxTokenUrl);
    }
  }
  /**
  * Returns a token used by the CKBox plugin for communication with the CKBox service.
  */
  getToken() {
    return this._token;
  }
  /**
  * The ID of workspace to use when uploading an image.
  */
  async getWorkspaceId() {
    const t = this.editor.t;
    const cannotAccessDefaultWorkspaceError = t("Cannot access default workspace.");
    const defaultWorkspaceId = this.editor.config.get("ckbox.defaultUploadWorkspaceId");
    const workspaceId = getWorkspaceId(await this._token, defaultWorkspaceId);
    if (workspaceId == null) {
      logError("ckbox-access-default-workspace-error");
      throw cannotAccessDefaultWorkspaceError;
    }
    return workspaceId;
  }
  /**
  * Resolves a promise with an object containing a category with which the uploaded file is associated or an error code.
  */
  async getCategoryIdForFile(fileOrUrl, options2) {
    const t = this.editor.t;
    const cannotFindCategoryError = t("Cannot determine a category for the uploaded file.");
    const defaultCategories = this.editor.config.get("ckbox.defaultUploadCategories");
    const allCategoriesPromise = this._getAvailableCategories(options2);
    const extension = typeof fileOrUrl == "string" ? convertMimeTypeToExtension(await getContentTypeOfUrl(fileOrUrl, options2)) : getFileExtension(fileOrUrl);
    const allCategories = await allCategoriesPromise;
    if (!allCategories) {
      throw cannotFindCategoryError;
    }
    if (defaultCategories) {
      const userCategory = Object.keys(defaultCategories).find((category2) => {
        return defaultCategories[category2].find((e) => e.toLowerCase() == extension);
      });
      if (userCategory) {
        const serverCategory = allCategories.find((category2) => category2.id === userCategory || category2.name === userCategory);
        if (!serverCategory) {
          throw cannotFindCategoryError;
        }
        return serverCategory.id;
      }
    }
    const category = allCategories.find((category2) => category2.extensions.find((e) => e.toLowerCase() == extension));
    if (!category) {
      throw cannotFindCategoryError;
    }
    return category.id;
  }
  /**
  * Resolves a promise with an array containing available categories with which the uploaded file can be associated.
  *
  * If the API returns limited results, the method will collect all items.
  */
  async _getAvailableCategories(options2) {
    const ITEMS_PER_REQUEST = 50;
    const editor = this.editor;
    const token = this._token;
    const { signal } = options2;
    const serviceOrigin = editor.config.get("ckbox.serviceOrigin");
    const workspaceId = await this.getWorkspaceId();
    try {
      const result = [];
      let offset = 0;
      let remainingItems;
      do {
        const data = await fetchCategories(offset);
        result.push(...data.items);
        remainingItems = data.totalCount - (offset + ITEMS_PER_REQUEST);
        offset += ITEMS_PER_REQUEST;
      } while (remainingItems > 0);
      return result;
    } catch {
      signal.throwIfAborted();
      logError("ckbox-fetch-category-http-error");
      return void 0;
    }
    async function fetchCategories(offset) {
      const categoryUrl = new URL("categories", serviceOrigin);
      categoryUrl.searchParams.set("limit", String(ITEMS_PER_REQUEST));
      categoryUrl.searchParams.set("offset", String(offset));
      categoryUrl.searchParams.set("workspaceId", workspaceId);
      return sendHttpRequest({
        url: categoryUrl,
        signal,
        authorization: (await token).value
      });
    }
  }
};
var CKBoxUploadAdapter = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "ImageUploadEditing",
      "ImageUploadProgress",
      FileRepository,
      CKBoxEditing
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKBoxUploadAdapter";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  async afterInit() {
    const editor = this.editor;
    const hasConfiguration = !!editor.config.get("ckbox");
    const isLibraryLoaded2 = !!window.CKBox;
    if (!hasConfiguration && !isLibraryLoaded2) {
      return;
    }
    const fileRepository = editor.plugins.get(FileRepository);
    const ckboxUtils = editor.plugins.get(CKBoxUtils);
    fileRepository.createUploadAdapter = (loader) => new Adapter3(loader, editor, ckboxUtils);
    const shouldInsertDataId = !editor.config.get("ckbox.ignoreDataId");
    const imageUploadEditing = editor.plugins.get("ImageUploadEditing");
    if (shouldInsertDataId) {
      imageUploadEditing.on("uploadComplete", (evt, { imageElement, data }) => {
        editor.model.change((writer) => {
          writer.setAttribute("ckboxImageId", data.ckboxImageId, imageElement);
        });
      });
    }
  }
};
var Adapter3 = class {
  /**
  * Creates a new adapter instance.
  */
  constructor(loader, editor, ckboxUtils) {
    /**
    * FileLoader instance to use during the upload.
    */
    __publicField(this, "loader");
    /**
    * CKEditor Cloud Services access token.
    */
    __publicField(this, "token");
    /**
    * The editor instance.
    */
    __publicField(this, "editor");
    /**
    * The abort controller for aborting asynchronous processes.
    */
    __publicField(this, "controller");
    /**
    * The base URL where all requests should be sent.
    */
    __publicField(this, "serviceOrigin");
    /**
    * The reference to CKBoxUtils plugin.
    */
    __publicField(this, "ckboxUtils");
    this.loader = loader;
    this.token = ckboxUtils.getToken();
    this.ckboxUtils = ckboxUtils;
    this.editor = editor;
    this.controller = new AbortController();
    this.serviceOrigin = editor.config.get("ckbox.serviceOrigin");
  }
  /**
  * Starts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#upload
  */
  async upload() {
    const ckboxUtils = this.ckboxUtils;
    const t = this.editor.t;
    const file = await this.loader.file;
    const category = await ckboxUtils.getCategoryIdForFile(file, {
      signal: this.controller.signal
    });
    const uploadUrl = new URL("assets", this.serviceOrigin);
    const formData = new FormData();
    uploadUrl.searchParams.set("workspaceId", await ckboxUtils.getWorkspaceId());
    formData.append("categoryId", category);
    formData.append("file", file);
    const requestConfig = {
      method: "POST",
      url: uploadUrl,
      data: formData,
      onUploadProgress: (evt) => {
        if (evt.lengthComputable) {
          this.loader.uploadTotal = evt.total;
          this.loader.uploaded = evt.loaded;
        }
      },
      signal: this.controller.signal,
      authorization: (await this.token).value
    };
    return sendHttpRequest(requestConfig).then(async (data) => {
      const imageUrls = getImageUrls(data.imageUrls);
      return {
        ckboxImageId: data.id,
        default: imageUrls.imageFallbackUrl,
        sources: imageUrls.imageSources
      };
    }).catch(() => {
      const genericError = t("Cannot upload file:") + ` ${file.name}.`;
      return Promise.reject(genericError);
    });
  }
  /**
  * Aborts the upload process.
  *
  * @see module:upload/filerepository~UploadAdapter#abort
  */
  abort() {
    this.controller.abort();
  }
};
var COMMAND_FORCE_DISABLE_ID = "NoPermission";
var CKBoxEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKBoxEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "LinkEditing",
      "PictureEditing",
      CKBoxUploadAdapter,
      CKBoxUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!this._shouldBeInitialised()) {
      return;
    }
    this._checkImagePlugins();
    if (isLibraryLoaded()) {
      editor.commands.add("ckbox", new CKBoxCommand(editor));
    }
    isUploadPermissionGranted(editor).then((isCreateAssetAllowed) => {
      if (!isCreateAssetAllowed) {
        this._blockImageCommands();
      }
    });
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    if (!this._shouldBeInitialised()) {
      return;
    }
    if (!editor.config.get("ckbox.ignoreDataId")) {
      this._initSchema();
      this._initConversion();
      this._initFixers();
    }
  }
  /**
  * Returns true only when the integrator intentionally wants to use the plugin, i.e. when the `config.ckbox` exists or
  * the CKBox JavaScript library is loaded.
  */
  _shouldBeInitialised() {
    const editor = this.editor;
    const hasConfiguration = !!editor.config.get("ckbox");
    return hasConfiguration || isLibraryLoaded();
  }
  /**
  * Blocks `uploadImage` and `ckboxImageEdit` commands.
  */
  _blockImageCommands() {
    const editor = this.editor;
    const uploadImageCommand = editor.commands.get("uploadImage");
    const imageEditingCommand = editor.commands.get("ckboxImageEdit");
    if (uploadImageCommand) {
      uploadImageCommand.isAccessAllowed = false;
      uploadImageCommand.forceDisabled(COMMAND_FORCE_DISABLE_ID);
    }
    if (imageEditingCommand) {
      imageEditingCommand.forceDisabled(COMMAND_FORCE_DISABLE_ID);
    }
  }
  /**
  * Checks if at least one image plugin is loaded.
  */
  _checkImagePlugins() {
    const editor = this.editor;
    if (!editor.plugins.has("ImageBlockEditing") && !editor.plugins.has("ImageInlineEditing")) {
      logError("ckbox-plugin-image-feature-missing", editor);
    }
  }
  /**
  * Extends the schema to allow the `ckboxImageId` and `ckboxLinkId` attributes for links and images.
  */
  _initSchema() {
    const editor = this.editor;
    const schema = editor.model.schema;
    schema.extend("$text", {
      allowAttributes: "ckboxLinkId"
    });
    if (schema.isRegistered("imageBlock")) {
      schema.extend("imageBlock", {
        allowAttributes: [
          "ckboxImageId",
          "ckboxLinkId"
        ]
      });
    }
    if (schema.isRegistered("imageInline")) {
      schema.extend("imageInline", {
        allowAttributes: [
          "ckboxImageId",
          "ckboxLinkId"
        ]
      });
    }
    schema.addAttributeCheck((context) => {
      if (!context.last.getAttribute("linkHref")) {
        return false;
      }
    }, "ckboxLinkId");
  }
  /**
  * Configures the upcast and downcast conversions for the `ckboxImageId` and `ckboxLinkId` attributes.
  */
  _initConversion() {
    const editor = this.editor;
    editor.conversion.for("downcast").add((dispatcher) => {
      dispatcher.on("attribute:ckboxLinkId:imageBlock", (evt, data, conversionApi) => {
        const { writer, mapper, consumable } = conversionApi;
        if (!consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewFigure = mapper.toViewElement(data.item);
        const linkInImage = [
          ...viewFigure.getChildren()
        ].find((child) => child.name === "a");
        if (!linkInImage) {
          return;
        }
        if (data.item.hasAttribute("ckboxLinkId")) {
          writer.setAttribute("data-ckbox-resource-id", data.item.getAttribute("ckboxLinkId"), linkInImage);
        } else {
          writer.removeAttribute("data-ckbox-resource-id", linkInImage);
        }
      }, {
        priority: "low"
      });
      dispatcher.on("attribute:ckboxLinkId", (evt, data, conversionApi) => {
        const { writer, mapper, consumable } = conversionApi;
        if (!consumable.consume(data.item, evt.name)) {
          return;
        }
        if (data.attributeOldValue) {
          const viewElement = createLinkElement(writer, data.attributeOldValue);
          writer.unwrap(mapper.toViewRange(data.range), viewElement);
        }
        if (data.attributeNewValue) {
          const viewElement = createLinkElement(writer, data.attributeNewValue);
          if (data.item.is("selection")) {
            const viewSelection = writer.document.selection;
            writer.wrap(viewSelection.getFirstRange(), viewElement);
          } else {
            writer.wrap(mapper.toViewRange(data.range), viewElement);
          }
        }
      }, {
        priority: "low"
      });
    });
    editor.conversion.for("upcast").add((dispatcher) => {
      dispatcher.on("element:a", (evt, data, conversionApi) => {
        const { writer, consumable } = conversionApi;
        if (!data.viewItem.getAttribute("href")) {
          return;
        }
        const consumableAttributes = {
          attributes: [
            "data-ckbox-resource-id"
          ]
        };
        if (!consumable.consume(data.viewItem, consumableAttributes)) {
          return;
        }
        const attributeValue = data.viewItem.getAttribute("data-ckbox-resource-id");
        if (!attributeValue) {
          return;
        }
        if (data.modelRange) {
          for (let item of data.modelRange.getItems()) {
            if (item.is("$textProxy")) {
              item = item.textNode;
            }
            if (shouldUpcastAttributeForNode(item)) {
              writer.setAttribute("ckboxLinkId", attributeValue, item);
            }
          }
        } else {
          const modelElement = data.modelCursor.nodeBefore || data.modelCursor.parent;
          writer.setAttribute("ckboxLinkId", attributeValue, modelElement);
        }
      }, {
        priority: "low"
      });
    });
    editor.conversion.for("downcast").attributeToAttribute({
      model: "ckboxImageId",
      view: "data-ckbox-resource-id"
    });
    editor.conversion.for("upcast").elementToAttribute({
      model: {
        key: "ckboxImageId",
        value: (viewElement) => viewElement.getAttribute("data-ckbox-resource-id")
      },
      view: {
        attributes: {
          "data-ckbox-resource-id": /[\s\S]+/
        }
      }
    });
    const replaceImageSourceCommand = editor.commands.get("replaceImageSource");
    if (replaceImageSourceCommand) {
      this.listenTo(replaceImageSourceCommand, "cleanupImage", (_, [writer, image]) => {
        writer.removeAttribute("ckboxImageId", image);
      });
    }
  }
  /**
  * Registers post-fixers that add or remove the `ckboxLinkId` and `ckboxImageId` attributes.
  */
  _initFixers() {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    model.document.registerPostFixer(syncDataIdPostFixer(editor));
    model.document.registerPostFixer(injectSelectionPostFixer(selection));
  }
};
function syncDataIdPostFixer(editor) {
  return (writer) => {
    let changed = false;
    const model = editor.model;
    const ckboxCommand = editor.commands.get("ckbox");
    if (!ckboxCommand) {
      return changed;
    }
    for (const entry of model.document.differ.getChanges()) {
      if (entry.type !== "insert" && entry.type !== "attribute") {
        continue;
      }
      const range = entry.type === "insert" ? new Range(entry.position, entry.position.getShiftedBy(entry.length)) : entry.range;
      const isLinkHrefAttributeRemoval = entry.type === "attribute" && entry.attributeKey === "linkHref" && entry.attributeNewValue === null;
      for (const item of range.getItems()) {
        if (isLinkHrefAttributeRemoval && item.hasAttribute("ckboxLinkId")) {
          writer.removeAttribute("ckboxLinkId", item);
          changed = true;
          continue;
        }
        const assets = findAssetsForItem(item, ckboxCommand._chosenAssets);
        for (const asset of assets) {
          const attributeName = asset.type === "image" ? "ckboxImageId" : "ckboxLinkId";
          if (asset.id === item.getAttribute(attributeName)) {
            continue;
          }
          writer.setAttribute(attributeName, asset.id, item);
          changed = true;
        }
      }
    }
    return changed;
  };
}
function injectSelectionPostFixer(selection) {
  return (writer) => {
    const shouldRemoveLinkIdAttribute = !selection.hasAttribute("linkHref") && selection.hasAttribute("ckboxLinkId");
    if (shouldRemoveLinkIdAttribute) {
      writer.removeSelectionAttribute("ckboxLinkId");
      return true;
    }
    return false;
  };
}
function findAssetsForItem(item, assets) {
  const isImageElement = item.is("element", "imageInline") || item.is("element", "imageBlock");
  const isLinkElement2 = item.hasAttribute("linkHref");
  return [
    ...assets
  ].filter((asset) => {
    if (asset.type === "image" && isImageElement) {
      return asset.attributes.imageFallbackUrl === item.getAttribute("src");
    }
    if (asset.type === "link" && isLinkElement2) {
      return asset.attributes.linkHref === item.getAttribute("linkHref");
    }
  });
}
function createLinkElement(writer, id) {
  const viewElement = writer.createAttributeElement("a", {
    "data-ckbox-resource-id": id
  }, {
    priority: 5
  });
  writer.setCustomProperty("link", true, viewElement);
  return viewElement;
}
function shouldUpcastAttributeForNode(node) {
  if (node.is("$text")) {
    return true;
  }
  if (node.is("element", "imageInline") || node.is("element", "imageBlock")) {
    return true;
  }
  return false;
}
function isLibraryLoaded() {
  return !!window.CKBox;
}
async function isUploadPermissionGranted(editor) {
  const ckboxUtils = editor.plugins.get(CKBoxUtils);
  const origin = editor.config.get("ckbox.serviceOrigin");
  const url = new URL("permissions", origin);
  const { value } = await ckboxUtils.getToken();
  const response = await sendHttpRequest({
    url,
    authorization: value,
    signal: new AbortController().signal
    // Aborting is unnecessary.
  });
  return Object.values(response).some((category) => category["asset:create"]);
}
var CKBox = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKBox";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      CKBoxEditing,
      CKBoxUI
    ];
  }
};
function createEditabilityChecker(allowExternalImagesEditing) {
  const checkUrl = createUrlChecker(allowExternalImagesEditing);
  return (element) => {
    const isImageElement = element.is("element", "imageInline") || element.is("element", "imageBlock");
    if (!isImageElement) {
      return false;
    }
    if (element.hasAttribute("ckboxImageId")) {
      return true;
    }
    if (element.hasAttribute("src")) {
      return checkUrl(element.getAttribute("src"));
    }
    return false;
  };
}
function createUrlChecker(allowExternalImagesEditing) {
  if (Array.isArray(allowExternalImagesEditing)) {
    const urlMatchers = allowExternalImagesEditing.map(createUrlChecker);
    return (src) => urlMatchers.some((matcher) => matcher(src));
  }
  if (allowExternalImagesEditing == "origin") {
    const origin = global.window.location.origin;
    return (src) => new URL(src, global.document.baseURI).origin == origin;
  }
  if (typeof allowExternalImagesEditing == "function") {
    return allowExternalImagesEditing;
  }
  if (allowExternalImagesEditing instanceof RegExp) {
    return (src) => !!(src.match(allowExternalImagesEditing) || src.replace(/^https?:\/\//, "").match(allowExternalImagesEditing));
  }
  return () => false;
}
var CKBoxImageEditCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The DOM element that acts as a mounting point for the CKBox Edit Image dialog.
    */
    __publicField(this, "_wrapper", null);
    /**
    * The states of image processing in progress.
    */
    __publicField(this, "_processInProgress", /* @__PURE__ */ new Set());
    /**
    * Determines if the element can be edited.
    */
    __publicField(this, "_canEdit");
    /**
    * A wrapper function to prepare mount options. Ensures that at most one preparation is in-flight.
    */
    __publicField(this, "_prepareOptions");
    /**
    * CKBox's onClose function runs before the final cleanup, potentially causing
    * page layout changes after it finishes. To address this, we use a setTimeout hack
    * to ensure that floating elements on the page maintain their correct position.
    *
    * See: https://github.com/ckeditor/ckeditor5/issues/16153.
    */
    __publicField(this, "_updateUiDelayed", delay(() => this.editor.ui.update(), 0));
    this.value = false;
    this._canEdit = createEditabilityChecker(editor.config.get("ckbox.allowExternalImagesEditing"));
    this._prepareOptions = abortableDebounce((signal, state) => this._prepareOptionsAbortable(signal, state));
    this._prepareListeners();
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    this.value = this._getValue();
    const selectedElement = editor.model.document.selection.getSelectedElement();
    this.isEnabled = !!selectedElement && this._canEdit(selectedElement) && !this._checkIfElementIsBeingProcessed(selectedElement);
  }
  /**
  * Opens the CKBox Image Editor dialog for editing the image.
  */
  execute() {
    if (this._getValue()) {
      return;
    }
    const wrapper = createElement(document, "div", {
      class: "ck ckbox-wrapper"
    });
    this._wrapper = wrapper;
    this.value = true;
    document.body.appendChild(this._wrapper);
    const imageElement = this.editor.model.document.selection.getSelectedElement();
    const processingState = {
      element: imageElement,
      controller: new AbortController()
    };
    this._prepareOptions(processingState).then((options2) => window.CKBox.mountImageEditor(wrapper, options2), (error) => {
      const editor = this.editor;
      const t = editor.t;
      const notification = editor.plugins.get(Notification);
      notification.showWarning(t("Failed to determine category of edited image."), {
        namespace: "ckbox"
      });
      console.error(error);
      this._handleImageEditorClose();
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._handleImageEditorClose();
    this._prepareOptions.abort();
    this._updateUiDelayed.cancel();
    for (const state of this._processInProgress.values()) {
      state.controller.abort();
    }
    super.destroy();
  }
  /**
  * Indicates if the CKBox Image Editor dialog is already opened.
  */
  _getValue() {
    return this._wrapper !== null;
  }
  /**
  * Creates the options object for the CKBox Image Editor dialog.
  */
  async _prepareOptionsAbortable(signal, state) {
    const editor = this.editor;
    const ckboxConfig = editor.config.get("ckbox");
    const ckboxUtils = editor.plugins.get(CKBoxUtils);
    const { element } = state;
    let imageMountOptions;
    const ckboxImageId = element.getAttribute("ckboxImageId");
    if (ckboxImageId) {
      imageMountOptions = {
        assetId: ckboxImageId
      };
    } else {
      const imageUrl = new URL(element.getAttribute("src"), document.baseURI).href;
      const uploadCategoryId = await ckboxUtils.getCategoryIdForFile(imageUrl, {
        signal
      });
      imageMountOptions = {
        imageUrl,
        uploadCategoryId
      };
    }
    return {
      ...imageMountOptions,
      imageEditing: {
        allowOverwrite: false
      },
      tokenUrl: ckboxConfig.tokenUrl,
      ...ckboxConfig.serviceOrigin && {
        serviceOrigin: ckboxConfig.serviceOrigin
      },
      onClose: () => this._handleImageEditorClose(),
      onSave: (asset) => this._handleImageEditorSave(state, asset)
    };
  }
  /**
  * Initializes event lister for an event of removing an image.
  */
  _prepareListeners() {
    this.listenTo(this.editor.model.document, "change:data", () => {
      const processingStates = this._getProcessingStatesOfDeletedImages();
      processingStates.forEach((processingState) => {
        processingState.controller.abort();
      });
    });
  }
  /**
  * Gets processing states of images that have been deleted in the mean time.
  */
  _getProcessingStatesOfDeletedImages() {
    const states = [];
    for (const state of this._processInProgress.values()) {
      if (state.element.root.rootName == "$graveyard") {
        states.push(state);
      }
    }
    return states;
  }
  _checkIfElementIsBeingProcessed(selectedElement) {
    for (const { element } of this._processInProgress) {
      if (isEqual_default(element, selectedElement)) {
        return true;
      }
    }
    return false;
  }
  /**
  * Closes the CKBox Image Editor dialog.
  */
  _handleImageEditorClose() {
    if (!this._wrapper) {
      return;
    }
    this._wrapper.remove();
    this._wrapper = null;
    this.editor.editing.view.focus();
    this._updateUiDelayed();
    this.refresh();
  }
  /**
  * Save edited image. In case server respond with "success" replace with edited image,
  * otherwise show notification error.
  */
  _handleImageEditorSave(state, asset) {
    const t = this.editor.locale.t;
    const notification = this.editor.plugins.get(Notification);
    const pendingActions = this.editor.plugins.get(PendingActions);
    const action = pendingActions.add(t("Processing the edited image."));
    this._processInProgress.add(state);
    this._showImageProcessingIndicator(state.element, asset);
    this.refresh();
    this._waitForAssetProcessed(asset.data.id, state.controller.signal).then((asset2) => {
      this._replaceImage(state.element, asset2);
    }, (error) => {
      this.editor.editing.reconvertItem(state.element);
      if (state.controller.signal.aborted) {
        return;
      }
      if (!error || error instanceof CKEditorError) {
        notification.showWarning(t("Server failed to process the image."), {
          namespace: "ckbox"
        });
      } else {
        console.error(error);
      }
    }).finally(() => {
      this._processInProgress.delete(state);
      pendingActions.remove(action);
      this.refresh();
    });
  }
  /**
  * Get asset's status on server. If server responds with "success" status then
  * image is already proceeded and ready for saving.
  */
  async _getAssetStatusFromServer(id, signal) {
    const ckboxUtils = this.editor.plugins.get(CKBoxUtils);
    const url = new URL("assets/" + id, this.editor.config.get("ckbox.serviceOrigin"));
    const response = await sendHttpRequest({
      url,
      signal,
      authorization: (await ckboxUtils.getToken()).value
    });
    const status = response.metadata.metadataProcessingStatus;
    if (!status || status == "queued") {
      throw new CKEditorError("ckbox-image-not-processed");
    }
    return {
      data: {
        ...response
      }
    };
  }
  /**
  * Waits for an asset to be processed.
  * It retries retrieving asset status from the server in case of failure.
  */
  async _waitForAssetProcessed(id, signal) {
    const result = await retry(() => this._getAssetStatusFromServer(id, signal), {
      signal,
      maxAttempts: 5
    });
    if (result.data.metadata.metadataProcessingStatus != "success") {
      throw new CKEditorError("ckbox-image-processing-failed");
    }
    return result;
  }
  /**
  * Shows processing indicator while image is processing.
  *
  * @param asset Data about certain asset.
  */
  _showImageProcessingIndicator(element, asset) {
    const editor = this.editor;
    editor.editing.view.change((writer) => {
      const imageElementView = editor.editing.mapper.toViewElement(element);
      const imageUtils = this.editor.plugins.get("ImageUtils");
      const img = imageUtils.findViewImgElement(imageElementView);
      writer.removeStyle("aspect-ratio", img);
      writer.setAttribute("width", asset.data.metadata.width, img);
      writer.setAttribute("height", asset.data.metadata.height, img);
      writer.setStyle("width", `${asset.data.metadata.width}px`, img);
      writer.setStyle("height", `${asset.data.metadata.height}px`, img);
      writer.addClass("image-processing", imageElementView);
    });
  }
  /**
  * Replace the edited image with the new one.
  */
  _replaceImage(element, asset) {
    const editor = this.editor;
    const { imageFallbackUrl, imageSources, imageWidth, imageHeight, imagePlaceholder } = prepareImageAssetAttributes(asset);
    const previousSelectionRanges = Array.from(editor.model.document.selection.getRanges());
    editor.model.change((writer) => {
      writer.setSelection(element, "on");
      editor.execute("insertImage", {
        imageType: element.is("element", "imageInline") ? "imageInline" : null,
        source: {
          src: imageFallbackUrl,
          sources: imageSources,
          width: imageWidth,
          height: imageHeight,
          ...imagePlaceholder ? {
            placeholder: imagePlaceholder
          } : null,
          ...element.hasAttribute("alt") ? {
            alt: element.getAttribute("alt")
          } : null
        }
      });
      const previousChildren = element.getChildren();
      element = editor.model.document.selection.getSelectedElement();
      for (const child of previousChildren) {
        writer.append(writer.cloneElement(child), element);
      }
      writer.setAttribute("ckboxImageId", asset.data.id, element);
      writer.setSelection(previousSelectionRanges);
    });
  }
};
var CKBoxImageEditEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKBoxImageEditEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      CKBoxEditing,
      CKBoxUtils,
      PendingActions,
      Notification,
      "ImageUtils",
      "ImageEditing"
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const { editor } = this;
    editor.commands.add("ckboxImageEdit", new CKBoxImageEditCommand(editor));
  }
};
var ckboxImageEditIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037H5.06l5.058-5.078L6.617 9.15a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v4.354a3.478 3.478 0 0 1 1.5.049V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.147 2.147 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.642-3.11 2.129 2.129 0 0 0-1.873-.978ZM8.089 17.635v2.388h2.389l7.046-7.046-2.39-2.39-7.045 7.048Zm11.282-6.507a.637.637 0 0 0 .139-.692.603.603 0 0 0-.139-.205l-1.49-1.488a.63.63 0 0 0-.899 0l-1.166 1.163 2.39 2.39 1.165-1.168Z"/></svg>';
var CKBoxImageEditUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKBoxImageEditUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("ckboxImageEdit", (locale) => {
      const command = editor.commands.get("ckboxImageEdit");
      const uploadImageCommand = editor.commands.get("uploadImage");
      const view = new ButtonView(locale);
      const t = locale.t;
      view.set({
        icon: ckboxImageEditIcon,
        tooltip: true
      });
      view.bind("label").to(uploadImageCommand, "isAccessAllowed", (isAccessAllowed) => isAccessAllowed ? t("Edit image") : t("You have no image editing permissions."));
      view.bind("isOn").to(command, "value", command, "isEnabled", (value, isEnabled) => value && isEnabled);
      view.bind("isEnabled").to(command);
      this.listenTo(view, "execute", () => {
        editor.execute("ckboxImageEdit");
        editor.editing.view.focus();
      });
      return view;
    });
  }
};
var CKBoxImageEdit = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKBoxImageEdit";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      CKBoxImageEditEditing,
      CKBoxImageEditUI
    ];
  }
};

// node_modules/@ckeditor/ckeditor5-ckfinder/dist/index.js
var CKFinderUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKFinderUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("ckfinder", () => this._createFileToolbarButton());
    editor.ui.componentFactory.add("menuBar:ckfinder", () => this._createFileMenuBarButton());
    if (editor.plugins.has("ImageInsertUI")) {
      editor.plugins.get("ImageInsertUI").registerIntegration({
        name: "assetManager",
        observable: () => editor.commands.get("ckfinder"),
        buttonViewCreator: () => this._createImageToolbarButton(),
        formViewCreator: () => this._createImageDropdownButton(),
        menuBarButtonViewCreator: (isOnly) => this._createImageMenuBarButton(isOnly ? "insertOnly" : "insertNested")
      });
    }
  }
  /**
  * Creates the base for various kinds of the button component provided by this feature.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const view = new ButtonClass(locale);
    const command = editor.commands.get("ckfinder");
    view.bind("isEnabled").to(command);
    view.on("execute", () => {
      editor.execute("ckfinder");
      editor.editing.view.focus();
    });
    return view;
  }
  /**
  * Creates a simple toolbar button for files management, with an icon and a tooltip.
  */
  _createFileToolbarButton() {
    const t = this.editor.locale.t;
    const button = this._createButton(ButtonView);
    button.icon = icons.browseFiles;
    button.label = t("Insert image or file");
    button.tooltip = true;
    return button;
  }
  /**
  * Creates a simple toolbar button for images management, with an icon and a tooltip.
  */
  _createImageToolbarButton() {
    const t = this.editor.locale.t;
    const imageInsertUI = this.editor.plugins.get("ImageInsertUI");
    const button = this._createButton(ButtonView);
    button.icon = icons.imageAssetManager;
    button.bind("label").to(imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace image with file manager") : t("Insert image with file manager"));
    button.tooltip = true;
    return button;
  }
  /**
  * Creates a button for images management for the dropdown view, with an icon, text and no tooltip.
  */
  _createImageDropdownButton() {
    const t = this.editor.locale.t;
    const imageInsertUI = this.editor.plugins.get("ImageInsertUI");
    const button = this._createButton(ButtonView);
    button.icon = icons.imageAssetManager;
    button.withText = true;
    button.bind("label").to(imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace with file manager") : t("Insert with file manager"));
    button.on("execute", () => {
      imageInsertUI.dropdownView.isOpen = false;
    });
    return button;
  }
  /**
  * Creates a button for files management for the menu bar.
  */
  _createFileMenuBarButton() {
    const t = this.editor.locale.t;
    const button = this._createButton(MenuBarMenuListItemButtonView);
    button.icon = icons.browseFiles;
    button.withText = true;
    button.label = t("File");
    return button;
  }
  /**
  * Creates a button for images management for the menu bar.
  */
  _createImageMenuBarButton(type) {
    const translateVariableKey = this.editor.locale.t;
    const t = this.editor.locale.t;
    const button = this._createButton(MenuBarMenuListItemButtonView);
    button.icon = icons.imageAssetManager;
    button.withText = true;
    switch (type) {
      case "insertOnly":
        button.label = translateVariableKey("Image");
        break;
      case "insertNested":
        button.label = t("With file manager");
        break;
    }
    return button;
  }
};
var CKFinderCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    this.affectsData = false;
    this.stopListening(this.editor.model.document, "change");
    this.listenTo(this.editor.model.document, "change", () => this.refresh(), {
      priority: "low"
    });
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const imageCommand = this.editor.commands.get("insertImage");
    const linkCommand = this.editor.commands.get("link");
    this.isEnabled = imageCommand.isEnabled || linkCommand.isEnabled;
  }
  /**
  * @inheritDoc
  */
  execute() {
    const editor = this.editor;
    const openerMethod = this.editor.config.get("ckfinder.openerMethod") || "modal";
    if (openerMethod != "popup" && openerMethod != "modal") {
      throw new CKEditorError("ckfinder-unknown-openermethod", editor);
    }
    const options2 = this.editor.config.get("ckfinder.options") || {};
    options2.chooseFiles = true;
    const originalOnInit = options2.onInit;
    if (!options2.language) {
      options2.language = editor.locale.uiLanguage;
    }
    options2.onInit = (finder) => {
      if (originalOnInit) {
        originalOnInit(finder);
      }
      finder.on("files:choose", (evt) => {
        const files = evt.data.files.toArray();
        const links = files.filter((file) => !file.isImage());
        const images = files.filter((file) => file.isImage());
        for (const linkFile of links) {
          editor.execute("link", linkFile.getUrl());
        }
        const imagesUrls = [];
        for (const image of images) {
          const url = image.getUrl();
          imagesUrls.push(url ? url : finder.request("file:getProxyUrl", {
            file: image
          }));
        }
        if (imagesUrls.length) {
          insertImages(editor, imagesUrls);
        }
      });
      finder.on("file:choose:resizedImage", (evt) => {
        const resizedUrl = evt.data.resizedUrl;
        if (!resizedUrl) {
          const notification = editor.plugins.get("Notification");
          const t = editor.locale.t;
          notification.showWarning(t("Could not obtain resized image URL."), {
            title: t("Selecting resized image failed"),
            namespace: "ckfinder"
          });
          return;
        }
        insertImages(editor, [
          resizedUrl
        ]);
      });
    };
    window.CKFinder[openerMethod](options2);
  }
};
function insertImages(editor, urls) {
  const imageCommand = editor.commands.get("insertImage");
  if (!imageCommand.isEnabled) {
    const notification = editor.plugins.get("Notification");
    const t = editor.locale.t;
    notification.showWarning(t("Could not insert image at the current position."), {
      title: t("Inserting image failed"),
      namespace: "ckfinder"
    });
    return;
  }
  editor.execute("insertImage", {
    source: urls
  });
}
var CKFinderEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKFinderEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Notification,
      "LinkEditing"
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("ImageBlockEditing") && !editor.plugins.has("ImageInlineEditing")) {
      throw new CKEditorError("ckfinder-missing-image-plugin", editor);
    }
    editor.commands.add("ckfinder", new CKFinderCommand(editor));
  }
};
var CKFinder = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CKFinder";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "Link",
      "CKFinderUploadAdapter",
      CKFinderEditing,
      CKFinderUI
    ];
  }
};

// node_modules/@ckeditor/ckeditor5-cloud-services/dist/index.js
var DEFAULT_OPTIONS = {
  autoRefresh: true
};
var DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME = 36e5;
var TOKEN_FAILED_REFRESH_TIMEOUT_TIME = 5e3;
var Token = class _Token extends ObservableMixin() {
  /**
  * Creates `Token` instance.
  * Method `init` should be called after using the constructor or use `create` method instead.
  *
  * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
  * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
  */
  constructor(tokenUrlOrRefreshToken, options2 = {}) {
    super();
    /**
    * Base refreshing function.
    */
    __publicField(this, "_refresh");
    /**
    * Cached token options.
    */
    __publicField(this, "_options");
    /**
    * `setTimeout()` id for a token refresh when {@link module:cloud-services/token/token~TokenOptions auto refresh} is enabled.
    */
    __publicField(this, "_tokenRefreshTimeout");
    if (!tokenUrlOrRefreshToken) {
      throw new CKEditorError("token-missing-token-url", this);
    }
    if (options2.initValue) {
      this._validateTokenValue(options2.initValue);
    }
    this.set("value", options2.initValue);
    if (typeof tokenUrlOrRefreshToken === "function") {
      this._refresh = tokenUrlOrRefreshToken;
    } else {
      this._refresh = () => defaultRefreshToken(tokenUrlOrRefreshToken);
    }
    this._options = {
      ...DEFAULT_OPTIONS,
      ...options2
    };
  }
  /**
  * Initializes the token.
  */
  init() {
    return new Promise((resolve, reject) => {
      if (!this.value) {
        this.refreshToken().then(resolve).catch(reject);
        return;
      }
      if (this._options.autoRefresh) {
        this._registerRefreshTokenTimeout();
      }
      resolve(this);
    });
  }
  /**
  * Refresh token method. Useful in a method form as it can be overridden in tests.
  *
  * This method will be invoked periodically based on the token expiry date after first call to keep the token up-to-date
  * (requires {@link module:cloud-services/token/token~TokenOptions auto refresh option} to be set).
  *
  * If the token refresh fails, the method will retry in 5 seconds intervals until success or the token gets
  * {@link #destroy destroyed}.
  */
  refreshToken() {
    const autoRefresh = this._options.autoRefresh;
    return this._refresh().then((value) => {
      this._validateTokenValue(value);
      this.set("value", value);
      if (autoRefresh) {
        this._registerRefreshTokenTimeout();
      }
      return this;
    }).catch((err) => {
      logWarning("token-refresh-failed", {
        autoRefresh
      });
      if (autoRefresh) {
        this._registerRefreshTokenTimeout(TOKEN_FAILED_REFRESH_TIMEOUT_TIME);
      }
      throw err;
    });
  }
  /**
  * Destroys token instance. Stops refreshing.
  */
  destroy() {
    clearTimeout(this._tokenRefreshTimeout);
  }
  /**
  * Checks whether the provided token follows the JSON Web Tokens (JWT) format.
  *
  * @param tokenValue The token to validate.
  */
  _validateTokenValue(tokenValue) {
    const isString = typeof tokenValue === "string";
    const isPlainString = !/^".*"$/.test(tokenValue);
    const isJWTFormat = isString && tokenValue.split(".").length === 3;
    if (!(isPlainString && isJWTFormat)) {
      throw new CKEditorError("token-not-in-jwt-format", this);
    }
  }
  /**
  * Registers a refresh token timeout for the time taken from token.
  */
  _registerRefreshTokenTimeout(timeoutTime) {
    const tokenRefreshTimeoutTime = timeoutTime || this._getTokenRefreshTimeoutTime();
    clearTimeout(this._tokenRefreshTimeout);
    this._tokenRefreshTimeout = setTimeout(() => {
      this.refreshToken();
    }, tokenRefreshTimeoutTime);
  }
  /**
  * Returns token refresh timeout time calculated from expire time in the token payload.
  *
  * If the token parse fails or the token payload doesn't contain, the default DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME is returned.
  */
  _getTokenRefreshTimeoutTime() {
    try {
      const [, binaryTokenPayload] = this.value.split(".");
      const { exp: tokenExpireTime } = JSON.parse(atob(binaryTokenPayload));
      if (!tokenExpireTime) {
        return DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME;
      }
      const tokenRefreshTimeoutTime = Math.floor((tokenExpireTime * 1e3 - Date.now()) / 2);
      return tokenRefreshTimeoutTime;
    } catch (err) {
      return DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME;
    }
  }
  /**
  * Creates a initialized {@link module:cloud-services/token/token~Token} instance.
  *
  * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
  * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
  */
  static create(tokenUrlOrRefreshToken, options2 = {}) {
    const token = new _Token(tokenUrlOrRefreshToken, options2);
    return token.init();
  }
};
function defaultRefreshToken(tokenUrl) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", tokenUrl);
    xhr.addEventListener("load", () => {
      const statusCode = xhr.status;
      const xhrResponse = xhr.response;
      if (statusCode < 200 || statusCode > 299) {
        return reject(new CKEditorError("token-cannot-download-new-token", null));
      }
      return resolve(xhrResponse);
    });
    xhr.addEventListener("error", () => reject(new Error("Network Error")));
    xhr.addEventListener("abort", () => reject(new Error("Abort")));
    xhr.send();
  });
}
var BASE64_HEADER_REG_EXP = /^data:(\S*?);base64,/;
var FileUploader = class extends EmitterMixin() {
  /**
  * Creates `FileUploader` instance.
  *
  * @param fileOrData A blob object or a data string encoded with Base64.
  * @param token Token used for authentication.
  * @param apiAddress API address.
  */
  constructor(fileOrData, token, apiAddress) {
    super();
    /**
    * A file that is being uploaded.
    */
    __publicField(this, "file");
    __publicField(this, "xhr");
    /**
    * CKEditor Cloud Services access token.
    */
    __publicField(this, "_token");
    /**
    * CKEditor Cloud Services API address.
    */
    __publicField(this, "_apiAddress");
    if (!fileOrData) {
      throw new CKEditorError("fileuploader-missing-file", null);
    }
    if (!token) {
      throw new CKEditorError("fileuploader-missing-token", null);
    }
    if (!apiAddress) {
      throw new CKEditorError("fileuploader-missing-api-address", null);
    }
    this.file = _isBase64(fileOrData) ? _base64ToBlob(fileOrData) : fileOrData;
    this._token = token;
    this._apiAddress = apiAddress;
  }
  /**
  * Registers callback on `progress` event.
  */
  onProgress(callback) {
    this.on("progress", (event, data) => callback(data));
    return this;
  }
  /**
  * Registers callback on `error` event. Event is called once when error occurs.
  */
  onError(callback) {
    this.once("error", (event, data) => callback(data));
    return this;
  }
  /**
  * Aborts upload process.
  */
  abort() {
    this.xhr.abort();
  }
  /**
  * Sends XHR request to API.
  */
  send() {
    this._prepareRequest();
    this._attachXHRListeners();
    return this._sendRequest();
  }
  /**
  * Prepares XHR request.
  */
  _prepareRequest() {
    const xhr = new XMLHttpRequest();
    xhr.open("POST", this._apiAddress);
    xhr.setRequestHeader("Authorization", this._token.value);
    xhr.responseType = "json";
    this.xhr = xhr;
  }
  /**
  * Attaches listeners to the XHR.
  */
  _attachXHRListeners() {
    const xhr = this.xhr;
    const onError = (message) => {
      return () => this.fire("error", message);
    };
    xhr.addEventListener("error", onError("Network Error"));
    xhr.addEventListener("abort", onError("Abort"));
    if (xhr.upload) {
      xhr.upload.addEventListener("progress", (event) => {
        if (event.lengthComputable) {
          this.fire("progress", {
            total: event.total,
            uploaded: event.loaded
          });
        }
      });
    }
    xhr.addEventListener("load", () => {
      const statusCode = xhr.status;
      const xhrResponse = xhr.response;
      if (statusCode < 200 || statusCode > 299) {
        return this.fire("error", xhrResponse.message || xhrResponse.error);
      }
    });
  }
  /**
  * Sends XHR request.
  */
  _sendRequest() {
    const formData = new FormData();
    const xhr = this.xhr;
    formData.append("file", this.file);
    return new Promise((resolve, reject) => {
      xhr.addEventListener("load", () => {
        const statusCode = xhr.status;
        const xhrResponse = xhr.response;
        if (statusCode < 200 || statusCode > 299) {
          if (xhrResponse.message) {
            return reject(new CKEditorError("fileuploader-uploading-data-failed", this, {
              message: xhrResponse.message
            }));
          }
          return reject(xhrResponse.error);
        }
        return resolve(xhrResponse);
      });
      xhr.addEventListener("error", () => reject(new Error("Network Error")));
      xhr.addEventListener("abort", () => reject(new Error("Abort")));
      xhr.send(formData);
    });
  }
};
function _base64ToBlob(base64, sliceSize = 512) {
  try {
    const contentType = base64.match(BASE64_HEADER_REG_EXP)[1];
    const base64Data = atob(base64.replace(BASE64_HEADER_REG_EXP, ""));
    const byteArrays = [];
    for (let offset = 0; offset < base64Data.length; offset += sliceSize) {
      const slice = base64Data.slice(offset, offset + sliceSize);
      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }
      byteArrays.push(new Uint8Array(byteNumbers));
    }
    return new Blob(byteArrays, {
      type: contentType
    });
  } catch (error) {
    throw new CKEditorError("fileuploader-decoding-image-data-error", null);
  }
}
function _isBase64(string) {
  if (typeof string !== "string") {
    return false;
  }
  const match = string.match(BASE64_HEADER_REG_EXP);
  return !!(match && match.length);
}
var UploadGateway = class {
  /**
  * Creates `UploadGateway` instance.
  *
  * @param token Token used for authentication.
  * @param apiAddress API address.
  */
  constructor(token, apiAddress) {
    /**
    * CKEditor Cloud Services access token.
    */
    __publicField(this, "_token");
    /**
    * CKEditor Cloud Services API address.
    */
    __publicField(this, "_apiAddress");
    if (!token) {
      throw new CKEditorError("uploadgateway-missing-token", null);
    }
    if (!apiAddress) {
      throw new CKEditorError("uploadgateway-missing-api-address", null);
    }
    this._token = token;
    this._apiAddress = apiAddress;
  }
  /**
  * Creates a {@link module:cloud-services/uploadgateway/fileuploader~FileUploader} instance that wraps
  * file upload process. The file is being sent at a time when the
  * {@link module:cloud-services/uploadgateway/fileuploader~FileUploader#send} method is called.
  *
  * ```ts
  * const token = await Token.create( 'https://token-endpoint' );
  * new UploadGateway( token, 'https://example.org' )
  * 	.upload( 'FILE' )
  * 	.onProgress( ( data ) => console.log( data ) )
  * 	.send()
  * 	.then( ( response ) => console.log( response ) );
  * ```
  *
  * @param {Blob|String} fileOrData A blob object or a data string encoded with Base64.
  * @returns {module:cloud-services/uploadgateway/fileuploader~FileUploader} Returns `FileUploader` instance.
  */
  upload(fileOrData) {
    return new FileUploader(fileOrData, this._token, this._apiAddress);
  }
};
var CloudServicesCore = class extends ContextPlugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CloudServicesCore";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Creates the {@link module:cloud-services/token/token~Token} instance.
  *
  * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
  * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
  * @param options.initValue Initial value of the token.
  * @param options.autoRefresh Specifies whether to start the refresh automatically.
  */
  createToken(tokenUrlOrRefreshToken, options2) {
    return new Token(tokenUrlOrRefreshToken, options2);
  }
  /**
  * Creates the {@link module:cloud-services/uploadgateway/uploadgateway~UploadGateway} instance.
  *
  * @param token Token used for authentication.
  * @param apiAddress API address.
  */
  createUploadGateway(token, apiAddress) {
    return new UploadGateway(token, apiAddress);
  }
};
var CloudServices = class extends ContextPlugin {
  constructor() {
    super(...arguments);
    /**
    * The authentication token URL for CKEditor Cloud Services or a callback to the token value promise. See the
    * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} for more details.
    */
    __publicField(this, "tokenUrl");
    /**
    * The URL to which the files should be uploaded.
    */
    __publicField(this, "uploadUrl");
    /**
    * The URL for web socket communication, used by the `RealTimeCollaborativeEditing` plugin. Every customer (organization in the CKEditor
    * Ecosystem dashboard) has their own, unique URLs to communicate with CKEditor Cloud Services. The URL can be found in the
    * CKEditor Ecosystem customer dashboard.
    *
    * Note: Unlike most plugins, `RealTimeCollaborativeEditing` is not included in any CKEditor 5 build and needs to be installed manually.
    * Check [Collaboration overview](https://ckeditor.com/docs/ckeditor5/latest/features/collaboration/overview.html) for more details.
    */
    __publicField(this, "webSocketUrl");
    /**
    * An optional parameter used for integration with CKEditor Cloud Services when uploading the editor build to cloud services.
    *
    * Whenever the editor build or the configuration changes, this parameter should be set to a new, unique value to differentiate
    * the new bundle (build + configuration) from the old ones.
    */
    __publicField(this, "bundleVersion");
    /**
    * Other plugins use this token for the authorization process. It handles token requesting and refreshing.
    * Its value is `null` when {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} is not provided.
    *
    * @readonly
    */
    __publicField(this, "token", null);
    /**
    * A map of token object instances keyed by the token URLs.
    */
    __publicField(this, "_tokens", /* @__PURE__ */ new Map());
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CloudServices";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      CloudServicesCore
    ];
  }
  /**
  * @inheritDoc
  */
  async init() {
    const config = this.context.config;
    const options2 = config.get("cloudServices") || {};
    for (const [key, value] of Object.entries(options2)) {
      this[key] = value;
    }
    if (!this.tokenUrl) {
      this.token = null;
      return;
    }
    const cloudServicesCore = this.context.plugins.get("CloudServicesCore");
    this.token = await cloudServicesCore.createToken(this.tokenUrl).init();
    this._tokens.set(this.tokenUrl, this.token);
  }
  /**
  * Registers an additional authentication token URL for CKEditor Cloud Services or a callback to the token value promise. See the
  * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} for more details.
  *
  * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
  */
  async registerTokenUrl(tokenUrl) {
    if (this._tokens.has(tokenUrl)) {
      return this.getTokenFor(tokenUrl);
    }
    const cloudServicesCore = this.context.plugins.get("CloudServicesCore");
    const token = await cloudServicesCore.createToken(tokenUrl).init();
    this._tokens.set(tokenUrl, token);
    return token;
  }
  /**
  * Returns an authentication token provider previously registered by {@link #registerTokenUrl}.
  *
  * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
  */
  getTokenFor(tokenUrl) {
    const token = this._tokens.get(tokenUrl);
    if (!token) {
      throw new CKEditorError("cloudservices-token-not-registered", this);
    }
    return token;
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    for (const token of this._tokens.values()) {
      token.destroy();
    }
  }
};

// node_modules/@ckeditor/ckeditor5-code-block/dist/index.js
function getNormalizedAndLocalizedLanguageDefinitions(editor) {
  const t = editor.t;
  const languageDefs = editor.config.get("codeBlock.languages");
  for (const def of languageDefs) {
    if (def.label === "Plain text") {
      def.label = t("Plain text");
    }
    if (def.class === void 0) {
      def.class = `language-${def.language}`;
    }
  }
  return languageDefs;
}
function getPropertyAssociation(languageDefs, key, value) {
  const association = {};
  for (const def of languageDefs) {
    if (key === "class") {
      const newKey = def[key].split(" ").shift();
      association[newKey] = def[value];
    } else {
      association[def[key]] = def[value];
    }
  }
  return association;
}
function getLeadingWhiteSpaces(textNode) {
  return textNode.data.match(/^(\s*)/)[0];
}
function rawSnippetTextToViewDocumentFragment(writer, text) {
  const fragment = writer.createDocumentFragment();
  const textLines = text.split("\n");
  const items = textLines.reduce((nodes, line, lineIndex) => {
    nodes.push(line);
    if (lineIndex < textLines.length - 1) {
      nodes.push(writer.createElement("br"));
    }
    return nodes;
  }, []);
  writer.appendChild(items, fragment);
  return fragment;
}
function getIndentOutdentPositions(model) {
  const selection = model.document.selection;
  const positions = [];
  if (selection.isCollapsed) {
    return [
      selection.anchor
    ];
  }
  const walker = selection.getFirstRange().getWalker({
    ignoreElementEnd: true,
    direction: "backward"
  });
  for (const { item } of walker) {
    let node = item.is("$textProxy") ? item.textNode : item;
    const parent = node.parent;
    if (!parent.is("element", "codeBlock") || node.is("element", "softBreak")) {
      continue;
    }
    while (node.previousSibling && !node.previousSibling.is("element", "softBreak")) {
      node = node.previousSibling;
    }
    const startOffset = !node.is("$text") ? node.startOffset : node.startOffset + getLeadingWhiteSpaces(node).length;
    const position = model.createPositionAt(parent, startOffset);
    if (positions.every((pos) => !pos.isEqual(position))) {
      positions.push(position);
    }
  }
  return positions;
}
function isModelSelectionInCodeBlock(selection) {
  const firstBlock = first(selection.getSelectedBlocks());
  return !!firstBlock && firstBlock.is("element", "codeBlock");
}
function canBeCodeBlock(schema, element) {
  if (element.is("rootElement") || schema.isLimit(element)) {
    return false;
  }
  return schema.checkChild(element.parent, "codeBlock");
}
function getCodeBlockAriaAnnouncement(t, languageDefs, element, direction) {
  const languagesToLabels = getPropertyAssociation(languageDefs, "language", "label");
  const codeBlockLanguage = element.getAttribute("language");
  if (codeBlockLanguage in languagesToLabels) {
    const language = languagesToLabels[codeBlockLanguage];
    if (direction === "enter") {
      return t("Entering %0 code snippet", language);
    }
    return t("Leaving %0 code snippet", language);
  }
  if (direction === "enter") {
    return t("Entering code snippet");
  }
  return t("Leaving code snippet");
}
function getTextNodeAtLineStart(position, model) {
  if (position.textNode) {
    position = model.createPositionBefore(position.textNode);
  }
  while (position.nodeBefore && !position.nodeBefore.is("element", "softBreak")) {
    position = model.createPositionBefore(position.nodeBefore);
  }
  const nodeAtStart = position.nodeAfter;
  return nodeAtStart && nodeAtStart.is("$text") ? nodeAtStart : null;
}
var CodeBlockCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * Contains the last used language.
    */
    __publicField(this, "_lastLanguage");
    this._lastLanguage = null;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the command. When the command {@link #value is on}, all topmost code blocks within
  * the selection will be removed. If it is off, all selected blocks will be flattened and
  * wrapped by a code block.
  *
  * @fires execute
  * @param options Command options.
  * @param options.language The code block language.
  * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a code block,
  * otherwise the command will remove the code block. If not set, the command will act basing on its current value.
  * @param options.usePreviousLanguageChoice If set on `true` and the `options.language` is not specified, the command
  * will apply the previous language (if the command was already executed) when inserting the `codeBlock` element.
  */
  execute(options2 = {}) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
    const firstLanguageInConfig = normalizedLanguagesDefs[0];
    const blocks = Array.from(selection.getSelectedBlocks());
    const value = options2.forceValue == void 0 ? !this.value : options2.forceValue;
    const language = getLanguage(options2, this._lastLanguage, firstLanguageInConfig.language);
    model.change((writer) => {
      if (value) {
        this._applyCodeBlock(writer, blocks, language);
      } else {
        this._removeCodeBlock(writer, blocks);
      }
    });
  }
  /**
  * Checks the command's {@link #value}.
  *
  * @returns The current value.
  */
  _getValue() {
    const selection = this.editor.model.document.selection;
    const firstBlock = first(selection.getSelectedBlocks());
    const isCodeBlock = !!(firstBlock && firstBlock.is("element", "codeBlock"));
    return isCodeBlock ? firstBlock.getAttribute("language") : false;
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    if (this.value) {
      return true;
    }
    const selection = this.editor.model.document.selection;
    const schema = this.editor.model.schema;
    const firstBlock = first(selection.getSelectedBlocks());
    if (!firstBlock) {
      return false;
    }
    return canBeCodeBlock(schema, firstBlock);
  }
  _applyCodeBlock(writer, blocks, language) {
    this._lastLanguage = language;
    const schema = this.editor.model.schema;
    const allowedBlocks = blocks.filter((block2) => canBeCodeBlock(schema, block2));
    for (const block2 of allowedBlocks) {
      writer.rename(block2, "codeBlock");
      writer.setAttribute("language", language, block2);
      schema.removeDisallowedAttributes([
        block2
      ], writer);
      Array.from(block2.getChildren()).filter((child) => !schema.checkChild(block2, child)).forEach((child) => writer.remove(child));
    }
    allowedBlocks.reverse().forEach((currentBlock, i) => {
      const nextBlock = allowedBlocks[i + 1];
      if (currentBlock.previousSibling === nextBlock) {
        writer.appendElement("softBreak", nextBlock);
        writer.merge(writer.createPositionBefore(currentBlock));
      }
    });
  }
  _removeCodeBlock(writer, blocks) {
    const codeBlocks = blocks.filter((block2) => block2.is("element", "codeBlock"));
    for (const block2 of codeBlocks) {
      const range = writer.createRangeOn(block2);
      for (const item of Array.from(range.getItems()).reverse()) {
        if (item.is("element", "softBreak") && item.parent.is("element", "codeBlock")) {
          const { position } = writer.split(writer.createPositionBefore(item));
          const elementAfter = position.nodeAfter;
          writer.rename(elementAfter, "paragraph");
          writer.removeAttribute("language", elementAfter);
          writer.remove(item);
        }
      }
      writer.rename(block2, "paragraph");
      writer.removeAttribute("language", block2);
    }
  }
};
function getLanguage(options2, lastLanguage, defaultLanguage) {
  if (options2.language) {
    return options2.language;
  }
  if (options2.usePreviousLanguageChoice && lastLanguage) {
    return lastLanguage;
  }
  return defaultLanguage;
}
var IndentCodeBlockCommand = class extends Command {
  constructor(editor) {
    super(editor);
    /**
    * A sequence of characters added to the line when the command is executed.
    */
    __publicField(this, "_indentSequence");
    this._indentSequence = editor.config.get("codeBlock.indentSequence");
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
  * code lines in the selection will be increased.
  *
  * @fires execute
  */
  execute() {
    const editor = this.editor;
    const model = editor.model;
    model.change((writer) => {
      const positions = getIndentOutdentPositions(model);
      for (const position of positions) {
        const indentSequenceTextElement = writer.createText(this._indentSequence);
        model.insertContent(indentSequenceTextElement, position);
      }
    });
  }
  /**
  * Checks whether the command can be enabled in the current context.
  */
  _checkEnabled() {
    if (!this._indentSequence) {
      return false;
    }
    return isModelSelectionInCodeBlock(this.editor.model.document.selection);
  }
};
var OutdentCodeBlockCommand = class extends Command {
  constructor(editor) {
    super(editor);
    /**
    * A sequence of characters removed from the line when the command is executed.
    */
    __publicField(this, "_indentSequence");
    this._indentSequence = editor.config.get("codeBlock.indentSequence");
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
  * code lines in the selection will be decreased.
  *
  * @fires execute
  */
  execute() {
    const editor = this.editor;
    const model = editor.model;
    model.change(() => {
      const positions = getIndentOutdentPositions(model);
      for (const position of positions) {
        const range = getLastOutdentableSequenceRange(model, position, this._indentSequence);
        if (range) {
          model.deleteContent(model.createSelection(range));
        }
      }
    });
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @private
  * @returns {Boolean} Whether the command should be enabled.
  */
  _checkEnabled() {
    if (!this._indentSequence) {
      return false;
    }
    const model = this.editor.model;
    if (!isModelSelectionInCodeBlock(model.document.selection)) {
      return false;
    }
    return getIndentOutdentPositions(model).some((position) => {
      return getLastOutdentableSequenceRange(model, position, this._indentSequence);
    });
  }
};
function getLastOutdentableSequenceRange(model, position, sequence) {
  const nodeAtPosition = getTextNodeAtLineStart(position, model);
  if (!nodeAtPosition) {
    return null;
  }
  const leadingWhiteSpaces = getLeadingWhiteSpaces(nodeAtPosition);
  const lastIndexOfSequence = leadingWhiteSpaces.lastIndexOf(sequence);
  if (lastIndexOfSequence + sequence.length !== leadingWhiteSpaces.length) {
    return null;
  }
  if (lastIndexOfSequence === -1) {
    return null;
  }
  const { parent, startOffset } = nodeAtPosition;
  return model.createRange(model.createPositionAt(parent, startOffset + lastIndexOfSequence), model.createPositionAt(parent, startOffset + lastIndexOfSequence + sequence.length));
}
function modelToViewCodeBlockInsertion(model, languageDefs, useLabels = false) {
  const languagesToClasses = getPropertyAssociation(languageDefs, "language", "class");
  const languagesToLabels = getPropertyAssociation(languageDefs, "language", "label");
  return (evt, data, conversionApi) => {
    const { writer, mapper, consumable } = conversionApi;
    if (!consumable.consume(data.item, "insert")) {
      return;
    }
    const codeBlockLanguage = data.item.getAttribute("language");
    const targetViewPosition = mapper.toViewPosition(model.createPositionBefore(data.item));
    const preAttributes = {};
    if (useLabels) {
      preAttributes["data-language"] = languagesToLabels[codeBlockLanguage];
      preAttributes.spellcheck = "false";
    }
    const codeAttributes = languagesToClasses[codeBlockLanguage] ? {
      class: languagesToClasses[codeBlockLanguage]
    } : void 0;
    const code = writer.createContainerElement("code", codeAttributes);
    const pre = writer.createContainerElement("pre", preAttributes, code);
    writer.insert(targetViewPosition, pre);
    mapper.bindElements(data.item, code);
  };
}
function modelToDataViewSoftBreakInsertion(model) {
  return (evt, data, conversionApi) => {
    if (data.item.parent.name !== "codeBlock") {
      return;
    }
    const { writer, mapper, consumable } = conversionApi;
    if (!consumable.consume(data.item, "insert")) {
      return;
    }
    const position = mapper.toViewPosition(model.createPositionBefore(data.item));
    writer.insert(position, writer.createText("\n"));
  };
}
function dataViewToModelCodeBlockInsertion(editingView, languageDefs) {
  const classesToLanguages = getPropertyAssociation(languageDefs, "class", "language");
  const defaultLanguageName = languageDefs[0].language;
  return (evt, data, conversionApi) => {
    const viewCodeElement = data.viewItem;
    const viewPreElement = viewCodeElement.parent;
    if (!viewPreElement || !viewPreElement.is("element", "pre")) {
      return;
    }
    if (data.modelCursor.findAncestor("codeBlock")) {
      return;
    }
    const { consumable, writer } = conversionApi;
    if (!consumable.test(viewCodeElement, {
      name: true
    })) {
      return;
    }
    const codeBlock = writer.createElement("codeBlock");
    const viewChildClasses = [
      ...viewCodeElement.getClassNames()
    ];
    if (!viewChildClasses.length) {
      viewChildClasses.push("");
    }
    for (const className of viewChildClasses) {
      const language = classesToLanguages[className];
      if (language) {
        writer.setAttribute("language", language, codeBlock);
        break;
      }
    }
    if (!codeBlock.hasAttribute("language")) {
      writer.setAttribute("language", defaultLanguageName, codeBlock);
    }
    conversionApi.convertChildren(viewCodeElement, codeBlock);
    if (!conversionApi.safeInsert(codeBlock, data.modelCursor)) {
      return;
    }
    consumable.consume(viewCodeElement, {
      name: true
    });
    conversionApi.updateConversionResult(codeBlock, data);
  };
}
function dataViewToModelTextNewlinesInsertion() {
  return (evt, data, { consumable, writer }) => {
    let position = data.modelCursor;
    if (!consumable.test(data.viewItem)) {
      return;
    }
    if (!position.findAncestor("codeBlock")) {
      return;
    }
    consumable.consume(data.viewItem);
    const text = data.viewItem.data;
    const textLines = text.split("\n").map((data2) => writer.createText(data2));
    const lastLine = textLines[textLines.length - 1];
    for (const node of textLines) {
      writer.insert(node, position);
      position = position.getShiftedBy(node.offsetSize);
      if (node !== lastLine) {
        const softBreak = writer.createElement("softBreak");
        writer.insert(softBreak, position);
        position = writer.createPositionAfter(softBreak);
      }
    }
    data.modelRange = writer.createRange(data.modelCursor, position);
    data.modelCursor = position;
  };
}
function dataViewToModelOrphanNodeConsumer() {
  return (evt, data, { consumable }) => {
    const preElement = data.viewItem;
    if (preElement.findAncestor("pre")) {
      return;
    }
    const preChildren = Array.from(preElement.getChildren());
    const childCodeElement = preChildren.find((node) => node.is("element", "code"));
    if (!childCodeElement) {
      return;
    }
    for (const child of preChildren) {
      if (child === childCodeElement || !child.is("$text")) {
        continue;
      }
      consumable.consume(child, {
        name: true
      });
    }
  };
}
var DEFAULT_ELEMENT = "paragraph";
var CodeBlockEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CodeBlockEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ShiftEnter
    ];
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("codeBlock", {
      languages: [
        {
          language: "plaintext",
          label: "Plain text"
        },
        {
          language: "c",
          label: "C"
        },
        {
          language: "cs",
          label: "C#"
        },
        {
          language: "cpp",
          label: "C++"
        },
        {
          language: "css",
          label: "CSS"
        },
        {
          language: "diff",
          label: "Diff"
        },
        {
          language: "html",
          label: "HTML"
        },
        {
          language: "java",
          label: "Java"
        },
        {
          language: "javascript",
          label: "JavaScript"
        },
        {
          language: "php",
          label: "PHP"
        },
        {
          language: "python",
          label: "Python"
        },
        {
          language: "ruby",
          label: "Ruby"
        },
        {
          language: "typescript",
          label: "TypeScript"
        },
        {
          language: "xml",
          label: "XML"
        }
      ],
      // A single tab.
      indentSequence: "	"
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const model = editor.model;
    const view = editor.editing.view;
    const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
    editor.commands.add("codeBlock", new CodeBlockCommand(editor));
    editor.commands.add("indentCodeBlock", new IndentCodeBlockCommand(editor));
    editor.commands.add("outdentCodeBlock", new OutdentCodeBlockCommand(editor));
    this.listenTo(view.document, "tab", (evt, data) => {
      const commandName = data.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
      const command = editor.commands.get(commandName);
      if (!command.isEnabled) {
        return;
      }
      editor.execute(commandName);
      data.stopPropagation();
      data.preventDefault();
      evt.stop();
    }, {
      context: "pre"
    });
    schema.register("codeBlock", {
      allowWhere: "$block",
      allowChildren: "$text",
      // Disallow `$inlineObject` and its derivatives like `inlineWidget` inside `codeBlock` to ensure that only text,
      // not other inline elements like inline images, are allowed. This maintains the semantic integrity of code blocks.
      disallowChildren: "$inlineObject",
      allowAttributes: [
        "language"
      ],
      allowAttributesOf: "$listItem",
      isBlock: true
    });
    schema.addAttributeCheck((context, attributeName) => {
      const parent = context.getItem(context.length - 2);
      const isFormatting = schema.getAttributeProperties(attributeName).isFormatting;
      if (isFormatting && parent && parent.name == "codeBlock") {
        return false;
      }
    });
    editor.editing.downcastDispatcher.on("insert:codeBlock", modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs, true));
    editor.data.downcastDispatcher.on("insert:codeBlock", modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs));
    editor.data.downcastDispatcher.on("insert:softBreak", modelToDataViewSoftBreakInsertion(model), {
      priority: "high"
    });
    editor.data.upcastDispatcher.on("element:code", dataViewToModelCodeBlockInsertion(view, normalizedLanguagesDefs));
    editor.data.upcastDispatcher.on("text", dataViewToModelTextNewlinesInsertion());
    editor.data.upcastDispatcher.on("element:pre", dataViewToModelOrphanNodeConsumer(), {
      priority: "high"
    });
    this.listenTo(editor.editing.view.document, "clipboardInput", (evt, data) => {
      let insertionRange = model.createRange(model.document.selection.anchor);
      if (data.targetRanges) {
        insertionRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
      }
      if (!insertionRange.start.parent.is("element", "codeBlock")) {
        return;
      }
      const text = data.dataTransfer.getData("text/plain");
      const writer = new UpcastWriter(editor.editing.view.document);
      data.content = rawSnippetTextToViewDocumentFragment(writer, text);
    });
    if (editor.plugins.has("ClipboardPipeline")) {
      editor.plugins.get(ClipboardPipeline).on("contentInsertion", (evt, data) => {
        const model2 = editor.model;
        const selection = model2.document.selection;
        if (!selection.anchor.parent.is("element", "codeBlock")) {
          return;
        }
        model2.change((writer) => {
          const contentRange = writer.createRangeIn(data.content);
          for (const item of [
            ...contentRange.getItems()
          ]) {
            if (item.is("node") && !schema.checkChild(selection.anchor, item)) {
              writer.remove(item);
            }
          }
        });
      });
    }
    this.listenTo(model, "getSelectedContent", (evt, [selection]) => {
      const anchor = selection.anchor;
      if (selection.isCollapsed || !anchor.parent.is("element", "codeBlock") || !anchor.hasSameParentAs(selection.focus)) {
        return;
      }
      model.change((writer) => {
        const docFragment = evt.return;
        if (anchor.parent.is("element") && (docFragment.childCount > 1 || selection.containsEntireContent(anchor.parent))) {
          const codeBlock = writer.createElement("codeBlock", anchor.parent.getAttributes());
          writer.append(docFragment, codeBlock);
          const newDocumentFragment = writer.createDocumentFragment();
          writer.append(codeBlock, newDocumentFragment);
          evt.return = newDocumentFragment;
          return;
        }
        const textNode = docFragment.getChild(0);
        if (schema.checkAttribute(textNode, "code")) {
          writer.setAttribute("code", true, textNode);
        }
      });
    });
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const commands = editor.commands;
    const indent = commands.get("indent");
    const outdent = commands.get("outdent");
    if (indent) {
      indent.registerChildCommand(commands.get("indentCodeBlock"), {
        priority: "highest"
      });
    }
    if (outdent) {
      outdent.registerChildCommand(commands.get("outdentCodeBlock"));
    }
    this.listenTo(editor.editing.view.document, "enter", (evt, data) => {
      const positionParent = editor.model.document.selection.getLastPosition().parent;
      if (!positionParent.is("element", "codeBlock")) {
        return;
      }
      if (!leaveBlockStartOnEnter(editor, data.isSoft) && !leaveBlockEndOnEnter(editor, data.isSoft)) {
        breakLineOnEnter(editor);
      }
      data.preventDefault();
      evt.stop();
    }, {
      context: "pre"
    });
    this._initAriaAnnouncements();
  }
  /**
  * Observe when user enters or leaves code block and set proper aria value in global live announcer.
  * This allows screen readers to indicate when the user has entered and left the specified code block.
  *
  * @internal
  */
  _initAriaAnnouncements() {
    const { model, ui, t } = this.editor;
    const languageDefs = getNormalizedAndLocalizedLanguageDefinitions(this.editor);
    let lastFocusedCodeBlock = null;
    model.document.selection.on("change:range", () => {
      const focusParent = model.document.selection.focus.parent;
      if (!ui || lastFocusedCodeBlock === focusParent || !focusParent.is("element")) {
        return;
      }
      if (lastFocusedCodeBlock && lastFocusedCodeBlock.is("element", "codeBlock")) {
        ui.ariaLiveAnnouncer.announce(getCodeBlockAriaAnnouncement(t, languageDefs, lastFocusedCodeBlock, "leave"));
      }
      if (focusParent.is("element", "codeBlock")) {
        ui.ariaLiveAnnouncer.announce(getCodeBlockAriaAnnouncement(t, languageDefs, focusParent, "enter"));
      }
      lastFocusedCodeBlock = focusParent;
    });
  }
};
function breakLineOnEnter(editor) {
  const model = editor.model;
  const modelDoc = model.document;
  const lastSelectionPosition = modelDoc.selection.getLastPosition();
  let leadingWhiteSpaces;
  const node = getTextNodeAtLineStart(lastSelectionPosition, model);
  if (node && node.is("$text")) {
    leadingWhiteSpaces = getLeadingWhiteSpaces(node);
  }
  editor.model.change((writer) => {
    editor.execute("shiftEnter");
    if (leadingWhiteSpaces) {
      writer.insertText(leadingWhiteSpaces, modelDoc.selection.anchor);
    }
  });
}
function leaveBlockStartOnEnter(editor, isSoftEnter) {
  const model = editor.model;
  const modelDoc = model.document;
  const view = editor.editing.view;
  const lastSelectionPosition = modelDoc.selection.getLastPosition();
  const nodeAfter = lastSelectionPosition.nodeAfter;
  if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtStart) {
    return false;
  }
  if (!isSoftBreakNode(nodeAfter)) {
    return false;
  }
  editor.model.change((writer) => {
    editor.execute("enter");
    const newBlock = modelDoc.selection.anchor.parent.previousSibling;
    writer.rename(newBlock, DEFAULT_ELEMENT);
    writer.setSelection(newBlock, "in");
    editor.model.schema.removeDisallowedAttributes([
      newBlock
    ], writer);
    writer.remove(nodeAfter);
  });
  view.scrollToTheSelection();
  return true;
}
function leaveBlockEndOnEnter(editor, isSoftEnter) {
  const model = editor.model;
  const modelDoc = model.document;
  const view = editor.editing.view;
  const lastSelectionPosition = modelDoc.selection.getLastPosition();
  const nodeBefore = lastSelectionPosition.nodeBefore;
  let emptyLineRangeToRemoveOnEnter;
  if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtEnd || !nodeBefore || !nodeBefore.previousSibling) {
    return false;
  }
  if (isSoftBreakNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling)) {
    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling), model.createPositionAfter(nodeBefore));
  } else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isSoftBreakNode(nodeBefore.previousSibling.previousSibling)) {
    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));
  } else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isEmptyishTextNode(nodeBefore.previousSibling.previousSibling) && nodeBefore.previousSibling.previousSibling && isSoftBreakNode(nodeBefore.previousSibling.previousSibling.previousSibling)) {
    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));
  } else {
    return false;
  }
  editor.model.change((writer) => {
    writer.remove(emptyLineRangeToRemoveOnEnter);
    editor.execute("enter");
    const newBlock = modelDoc.selection.anchor.parent;
    writer.rename(newBlock, DEFAULT_ELEMENT);
    editor.model.schema.removeDisallowedAttributes([
      newBlock
    ], writer);
  });
  view.scrollToTheSelection();
  return true;
}
function isEmptyishTextNode(node) {
  return node && node.is("$text") && !node.data.match(/\S/);
}
function isSoftBreakNode(node) {
  return node && node.is("element", "softBreak");
}
var CodeBlockUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CodeBlockUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const componentFactory = editor.ui.componentFactory;
    const normalizedLanguageDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
    const itemDefinitions = this._getLanguageListItemDefinitions(normalizedLanguageDefs);
    const command = editor.commands.get("codeBlock");
    componentFactory.add("codeBlock", (locale) => {
      const dropdownView = createDropdown(locale, SplitButtonView);
      const splitButtonView = dropdownView.buttonView;
      const accessibleLabel = t("Insert code block");
      splitButtonView.set({
        label: accessibleLabel,
        tooltip: true,
        icon: icons.codeBlock,
        isToggleable: true
      });
      splitButtonView.bind("isOn").to(command, "value", (value) => !!value);
      splitButtonView.on("execute", () => {
        editor.execute("codeBlock", {
          usePreviousLanguageChoice: true
        });
        editor.editing.view.focus();
      });
      dropdownView.on("execute", (evt) => {
        editor.execute("codeBlock", {
          language: evt.source._codeBlockLanguage,
          forceValue: true
        });
        editor.editing.view.focus();
      });
      dropdownView.class = "ck-code-block-dropdown";
      dropdownView.bind("isEnabled").to(command);
      addListToDropdown(dropdownView, itemDefinitions, {
        role: "menu",
        ariaLabel: accessibleLabel
      });
      return dropdownView;
    });
    componentFactory.add("menuBar:codeBlock", (locale) => {
      const menuView = new MenuBarMenuView(locale);
      menuView.buttonView.set({
        role: "menuitem",
        label: t("Code block"),
        icon: icons.codeBlock
      });
      menuView.bind("isEnabled").to(command);
      const listView = new MenuBarMenuListView(locale);
      listView.set({
        ariaLabel: t("Insert code block")
      });
      for (const definition of itemDefinitions) {
        const listItemView = new MenuBarMenuListItemView(locale, menuView);
        const buttonView = new MenuBarMenuListItemButtonView(locale);
        buttonView.bind(...Object.keys(definition.model)).to(definition.model);
        buttonView.set({
          isToggleable: true,
          role: "menuitemcheckbox"
        });
        buttonView.delegate("execute").to(menuView);
        buttonView.on("execute", () => {
          editor.execute("codeBlock", {
            language: definition.model._codeBlockLanguage,
            forceValue: command.value == definition.model._codeBlockLanguage ? false : true
          });
          editor.editing.view.focus();
        });
        listItemView.children.add(buttonView);
        listView.items.add(listItemView);
      }
      menuView.panelView.children.add(listView);
      return menuView;
    });
  }
  /**
  * A helper returning a collection of the `codeBlock` dropdown items representing languages
  * available for the user to choose from.
  */
  _getLanguageListItemDefinitions(normalizedLanguageDefs) {
    const editor = this.editor;
    const command = editor.commands.get("codeBlock");
    const itemDefinitions = new Collection();
    for (const languageDef of normalizedLanguageDefs) {
      const definition = {
        type: "button",
        model: new Model2({
          _codeBlockLanguage: languageDef.language,
          label: languageDef.label,
          role: "menuitemradio",
          withText: true
        })
      };
      definition.model.bind("isOn").to(command, "value", (value) => {
        return value === definition.model._codeBlockLanguage;
      });
      itemDefinitions.add(definition);
    }
    return itemDefinitions;
  }
};
var CodeBlock = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      CodeBlockEditing,
      CodeBlockUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CodeBlock";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-easy-image/dist/index.js
var CloudServicesUploadAdapter = class extends Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "_uploadGateway");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CloudServicesUploadAdapter";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "CloudServices",
      FileRepository
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const cloudServices = editor.plugins.get("CloudServices");
    const token = cloudServices.token;
    const uploadUrl = cloudServices.uploadUrl;
    if (!token) {
      return;
    }
    const cloudServicesCore = editor.plugins.get("CloudServicesCore");
    this._uploadGateway = cloudServicesCore.createUploadGateway(token, uploadUrl);
    editor.plugins.get(FileRepository).createUploadAdapter = (loader) => {
      return new Adapter4(this._uploadGateway, loader);
    };
  }
};
var Adapter4 = class {
  constructor(uploadGateway, loader) {
    __publicField(this, "uploadGateway");
    __publicField(this, "loader");
    __publicField(this, "fileUploader");
    this.uploadGateway = uploadGateway;
    this.loader = loader;
  }
  upload() {
    return this.loader.file.then((file) => {
      this.fileUploader = this.uploadGateway.upload(file);
      this.fileUploader.on("progress", (evt, data) => {
        this.loader.uploadTotal = data.total;
        this.loader.uploaded = data.uploaded;
      });
      return this.fileUploader.send();
    });
  }
  abort() {
    this.fileUploader.abort();
  }
};
var EasyImage = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "EasyImage";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      CloudServicesUploadAdapter,
      "ImageUpload"
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("ImageBlockEditing") && !editor.plugins.has("ImageInlineEditing")) {
      logWarning("easy-image-image-feature-missing", editor);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-editor-balloon/dist/index.js
var BalloonEditorUI = class extends EditorUI {
  /**
  * Creates an instance of the balloon editor UI class.
  *
  * @param editor The editor instance.
  * @param view The view of the UI.
  */
  constructor(editor, view) {
    super(editor);
    /**
    * The main (topmost) view of the editor UI.
    */
    __publicField(this, "view");
    this.view = view;
  }
  /**
  * @inheritDoc
  */
  get element() {
    return this.view.editable.element;
  }
  /**
  * Initializes the UI.
  */
  init() {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    this._initPlaceholder();
    this._initMenuBar(this.view.menuBarView);
    this.fire("ready");
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    if (editingView.getDomRoot(view.editable.name)) {
      editingView.detachDomRoot(view.editable.name);
    }
    view.destroy();
  }
  /**
  * Enable the placeholder text on the editing root.
  */
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      const placeholderText = typeof placeholder === "string" ? placeholder : placeholder[editingRoot.rootName];
      if (placeholderText) {
        editingRoot.placeholder = placeholderText;
      }
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
};
var BalloonEditorUIView = class extends EditorUIView {
  /**
  * Creates an instance of the balloon editor UI view.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param editingView The editing view instance this view is related to.
  * @param editableElement The editable element. If not specified, it will be automatically created by
  * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
  * @param label When set, this value will be used as an accessible `aria-label` of the
  * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
  */
  constructor(locale, editingView, editableElement, label) {
    super(locale);
    /**
    * Editable UI view.
    */
    __publicField(this, "editable");
    /**
    * Menu bar view instance.
    */
    __publicField(this, "menuBarView");
    this.editable = new InlineEditableUIView(locale, editingView, editableElement, {
      label
    });
    this.menuBarView = new MenuBarView(locale);
    this.menuBarView.extendTemplate({
      attributes: {
        class: [
          "ck-reset_all",
          "ck-rounded-corners"
        ],
        dir: locale.uiLanguageDirection
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.registerChild(this.editable);
    this.registerChild(this.menuBarView);
  }
};
var BalloonEditor = class extends ElementApiMixin(Editor) {
  /**
  * Creates an instance of the balloon editor.
  *
  * **Note:** do not use the constructor to create editor instances. Use the static
  * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`} method instead.
  *
  * @param sourceElementOrData The DOM element that will be the source for the created editor
  * (on which the editor will be initialized) or initial data for the editor. For more information see
  * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}.
  * @param config The editor configuration.
  */
  constructor(sourceElementOrData, config = {}) {
    if (!isElement(sourceElementOrData) && config.initialData !== void 0) {
      throw new CKEditorError("editor-create-initial-data", null);
    }
    super(config);
    /**
    * @inheritDoc
    */
    __publicField(this, "ui");
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData(sourceElementOrData));
    }
    if (isElement(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
      secureSourceElement(this, sourceElementOrData);
    }
    const plugins = this.config.get("plugins");
    plugins.push(BalloonToolbar);
    this.config.set("plugins", plugins);
    this.config.define("balloonToolbar", this.config.get("toolbar"));
    this.model.document.createRoot();
    const view = new BalloonEditorUIView(this.locale, this.editing.view, this.sourceElement, this.config.get("label"));
    this.ui = new BalloonEditorUI(this, view);
    attachToForm(this);
  }
  /**
  * Destroys the editor instance, releasing all resources used by it.
  *
  * Updates the original editor element with the data if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
  * configuration option is set to `true`.
  */
  destroy() {
    const data = this.getData();
    this.ui.destroy();
    return super.destroy().then(() => {
      if (this.sourceElement) {
        this.updateSourceElement(data);
      }
    });
  }
  /**
  * Creates a new balloon editor instance.
  *
  * There are three general ways how the editor can be initialized.
  *
  * # Using an existing DOM element (and loading data from it)
  *
  * You can initialize the editor using an existing DOM element:
  *
  * ```ts
  * BalloonEditor
  * 	.create( document.querySelector( '#editor' ) )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * The element's content will be used as the editor data and the element will become the editable element.
  *
  * # Creating a detached editor
  *
  * Alternatively, you can initialize the editor by passing the initial data directly as a string.
  * In this case, the editor will render an element that must be inserted into the DOM for the editor to work properly:
  *
  * ```ts
  * BalloonEditor
  * 	.create( '<p>Hello world!</p>' )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  *
  * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
  * 		document.body.appendChild( editor.ui.element );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
  * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
  *
  * # Using an existing DOM element (and data provided in `config.initialData`)
  *
  * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
  *
  * ```ts
  * BalloonEditor
  * 	.create( document.querySelector( '#editor' ), {
  * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
  * 	} )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
  * makes it difficult to set the content of the source element.
  *
  * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
  *
  * # Configuring the editor
  *
  * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
  * customizing plugins, toolbar and more.
  *
  * # Using the editor from source
  *
  * If you want to use the balloon editor,
  * you need to define the list of
  * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
  * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}.
  *
  * @param sourceElementOrData The DOM element that will be the source for the created editor
  * or the editor's initial data.
  *
  * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
  * The editor data will be set back to the original element once the editor is destroyed only if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
  * option is set to `true`.
  *
  * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
  * It is available under the {@link module:editor-balloon/ballooneditorui~BalloonEditorUI#element `editor.ui.element`} property.
  *
  * @param config The editor configuration.
  * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
  */
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      if (isElement(sourceElementOrData) && sourceElementOrData.tagName === "TEXTAREA") {
        throw new CKEditorError("editor-wrong-element", null);
      }
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
function getInitialData(sourceElementOrData) {
  return isElement(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-classic/dist/index.js
var ClassicEditorUI = class extends EditorUI {
  /**
  * Creates an instance of the classic editor UI class.
  *
  * @param editor The editor instance.
  * @param view The view of the UI.
  */
  constructor(editor, view) {
    super(editor);
    /**
    * The main (topmost) view of the editor UI.
    */
    __publicField(this, "view");
    /**
    * A normalized `config.toolbar` object.
    */
    __publicField(this, "_toolbarConfig");
    /**
    * The element replacer instance used to hide the editor's source element.
    */
    __publicField(this, "_elementReplacer");
    this.view = view;
    this._toolbarConfig = normalizeToolbarConfig(editor.config.get("toolbar"));
    this._elementReplacer = new ElementReplacer();
    this.listenTo(editor.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
  }
  /**
  * @inheritDoc
  */
  get element() {
    return this.view.element;
  }
  /**
  * Initializes the UI.
  *
  * @param replacementElement The DOM element that will be the source for the created editor.
  */
  init(replacementElement) {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    view.editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    if (replacementElement) {
      this._elementReplacer.replace(replacementElement, this.element);
    }
    this._initPlaceholder();
    this._initToolbar();
    if (view.menuBarView) {
      this._initMenuBar(view.menuBarView);
    }
    this._initDialogPluginIntegration();
    this._initContextualBalloonIntegration();
    this.fire("ready");
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    this._elementReplacer.restore();
    if (editingView.getDomRoot(view.editable.name)) {
      editingView.detachDomRoot(view.editable.name);
    }
    view.destroy();
  }
  /**
  * Initializes the editor toolbar.
  */
  _initToolbar() {
    const view = this.view;
    view.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
    view.stickyPanel.limiterElement = view.element;
    view.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top }) => top || 0);
    view.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
    this.addToolbar(view.toolbar);
  }
  /**
  * Enable the placeholder text on the editing root.
  */
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const sourceElement = editor.sourceElement;
    let placeholderText;
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      placeholderText = typeof placeholder === "string" ? placeholder : placeholder[this.view.editable.name];
    }
    if (!placeholderText && sourceElement && sourceElement.tagName.toLowerCase() === "textarea") {
      placeholderText = sourceElement.getAttribute("placeholder");
    }
    if (placeholderText) {
      editingRoot.placeholder = placeholderText;
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
  /**
  * Provides an integration between the sticky toolbar and {@link module:ui/panel/balloon/contextualballoon contextual balloon plugin}.
  * It allows the contextual balloon to consider the height of the
  * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel}. It prevents the balloon from overlapping
  * the sticky toolbar by adjusting the balloon's position using viewport offset configuration.
  */
  _initContextualBalloonIntegration() {
    if (!this.editor.plugins.has("ContextualBalloon")) {
      return;
    }
    const { stickyPanel } = this.view;
    const contextualBalloon = this.editor.plugins.get("ContextualBalloon");
    contextualBalloon.on("getPositionOptions", (evt) => {
      const position = evt.return;
      if (!position || !stickyPanel.isSticky || !stickyPanel.element) {
        return;
      }
      const stickyPanelHeight = new Rect(stickyPanel.element).height;
      const target = typeof position.target === "function" ? position.target() : position.target;
      const limiter = typeof position.limiter === "function" ? position.limiter() : position.limiter;
      if (target && limiter && new Rect(target).height >= new Rect(limiter).height - stickyPanelHeight) {
        return;
      }
      const viewportOffsetConfig = {
        ...position.viewportOffsetConfig
      };
      const newTopViewportOffset = (viewportOffsetConfig.top || 0) + stickyPanelHeight;
      evt.return = {
        ...position,
        viewportOffsetConfig: {
          ...viewportOffsetConfig,
          top: newTopViewportOffset
        }
      };
    }, {
      priority: "low"
    });
    const updateBalloonPosition = () => {
      if (contextualBalloon.visibleView) {
        contextualBalloon.updatePosition();
      }
    };
    this.listenTo(stickyPanel, "change:isSticky", updateBalloonPosition);
    this.listenTo(this.editor.ui, "change:viewportOffset", updateBalloonPosition);
  }
  /**
  * Provides an integration between the sticky toolbar and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
  * It allows the UI-agnostic engine method to consider the geometry of the
  * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel} that pins to the
  * edge of the viewport and can obscure the user caret after scrolling the window.
  *
  * @param evt The `scrollToTheSelection` event info.
  * @param data The payload carried by the `scrollToTheSelection` event.
  * @param originalArgs The original arguments passed to `scrollViewportToShowTarget()` method (see implementation to learn more).
  */
  _handleScrollToTheSelectionWithStickyPanel(evt, data, originalArgs) {
    const stickyPanel = this.view.stickyPanel;
    if (stickyPanel.isSticky) {
      const stickyPanelHeight = new Rect(stickyPanel.element).height;
      data.viewportOffset.top += stickyPanelHeight;
    } else {
      const scrollViewportOnPanelGettingSticky = () => {
        this.editor.editing.view.scrollToTheSelection(originalArgs);
      };
      this.listenTo(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
      setTimeout(() => {
        this.stopListening(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
      }, 20);
    }
  }
  /**
  * Provides an integration between the sticky toolbar and {@link module:ui/dialog/dialog the Dialog plugin}.
  *
  * It moves the dialog down to ensure that the
  * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel sticky panel}
  * used by the editor UI will not get obscured by the dialog when the dialog uses one of its automatic positions.
  */
  _initDialogPluginIntegration() {
    if (!this.editor.plugins.has("Dialog")) {
      return;
    }
    const stickyPanel = this.view.stickyPanel;
    const dialogPlugin = this.editor.plugins.get("Dialog");
    dialogPlugin.on("show", () => {
      const dialogView = dialogPlugin.view;
      dialogView.on("moveTo", (evt, data) => {
        if (!stickyPanel.isSticky || dialogView.wasMoved) {
          return;
        }
        const stickyPanelContentRect = new Rect(stickyPanel.contentPanelElement);
        if (data[1] < stickyPanelContentRect.bottom + DialogView.defaultOffset) {
          data[1] = stickyPanelContentRect.bottom + DialogView.defaultOffset;
        }
      }, {
        priority: "high"
      });
    }, {
      priority: "low"
    });
  }
};
var ClassicEditorUIView = class extends BoxedEditorUIView {
  /**
  * Creates an instance of the classic editor UI view.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param editingView The editing view instance this view is related to.
  * @param options Configuration options for the view instance.
  * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
  * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
  * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
  * @param options.label When set, this value will be used as an accessible `aria-label` of the
  * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
  */
  constructor(locale, editingView, options2 = {}) {
    super(locale);
    /**
    * Sticky panel view instance. This is a parent view of a {@link #toolbar}
    * that makes toolbar sticky.
    */
    __publicField(this, "stickyPanel");
    /**
    * Toolbar view instance.
    */
    __publicField(this, "toolbar");
    /**
    * Editable UI view.
    */
    __publicField(this, "editable");
    this.stickyPanel = new StickyPanelView(locale);
    this.toolbar = new ToolbarView(locale, {
      shouldGroupWhenFull: options2.shouldToolbarGroupWhenFull
    });
    if (options2.useMenuBar) {
      this.menuBarView = new MenuBarView(locale);
    }
    this.editable = new InlineEditableUIView(locale, editingView, void 0, {
      label: options2.label
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    if (this.menuBarView) {
      this.stickyPanel.content.addMany([
        this.menuBarView,
        this.toolbar
      ]);
    } else {
      this.stickyPanel.content.add(this.toolbar);
    }
    this.top.add(this.stickyPanel);
    this.main.add(this.editable);
  }
};
var ClassicEditor = class extends ElementApiMixin(Editor) {
  /**
  * Creates an instance of the classic editor.
  *
  * **Note:** do not use the constructor to create editor instances. Use the static
  * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
  *
  * @param sourceElementOrData The DOM element that will be the source for the created editor
  * or the editor's initial data. For more information see
  * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
  * @param config The editor configuration.
  */
  constructor(sourceElementOrData, config = {}) {
    if (!isElement2(sourceElementOrData) && config.initialData !== void 0) {
      throw new CKEditorError("editor-create-initial-data", null);
    }
    super(config);
    /**
    * @inheritDoc
    */
    __publicField(this, "ui");
    this.config.define("menuBar.isVisible", false);
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData2(sourceElementOrData));
    }
    if (isElement2(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
    }
    this.model.document.createRoot();
    const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
    const menuBarConfig = this.config.get("menuBar");
    const view = new ClassicEditorUIView(this.locale, this.editing.view, {
      shouldToolbarGroupWhenFull,
      useMenuBar: menuBarConfig.isVisible,
      label: this.config.get("label")
    });
    this.ui = new ClassicEditorUI(this, view);
    attachToForm(this);
  }
  /**
  * Destroys the editor instance, releasing all resources used by it.
  *
  * Updates the original editor element with the data if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
  * configuration option is set to `true`.
  */
  destroy() {
    if (this.sourceElement) {
      this.updateSourceElement();
    }
    this.ui.destroy();
    return super.destroy();
  }
  /**
  * Creates a new classic editor instance.
  *
  * There are three ways how the editor can be initialized.
  *
  * # Replacing a DOM element (and loading data from it)
  *
  * You can initialize the editor using an existing DOM element:
  *
  * ```ts
  * ClassicEditor
  * 	.create( document.querySelector( '#editor' ) )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * The element's content will be used as the editor data and the element will be replaced by the editor UI.
  *
  * # Creating a detached editor
  *
  * Alternatively, you can initialize the editor by passing the initial data directly as a string.
  * In this case, the editor will render an element that must be inserted into the DOM:
  *
  * ```ts
  * ClassicEditor
  * 	.create( '<p>Hello world!</p>' )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  *
  * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
  * 		document.body.appendChild( editor.ui.element );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
  * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
  *
  * # Replacing a DOM element (and data provided in `config.initialData`)
  *
  * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
  *
  * ```ts
  * ClassicEditor
  * 	.create( document.querySelector( '#editor' ), {
  * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
  * 	} )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
  * makes it difficult to set the content of the source element.
  *
  * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
  *
  * # Configuring the editor
  *
  * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
  * customizing plugins, toolbar and more.
  *
  * @param sourceElementOrData The DOM element that will be the source for the created editor
  * or the editor's initial data.
  *
  * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
  * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
  * in the DOM (the original one will be hidden and the editor will be injected next to it).
  *
  * If the {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
  * option is set to `true`, the editor data will be set back to the original element once the editor is destroyed and when a form,
  * in which this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration
  * with native web forms.
  *
  * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
  * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
  *
  * @param config The editor configuration.
  * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
  */
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init(isElement2(sourceElementOrData) ? sourceElementOrData : null)).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
function getInitialData2(sourceElementOrData) {
  return isElement2(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement2(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-decoupled/dist/index.js
var DecoupledEditorUI = class extends EditorUI {
  /**
  * Creates an instance of the decoupled editor UI class.
  *
  * @param editor The editor instance.
  * @param view The view of the UI.
  */
  constructor(editor, view) {
    super(editor);
    /**
    * The main (topmost) view of the editor UI.
    */
    __publicField(this, "view");
    this.view = view;
  }
  /**
  * Initializes the UI.
  */
  init() {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    view.editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    this._initPlaceholder();
    this._initToolbar();
    this._initMenuBar(this.view.menuBarView);
    this.fire("ready");
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    if (editingView.getDomRoot(view.editable.name)) {
      editingView.detachDomRoot(view.editable.name);
    }
    view.destroy();
  }
  /**
  * Initializes the inline editor toolbar and its panel.
  */
  _initToolbar() {
    const editor = this.editor;
    const view = this.view;
    const toolbar = view.toolbar;
    toolbar.fillFromConfig(editor.config.get("toolbar"), this.componentFactory);
    this.addToolbar(view.toolbar);
  }
  /**
  * Enable the placeholder text on the editing root.
  */
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      const placeholderText = typeof placeholder === "string" ? placeholder : placeholder[editingRoot.rootName];
      if (placeholderText) {
        editingRoot.placeholder = placeholderText;
      }
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
};
var DecoupledEditorUIView = class extends EditorUIView {
  /**
  * Creates an instance of the decoupled editor UI view.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param editingView The editing view instance this view is related to.
  * @param options Configuration options for the view instance.
  * @param options.editableElement The editable element. If not specified, it will be automatically created by
  * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
  * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
  * in the main {@link module:editor-decoupled/decouplededitoruiview~DecoupledEditorUIView#toolbar toolbar}.
  * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
  * @param options.label When set, this value will be used as an accessible `aria-label` of the
  * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
  */
  constructor(locale, editingView, options2 = {}) {
    super(locale);
    /**
    * The main toolbar of the decoupled editor UI.
    */
    __publicField(this, "toolbar");
    /**
    * The editable of the decoupled editor UI.
    */
    __publicField(this, "editable");
    /**
    * Menu bar view instance.
    */
    __publicField(this, "menuBarView");
    this.toolbar = new ToolbarView(locale, {
      shouldGroupWhenFull: options2.shouldToolbarGroupWhenFull
    });
    this.menuBarView = new MenuBarView(locale);
    this.editable = new InlineEditableUIView(locale, editingView, options2.editableElement, {
      label: options2.label
    });
    this.toolbar.extendTemplate({
      attributes: {
        class: [
          "ck-reset_all",
          "ck-rounded-corners"
        ],
        dir: locale.uiLanguageDirection
      }
    });
    this.menuBarView.extendTemplate({
      attributes: {
        class: [
          "ck-reset_all",
          "ck-rounded-corners"
        ],
        dir: locale.uiLanguageDirection
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.registerChild([
      this.menuBarView,
      this.toolbar,
      this.editable
    ]);
  }
};
var DecoupledEditor = class extends ElementApiMixin(Editor) {
  /**
  * Creates an instance of the decoupled editor.
  *
  * **Note:** Do not use the constructor to create editor instances. Use the static
  * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`} method instead.
  *
  * @param sourceElementOrData The DOM element that will be the source for the created editor
  * (on which the editor will be initialized) or initial data for the editor. For more information see
  * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}.
  * @param config The editor configuration.
  */
  constructor(sourceElementOrData, config = {}) {
    if (!isElement3(sourceElementOrData) && config.initialData !== void 0) {
      throw new CKEditorError("editor-create-initial-data", null);
    }
    super(config);
    /**
    * @inheritDoc
    */
    __publicField(this, "ui");
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData3(sourceElementOrData));
    }
    if (isElement3(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
      secureSourceElement(this, sourceElementOrData);
    }
    this.model.document.createRoot();
    const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
    const view = new DecoupledEditorUIView(this.locale, this.editing.view, {
      editableElement: this.sourceElement,
      shouldToolbarGroupWhenFull,
      label: this.config.get("label")
    });
    this.ui = new DecoupledEditorUI(this, view);
  }
  /**
  * Destroys the editor instance, releasing all resources used by it.
  *
  * Updates the original editor element with the data if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
  * configuration option is set to `true`.
  *
  * **Note**: The decoupled editor does not remove the toolbar and editable when destroyed. You can
  * do that yourself in the destruction chain:
  *
  * ```ts
  * editor.destroy()
  * 	.then( () => {
  * 		// Remove the toolbar from DOM.
  * 		editor.ui.view.toolbar.element.remove();
  *
  * 		// Remove the editable from DOM.
  * 		editor.ui.view.editable.element.remove();
  *
  * 		console.log( 'Editor was destroyed' );
  * 	} );
  * ```
  */
  destroy() {
    const data = this.getData();
    this.ui.destroy();
    return super.destroy().then(() => {
      if (this.sourceElement) {
        this.updateSourceElement(data);
      }
    });
  }
  /**
  * Creates a new decoupled editor instance.
  *
  * **Note:** remember that `DecoupledEditor` does not append the toolbar element to your web page, so you have to do it manually
  * after the editor has been initialized.
  *
  * There are two ways how the editor can be initialized.
  *
  * # Using an existing DOM element (and loading data from it)
  *
  * You can initialize the editor using an existing DOM element:
  *
  * ```ts
  * DecoupledEditor
  * 	.create( document.querySelector( '#editor' ) )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  *
  * 		// Append the toolbar to the <body> element.
  * 		document.body.appendChild( editor.ui.view.toolbar.element );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * The element's content will be used as the editor data and the element will become the editable element.
  *
  * # Creating a detached editor
  *
  * Alternatively, you can initialize the editor by passing the initial data directly as a string.
  * In this case, you will have to manually append both the toolbar element and the editable element to your web page.
  *
  * ```ts
  * DecoupledEditor
  * 	.create( '<p>Hello world!</p>' )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  *
  * 		// Append the toolbar to the <body> element.
  * 		document.body.appendChild( editor.ui.view.toolbar.element );
  *
  * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
  * 		document.body.appendChild( editor.ui.getEditableElement() );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
  * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
  *
  * # Using an existing DOM element (and data provided in `config.initialData`)
  *
  * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
  *
  * ```ts
  * DecoupledEditor
  * 	.create( document.querySelector( '#editor' ), {
  * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
  * 	} )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  *
  * 		// Append the toolbar to the <body> element.
  * 		document.body.appendChild( editor.ui.view.toolbar.element );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
  * makes it difficult to set the content of the source element.
  *
  * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
  *
  * # Configuring the editor
  *
  * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
  * customizing plugins, toolbar and more.
  *
  * @param sourceElementOrData The DOM element that will be the source for the created editor
  * or the editor's initial data.
  *
  * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
  * The editor data will be set back to the original element once the editor is destroyed only if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
  * option is set to `true`.
  *
  * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
  * It is available via
  * {@link module:editor-decoupled/decouplededitorui~DecoupledEditorUI#getEditableElement `editor.ui.getEditableElement()`}.
  *
  * @param config The editor configuration.
  * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
  */
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      if (isElement3(sourceElementOrData) && sourceElementOrData.tagName === "TEXTAREA") {
        throw new CKEditorError("editor-wrong-element", null);
      }
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
function getInitialData3(sourceElementOrData) {
  return isElement3(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement3(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-inline/dist/index.js
var InlineEditorUI = class extends EditorUI {
  /**
  * Creates an instance of the inline editor UI class.
  *
  * @param editor The editor instance.
  * @param view The view of the UI.
  */
  constructor(editor, view) {
    super(editor);
    /**
    * The main (topmost) view of the editor UI.
    */
    __publicField(this, "view");
    /**
    * A normalized `config.toolbar` object.
    */
    __publicField(this, "_toolbarConfig");
    this.view = view;
    this._toolbarConfig = normalizeToolbarConfig(editor.config.get("toolbar"));
  }
  /**
  * @inheritDoc
  */
  get element() {
    return this.view.editable.element;
  }
  /**
  * Initializes the UI.
  */
  init() {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    this._initPlaceholder();
    this._initToolbar();
    if (view.menuBarView) {
      this._initMenuBar(view.menuBarView);
    }
    this.fire("ready");
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    editingView.detachDomRoot(view.editable.name);
    view.destroy();
  }
  /**
  * Initializes the inline editor toolbar and its panel.
  */
  _initToolbar() {
    const editor = this.editor;
    const view = this.view;
    const editableElement = view.editable.element;
    const toolbar = view.toolbar;
    view.panel.bind("isVisible").to(this.focusTracker, "isFocused");
    view.bind("viewportTopOffset").to(this, "viewportOffset", ({ top }) => top || 0);
    view.listenTo(editor.ui, "update", () => {
      if (view.panel.isVisible) {
        view.panel.pin({
          target: editableElement,
          positions: view.panelPositions
        });
      }
    });
    toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
    this.addToolbar(toolbar);
  }
  /**
  * Enable the placeholder text on the editing root.
  */
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      const placeholderText = typeof placeholder === "string" ? placeholder : placeholder[editingRoot.rootName];
      if (placeholderText) {
        editingRoot.placeholder = placeholderText;
      }
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
};
var toPx = toUnit("px");
var InlineEditorUIView = class extends EditorUIView {
  /**
  * Creates an instance of the inline editor UI view.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param editingView The editing view instance this view is related to.
  * @param editableElement The editable element. If not specified, it will be automatically created by
  * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
  * @param options Configuration options for the view instance.
  * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
  * in the main {@link module:editor-inline/inlineeditoruiview~InlineEditorUIView#toolbar toolbar}.
  * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
  * @param options.label When set, this value will be used as an accessible `aria-label` of the
  * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
  */
  constructor(locale, editingView, editableElement, options2 = {}) {
    super(locale);
    /**
    * A floating toolbar view instance.
    */
    __publicField(this, "toolbar");
    /**
    * A balloon panel view instance.
    */
    __publicField(this, "panel");
    /**
    * A set of positioning functions used by the {@link #panel} to float around
    * {@link #element editableElement}.
    *
    * The positioning functions are as follows:
    *
    * * West:
    *
    * ```
    * [ Panel ]
    * +------------------+
    * | #editableElement |
    * +------------------+
    *
    * +------------------+
    * | #editableElement |
    * |[ Panel ]         |
    * |                  |
    * +------------------+
    *
    * +------------------+
    * | #editableElement |
    * +------------------+
    * [ Panel ]
    * ```
    *
    * * East:
    *
    * ```
    *            [ Panel ]
    * +------------------+
    * | #editableElement |
    * +------------------+
    *
    * +------------------+
    * | #editableElement |
    * |         [ Panel ]|
    * |                  |
    * +------------------+
    *
    * +------------------+
    * | #editableElement |
    * +------------------+
    *            [ Panel ]
    * ```
    *
    * See: {@link module:utils/dom/position~Options#positions}.
    */
    __publicField(this, "panelPositions");
    /**
    * Editable UI view.
    */
    __publicField(this, "editable");
    /**
    * An instance of the resize observer that helps dynamically determine the geometry of the toolbar
    * and manage items that do not fit into a single row.
    *
    * **Note:** Created in {@link #render}.
    */
    __publicField(this, "_resizeObserver");
    this.toolbar = new ToolbarView(locale, {
      shouldGroupWhenFull: options2.shouldToolbarGroupWhenFull,
      isFloating: true
    });
    if (options2.useMenuBar) {
      this.menuBarView = new MenuBarView(locale);
    }
    this.set("viewportTopOffset", 0);
    this.panel = new BalloonPanelView(locale);
    this.panelPositions = this._getPanelPositions();
    this.panel.extendTemplate({
      attributes: {
        class: "ck-toolbar-container"
      }
    });
    this.editable = new InlineEditableUIView(locale, editingView, editableElement, {
      label: options2.label
    });
    this._resizeObserver = null;
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.body.add(this.panel);
    this.registerChild(this.editable);
    if (this.menuBarView) {
      this.panel.content.addMany([
        this.menuBarView,
        this.toolbar
      ]);
    } else {
      this.panel.content.add(this.toolbar);
    }
    const options2 = this.toolbar.options;
    if (options2.shouldGroupWhenFull) {
      const editableElement = this.editable.element;
      this._resizeObserver = new ResizeObserver(editableElement, () => {
        this.toolbar.maxWidth = toPx(new Rect(editableElement).width);
      });
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  /**
  * Determines the panel top position of the {@link #panel} in {@link #panelPositions}.
  *
  * @param editableRect Rect of the {@link #element}.
  * @param panelRect Rect of the {@link #panel}.
  */
  _getPanelPositionTop(editableRect, panelRect) {
    let top;
    if (editableRect.top > panelRect.height + this.viewportTopOffset) {
      top = editableRect.top - panelRect.height;
    } else if (editableRect.bottom > panelRect.height + this.viewportTopOffset + 50) {
      top = this.viewportTopOffset;
    } else {
      top = editableRect.bottom;
    }
    return top;
  }
  /**
  * Returns the positions for {@link #panelPositions}.
  *
  * See: {@link module:utils/dom/position~Options#positions}.
  */
  _getPanelPositions() {
    const positions = [
      (editableRect, panelRect) => {
        return {
          top: this._getPanelPositionTop(editableRect, panelRect),
          left: editableRect.left,
          name: "toolbar_west",
          config: {
            withArrow: false
          }
        };
      },
      (editableRect, panelRect) => {
        return {
          top: this._getPanelPositionTop(editableRect, panelRect),
          left: editableRect.left + editableRect.width - panelRect.width,
          name: "toolbar_east",
          config: {
            withArrow: false
          }
        };
      }
    ];
    if (this.locale.uiLanguageDirection === "ltr") {
      return positions;
    } else {
      return positions.reverse();
    }
  }
};
var InlineEditor = class extends ElementApiMixin(Editor) {
  /**
  * Creates an instance of the inline editor.
  *
  * **Note:** Do not use the constructor to create editor instances. Use the static
  * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`} method instead.
  *
  * @param sourceElementOrData The DOM element that will be the source for the created editor
  * (on which the editor will be initialized) or initial data for the editor. For more information see
  * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}.
  * @param config The editor configuration.
  */
  constructor(sourceElementOrData, config = {}) {
    if (!isElement4(sourceElementOrData) && config.initialData !== void 0) {
      throw new CKEditorError("editor-create-initial-data", null);
    }
    super(config);
    /**
    * @inheritDoc
    */
    __publicField(this, "ui");
    this.config.define("menuBar.isVisible", false);
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData4(sourceElementOrData));
    }
    this.model.document.createRoot();
    if (isElement4(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
      secureSourceElement(this, sourceElementOrData);
    }
    const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
    const menuBarConfig = this.config.get("menuBar");
    const view = new InlineEditorUIView(this.locale, this.editing.view, this.sourceElement, {
      shouldToolbarGroupWhenFull,
      useMenuBar: menuBarConfig.isVisible,
      label: this.config.get("label")
    });
    this.ui = new InlineEditorUI(this, view);
    attachToForm(this);
  }
  /**
  * Destroys the editor instance, releasing all resources used by it.
  *
  * Updates the original editor element with the data if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
  * configuration option is set to `true`.
  */
  destroy() {
    const data = this.getData();
    this.ui.destroy();
    return super.destroy().then(() => {
      if (this.sourceElement) {
        this.updateSourceElement(data);
      }
    });
  }
  /**
  * Creates a new inline editor instance.
  *
  * There are three general ways how the editor can be initialized.
  *
  * # Using an existing DOM element (and loading data from it)
  *
  * You can initialize the editor using an existing DOM element:
  *
  * ```ts
  * InlineEditor
  * 	.create( document.querySelector( '#editor' ) )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * The element's content will be used as the editor data and the element will become the editable element.
  *
  * # Creating a detached editor
  *
  * Alternatively, you can initialize the editor by passing the initial data directly as a `String`.
  * In this case, the editor will render an element that must be inserted into the DOM for the editor to work properly:
  *
  * ```ts
  * InlineEditor
  * 	.create( '<p>Hello world!</p>' )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  *
  * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
  * 		document.body.appendChild( editor.ui.element );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
  * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
  *
  * # Using an existing DOM element (and data provided in `config.initialData`)
  *
  * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
  *
  * ```ts
  * InlineEditor
  * 	.create( document.querySelector( '#editor' ), {
  * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
  * 	} )
  * 	.then( editor => {
  * 		console.log( 'Editor was initialized', editor );
  * 	} )
  * 	.catch( err => {
  * 		console.error( err.stack );
  * 	} );
  * ```
  *
  * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
  * makes it difficult to set the content of the source element.
  *
  * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
  *
  * # Configuring the editor
  *
  * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
  * customizing plugins, toolbar and more.
  *
  * @param sourceElementOrData The DOM element that will be the source for the created editor
  * or the editor's initial data.
  *
  * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
  * The editor data will be set back to the original element once the editor is destroyed only if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
  * option is set to `true`.
  *
  * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
  * It is available under the {@link module:editor-inline/inlineeditorui~InlineEditorUI#element `editor.ui.element`} property.
  *
  * @param config The editor configuration.
  * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
  */
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      if (isElement4(sourceElementOrData) && sourceElementOrData.tagName === "TEXTAREA") {
        throw new CKEditorError("editor-wrong-element", null);
      }
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
function getInitialData4(sourceElementOrData) {
  return isElement4(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement4(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-multi-root/dist/index.js
var MultiRootEditorUI = class extends EditorUI {
  /**
  * Creates an instance of the multi-root editor UI class.
  *
  * @param editor The editor instance.
  * @param view The view of the UI.
  */
  constructor(editor, view) {
    super(editor);
    /**
    * The main (topmost) view of the editor UI.
    */
    __publicField(this, "view");
    /**
    * The editable element that was focused the last time when any of the editables had focus.
    */
    __publicField(this, "_lastFocusedEditableElement");
    this.view = view;
    this._lastFocusedEditableElement = null;
  }
  /**
  * Initializes the UI.
  */
  init() {
    const view = this.view;
    view.render();
    this.focusTracker.on("change:focusedElement", (evt, name, focusedElement) => {
      for (const editable of Object.values(this.view.editables)) {
        if (focusedElement === editable.element) {
          this._lastFocusedEditableElement = editable.element;
        }
      }
    });
    this.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
      if (!isFocused) {
        this._lastFocusedEditableElement = null;
      }
    });
    for (const editable of Object.values(this.view.editables)) {
      this.addEditable(editable);
    }
    this._initToolbar();
    this._initMenuBar(this.view.menuBarView);
    this.fire("ready");
  }
  /**
  * Adds the editable to the editor UI.
  *
  * After the editable is added to the editor UI it can be considered "active".
  *
  * The editable is attached to the editor editing pipeline, which means that it will be updated as the editor model updates and
  * changing its content will be reflected in the editor model. Keystrokes, focus handling and placeholder are initialized.
  *
  * @param editable The editable instance to add.
  * @param placeholder Placeholder for the editable element. If not set, placeholder value from the
  * {@link module:core/editor/editorconfig~EditorConfig#placeholder editor configuration} will be used (if it was provided).
  */
  addEditable(editable, placeholder) {
    const editableElement = editable.element;
    this.editor.editing.view.attachDomRoot(editableElement, editable.name);
    this.setEditableElement(editable.name, editableElement);
    editable.bind("isFocused").to(this.focusTracker, "isFocused", this.focusTracker, "focusedElement", (isFocused, focusedElement) => {
      if (!isFocused) {
        return false;
      }
      if (focusedElement === editableElement) {
        return true;
      } else {
        return this._lastFocusedEditableElement === editableElement;
      }
    });
    this._initPlaceholder(editable, placeholder);
  }
  /**
  * Removes the editable instance from the editor UI.
  *
  * Removed editable can be considered "deactivated".
  *
  * The editable is detached from the editing pipeline, so model changes are no longer reflected in it. All handling added in
  * {@link #addEditable} is removed.
  *
  * @param editable Editable to remove from the editor UI.
  */
  removeEditable(editable) {
    this.editor.editing.view.detachDomRoot(editable.name);
    editable.unbind("isFocused");
    this.removeEditableElement(editable.name);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    for (const editable of Object.values(this.view.editables)) {
      this.removeEditable(editable);
    }
    this.view.destroy();
  }
  /**
  * Initializes the editor main toolbar and its panel.
  */
  _initToolbar() {
    const editor = this.editor;
    const view = this.view;
    const toolbar = view.toolbar;
    toolbar.fillFromConfig(editor.config.get("toolbar"), this.componentFactory);
    this.addToolbar(view.toolbar);
  }
  /**
  * Enables the placeholder text on a given editable.
  *
  * @param editable Editable on which the placeholder should be set.
  * @param placeholder Placeholder for the editable element. If not set, placeholder value from the
  * {@link module:core/editor/editorconfig~EditorConfig#placeholder editor configuration} will be used (if it was provided).
  */
  _initPlaceholder(editable, placeholder) {
    if (!placeholder) {
      const configPlaceholder = this.editor.config.get("placeholder");
      if (configPlaceholder) {
        placeholder = typeof configPlaceholder === "string" ? configPlaceholder : configPlaceholder[editable.name];
      }
    }
    const editingView = this.editor.editing.view;
    const editingRoot = editingView.document.getRoot(editable.name);
    if (placeholder) {
      editingRoot.placeholder = placeholder;
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
};
var MultiRootEditorUIView = class extends EditorUIView {
  /**
  * Creates an instance of the multi-root editor UI view.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param editingView The editing view instance this view is related to.
  * @param editableNames Names for all editable views. For each name, one
  * {@link module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView `InlineEditableUIView`} instance will be initialized.
  * @param options Configuration options for the view instance.
  * @param options.editableElements The editable elements to be used, assigned to their names. If not specified, they will be
  * automatically created by {@link module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView `InlineEditableUIView`}
  * instances.
  * @param options.shouldToolbarGroupWhenFull When set to `true` enables automatic items grouping
  * in the main {@link module:editor-multi-root/multirooteditoruiview~MultiRootEditorUIView#toolbar toolbar}.
  * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
  * @param options.label When set, this value will be used as an accessible `aria-label` of the
  * {@link module:ui/editableui/editableuiview~EditableUIView editable view} elements.
  */
  constructor(locale, editingView, editableNames, options2 = {}) {
    super(locale);
    /**
    * The main toolbar of the multi-root editor UI.
    */
    __publicField(this, "toolbar");
    /**
    * Editable elements used by the multi-root editor UI.
    */
    __publicField(this, "editables");
    __publicField(this, "editable");
    /**
    * Menu bar view instance.
    */
    __publicField(this, "menuBarView");
    /**
    * The editing view instance this view is related to.
    */
    __publicField(this, "_editingView");
    this._editingView = editingView;
    this.toolbar = new ToolbarView(locale, {
      shouldGroupWhenFull: options2.shouldToolbarGroupWhenFull
    });
    this.menuBarView = new MenuBarView(locale);
    this.editables = {};
    for (const editableName of editableNames) {
      const editableElement = options2.editableElements ? options2.editableElements[editableName] : void 0;
      let { label } = options2;
      if (typeof label === "object") {
        label = label[editableName];
      }
      this.createEditable(editableName, editableElement, label);
    }
    this.editable = Object.values(this.editables)[0];
    this.toolbar.extendTemplate({
      attributes: {
        class: [
          "ck-reset_all",
          "ck-rounded-corners"
        ],
        dir: locale.uiLanguageDirection
      }
    });
    this.menuBarView.extendTemplate({
      attributes: {
        class: [
          "ck-reset_all",
          "ck-rounded-corners"
        ],
        dir: locale.uiLanguageDirection
      }
    });
  }
  /**
  * Creates an editable instance with given name and registers it in the editor UI view.
  *
  * If `editableElement` is provided, the editable instance will be created on top of it. Otherwise, the editor will create a new
  * DOM element and use it instead.
  *
  * @param editableName The name for the editable.
  * @param editableElement DOM element for which the editable should be created.
  * @param label The accessible editable label used by assistive technologies.
  * @returns The created editable instance.
  */
  createEditable(editableName, editableElement, label) {
    const editable = new InlineEditableUIView(this.locale, this._editingView, editableElement, {
      label
    });
    this.editables[editableName] = editable;
    editable.name = editableName;
    if (this.isRendered) {
      this.registerChild(editable);
    }
    return editable;
  }
  /**
  * Destroys and removes the editable from the editor UI view.
  *
  * @param editableName The name of the editable that should be removed.
  */
  removeEditable(editableName) {
    const editable = this.editables[editableName];
    if (this.isRendered) {
      this.deregisterChild(editable);
    }
    delete this.editables[editableName];
    editable.destroy();
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.registerChild(Object.values(this.editables));
    this.registerChild(this.toolbar);
    this.registerChild(this.menuBarView);
  }
};
var MultiRootEditor = class extends Editor {
  /**
  * Creates an instance of the multi-root editor.
  *
  * **Note:** Do not use the constructor to create editor instances. Use the static
  * {@link module:editor-multi-root/multirooteditor~MultiRootEditor.create `MultiRootEditor.create()`} method instead.
  *
  * @param sourceElementsOrData The DOM elements that will be the source for the created editor
  * or the editor's initial data. The editor will initialize multiple roots with names according to the keys in the passed object.
  * For more information see {@link module:editor-multi-root/multirooteditor~MultiRootEditor.create `MultiRootEditor.create()`}.
  * @param config The editor configuration.
  */
  constructor(sourceElementsOrData, config = {}) {
    const rootNames = Object.keys(sourceElementsOrData);
    const sourceIsData = rootNames.length === 0 || typeof sourceElementsOrData[rootNames[0]] === "string";
    if (sourceIsData && config.initialData !== void 0 && Object.keys(config.initialData).length > 0) {
      throw new CKEditorError("editor-create-initial-data", null);
    }
    super(config);
    /**
    * @inheritDoc
    */
    __publicField(this, "ui");
    /**
    * The elements on which the editor has been initialized.
    */
    __publicField(this, "sourceElements");
    /**
    * Holds attributes keys that were passed in {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes `rootsAttributes`}
    * config property and should be returned by {@link #getRootsAttributes}.
    */
    __publicField(this, "_registeredRootsAttributesKeys", /* @__PURE__ */ new Set());
    /**
    * A set of lock IDs for enabling or disabling particular root.
    */
    __publicField(this, "_readOnlyRootLocks", /* @__PURE__ */ new Map());
    if (!sourceIsData) {
      this.sourceElements = sourceElementsOrData;
    } else {
      this.sourceElements = {};
    }
    if (this.config.get("initialData") === void 0) {
      const initialData = {};
      for (const rootName of rootNames) {
        initialData[rootName] = getInitialData5(sourceElementsOrData[rootName]);
      }
      this.config.set("initialData", initialData);
    }
    if (!sourceIsData) {
      for (const rootName of rootNames) {
        secureSourceElement(this, sourceElementsOrData[rootName]);
      }
    }
    this.editing.view.document.roots.on("add", (evt, viewRoot) => {
      viewRoot.unbind("isReadOnly");
      viewRoot.bind("isReadOnly").to(this.editing.view.document, "isReadOnly", (isReadOnly) => {
        return isReadOnly || this._readOnlyRootLocks.has(viewRoot.rootName);
      });
      viewRoot.on("change:isReadOnly", (evt2, prop, value) => {
        const viewRange = this.editing.view.createRangeIn(viewRoot);
        for (const viewItem of viewRange.getItems()) {
          if (viewItem.is("editableElement")) {
            viewItem.unbind("isReadOnly");
            viewItem.isReadOnly = value;
          }
        }
      });
    });
    for (const rootName of rootNames) {
      this.model.document.createRoot("$root", rootName);
    }
    if (this.config.get("lazyRoots")) {
      for (const rootName of this.config.get("lazyRoots")) {
        const root2 = this.model.document.createRoot("$root", rootName);
        root2._isLoaded = false;
      }
    }
    if (this.config.get("rootsAttributes")) {
      const rootsAttributes = this.config.get("rootsAttributes");
      for (const [rootName, attributes] of Object.entries(rootsAttributes)) {
        if (!this.model.document.getRoot(rootName)) {
          throw new CKEditorError("multi-root-editor-root-attributes-no-root", null);
        }
        for (const key of Object.keys(attributes)) {
          this.registerRootAttribute(key);
        }
      }
      this.data.on("init", () => {
        this.model.enqueueChange({
          isUndoable: false
        }, (writer) => {
          for (const [name, attributes] of Object.entries(rootsAttributes)) {
            const root2 = this.model.document.getRoot(name);
            for (const [key, value] of Object.entries(attributes)) {
              if (value !== null) {
                writer.setAttribute(key, value, root2);
              }
            }
          }
        });
      });
    }
    const options2 = {
      shouldToolbarGroupWhenFull: !this.config.get("toolbar.shouldNotGroupWhenFull"),
      editableElements: sourceIsData ? void 0 : sourceElementsOrData,
      label: this.config.get("label")
    };
    const view = new MultiRootEditorUIView(this.locale, this.editing.view, rootNames, options2);
    this.ui = new MultiRootEditorUI(this, view);
    this.model.document.on("change:data", () => {
      const changedRoots = this.model.document.differ.getChangedRoots();
      for (const changes of changedRoots) {
        const root2 = this.model.document.getRoot(changes.name);
        if (changes.state == "detached") {
          this.fire("detachRoot", root2);
        }
      }
      for (const changes of changedRoots) {
        const root2 = this.model.document.getRoot(changes.name);
        if (changes.state == "attached") {
          this.fire("addRoot", root2);
        }
      }
    });
    this.listenTo(this.model, "canEditAt", (evt, [selection]) => {
      if (!selection) {
        return;
      }
      let selectionInReadOnlyRoot = false;
      for (const range of selection.getRanges()) {
        const root2 = range.root;
        if (this._readOnlyRootLocks.has(root2.rootName)) {
          selectionInReadOnlyRoot = true;
          break;
        }
      }
      if (selectionInReadOnlyRoot) {
        evt.return = false;
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.decorate("loadRoot");
    this.on("loadRoot", (evt, [rootName]) => {
      const root2 = this.model.document.getRoot(rootName);
      if (!root2) {
        throw new CKEditorError("multi-root-editor-load-root-no-root", this, {
          rootName
        });
      }
      if (root2._isLoaded) {
        logWarning("multi-root-editor-load-root-already-loaded");
        evt.stop();
      }
    }, {
      priority: "highest"
    });
  }
  /**
  * Destroys the editor instance, releasing all resources used by it.
  *
  * Updates the original editor element with the data if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
  * configuration option is set to `true`.
  *
  * **Note**: The multi-root editor does not remove the toolbar and editable when destroyed. You can
  * do that yourself in the destruction chain, if you need to:
  *
  * ```ts
  * editor.destroy().then( () => {
  * 	// Remove the toolbar from DOM.
  * 	editor.ui.view.toolbar.element.remove();
  *
  * 	// Remove editable elements from DOM.
  * 	for ( const editable of Object.values( editor.ui.view.editables ) ) {
  * 	    editable.element.remove();
  * 	}
  *
  * 	console.log( 'Editor was destroyed' );
  * } );
  * ```
  */
  destroy() {
    const shouldUpdateSourceElement = this.config.get("updateSourceElementOnDestroy");
    const data = {};
    for (const rootName of Object.keys(this.sourceElements)) {
      data[rootName] = shouldUpdateSourceElement ? this.getData({
        rootName
      }) : "";
    }
    this.ui.destroy();
    return super.destroy().then(() => {
      for (const rootName of Object.keys(this.sourceElements)) {
        setDataInElement(this.sourceElements[rootName], data[rootName]);
      }
    });
  }
  /**
  * Adds a new root to the editor.
  *
  * ```ts
  * editor.addRoot( 'myRoot', { data: '<p>Initial root data.</p>' } );
  * ```
  *
  * After a root is added, you will be able to modify and retrieve its data.
  *
  * All root names must be unique. An error will be thrown if you will try to create a root with the name same as
  * an already existing, attached root. However, you can call this method for a detached root. See also {@link #detachRoot}.
  *
  * Whenever a root is added, the editor instance will fire {@link #event:addRoot `addRoot` event}. The event is also called when
  * the root is added indirectly, e.g. by the undo feature or on a remote client during real-time collaboration.
  *
  * Note, that this method only adds a root to the editor model. It **does not** create a DOM editable element for the new root.
  * Until such element is created (and attached to the root), the root is "virtual": it is not displayed anywhere and its data can
  * be changed only using the editor API.
  *
  * To create a DOM editable element for the root, listen to {@link #event:addRoot `addRoot` event} and call {@link #createEditable}.
  * Then, insert the DOM element in a desired place, that will depend on the integration with your application and your requirements.
  *
  * ```ts
  * editor.on( 'addRoot', ( evt, root ) => {
  * 	const editableElement = editor.createEditable( root );
  *
  * 	// You may want to create a more complex DOM structure here.
  * 	//
  * 	// Alternatively, you may want to create a DOM structure before
  * 	// calling `editor.addRoot()` and only append `editableElement` at
  * 	// a proper place.
  *
  * 	document.querySelector( '#editors' ).appendChild( editableElement );
  * } );
  *
  * // ...
  *
  * editor.addRoot( 'myRoot' ); // Will create a root, a DOM editable element and append it to `#editors` container element.
  * ```
  *
  * You can set root attributes on the new root while you add it:
  *
  * ```ts
  * // Add a collapsed root at fourth position from top.
  * // Keep in mind that these are just examples of attributes. You need to provide your own features that will handle the attributes.
  * editor.addRoot( 'myRoot', { attributes: { isCollapsed: true, index: 4 } } );
  * ```
  *
  * Note that attributes added together with a root are automatically registered.
  *
  * See also {@link ~MultiRootEditor#registerRootAttribute `MultiRootEditor#registerRootAttribute()`} and
  * {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes `config.rootsAttributes` configuration option}.
  *
  * By setting `isUndoable` flag to `true`, you can allow for detaching the root using the undo feature.
  *
  * Additionally, you can group adding multiple roots in one undo step. This can be useful if you add multiple roots that are
  * combined into one, bigger UI element, and want them all to be undone together.
  *
  * ```ts
  * let rowId = 0;
  *
  * editor.model.change( () => {
  * 	editor.addRoot( 'left-row-' + rowId, { isUndoable: true } );
  * 	editor.addRoot( 'center-row-' + rowId, { isUndoable: true } );
  * 	editor.addRoot( 'right-row-' + rowId, { isUndoable: true } );
  *
  * 	rowId++;
  * } );
  * ```
  *
  * @param rootName Name of the root to add.
  * @param options Additional options for the added root.
  */
  addRoot(rootName, { data = "", attributes = {}, elementName = "$root", isUndoable = false } = {}) {
    const _addRoot = (writer) => {
      const root2 = writer.addRoot(rootName, elementName);
      if (data) {
        writer.insert(this.data.parse(data, root2), root2, 0);
      }
      for (const key of Object.keys(attributes)) {
        this.registerRootAttribute(key);
        writer.setAttribute(key, attributes[key], root2);
      }
    };
    if (isUndoable) {
      this.model.change(_addRoot);
    } else {
      this.model.enqueueChange({
        isUndoable: false
      }, _addRoot);
    }
  }
  /**
  * Detaches a root from the editor.
  *
  * ```ts
  * editor.detachRoot( 'myRoot' );
  * ```
  *
  * A detached root is not entirely removed from the editor model, however it can be considered removed.
  *
  * After a root is detached all its children are removed, all markers inside it are removed, and whenever something is inserted to it,
  * it is automatically removed as well. Finally, a detached root is not returned by
  * {@link module:engine/model/document~Document#getRootNames} by default.
  *
  * It is possible to re-add a previously detached root calling {@link #addRoot}.
  *
  * Whenever a root is detached, the editor instance will fire {@link #event:detachRoot `detachRoot` event}. The event is also
  * called when the root is detached indirectly, e.g. by the undo feature or on a remote client during real-time collaboration.
  *
  * Note, that this method only detached a root in the editor model. It **does not** destroy the DOM editable element linked with
  * the root and it **does not** remove the DOM element from the DOM structure of your application.
  *
  * To properly remove a DOM editable element after a root was detached, listen to {@link #event:detachRoot `detachRoot` event}
  * and call {@link #detachEditable}. Then, remove the DOM element from your application.
  *
  * ```ts
  * editor.on( 'detachRoot', ( evt, root ) => {
  * 	const editableElement = editor.detachEditable( root );
  *
  * 	// You may want to do an additional DOM clean-up here.
  *
  * 	editableElement.remove();
  * } );
  *
  * // ...
  *
  * editor.detachRoot( 'myRoot' ); // Will detach the root, and remove the DOM editable element.
  * ```
  *
  * By setting `isUndoable` flag to `true`, you can allow for re-adding the root using the undo feature.
  *
  * Additionally, you can group detaching multiple roots in one undo step. This can be useful if the roots are combined into one,
  * bigger UI element, and you want them all to be re-added together.
  *
  * ```ts
  * editor.model.change( () => {
  * 	editor.detachRoot( 'left-row-3', true );
  * 	editor.detachRoot( 'center-row-3', true );
  * 	editor.detachRoot( 'right-row-3', true );
  * } );
  * ```
  *
  * @param rootName Name of the root to detach.
  * @param isUndoable Whether detaching the root can be undone (using the undo feature) or not.
  */
  detachRoot(rootName, isUndoable = false) {
    if (isUndoable) {
      this.model.change((writer) => writer.detachRoot(rootName));
    } else {
      this.model.enqueueChange({
        isUndoable: false
      }, (writer) => writer.detachRoot(rootName));
    }
  }
  /**
  * Creates and returns a new DOM editable element for the given root element.
  *
  * The new DOM editable is attached to the model root and can be used to modify the root content.
  *
  * @param root Root for which the editable element should be created.
  * @param placeholder Placeholder for the editable element. If not set, placeholder value from the
  * {@link module:core/editor/editorconfig~EditorConfig#placeholder editor configuration} will be used (if it was provided).
  * @param label The accessible label text describing the editable to the assistive technologies.
  * @returns The created DOM element. Append it in a desired place in your application.
  */
  createEditable(root2, placeholder, label) {
    const editable = this.ui.view.createEditable(root2.rootName, void 0, label);
    this.ui.addEditable(editable, placeholder);
    this.editing.view.forceRender();
    return editable.element;
  }
  /**
  * Detaches the DOM editable element that was attached to the given root.
  *
  * @param root Root for which the editable element should be detached.
  * @returns The DOM element that was detached. You may want to remove it from your application DOM structure.
  */
  detachEditable(root2) {
    const rootName = root2.rootName;
    const editable = this.ui.view.editables[rootName];
    this.ui.removeEditable(editable);
    this.ui.view.removeEditable(rootName);
    return editable.element;
  }
  /**
  * Loads a root that has previously been declared in {@link module:core/editor/editorconfig~EditorConfig#lazyRoots `lazyRoots`}
  * configuration option.
  *
  * Only roots specified in the editor config can be loaded. A root cannot be loaded multiple times. A root cannot be unloaded and
  * loading a root cannot be reverted using the undo feature.
  *
  * When a root becomes loaded, it will be treated by the editor as though it was just added. This, among others, means that all
  * related events and mechanisms will be fired, including {@link ~MultiRootEditor#event:addRoot `addRoot` event},
  * {@link module:engine/model/document~Document#event:change `model.Document` `change` event}, model post-fixers and conversion.
  *
  * Until the root becomes loaded, all above mechanisms are suppressed.
  *
  * This method is {@link module:utils/observablemixin~Observable#decorate decorated}.
  *
  * Note that attributes loaded together with a root are automatically registered.
  *
  * See also {@link ~MultiRootEditor#registerRootAttribute `MultiRootEditor#registerRootAttribute()`} and
  * {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes `config.rootsAttributes` configuration option}.
  *
  * When this method is used in real-time collaboration environment, its effects become asynchronous as the editor will first synchronize
  * with the remote editing session, before the root is added to the editor.
  *
  * If the root has been already loaded by any other client, the additional data passed in `loadRoot()` parameters will be ignored.
  *
  * @param rootName Name of the root to load.
  * @param options Additional options for the loaded root.
  * @fires loadRoot
  */
  loadRoot(rootName, { data = "", attributes = {} } = {}) {
    const root2 = this.model.document.getRoot(rootName);
    this.model.enqueueChange({
      isUndoable: false
    }, (writer) => {
      if (data) {
        writer.insert(this.data.parse(data, root2), root2, 0);
      }
      for (const key of Object.keys(attributes)) {
        this.registerRootAttribute(key);
        writer.setAttribute(key, attributes[key], root2);
      }
      root2._isLoaded = true;
      this.model.document.differ._bufferRootLoad(root2);
    });
  }
  /**
  * Returns the document data for all attached roots.
  *
  * @param options Additional configuration for the retrieved data.
  * Editor features may introduce more configuration options that can be set through this parameter.
  * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
  * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
  * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
  * @returns The full document data.
  */
  getFullData(options2) {
    const data = {};
    for (const rootName of this.model.document.getRootNames()) {
      data[rootName] = this.data.get({
        ...options2,
        rootName
      });
    }
    return data;
  }
  /**
  * Returns attributes for all attached roots.
  *
  * Note: all and only {@link ~MultiRootEditor#registerRootAttribute registered} roots attributes will be returned.
  * If a registered root attribute is not set for a given root, `null` will be returned.
  *
  * @returns Object with roots attributes. Keys are roots names, while values are attributes set on given root.
  */
  getRootsAttributes() {
    const rootsAttributes = {};
    for (const rootName of this.model.document.getRootNames()) {
      rootsAttributes[rootName] = this.getRootAttributes(rootName);
    }
    return rootsAttributes;
  }
  /**
  * Returns attributes for the specified root.
  *
  * Note: all and only {@link ~MultiRootEditor#registerRootAttribute registered} roots attributes will be returned.
  * If a registered root attribute is not set for a given root, `null` will be returned.
  */
  getRootAttributes(rootName) {
    const rootAttributes = {};
    const root2 = this.model.document.getRoot(rootName);
    for (const key of this._registeredRootsAttributesKeys) {
      rootAttributes[key] = root2.hasAttribute(key) ? root2.getAttribute(key) : null;
    }
    return rootAttributes;
  }
  /**
  * Registers given string as a root attribute key. Registered root attributes are added to
  * {@link module:engine/model/schema~Schema schema}, and also returned by
  * {@link ~MultiRootEditor#getRootAttributes `getRootAttributes()`} and
  * {@link ~MultiRootEditor#getRootsAttributes `getRootsAttributes()`}.
  *
  * Note: attributes passed in {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes `config.rootsAttributes`} are
  * automatically registered as the editor is initialized. However, registering the same attribute twice does not have any negative
  * impact, so it is recommended to use this method in any feature that uses roots attributes.
  */
  registerRootAttribute(key) {
    if (this._registeredRootsAttributesKeys.has(key)) {
      return;
    }
    this._registeredRootsAttributesKeys.add(key);
    this.editing.model.schema.extend("$root", {
      allowAttributes: key
    });
  }
  /**
  * Switches given editor root to the read-only mode.
  *
  * In contrary to {@link module:core/editor/editor~Editor#enableReadOnlyMode `enableReadOnlyMode()`}, which switches the whole editor
  * to the read-only mode, this method turns only a particular root to the read-only mode. This can be useful when you want to prevent
  * editing only a part of the editor content.
  *
  * When you switch a root to the read-only mode, you need provide a unique identifier (`lockId`) that will identify this request. You
  * will need to provide the same `lockId` when you will want to
  * {@link module:editor-multi-root/multirooteditor~MultiRootEditor#enableRoot re-enable} the root.
  *
  * ```ts
  * const model = editor.model;
  * const myRoot = model.document.getRoot( 'myRoot' );
  *
  * editor.disableRoot( 'myRoot', 'my-lock' );
  * model.canEditAt( myRoot ); // `false`
  *
  * editor.disableRoot( 'myRoot', 'other-lock' );
  * editor.disableRoot( 'myRoot', 'other-lock' ); // Multiple locks with the same ID have no effect.
  * model.canEditAt( myRoot ); // `false`
  *
  * editor.enableRoot( 'myRoot', 'my-lock' );
  * model.canEditAt( myRoot ); // `false`
  *
  * editor.enableRoot( 'myRoot', 'other-lock' );
  * model.canEditAt( myRoot ); // `true`
  * ```
  *
  * See also {@link module:core/editor/editor~Editor#enableReadOnlyMode `Editor#enableReadOnlyMode()`} and
  * {@link module:editor-multi-root/multirooteditor~MultiRootEditor#enableRoot `MultiRootEditor#enableRoot()`}.
  *
  * @param rootName Name of the root to switch to read-only mode.
  * @param lockId A unique ID for setting the editor to the read-only state.
  */
  disableRoot(rootName, lockId) {
    if (rootName == "$graveyard") {
      throw new CKEditorError("multi-root-editor-cannot-disable-graveyard-root", this);
    }
    const locksForGivenRoot = this._readOnlyRootLocks.get(rootName);
    if (locksForGivenRoot) {
      locksForGivenRoot.add(lockId);
    } else {
      this._readOnlyRootLocks.set(rootName, /* @__PURE__ */ new Set([
        lockId
      ]));
      const editableRootElement = this.editing.view.document.getRoot(rootName);
      editableRootElement.isReadOnly = true;
      Array.from(this.commands.commands()).forEach((command) => command.affectsData && command.refresh());
    }
  }
  /**
  * Removes given read-only lock from the given root.
  *
  * See {@link module:editor-multi-root/multirooteditor~MultiRootEditor#disableRoot `disableRoot()`}.
  *
  * @param rootName Name of the root to switch back from the read-only mode.
  * @param lockId A unique ID for setting the editor to the read-only state.
  */
  enableRoot(rootName, lockId) {
    const locksForGivenRoot = this._readOnlyRootLocks.get(rootName);
    if (!locksForGivenRoot || !locksForGivenRoot.has(lockId)) {
      return;
    }
    if (locksForGivenRoot.size === 1) {
      this._readOnlyRootLocks.delete(rootName);
      const editableRootElement = this.editing.view.document.getRoot(rootName);
      editableRootElement.isReadOnly = this.isReadOnly;
      Array.from(this.commands.commands()).forEach((command) => command.affectsData && command.refresh());
    } else {
      locksForGivenRoot.delete(lockId);
    }
  }
  /**
  * Creates a new multi-root editor instance.
  *
  * **Note:** remember that `MultiRootEditor` does not append the toolbar element to your web page, so you have to do it manually
  * after the editor has been initialized.
  *
  * There are a few different ways to initialize the multi-root editor.
  *
  * # Using existing DOM elements:
  *
  * ```ts
  * MultiRootEditor.create( {
  * 	intro: document.querySelector( '#editor-intro' ),
  * 	content: document.querySelector( '#editor-content' ),
  * 	sidePanelLeft: document.querySelector( '#editor-side-left' ),
  * 	sidePanelRight: document.querySelector( '#editor-side-right' ),
  * 	outro: document.querySelector( '#editor-outro' )
  * } )
  * .then( editor => {
  * 	console.log( 'Editor was initialized', editor );
  *
  * 	// Append the toolbar inside a provided DOM element.
  * 	document.querySelector( '#toolbar-container' ).appendChild( editor.ui.view.toolbar.element );
  * } )
  * .catch( err => {
  * 	console.error( err.stack );
  * } );
  * ```
  *
  * The elements' content will be used as the editor data and elements will become editable elements.
  *
  * # Creating a detached editor
  *
  * Alternatively, you can initialize the editor by passing the initial data directly as strings.
  * In this case, you will have to manually append both the toolbar element and the editable elements to your web page.
  *
  * ```ts
  * MultiRootEditor.create( {
  * 	intro: '<p><strong>Exciting</strong> intro text to an article.</p>',
  * 	content: '<p>Lorem ipsum dolor sit amet.</p>',
  * 	sidePanelLeft: '<blockquote>Strong quotation from article.</blockquote>',
  * 	sidePanelRight: '<p>List of similar articles...</p>',
  * 	outro: '<p>Closing text.</p>'
  * } )
  * .then( editor => {
  * 	console.log( 'Editor was initialized', editor );
  *
  * 	// Append the toolbar inside a provided DOM element.
  * 	document.querySelector( '#toolbar-container' ).appendChild( editor.ui.view.toolbar.element );
  *
  * 	// Append DOM editable elements created by the editor.
  * 	const editables = editor.ui.view.editables;
  * 	const container = document.querySelector( '#editable-container' );
  *
  * 	container.appendChild( editables.intro.element );
  * 	container.appendChild( editables.content.element );
  * 	container.appendChild( editables.outro.element );
  * } )
  * .catch( err => {
  * 	console.error( err.stack );
  * } );
  * ```
  *
  * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
  * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
  *
  * # Using an existing DOM element (and data provided in `config.initialData`)
  *
  * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
  *
  * ```ts
  * MultiRootEditor.create( {
  * 	intro: document.querySelector( '#editor-intro' ),
  * 	content: document.querySelector( '#editor-content' ),
  * 	sidePanelLeft: document.querySelector( '#editor-side-left' ),
  * 	sidePanelRight: document.querySelector( '#editor-side-right' ),
  * 	outro: document.querySelector( '#editor-outro' )
  * }, {
  * 	initialData: {
  * 		intro: '<p><strong>Exciting</strong> intro text to an article.</p>',
  * 		content: '<p>Lorem ipsum dolor sit amet.</p>',
  * 		sidePanelLeft '<blockquote>Strong quotation from article.</blockquote>':
  * 		sidePanelRight '<p>List of similar articles...</p>':
  * 		outro: '<p>Closing text.</p>'
  * 	}
  * } )
  * .then( editor => {
  * 	console.log( 'Editor was initialized', editor );
  *
  * 	// Append the toolbar inside a provided DOM element.
  * 	document.querySelector( '#toolbar-container' ).appendChild( editor.ui.view.toolbar.element );
  * } )
  * .catch( err => {
  * 	console.error( err.stack );
  * } );
  * ```
  *
  * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
  * makes it difficult to set the content of the source element.
  *
  * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
  *
  * # Configuring the editor
  *
  * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
  * customizing plugins, toolbar and more.
  *
  * @param sourceElementsOrData The DOM elements that will be the source for the created editor
  * or the editor's initial data. The editor will initialize multiple roots with names according to the keys in the passed object.
  *
  * If DOM elements are passed, their content will be automatically loaded to the editor upon initialization and the elements will be
  * used as the editor's editable areas. The editor data will be set back to the original element once the editor is destroyed if the
  * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy} option
  * is set to `true`.
  *
  * If the initial data is passed, a detached editor will be created. For each entry in the passed object, one editor root and one
  * editable DOM element will be created. You will need to attach the editable elements into the DOM manually. The elements are available
  * through the {@link module:editor-multi-root/multirooteditorui~MultiRootEditorUI#getEditableElement `editor.ui.getEditableElement()`}
  * method.
  * @param config The editor configuration.
  * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
  */
  static create(sourceElementsOrData, config = {}) {
    return new Promise((resolve) => {
      for (const sourceItem of Object.values(sourceElementsOrData)) {
        if (isElement5(sourceItem) && sourceItem.tagName === "TEXTAREA") {
          throw new CKEditorError("editor-wrong-element", null);
        }
      }
      const editor = new this(sourceElementsOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => {
        editor._verifyRootsWithInitialData();
        return editor.data.init(editor.config.get("initialData"));
      }).then(() => editor.fire("ready")).then(() => editor));
    });
  }
  /**
  * @internal
  */
  _verifyRootsWithInitialData() {
    const initialData = this.config.get("initialData");
    for (const rootName of this.model.document.getRootNames()) {
      if (!(rootName in initialData)) {
        throw new CKEditorError("multi-root-editor-root-initial-data-mismatch", null);
      }
    }
    for (const rootName of Object.keys(initialData)) {
      const root2 = this.model.document.getRoot(rootName);
      if (!root2 || !root2.isAttached()) {
        throw new CKEditorError("multi-root-editor-root-initial-data-mismatch", null);
      }
    }
  }
};
function getInitialData5(sourceElementOrData) {
  return isElement5(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement5(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-essentials/dist/index.js
var Essentials = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      AccessibilityHelp,
      Clipboard,
      Enter,
      SelectAll,
      ShiftEnter,
      Typing,
      Undo
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Essentials";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-find-and-replace/dist/index.js
var FindAndReplaceFormView = class extends View2 {
  /**
  * Creates a view of find and replace form.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * A collection of child views.
    */
    __publicField(this, "children");
    /**
    * The find in text input view that stores the searched string.
    *
    * @internal
    */
    __publicField(this, "_findInputView");
    /**
    * The replace input view.
    */
    __publicField(this, "_replaceInputView");
    /**
    * The find button view that initializes the search process.
    */
    __publicField(this, "_findButtonView");
    /**
    * The find previous button view.
    */
    __publicField(this, "_findPrevButtonView");
    /**
    * The find next button view.
    */
    __publicField(this, "_findNextButtonView");
    /**
    * A collapsible view aggregating the advanced search options.
    */
    __publicField(this, "_advancedOptionsCollapsibleView");
    /**
    * A switch button view controlling the "Match case" option.
    */
    __publicField(this, "_matchCaseSwitchView");
    /**
    * A switch button view controlling the "Whole words only" option.
    */
    __publicField(this, "_wholeWordsOnlySwitchView");
    /**
    * The replace button view.
    */
    __publicField(this, "_replaceButtonView");
    /**
    * The replace all button view.
    */
    __publicField(this, "_replaceAllButtonView");
    /**
    * The `div` aggregating the inputs.
    */
    __publicField(this, "_inputsDivView");
    /**
    * The `div` aggregating the action buttons.
    */
    __publicField(this, "_actionButtonsDivView");
    /**
    * Tracks information about the DOM focus in the form.
    */
    __publicField(this, "_focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "_keystrokes");
    /**
    * A collection of views that can be focused in the form.
    */
    __publicField(this, "_focusables");
    /**
    * Helps cycling over {@link #_focusables} in the form.
    */
    __publicField(this, "focusCycler");
    const t = locale.t;
    this.children = this.createCollection();
    this.set("matchCount", 0);
    this.set("highlightOffset", 0);
    this.set("isDirty", false);
    this.set("_areCommandsEnabled", {});
    this.set("_resultsCounterText", "");
    this.set("_matchCase", false);
    this.set("_wholeWordsOnly", false);
    this.bind("_searchResultsFound").to(this, "matchCount", this, "isDirty", (matchCount, isDirty) => {
      return matchCount > 0 && !isDirty;
    });
    this._findInputView = this._createInputField(t("Find in text"));
    this._findPrevButtonView = this._createButton({
      label: t("Previous result"),
      class: "ck-button-prev",
      icon: icons.previousArrow,
      keystroke: "Shift+F3",
      tooltip: true
    });
    this._findNextButtonView = this._createButton({
      label: t("Next result"),
      class: "ck-button-next",
      icon: icons.previousArrow,
      keystroke: "F3",
      tooltip: true
    });
    this._replaceInputView = this._createInputField(t("Replace with"), "ck-labeled-field-replace");
    this._inputsDivView = this._createInputsDiv();
    this._matchCaseSwitchView = this._createMatchCaseSwitch();
    this._wholeWordsOnlySwitchView = this._createWholeWordsOnlySwitch();
    this._advancedOptionsCollapsibleView = this._createAdvancedOptionsCollapsible();
    this._replaceAllButtonView = this._createButton({
      label: t("Replace all"),
      class: "ck-button-replaceall",
      withText: true
    });
    this._replaceButtonView = this._createButton({
      label: t("Replace"),
      class: "ck-button-replace",
      withText: true
    });
    this._findButtonView = this._createButton({
      label: t("Find"),
      class: "ck-button-find ck-button-action",
      withText: true
    });
    this._actionButtonsDivView = this._createActionButtonsDiv();
    this._focusTracker = new FocusTracker();
    this._keystrokes = new KeystrokeHandler();
    this._focusables = new ViewCollection();
    this.focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this._focusTracker,
      keystrokeHandler: this._keystrokes,
      actions: {
        // Navigate form fields backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    });
    this.children.addMany([
      this._inputsDivView,
      this._advancedOptionsCollapsibleView,
      this._actionButtonsDivView
    ]);
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-find-and-replace-form"
        ],
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    this._initFocusCycling();
    this._initKeystrokeHandling();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._focusTracker.destroy();
    this._keystrokes.destroy();
  }
  /**
  * @inheritDoc
  */
  focus(direction) {
    if (direction === -1) {
      this.focusCycler.focusLast();
    } else {
      this.focusCycler.focusFirst();
    }
  }
  /**
  * Resets the form before re-appearing.
  *
  * It clears error messages, hides the match counter and disables the replace feature
  * until the next hit of the "Find" button.
  *
  * **Note**: It does not reset inputs and options, though. This way the form works better in editors with
  * disappearing toolbar (e.g. BalloonEditor): hiding the toolbar by accident (together with the find and replace UI)
  * does not require filling the entire form again.
  */
  reset() {
    this._findInputView.errorText = null;
    this.isDirty = true;
  }
  /**
  * Returns the value of the find input.
  */
  get _textToFind() {
    return this._findInputView.fieldView.element.value;
  }
  /**
  * Returns the value of the replace input.
  */
  get _textToReplace() {
    return this._replaceInputView.fieldView.element.value;
  }
  /**
  * Configures and returns the `<div>` aggregating all form inputs.
  */
  _createInputsDiv() {
    const locale = this.locale;
    const t = locale.t;
    const inputsDivView = new View2(locale);
    this._findInputView.fieldView.on("input", () => {
      this.isDirty = true;
    });
    this._findPrevButtonView.delegate("execute").to(this, "findPrevious");
    this._findNextButtonView.delegate("execute").to(this, "findNext");
    this._findPrevButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", ({ findPrevious }) => findPrevious);
    this._findNextButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", ({ findNext }) => findNext);
    this._injectFindResultsCounter();
    this._replaceInputView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({ replace }, resultsFound) => replace && resultsFound);
    this._replaceInputView.bind("infoText").to(this._replaceInputView, "isEnabled", this._replaceInputView, "isFocused", (isEnabled, isFocused) => {
      if (isEnabled || !isFocused) {
        return "";
      }
      return t("Tip: Find some text first in order to replace it.");
    });
    inputsDivView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-find-and-replace-form__inputs"
        ]
      },
      children: [
        this._findInputView,
        this._findPrevButtonView,
        this._findNextButtonView,
        this._replaceInputView
      ]
    });
    return inputsDivView;
  }
  /**
  * The action performed when the {@link #_findButtonView} is pressed.
  */
  _onFindButtonExecute() {
    if (!this._textToFind) {
      const t = this.t;
      this._findInputView.errorText = t("Text to find must not be empty.");
      return;
    }
    this.isDirty = false;
    this.fire("findNext", {
      searchText: this._textToFind,
      matchCase: this._matchCase,
      wholeWords: this._wholeWordsOnly
    });
  }
  /**
  * Configures an injects the find results counter displaying a "N of M" label of the {@link #_findInputView}.
  */
  _injectFindResultsCounter() {
    const locale = this.locale;
    const t = locale.t;
    const bind = this.bindTemplate;
    const resultsCounterView = new View2(this.locale);
    this.bind("_resultsCounterText").to(this, "highlightOffset", this, "matchCount", (highlightOffset, matchCount) => t("%0 of %1", [
      highlightOffset,
      matchCount
    ]));
    resultsCounterView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-results-counter",
          // The counter only makes sense when the field text corresponds to search results in the editing.
          bind.if("isDirty", "ck-hidden")
        ]
      },
      children: [
        {
          text: bind.to("_resultsCounterText")
        }
      ]
    });
    const updateFindInputPadding = () => {
      const inputElement = this._findInputView.fieldView.element;
      if (!inputElement || !isVisible(inputElement)) {
        return;
      }
      const counterWidth = new Rect(resultsCounterView.element).width;
      const paddingPropertyName = locale.uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
      if (!counterWidth) {
        inputElement.style[paddingPropertyName] = "";
      } else {
        inputElement.style[paddingPropertyName] = `calc( 2 * var(--ck-spacing-standard) + ${counterWidth}px )`;
      }
    };
    this.on("change:_resultsCounterText", updateFindInputPadding, {
      priority: "low"
    });
    this.on("change:isDirty", updateFindInputPadding, {
      priority: "low"
    });
    this._findInputView.template.children[0].children.push(resultsCounterView);
  }
  /**
  * Creates the collapsible view aggregating the advanced search options.
  */
  _createAdvancedOptionsCollapsible() {
    const t = this.locale.t;
    const collapsible = new CollapsibleView(this.locale, [
      this._matchCaseSwitchView,
      this._wholeWordsOnlySwitchView
    ]);
    collapsible.set({
      label: t("Advanced options"),
      isCollapsed: true
    });
    return collapsible;
  }
  /**
  * Configures and returns the `<div>` element aggregating all form action buttons.
  */
  _createActionButtonsDiv() {
    const actionsDivView = new View2(this.locale);
    this._replaceButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({ replace }, resultsFound) => replace && resultsFound);
    this._replaceAllButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({ replaceAll }, resultsFound) => replaceAll && resultsFound);
    this._replaceButtonView.on("execute", () => {
      this.fire("replace", {
        searchText: this._textToFind,
        replaceText: this._textToReplace
      });
    });
    this._replaceAllButtonView.on("execute", () => {
      this.fire("replaceAll", {
        searchText: this._textToFind,
        replaceText: this._textToReplace
      });
      this.focus();
    });
    this._findButtonView.on("execute", this._onFindButtonExecute.bind(this));
    actionsDivView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-find-and-replace-form__actions"
        ]
      },
      children: [
        this._replaceAllButtonView,
        this._replaceButtonView,
        this._findButtonView
      ]
    });
    return actionsDivView;
  }
  /**
  * Creates, configures and returns and instance of a dropdown allowing users to narrow
  * the search criteria down. The dropdown has a list with switch buttons for each option.
  */
  _createMatchCaseSwitch() {
    const t = this.locale.t;
    const matchCaseSwitchButton = new SwitchButtonView(this.locale);
    matchCaseSwitchButton.set({
      label: t("Match case"),
      withText: true
    });
    matchCaseSwitchButton.bind("isOn").to(this, "_matchCase");
    matchCaseSwitchButton.on("execute", () => {
      this._matchCase = !this._matchCase;
      this.isDirty = true;
    });
    return matchCaseSwitchButton;
  }
  /**
  * Creates, configures and returns and instance of a dropdown allowing users to narrow
  * the search criteria down. The dropdown has a list with switch buttons for each option.
  */
  _createWholeWordsOnlySwitch() {
    const t = this.locale.t;
    const wholeWordsOnlySwitchButton = new SwitchButtonView(this.locale);
    wholeWordsOnlySwitchButton.set({
      label: t("Whole words only"),
      withText: true
    });
    wholeWordsOnlySwitchButton.bind("isOn").to(this, "_wholeWordsOnly");
    wholeWordsOnlySwitchButton.on("execute", () => {
      this._wholeWordsOnly = !this._wholeWordsOnly;
      this.isDirty = true;
    });
    return wholeWordsOnlySwitchButton;
  }
  /**
  * Initializes the {@link #_focusables} and {@link #_focusTracker} to allow navigation
  * using <kbd>Tab</kbd> and <kbd>Shift</kbd>+<kbd>Tab</kbd> keystrokes in the right order.
  */
  _initFocusCycling() {
    const childViews = [
      this._findInputView,
      this._findPrevButtonView,
      this._findNextButtonView,
      this._replaceInputView,
      this._advancedOptionsCollapsibleView.buttonView,
      this._matchCaseSwitchView,
      this._wholeWordsOnlySwitchView,
      this._replaceAllButtonView,
      this._replaceButtonView,
      this._findButtonView
    ];
    childViews.forEach((v) => {
      this._focusables.add(v);
      this._focusTracker.add(v.element);
    });
  }
  /**
  * Initializes the keystroke handling in the form.
  */
  _initKeystrokeHandling() {
    const stopPropagation = (data) => data.stopPropagation();
    const stopPropagationAndPreventDefault = (data) => {
      data.stopPropagation();
      data.preventDefault();
    };
    this._keystrokes.listenTo(this.element);
    this._keystrokes.set("f3", (event) => {
      stopPropagationAndPreventDefault(event);
      this._findNextButtonView.fire("execute");
    });
    this._keystrokes.set("shift+f3", (event) => {
      stopPropagationAndPreventDefault(event);
      this._findPrevButtonView.fire("execute");
    });
    this._keystrokes.set("enter", (event) => {
      const target = event.target;
      if (target === this._findInputView.fieldView.element) {
        if (this._areCommandsEnabled.findNext) {
          this._findNextButtonView.fire("execute");
        } else {
          this._findButtonView.fire("execute");
        }
        stopPropagationAndPreventDefault(event);
      } else if (target === this._replaceInputView.fieldView.element && !this.isDirty) {
        this._replaceButtonView.fire("execute");
        stopPropagationAndPreventDefault(event);
      }
    });
    this._keystrokes.set("shift+enter", (event) => {
      const target = event.target;
      if (target !== this._findInputView.fieldView.element) {
        return;
      }
      if (this._areCommandsEnabled.findPrevious) {
        this._findPrevButtonView.fire("execute");
      } else {
        this._findButtonView.fire("execute");
      }
      stopPropagationAndPreventDefault(event);
    });
    this._keystrokes.set("arrowright", stopPropagation);
    this._keystrokes.set("arrowleft", stopPropagation);
    this._keystrokes.set("arrowup", stopPropagation);
    this._keystrokes.set("arrowdown", stopPropagation);
  }
  /**
  * Creates a button view.
  *
  * @param options The properties of the `ButtonView`.
  * @returns The button view instance.
  */
  _createButton(options2) {
    const button = new ButtonView(this.locale);
    button.set(options2);
    return button;
  }
  /**
  * Creates a labeled input view.
  *
  * @param label The input label.
  * @returns The labeled input view instance.
  */
  _createInputField(label, className) {
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    labeledInput.label = label;
    labeledInput.class = className;
    return labeledInput;
  }
};
var loupeIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286l-3.857-4.596z"/><path d="M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306zm-3.4-5.715c.562.305.742 1.106.354 1.494-.388.388-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.469 6.469 0 0 1 3.1.784z"/><path d="M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0zm11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0z"/></svg>';
var FindAndReplaceUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * A reference to the find and replace form view.
    */
    __publicField(this, "formView");
    editor.config.define("findAndReplace.uiType", "dialog");
    this.formView = null;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Dialog
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FindAndReplaceUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const isUiUsingDropdown = editor.config.get("findAndReplace.uiType") === "dropdown";
    const findCommand = editor.commands.get("find");
    const t = this.editor.t;
    editor.ui.componentFactory.add("findAndReplace", () => {
      let view;
      if (isUiUsingDropdown) {
        view = this._createDropdown();
        view.bind("isEnabled").to(findCommand);
      } else {
        view = this._createDialogButtonForToolbar();
      }
      editor.keystrokes.set("Ctrl+F", (data, cancelEvent) => {
        if (!findCommand.isEnabled) {
          return;
        }
        if (view instanceof DropdownView) {
          const dropdownButtonView = view.buttonView;
          if (!dropdownButtonView.isOn) {
            dropdownButtonView.fire("execute");
          }
        } else {
          if (view.isOn) {
            editor.plugins.get("Dialog").view.focus();
          } else {
            view.fire("execute");
          }
        }
        cancelEvent();
      });
      return view;
    });
    if (!isUiUsingDropdown) {
      editor.ui.componentFactory.add("menuBar:findAndReplace", () => {
        return this._createDialogButtonForMenuBar();
      });
    }
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Find in the document"),
          keystroke: "CTRL+F"
        }
      ]
    });
  }
  /**
  * Creates a dropdown containing the find and replace form.
  */
  _createDropdown() {
    const editor = this.editor;
    const t = editor.locale.t;
    const dropdownView = createDropdown(editor.locale);
    dropdownView.once("change:isOpen", () => {
      this.formView = this._createFormView();
      this.formView.children.add(new FormHeaderView(editor.locale, {
        label: t("Find and replace")
      }), 0);
      dropdownView.panelView.children.add(this.formView);
    });
    dropdownView.on("change:isOpen", (event, name, isOpen) => {
      if (isOpen) {
        this._setupFormView();
      } else {
        this.fire("searchReseted");
      }
    }, {
      priority: "low"
    });
    dropdownView.buttonView.set({
      icon: loupeIcon,
      label: t("Find and replace"),
      keystroke: "CTRL+F",
      tooltip: true
    });
    return dropdownView;
  }
  /**
  * Creates a button that opens a dialog with the find and replace form.
  */
  _createDialogButtonForToolbar() {
    const editor = this.editor;
    const buttonView = this._createButton(ButtonView);
    const dialog = editor.plugins.get("Dialog");
    buttonView.set({
      tooltip: true
    });
    buttonView.bind("isOn").to(dialog, "id", (id) => id === "findAndReplace");
    buttonView.on("execute", () => {
      if (buttonView.isOn) {
        dialog.hide();
      } else {
        this._showDialog();
      }
    });
    return buttonView;
  }
  /**
  * Creates a button for for menu bar that will show find and replace dialog.
  */
  _createDialogButtonForMenuBar() {
    const buttonView = this._createButton(MenuBarMenuListItemButtonView);
    const dialogPlugin = this.editor.plugins.get("Dialog");
    const dialog = this.editor.plugins.get("Dialog");
    buttonView.set({
      role: "menuitemcheckbox",
      isToggleable: true
    });
    buttonView.bind("isOn").to(dialog, "id", (id) => id === "findAndReplace");
    buttonView.on("execute", () => {
      if (dialogPlugin.id === "findAndReplace") {
        dialogPlugin.hide();
        return;
      }
      this._showDialog();
    });
    return buttonView;
  }
  /**
  * Creates a button for find and replace command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const findCommand = editor.commands.get("find");
    const buttonView = new ButtonClass(editor.locale);
    const t = editor.locale.t;
    buttonView.bind("isEnabled").to(findCommand);
    buttonView.set({
      icon: loupeIcon,
      label: t("Find and replace"),
      keystroke: "CTRL+F"
    });
    return buttonView;
  }
  /**
  * Shows the find and replace dialog.
  */
  _showDialog() {
    const editor = this.editor;
    const dialog = editor.plugins.get("Dialog");
    const t = editor.locale.t;
    if (!this.formView) {
      this.formView = this._createFormView();
    }
    dialog.show({
      id: "findAndReplace",
      title: t("Find and replace"),
      content: this.formView,
      position: DialogViewPosition.EDITOR_TOP_SIDE,
      onShow: () => {
        this._setupFormView();
      },
      onHide: () => {
        this.fire("searchReseted");
      }
    });
  }
  /**
  * Sets up the form view for the find and replace.
  *
  * @param formView A related form view.
  */
  _createFormView() {
    const editor = this.editor;
    const formView = new (CssTransitionDisablerMixin(FindAndReplaceFormView))(editor.locale);
    const commands = editor.commands;
    const findAndReplaceEditing = this.editor.plugins.get("FindAndReplaceEditing");
    const editingState = findAndReplaceEditing.state;
    formView.bind("highlightOffset").to(editingState, "highlightedOffset");
    formView.listenTo(editingState.results, "change", () => {
      formView.matchCount = editingState.results.length;
    });
    const findNextCommand = commands.get("findNext");
    const findPreviousCommand = commands.get("findPrevious");
    const replaceCommand = commands.get("replace");
    const replaceAllCommand = commands.get("replaceAll");
    formView.bind("_areCommandsEnabled").to(findNextCommand, "isEnabled", findPreviousCommand, "isEnabled", replaceCommand, "isEnabled", replaceAllCommand, "isEnabled", (findNext, findPrevious, replace, replaceAll) => ({
      findNext,
      findPrevious,
      replace,
      replaceAll
    }));
    formView.delegate("findNext", "findPrevious", "replace", "replaceAll").to(this);
    formView.on("change:isDirty", (evt, data, isDirty) => {
      if (isDirty) {
        this.fire("searchReseted");
      }
    });
    return formView;
  }
  /**
  * Clears the find and replace form and focuses the search text field.
  */
  _setupFormView() {
    this.formView.disableCssTransitions();
    this.formView.reset();
    this.formView._findInputView.fieldView.select();
    this.formView.enableCssTransitions();
  }
};
var FindCommand = class extends Command {
  /**
  * Creates a new `FindCommand` instance.
  *
  * @param editor The editor on which this command will be used.
  * @param state An object to hold plugin state.
  */
  constructor(editor, state) {
    super(editor);
    /**
    * The find and replace state object used for command operations.
    */
    __publicField(this, "_state");
    this.isEnabled = true;
    this.affectsData = false;
    this._state = state;
  }
  /**
  * Executes the command.
  *
  * @param callbackOrText
  * @param options Options object.
  * @param options.matchCase If set to `true`, the letter case will be matched.
  * @param options.wholeWords If set to `true`, only whole words that match `callbackOrText` will be matched.
  *
  * @fires execute
  */
  execute(callbackOrText, { matchCase, wholeWords } = {}) {
    const { editor } = this;
    const { model } = editor;
    const findAndReplaceUtils = editor.plugins.get("FindAndReplaceUtils");
    let findCallback;
    let callbackSearchText = "";
    if (typeof callbackOrText === "string") {
      findCallback = (...args) => ({
        results: findAndReplaceUtils.findByTextCallback(callbackOrText, {
          matchCase,
          wholeWords
        })(...args),
        searchText: callbackOrText
      });
    } else {
      findCallback = callbackOrText;
    }
    const oldCallback = findCallback;
    findCallback = (...args) => {
      const result = oldCallback(...args);
      if (result && "searchText" in result) {
        callbackSearchText = result.searchText;
      }
      return result;
    };
    const results = model.document.getRootNames().reduce((currentResults, rootName) => findAndReplaceUtils.updateFindResultFromRange(model.createRangeIn(model.document.getRoot(rootName)), model, findCallback, currentResults), null);
    this._state.clear(model);
    this._state.results.addMany(results);
    this._state.highlightedResult = results.get(0);
    this._state.searchText = callbackSearchText;
    if (findCallback) {
      this._state.lastSearchCallback = findCallback;
    }
    this._state.matchCase = !!matchCase;
    this._state.matchWholeWords = !!wholeWords;
    return {
      results,
      findCallback
    };
  }
};
var ReplaceCommandBase = class extends Command {
  /**
  * Creates a new `ReplaceCommand` instance.
  *
  * @param editor Editor on which this command will be used.
  * @param state An object to hold plugin state.
  */
  constructor(editor, state) {
    super(editor);
    /**
    * The find and replace state object used for command operations.
    */
    __publicField(this, "_state");
    this.isEnabled = true;
    this._state = state;
    this._isEnabledBasedOnSelection = false;
  }
  /**
  * Common logic for both `replace` commands.
  * Replace a given find result by a string or a callback.
  *
  * @param result A single result from the find command.
  */
  _replace(replacementText, result) {
    const { model } = this.editor;
    const range = result.marker.getRange();
    if (!model.canEditAt(range)) {
      return;
    }
    model.change((writer) => {
      if (range.root.rootName === "$graveyard") {
        this._state.results.remove(result);
        return;
      }
      let textAttributes = {};
      for (const item of range.getItems()) {
        if (item.is("$text") || item.is("$textProxy")) {
          textAttributes = item.getAttributes();
          break;
        }
      }
      model.insertContent(writer.createText(replacementText, textAttributes), range);
      if (this._state.results.has(result)) {
        this._state.results.remove(result);
      }
    });
  }
};
var ReplaceCommand = class extends ReplaceCommandBase {
  /**
  * Replace a given find result by a string or a callback.
  *
  * @param result A single result from the find command.
  *
  * @fires execute
  */
  execute(replacementText, result) {
    this._replace(replacementText, result);
  }
};
var ReplaceAllCommand = class extends ReplaceCommandBase {
  /**
  * Replaces all the occurrences of `textToReplace` with a given `newText` string.
  *
  * ```ts
  *	replaceAllCommand.execute( 'replaceAll', 'new text replacement', 'text to replace' );
  * ```
  *
  * Alternatively you can call it from editor instance:
  *
  * ```ts
  *	editor.execute( 'replaceAll', 'new text', 'old text' );
  * ```
  *
  * @param newText Text that will be inserted to the editor for each match.
  * @param textToReplace Text to be replaced or a collection of matches
  * as returned by the find command.
  *
  * @fires module:core/command~Command#event:execute
  */
  execute(newText, textToReplace) {
    const { editor } = this;
    const { model } = editor;
    const findAndReplaceUtils = editor.plugins.get("FindAndReplaceUtils");
    const results = textToReplace instanceof Collection ? textToReplace : model.document.getRootNames().reduce((currentResults, rootName) => findAndReplaceUtils.updateFindResultFromRange(model.createRangeIn(model.document.getRoot(rootName)), model, findAndReplaceUtils.findByTextCallback(textToReplace, this._state), currentResults), null);
    if (results.length) {
      model.change(() => {
        [
          ...results
        ].forEach((searchResult) => {
          this._replace(newText, searchResult);
        });
      });
    }
  }
};
var FindNextCommand = class extends Command {
  /**
  * Creates a new `FindNextCommand` instance.
  *
  * @param editor The editor on which this command will be used.
  * @param state An object to hold plugin state.
  */
  constructor(editor, state) {
    super(editor);
    /**
    * The find and replace state object used for command operations.
    */
    __publicField(this, "_state");
    this.affectsData = false;
    this._state = state;
    this.isEnabled = false;
    this.listenTo(this._state.results, "change", () => {
      this.isEnabled = this._state.results.length > 1;
    });
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._state.results.length > 1;
  }
  /**
  * @inheritDoc
  */
  execute() {
    const results = this._state.results;
    const currentIndex = results.getIndex(this._state.highlightedResult);
    const nextIndex = currentIndex + 1 >= results.length ? 0 : currentIndex + 1;
    this._state.highlightedResult = this._state.results.get(nextIndex);
  }
};
var FindPreviousCommand = class extends FindNextCommand {
  /**
  * @inheritDoc
  */
  execute() {
    const results = this._state.results;
    const currentIndex = results.getIndex(this._state.highlightedResult);
    const previousIndex = currentIndex - 1 < 0 ? this._state.results.length - 1 : currentIndex - 1;
    this._state.highlightedResult = this._state.results.get(previousIndex);
  }
};
var FindAndReplaceState = class extends ObservableMixin() {
  /**
  * Creates an instance of the state.
  */
  constructor(model) {
    super();
    this.set("results", new Collection());
    this.set("highlightedResult", null);
    this.set("highlightedOffset", 0);
    this.set("searchText", "");
    this.set("replaceText", "");
    this.set("lastSearchCallback", null);
    this.set("matchCase", false);
    this.set("matchWholeWords", false);
    this.results.on("change", (eventInfo, { removed, index }) => {
      if (Array.from(removed).length) {
        let highlightedResultRemoved = false;
        model.change((writer) => {
          for (const removedResult of removed) {
            if (this.highlightedResult === removedResult) {
              highlightedResultRemoved = true;
            }
            if (model.markers.has(removedResult.marker.name)) {
              writer.removeMarker(removedResult.marker);
            }
          }
        });
        if (highlightedResultRemoved) {
          const nextHighlightedIndex = index >= this.results.length ? 0 : index;
          this.highlightedResult = this.results.get(nextHighlightedIndex);
        }
      }
    });
    this.on("change:highlightedResult", () => {
      this.refreshHighlightOffset();
    });
  }
  /**
  * Cleans the state up and removes markers from the model.
  */
  clear(model) {
    this.searchText = "";
    model.change((writer) => {
      if (this.highlightedResult) {
        const oldMatchId = this.highlightedResult.marker.name.split(":")[1];
        const oldMarker = model.markers.get(`findResultHighlighted:${oldMatchId}`);
        if (oldMarker) {
          writer.removeMarker(oldMarker);
        }
      }
      [
        ...this.results
      ].forEach(({ marker }) => {
        writer.removeMarker(marker);
      });
    });
    this.results.clear();
  }
  /**
  * Refreshes the highlight result offset based on it's index within the result list.
  */
  refreshHighlightOffset() {
    const { highlightedResult, results } = this;
    const sortMapping = {
      before: -1,
      same: 0,
      after: 1,
      different: 1
    };
    if (highlightedResult) {
      this.highlightedOffset = Array.from(results).sort((a, b) => sortMapping[a.marker.getStart().compareWith(b.marker.getStart())]).indexOf(highlightedResult) + 1;
    } else {
      this.highlightedOffset = 0;
    }
  }
};
var FindAndReplaceUtils = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FindAndReplaceUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Executes findCallback and updates search results list.
  *
  * @param range The model range to scan for matches.
  * @param model The model.
  * @param findCallback The callback that should return `true` if provided text matches the search term.
  * @param startResults An optional collection of find matches that the function should
  * start with. This would be a collection returned by a previous `updateFindResultFromRange()` call.
  * @returns A collection of objects describing find match.
  *
  * An example structure:
  *
  * ```js
  * {
  *	id: resultId,
  *	label: foundItem.label,
  *	marker
  *	}
  * ```
  */
  updateFindResultFromRange(range, model, findCallback, startResults) {
    const results = startResults || new Collection();
    const checkIfResultAlreadyOnList = (marker) => results.find((markerItem) => {
      const { marker: resultsMarker } = markerItem;
      const resultRange = resultsMarker.getRange();
      const markerRange = marker.getRange();
      return resultRange.isEqual(markerRange);
    });
    model.change((writer) => {
      [
        ...range
      ].forEach(({ type, item }) => {
        if (type === "elementStart") {
          if (model.schema.checkChild(item, "$text")) {
            let foundItems = findCallback({
              item,
              text: this.rangeToText(model.createRangeIn(item))
            });
            if (!foundItems) {
              return;
            }
            if ("results" in foundItems) {
              foundItems = foundItems.results;
            }
            foundItems.forEach((foundItem) => {
              const resultId = `findResult:${uid()}`;
              const marker = writer.addMarker(resultId, {
                usingOperation: false,
                affectsData: false,
                range: writer.createRange(writer.createPositionAt(item, foundItem.start), writer.createPositionAt(item, foundItem.end))
              });
              const index = findInsertIndex(results, marker);
              if (!checkIfResultAlreadyOnList(marker)) {
                results.add({
                  id: resultId,
                  label: foundItem.label,
                  marker
                }, index);
              }
            });
          }
        }
      });
    });
    return results;
  }
  /**
  * Returns text representation of a range. The returned text length should be the same as range length.
  * In order to achieve this, this function will replace inline elements (text-line) as new line character ("\n").
  *
  * @param range The model range.
  * @returns The text content of the provided range.
  */
  rangeToText(range) {
    return Array.from(range.getItems()).reduce((rangeText, node) => {
      if (!(node.is("$text") || node.is("$textProxy"))) {
        return `${rangeText}
`;
      }
      return rangeText + node.data;
    }, "");
  }
  /**
  * Creates a text matching callback for a specified search term and matching options.
  *
  * @param searchTerm The search term.
  * @param options Matching options.
  * 	- options.matchCase=false If set to `true` letter casing will be ignored.
  * 	- options.wholeWords=false If set to `true` only whole words that match `callbackOrText` will be matched.
  */
  findByTextCallback(searchTerm, options2) {
    let flags = "gu";
    if (!options2.matchCase) {
      flags += "i";
    }
    let regExpQuery = `(${escapeRegExp_default(searchTerm)})`;
    if (options2.wholeWords) {
      const nonLetterGroup = "[^a-zA-Z--]";
      if (!new RegExp("^" + nonLetterGroup).test(searchTerm)) {
        regExpQuery = `(^|${nonLetterGroup}|_)${regExpQuery}`;
      }
      if (!new RegExp(nonLetterGroup + "$").test(searchTerm)) {
        regExpQuery = `${regExpQuery}(?=_|${nonLetterGroup}|$)`;
      }
    }
    const regExp = new RegExp(regExpQuery, flags);
    function findCallback({ text }) {
      const matches = [
        ...text.matchAll(regExp)
      ];
      return matches.map(regexpMatchToFindResult);
    }
    return findCallback;
  }
};
function findInsertIndex(resultsList, markerToInsert) {
  const result = resultsList.find(({ marker }) => {
    return markerToInsert.getStart().isBefore(marker.getStart());
  });
  return result ? resultsList.getIndex(result) : resultsList.length;
}
function regexpMatchToFindResult(matchResult) {
  const lastGroupIndex = matchResult.length - 1;
  let startOffset = matchResult.index;
  if (matchResult.length === 3) {
    startOffset += matchResult[1].length;
  }
  return {
    label: matchResult[lastGroupIndex],
    start: startOffset,
    end: startOffset + matchResult[lastGroupIndex].length
  };
}
var HIGHLIGHT_CLASS2 = "ck-find-result_selected";
var FindAndReplaceEditing = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * An object storing the find and replace state within a given editor instance.
    */
    __publicField(this, "state");
    /**
    * Reacts to document changes in order to update search list.
    */
    __publicField(this, "_onDocumentChange", () => {
      const changedNodes = /* @__PURE__ */ new Set();
      const removedMarkers = /* @__PURE__ */ new Set();
      const model = this.editor.model;
      const { results } = this.state;
      const changes = model.document.differ.getChanges();
      const changedMarkers = model.document.differ.getChangedMarkers();
      changes.forEach((change) => {
        if (!change.position) {
          return;
        }
        if (change.name === "$text" || change.position.nodeAfter && model.schema.isInline(change.position.nodeAfter)) {
          changedNodes.add(change.position.parent);
          [
            ...model.markers.getMarkersAtPosition(change.position)
          ].forEach((markerAtChange) => {
            removedMarkers.add(markerAtChange.name);
          });
        } else if (change.type === "insert" && change.position.nodeAfter) {
          changedNodes.add(change.position.nodeAfter);
        }
      });
      changedMarkers.forEach(({ name, data: { newRange } }) => {
        if (newRange && newRange.start.root.rootName === "$graveyard") {
          removedMarkers.add(name);
        }
      });
      changedNodes.forEach((node) => {
        const markersInNode = [
          ...model.markers.getMarkersIntersectingRange(model.createRangeIn(node))
        ];
        markersInNode.forEach((marker) => removedMarkers.add(marker.name));
      });
      removedMarkers.forEach((markerName) => {
        if (!results.has(markerName)) {
          return;
        }
        if (results.get(markerName) === this.state.highlightedResult) {
          this.state.highlightedResult = null;
        }
        results.remove(markerName);
      });
      const changedSearchResults = [];
      const findAndReplaceUtils = this.editor.plugins.get("FindAndReplaceUtils");
      changedNodes.forEach((nodeToCheck) => {
        const changedNodeSearchResults = findAndReplaceUtils.updateFindResultFromRange(model.createRangeOn(nodeToCheck), model, this.state.lastSearchCallback, results);
        changedSearchResults.push(...changedNodeSearchResults);
      });
      changedMarkers.forEach((markerToCheck) => {
        if (markerToCheck.data.newRange) {
          const changedNodeSearchResults = findAndReplaceUtils.updateFindResultFromRange(markerToCheck.data.newRange, model, this.state.lastSearchCallback, results);
          changedSearchResults.push(...changedNodeSearchResults);
        }
      });
      if (!this.state.highlightedResult && changedSearchResults.length) {
        this.state.highlightedResult = changedSearchResults[0];
      } else {
        this.state.refreshHighlightOffset();
      }
    });
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FindAndReplaceUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FindAndReplaceEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this.state = new FindAndReplaceState(this.editor.model);
    this.set("_isSearchActive", false);
    this._defineConverters();
    this._defineCommands();
    this.listenTo(this.state, "change:highlightedResult", (eventInfo, name, newValue, oldValue) => {
      const { model } = this.editor;
      model.change((writer) => {
        if (oldValue) {
          const oldMatchId = oldValue.marker.name.split(":")[1];
          const oldMarker = model.markers.get(`findResultHighlighted:${oldMatchId}`);
          if (oldMarker) {
            writer.removeMarker(oldMarker);
          }
        }
        if (newValue) {
          const newMatchId = newValue.marker.name.split(":")[1];
          writer.addMarker(`findResultHighlighted:${newMatchId}`, {
            usingOperation: false,
            affectsData: false,
            range: newValue.marker.getRange()
          });
        }
      });
    });
    const scrollToHighlightedResult = (eventInfo, name, newValue) => {
      if (newValue) {
        const domConverter = this.editor.editing.view.domConverter;
        const viewRange = this.editor.editing.mapper.toViewRange(newValue.marker.getRange());
        scrollViewportToShowTarget({
          target: domConverter.viewRangeToDom(viewRange),
          viewportOffset: 40
        });
      }
    };
    const debouncedScrollListener = debounce_default(scrollToHighlightedResult.bind(this), 32);
    this.listenTo(this.state, "change:highlightedResult", debouncedScrollListener, {
      priority: "low"
    });
    this.listenTo(this.editor, "destroy", debouncedScrollListener.cancel);
    this.on("change:_isSearchActive", (evt, name, isSearchActive) => {
      if (isSearchActive) {
        this.listenTo(this.editor.model.document, "change:data", this._onDocumentChange);
      } else {
        this.stopListening(this.editor.model.document, "change:data", this._onDocumentChange);
      }
    });
  }
  /**
  * Initiate a search.
  */
  find(callbackOrText, findAttributes) {
    this._isSearchActive = true;
    this.editor.execute("find", callbackOrText, findAttributes);
    return this.state.results;
  }
  /**
  * Stops active results from updating, and clears out the results.
  */
  stop() {
    this.state.clear(this.editor.model);
    this._isSearchActive = false;
  }
  /**
  * Sets up the commands.
  */
  _defineCommands() {
    this.editor.commands.add("find", new FindCommand(this.editor, this.state));
    this.editor.commands.add("findNext", new FindNextCommand(this.editor, this.state));
    this.editor.commands.add("findPrevious", new FindPreviousCommand(this.editor, this.state));
    this.editor.commands.add("replace", new ReplaceCommand(this.editor, this.state));
    this.editor.commands.add("replaceAll", new ReplaceAllCommand(this.editor, this.state));
  }
  /**
  * Sets up the marker downcast converters for search results highlighting.
  */
  _defineConverters() {
    const { editor } = this;
    editor.conversion.for("editingDowncast").markerToHighlight({
      model: "findResult",
      view: ({ markerName }) => {
        const [, id] = markerName.split(":");
        return {
          name: "span",
          classes: [
            "ck-find-result"
          ],
          attributes: {
            // ...however, adding a unique attribute should be future-proof..
            "data-find-result": id
          }
        };
      }
    });
    editor.conversion.for("editingDowncast").markerToHighlight({
      model: "findResultHighlighted",
      view: ({ markerName }) => {
        const [, id] = markerName.split(":");
        return {
          name: "span",
          classes: [
            HIGHLIGHT_CLASS2
          ],
          attributes: {
            // ...however, adding a unique attribute should be future-proof..
            "data-find-result": id
          }
        };
      }
    });
  }
};
var FindAndReplace = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FindAndReplaceEditing,
      FindAndReplaceUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FindAndReplace";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const ui = this.editor.plugins.get("FindAndReplaceUI");
    const findAndReplaceEditing = this.editor.plugins.get("FindAndReplaceEditing");
    const state = findAndReplaceEditing.state;
    ui.on("findNext", (event, data) => {
      if (data) {
        state.searchText = data.searchText;
        findAndReplaceEditing.find(data.searchText, data);
      } else {
        this.editor.execute("findNext");
      }
    });
    ui.on("findPrevious", (event, data) => {
      if (data && state.searchText !== data.searchText) {
        findAndReplaceEditing.find(data.searchText);
      } else {
        this.editor.execute("findPrevious");
      }
    });
    ui.on("replace", (event, data) => {
      if (state.searchText !== data.searchText) {
        findAndReplaceEditing.find(data.searchText);
      }
      const highlightedResult = state.highlightedResult;
      if (highlightedResult) {
        this.editor.execute("replace", data.replaceText, highlightedResult);
      }
    });
    ui.on("replaceAll", (event, data) => {
      if (state.searchText !== data.searchText) {
        findAndReplaceEditing.find(data.searchText);
      }
      this.editor.execute("replaceAll", data.replaceText, state.results);
    });
    ui.on("searchReseted", () => {
      state.clear(this.editor.model);
      findAndReplaceEditing.stop();
    });
  }
};

// node_modules/@ckeditor/ckeditor5-font/dist/index.js
var FontCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor Editor instance.
  * @param attributeKey The name of a model attribute on which this command operates.
  */
  constructor(editor, attributeKey2) {
    super(editor);
    /**
    * A model attribute on which this command operates.
    */
    __publicField(this, "attributeKey");
    this.attributeKey = attributeKey2;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.value = doc.selection.getAttribute(this.attributeKey);
    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
  }
  /**
  * Executes the command. Applies the `value` of the {@link #attributeKey} to the selection.
  * If no `value` is passed, it removes the attribute from the selection.
  *
  * @param options Options for the executed command.
  * @param options.value The value to apply.
  * @fires execute
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    const selection = document2.selection;
    const value = options2.value;
    const batch = options2.batch;
    const updateAttribute = (writer) => {
      if (selection.isCollapsed) {
        if (value) {
          writer.setSelectionAttribute(this.attributeKey, value);
        } else {
          writer.removeSelectionAttribute(this.attributeKey);
        }
      } else {
        const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);
        for (const range of ranges) {
          if (value) {
            writer.setAttribute(this.attributeKey, value, range);
          } else {
            writer.removeAttribute(this.attributeKey, range);
          }
        }
      }
    };
    if (batch) {
      model.enqueueChange(batch, (writer) => {
        updateAttribute(writer);
      });
    } else {
      model.change((writer) => {
        updateAttribute(writer);
      });
    }
  }
};
var FONT_SIZE = "fontSize";
var FONT_FAMILY = "fontFamily";
var FONT_COLOR = "fontColor";
var FONT_BACKGROUND_COLOR = "fontBackgroundColor";
function buildDefinition(modelAttributeKey, options2) {
  const definition = {
    model: {
      key: modelAttributeKey,
      values: []
    },
    view: {},
    upcastAlso: {}
  };
  for (const option of options2) {
    definition.model.values.push(option.model);
    definition.view[option.model] = option.view;
    if (option.upcastAlso) {
      definition.upcastAlso[option.model] = option.upcastAlso;
    }
  }
  return definition;
}
function renderUpcastAttribute(styleAttr) {
  return (viewElement) => normalizeColorCode(viewElement.getStyle(styleAttr));
}
function renderDowncastElement(styleAttr) {
  return (modelAttributeValue, { writer }) => writer.createAttributeElement("span", {
    style: `${styleAttr}:${modelAttributeValue}`
  }, {
    priority: 7
  });
}
function addColorSelectorToDropdown({ dropdownView, colors, columns, removeButtonLabel, colorPickerLabel, documentColorsLabel, documentColorsCount, colorPickerViewConfig }) {
  const locale = dropdownView.locale;
  const colorSelectorView = new ColorSelectorView(locale, {
    colors,
    columns,
    removeButtonLabel,
    colorPickerLabel,
    documentColorsLabel,
    documentColorsCount,
    colorPickerViewConfig
  });
  dropdownView.colorSelectorView = colorSelectorView;
  dropdownView.panelView.children.add(colorSelectorView);
  return colorSelectorView;
}
function normalizeColorCode(value) {
  return value.replace(/\s/g, "");
}
var FontFamilyCommand = class extends FontCommand {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor, FONT_FAMILY);
  }
};
function normalizeOptions$1(configuredOptions) {
  return configuredOptions.map(getOptionDefinition$1).filter((option) => option !== void 0);
}
function getOptionDefinition$1(option) {
  if (typeof option === "object") {
    return option;
  }
  if (option === "default") {
    return {
      title: "Default",
      model: void 0
    };
  }
  if (typeof option !== "string") {
    return void 0;
  }
  return generateFontPreset(option);
}
function generateFontPreset(fontDefinition) {
  const fontNames = fontDefinition.replace(/"|'/g, "").split(",");
  const firstFontName = fontNames[0];
  const cssFontNames = fontNames.map(normalizeFontNameForCSS).join(", ");
  return {
    title: firstFontName,
    model: cssFontNames,
    view: {
      name: "span",
      styles: {
        "font-family": cssFontNames
      },
      priority: 7
    }
  };
}
function normalizeFontNameForCSS(fontName) {
  fontName = fontName.trim();
  if (fontName.indexOf(" ") > 0) {
    fontName = `'${fontName}'`;
  }
  return fontName;
}
var FontFamilyEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontFamilyEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define(FONT_FAMILY, {
      options: [
        "default",
        "Arial, Helvetica, sans-serif",
        "Courier New, Courier, monospace",
        "Georgia, serif",
        "Lucida Sans Unicode, Lucida Grande, sans-serif",
        "Tahoma, Geneva, sans-serif",
        "Times New Roman, Times, serif",
        "Trebuchet MS, Helvetica, sans-serif",
        "Verdana, Geneva, sans-serif"
      ],
      supportAllValues: false
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", {
      allowAttributes: FONT_FAMILY
    });
    editor.model.schema.setAttributeProperties(FONT_FAMILY, {
      isFormatting: true,
      copyOnEnter: true
    });
    const options2 = normalizeOptions$1(editor.config.get("fontFamily.options")).filter((item) => item.model);
    const definition = buildDefinition(FONT_FAMILY, options2);
    if (editor.config.get("fontFamily.supportAllValues")) {
      this._prepareAnyValueConverters();
      this._prepareCompatibilityConverter();
    } else {
      editor.conversion.attributeToElement(definition);
    }
    editor.commands.add(FONT_FAMILY, new FontFamilyCommand(editor));
  }
  /**
  * These converters enable keeping any value found as `style="font-family: *"` as a value of an attribute on a text even
  * if it is not defined in the plugin configuration.
  */
  _prepareAnyValueConverters() {
    const editor = this.editor;
    editor.conversion.for("downcast").attributeToElement({
      model: FONT_FAMILY,
      view: (attributeValue, { writer }) => {
        return writer.createAttributeElement("span", {
          style: "font-family:" + attributeValue
        }, {
          priority: 7
        });
      }
    });
    editor.conversion.for("upcast").elementToAttribute({
      model: {
        key: FONT_FAMILY,
        value: (viewElement) => viewElement.getStyle("font-family")
      },
      view: {
        name: "span",
        styles: {
          "font-family": /.*/
        }
      }
    });
  }
  /**
  * Adds support for legacy `<font face="..">` formatting.
  */
  _prepareCompatibilityConverter() {
    const editor = this.editor;
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          "face": /.*/
        }
      },
      model: {
        key: FONT_FAMILY,
        value: (viewElement) => viewElement.getAttribute("face")
      }
    });
  }
};
var fontFamilyIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>';
var FontFamilyUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontFamilyUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const options2 = this._getLocalizedOptions();
    const command = editor.commands.get(FONT_FAMILY);
    const accessibleLabel = t("Font Family");
    const listOptions = _prepareListOptions$1(options2, command);
    editor.ui.componentFactory.add(FONT_FAMILY, (locale) => {
      const dropdownView = createDropdown(locale);
      addListToDropdown(dropdownView, listOptions, {
        role: "menu",
        ariaLabel: accessibleLabel
      });
      dropdownView.buttonView.set({
        label: accessibleLabel,
        icon: fontFamilyIcon,
        tooltip: true
      });
      dropdownView.extendTemplate({
        attributes: {
          class: "ck-font-family-dropdown"
        }
      });
      dropdownView.bind("isEnabled").to(command);
      this.listenTo(dropdownView, "execute", (evt) => {
        editor.execute(evt.source.commandName, {
          value: evt.source.commandParam
        });
        editor.editing.view.focus();
      });
      return dropdownView;
    });
    editor.ui.componentFactory.add(`menuBar:${FONT_FAMILY}`, (locale) => {
      const menuView = new MenuBarMenuView(locale);
      menuView.buttonView.set({
        label: accessibleLabel,
        icon: fontFamilyIcon
      });
      menuView.bind("isEnabled").to(command);
      const listView = new MenuBarMenuListView(locale);
      for (const definition of listOptions) {
        const listItemView = new MenuBarMenuListItemView(locale, menuView);
        const buttonView = new MenuBarMenuListItemButtonView(locale);
        buttonView.set({
          role: "menuitemradio",
          isToggleable: true
        });
        buttonView.bind(...Object.keys(definition.model)).to(definition.model);
        buttonView.delegate("execute").to(menuView);
        buttonView.on("execute", () => {
          editor.execute(definition.model.commandName, {
            value: definition.model.commandParam
          });
          editor.editing.view.focus();
        });
        listItemView.children.add(buttonView);
        listView.items.add(listItemView);
      }
      menuView.panelView.children.add(listView);
      return menuView;
    });
  }
  /**
  * Returns options as defined in `config.fontFamily.options` but processed to account for
  * editor localization, i.e. to display {@link module:font/fontconfig~FontFamilyOption}
  * in the correct language.
  *
  * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
  * when the user configuration is defined because the editor does not exist yet.
  */
  _getLocalizedOptions() {
    const editor = this.editor;
    const t = editor.t;
    const options2 = normalizeOptions$1(editor.config.get(FONT_FAMILY).options);
    return options2.map((option) => {
      if (option.title === "Default") {
        option.title = t("Default");
      }
      return option;
    });
  }
};
function _prepareListOptions$1(options2, command) {
  const itemDefinitions = new Collection();
  for (const option of options2) {
    const def = {
      type: "button",
      model: new Model2({
        commandName: FONT_FAMILY,
        commandParam: option.model,
        label: option.title,
        role: "menuitemradio",
        withText: true
      })
    };
    def.model.bind("isOn").to(command, "value", (value) => {
      if (value === option.model) {
        return true;
      }
      if (!value || !option.model) {
        return false;
      }
      return value.split(",")[0].replace(/'/g, "").toLowerCase() === option.model.toLowerCase();
    });
    if (option.view && typeof option.view !== "string" && option.view.styles) {
      def.model.set("labelStyle", `font-family: ${option.view.styles["font-family"]}`);
    }
    itemDefinitions.add(def);
  }
  return itemDefinitions;
}
var FontFamily = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FontFamilyEditing,
      FontFamilyUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontFamily";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var FontSizeCommand = class extends FontCommand {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor, FONT_SIZE);
  }
};
function normalizeOptions(configuredOptions) {
  return configuredOptions.map((item) => getOptionDefinition(item)).filter((option) => option !== void 0);
}
var namedPresets = {
  get tiny() {
    return {
      title: "Tiny",
      model: "tiny",
      view: {
        name: "span",
        classes: "text-tiny",
        priority: 7
      }
    };
  },
  get small() {
    return {
      title: "Small",
      model: "small",
      view: {
        name: "span",
        classes: "text-small",
        priority: 7
      }
    };
  },
  get big() {
    return {
      title: "Big",
      model: "big",
      view: {
        name: "span",
        classes: "text-big",
        priority: 7
      }
    };
  },
  get huge() {
    return {
      title: "Huge",
      model: "huge",
      view: {
        name: "span",
        classes: "text-huge",
        priority: 7
      }
    };
  }
};
function getOptionDefinition(option) {
  if (typeof option === "number") {
    option = String(option);
  }
  if (typeof option === "object" && isFullItemDefinition(option)) {
    return attachPriority(option);
  }
  const preset = findPreset(option);
  if (preset) {
    return attachPriority(preset);
  }
  if (option === "default") {
    return {
      model: void 0,
      title: "Default"
    };
  }
  if (isNumericalDefinition(option)) {
    return void 0;
  }
  return generatePixelPreset(option);
}
function generatePixelPreset(definition) {
  if (typeof definition === "string") {
    definition = {
      title: definition,
      model: `${parseFloat(definition)}px`
    };
  }
  definition.view = {
    name: "span",
    styles: {
      "font-size": definition.model
    }
  };
  return attachPriority(definition);
}
function attachPriority(definition) {
  if (definition.view && typeof definition.view !== "string" && !definition.view.priority) {
    definition.view.priority = 7;
  }
  return definition;
}
function findPreset(definition) {
  return typeof definition === "string" ? namedPresets[definition] : namedPresets[definition.model];
}
function isFullItemDefinition(definition) {
  return definition.title && definition.model && definition.view;
}
function isNumericalDefinition(definition) {
  let numberValue;
  if (typeof definition === "object") {
    if (!definition.model) {
      throw new CKEditorError("font-size-invalid-definition", null, definition);
    } else {
      numberValue = parseFloat(definition.model);
    }
  } else {
    numberValue = parseFloat(definition);
  }
  return isNaN(numberValue);
}
var styleFontSize = [
  "x-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large"
];
var FontSizeEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontSizeEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define(FONT_SIZE, {
      options: [
        "tiny",
        "small",
        "default",
        "big",
        "huge"
      ],
      supportAllValues: false
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", {
      allowAttributes: FONT_SIZE
    });
    editor.model.schema.setAttributeProperties(FONT_SIZE, {
      isFormatting: true,
      copyOnEnter: true
    });
    const supportAllValues = editor.config.get("fontSize.supportAllValues");
    const options2 = normalizeOptions(this.editor.config.get("fontSize.options")).filter((item) => item.model);
    const definition = buildDefinition(FONT_SIZE, options2);
    if (supportAllValues) {
      this._prepareAnyValueConverters(definition);
      this._prepareCompatibilityConverter();
    } else {
      editor.conversion.attributeToElement(definition);
    }
    editor.commands.add(FONT_SIZE, new FontSizeCommand(editor));
  }
  /**
  * These converters enable keeping any value found as `style="font-size: *"` as a value of an attribute on a text even
  * if it is not defined in the plugin configuration.
  *
  * @param definition Converter definition out of input data.
  */
  _prepareAnyValueConverters(definition) {
    const editor = this.editor;
    const presets = definition.model.values.filter((value) => {
      return !isLength(String(value)) && !isPercentage(String(value));
    });
    if (presets.length) {
      throw new CKEditorError("font-size-invalid-use-of-named-presets", null, {
        presets
      });
    }
    editor.conversion.for("downcast").attributeToElement({
      model: FONT_SIZE,
      view: (attributeValue, { writer }) => {
        if (!attributeValue) {
          return;
        }
        return writer.createAttributeElement("span", {
          style: "font-size:" + attributeValue
        }, {
          priority: 7
        });
      }
    });
    editor.conversion.for("upcast").elementToAttribute({
      model: {
        key: FONT_SIZE,
        value: (viewElement) => viewElement.getStyle("font-size")
      },
      view: {
        name: "span",
        styles: {
          "font-size": /.*/
        }
      }
    });
  }
  /**
  * Adds support for legacy `<font size="..">` formatting.
  */
  _prepareCompatibilityConverter() {
    const editor = this.editor;
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          // Documentation mentions sizes from 1 to 7. To handle old content we support all values
          // up to 999 but clamp it to the valid range. Why 999? It should cover accidental values
          // similar to percentage, e.g. 100%, 200% which could be the usual mistake for font size.
          "size": /^[+-]?\d{1,3}$/
        }
      },
      model: {
        key: FONT_SIZE,
        value: (viewElement) => {
          const value = viewElement.getAttribute("size");
          const isRelative = value[0] === "-" || value[0] === "+";
          let size = parseInt(value, 10);
          if (isRelative) {
            size = 3 + size;
          }
          const maxSize = styleFontSize.length - 1;
          const clampedSize = Math.min(Math.max(size, 0), maxSize);
          return styleFontSize[clampedSize];
        }
      }
    });
  }
};
var fontSizeIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
var FontSizeUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontSizeUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const options2 = this._getLocalizedOptions();
    const command = editor.commands.get(FONT_SIZE);
    const accessibleLabel = t("Font Size");
    const listOptions = _prepareListOptions(options2, command);
    editor.ui.componentFactory.add(FONT_SIZE, (locale) => {
      const dropdownView = createDropdown(locale);
      addListToDropdown(dropdownView, listOptions, {
        role: "menu",
        ariaLabel: accessibleLabel
      });
      dropdownView.buttonView.set({
        label: accessibleLabel,
        icon: fontSizeIcon,
        tooltip: true
      });
      dropdownView.extendTemplate({
        attributes: {
          class: [
            "ck-font-size-dropdown"
          ]
        }
      });
      dropdownView.bind("isEnabled").to(command);
      this.listenTo(dropdownView, "execute", (evt) => {
        editor.execute(evt.source.commandName, {
          value: evt.source.commandParam
        });
        editor.editing.view.focus();
      });
      return dropdownView;
    });
    editor.ui.componentFactory.add(`menuBar:${FONT_SIZE}`, (locale) => {
      const menuView = new MenuBarMenuView(locale);
      menuView.buttonView.set({
        label: accessibleLabel,
        icon: fontSizeIcon
      });
      menuView.bind("isEnabled").to(command);
      const listView = new MenuBarMenuListView(locale);
      for (const definition of listOptions) {
        const listItemView = new MenuBarMenuListItemView(locale, menuView);
        const buttonView = new MenuBarMenuListItemButtonView(locale);
        buttonView.set({
          role: "menuitemradio",
          isToggleable: true
        });
        buttonView.bind(...Object.keys(definition.model)).to(definition.model);
        buttonView.delegate("execute").to(menuView);
        buttonView.on("execute", () => {
          editor.execute(definition.model.commandName, {
            value: definition.model.commandParam
          });
          editor.editing.view.focus();
        });
        listItemView.children.add(buttonView);
        listView.items.add(listItemView);
      }
      menuView.panelView.children.add(listView);
      return menuView;
    });
  }
  /**
  * Returns options as defined in `config.fontSize.options` but processed to account for
  * editor localization, i.e. to display {@link module:font/fontconfig~FontSizeOption}
  * in the correct language.
  *
  * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
  * when the user configuration is defined because the editor does not exist yet.
  */
  _getLocalizedOptions() {
    const editor = this.editor;
    const t = editor.t;
    const localizedTitles = {
      Default: t("Default"),
      Tiny: t("Tiny"),
      Small: t("Small"),
      Big: t("Big"),
      Huge: t("Huge")
    };
    const options2 = normalizeOptions(editor.config.get(FONT_SIZE).options);
    return options2.map((option) => {
      const title = localizedTitles[option.title];
      if (title && title != option.title) {
        option = Object.assign({}, option, {
          title
        });
      }
      return option;
    });
  }
};
function _prepareListOptions(options2, command) {
  const itemDefinitions = new Collection();
  for (const option of options2) {
    const def = {
      type: "button",
      model: new Model2({
        commandName: FONT_SIZE,
        commandParam: option.model,
        label: option.title,
        class: "ck-fontsize-option",
        role: "menuitemradio",
        withText: true
      })
    };
    if (option.view && typeof option.view !== "string") {
      if (option.view.styles) {
        def.model.set("labelStyle", `font-size:${option.view.styles["font-size"]}`);
      }
      if (option.view.classes) {
        def.model.set("class", `${def.model.class} ${option.view.classes}`);
      }
    }
    def.model.bind("isOn").to(command, "value", (value) => value === option.model);
    itemDefinitions.add(def);
  }
  return itemDefinitions;
}
var FontSize = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FontSizeEditing,
      FontSizeUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontSize";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Normalizes and translates the {@link module:font/fontconfig~FontSizeConfig#options configuration options}
  * to the {@link module:font/fontconfig~FontSizeOption} format.
  *
  * @param configuredOptions An array of options taken from the configuration.
  */
  normalizeSizeOptions(options2) {
    return normalizeOptions(options2);
  }
};
var FontColorCommand = class extends FontCommand {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor, FONT_COLOR);
  }
};
var FontColorEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontColorEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define(FONT_COLOR, {
      colors: [
        {
          color: "hsl(0, 0%, 0%)",
          label: "Black"
        },
        {
          color: "hsl(0, 0%, 30%)",
          label: "Dim grey"
        },
        {
          color: "hsl(0, 0%, 60%)",
          label: "Grey"
        },
        {
          color: "hsl(0, 0%, 90%)",
          label: "Light grey"
        },
        {
          color: "hsl(0, 0%, 100%)",
          label: "White",
          hasBorder: true
        },
        {
          color: "hsl(0, 75%, 60%)",
          label: "Red"
        },
        {
          color: "hsl(30, 75%, 60%)",
          label: "Orange"
        },
        {
          color: "hsl(60, 75%, 60%)",
          label: "Yellow"
        },
        {
          color: "hsl(90, 75%, 60%)",
          label: "Light green"
        },
        {
          color: "hsl(120, 75%, 60%)",
          label: "Green"
        },
        {
          color: "hsl(150, 75%, 60%)",
          label: "Aquamarine"
        },
        {
          color: "hsl(180, 75%, 60%)",
          label: "Turquoise"
        },
        {
          color: "hsl(210, 75%, 60%)",
          label: "Light blue"
        },
        {
          color: "hsl(240, 75%, 60%)",
          label: "Blue"
        },
        {
          color: "hsl(270, 75%, 60%)",
          label: "Purple"
        }
      ],
      columns: 5
    });
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "span",
        styles: {
          "color": /[\s\S]+/
        }
      },
      model: {
        key: FONT_COLOR,
        value: renderUpcastAttribute("color")
      }
    });
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          "color": /^#?\w+$/
        }
      },
      model: {
        key: FONT_COLOR,
        value: (viewElement) => viewElement.getAttribute("color")
      }
    });
    editor.conversion.for("downcast").attributeToElement({
      model: FONT_COLOR,
      view: renderDowncastElement("color")
    });
    editor.commands.add(FONT_COLOR, new FontColorCommand(editor));
    editor.model.schema.extend("$text", {
      allowAttributes: FONT_COLOR
    });
    editor.model.schema.setAttributeProperties(FONT_COLOR, {
      isFormatting: true,
      copyOnEnter: true
    });
  }
};
var ColorUI = class extends Plugin {
  /**
  * Creates a plugin which introduces a dropdown with a preconfigured
  * {@link module:ui/colorselector/colorselectorview~ColorSelectorView}.
  *
  * @param config The configuration object.
  * @param config.commandName The name of the command which will be executed when a color tile is clicked.
  * @param config.componentName The name of the dropdown in the {@link module:ui/componentfactory~ComponentFactory}
  * and the configuration scope name in `editor.config`.
  * @param config.icon The SVG icon used by the dropdown.
  * @param config.dropdownLabel The label used by the dropdown.
  */
  constructor(editor, { commandName, componentName, icon, dropdownLabel }) {
    super(editor);
    /**
    * The name of the command which will be executed when a color tile is clicked.
    */
    __publicField(this, "commandName");
    /**
    * The name of this component in the {@link module:ui/componentfactory~ComponentFactory}.
    * Also the configuration scope name in `editor.config`.
    */
    __publicField(this, "componentName");
    /**
    * The SVG icon used by the dropdown.
    */
    __publicField(this, "icon");
    /**
    * The label used by the dropdown.
    */
    __publicField(this, "dropdownLabel");
    /**
    * The number of columns in the color grid.
    */
    __publicField(this, "columns");
    this.commandName = commandName;
    this.componentName = componentName;
    this.icon = icon;
    this.dropdownLabel = dropdownLabel;
    this.columns = editor.config.get(`${this.componentName}.columns`);
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const t = locale.t;
    const command = editor.commands.get(this.commandName);
    const componentConfig = editor.config.get(this.componentName);
    const colorsConfig = normalizeColorOptions(componentConfig.colors);
    const localizedColors = getLocalizedColorOptions(locale, colorsConfig);
    const documentColorsCount = componentConfig.documentColors;
    const hasColorPicker = componentConfig.colorPicker !== false;
    editor.ui.componentFactory.add(this.componentName, (locale2) => {
      const dropdownView = createDropdown(locale2);
      let dropdownContentRendered = false;
      const colorSelectorView = addColorSelectorToDropdown({
        dropdownView,
        colors: localizedColors.map((option) => ({
          label: option.label,
          color: option.model,
          options: {
            hasBorder: option.hasBorder
          }
        })),
        columns: this.columns,
        removeButtonLabel: t("Remove color"),
        colorPickerLabel: t("Color picker"),
        documentColorsLabel: documentColorsCount !== 0 ? t("Document colors") : "",
        documentColorsCount: documentColorsCount === void 0 ? this.columns : documentColorsCount,
        colorPickerViewConfig: hasColorPicker ? componentConfig.colorPicker || {} : false
      });
      colorSelectorView.bind("selectedColor").to(command, "value");
      dropdownView.buttonView.set({
        label: this.dropdownLabel,
        icon: this.icon,
        tooltip: true
      });
      dropdownView.extendTemplate({
        attributes: {
          class: "ck-color-ui-dropdown"
        }
      });
      dropdownView.bind("isEnabled").to(command);
      colorSelectorView.on("execute", (evt, data) => {
        if (dropdownView.isOpen) {
          editor.execute(this.commandName, {
            value: data.value,
            batch: this._undoStepBatch
          });
        }
        if (data.source !== "colorPicker") {
          editor.editing.view.focus();
        }
        if (data.source === "colorPickerSaveButton") {
          dropdownView.isOpen = false;
        }
      });
      colorSelectorView.on("colorPicker:show", () => {
        this._undoStepBatch = editor.model.createBatch();
      });
      colorSelectorView.on("colorPicker:cancel", () => {
        if (this._undoStepBatch.operations.length) {
          dropdownView.isOpen = false;
          editor.execute("undo", this._undoStepBatch);
        }
        editor.editing.view.focus();
      });
      dropdownView.on("change:isOpen", (evt, name, isVisible2) => {
        if (!dropdownContentRendered) {
          dropdownContentRendered = true;
          dropdownView.colorSelectorView.appendUI();
        }
        if (isVisible2) {
          if (documentColorsCount !== 0) {
            colorSelectorView.updateDocumentColors(editor.model, this.componentName);
          }
          colorSelectorView.updateSelectedColors();
          colorSelectorView.showColorGridsFragment();
        }
      });
      focusChildOnDropdownOpen(dropdownView, () => dropdownView.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((item) => item.isOn));
      return dropdownView;
    });
    editor.ui.componentFactory.add(`menuBar:${this.componentName}`, (locale2) => {
      const menuView = new MenuBarMenuView(locale2);
      menuView.buttonView.set({
        label: this.dropdownLabel,
        icon: this.icon
      });
      menuView.bind("isEnabled").to(command);
      let contentRendered = false;
      const colorSelectorView = new ColorSelectorView(locale2, {
        colors: localizedColors.map((option) => ({
          label: option.label,
          color: option.model,
          options: {
            hasBorder: option.hasBorder
          }
        })),
        columns: this.columns,
        removeButtonLabel: t("Remove color"),
        colorPickerLabel: t("Color picker"),
        documentColorsLabel: documentColorsCount !== 0 ? t("Document colors") : "",
        documentColorsCount: documentColorsCount === void 0 ? this.columns : documentColorsCount,
        colorPickerViewConfig: false
      });
      colorSelectorView.bind("selectedColor").to(command, "value");
      colorSelectorView.delegate("execute").to(menuView);
      colorSelectorView.on("execute", (evt, data) => {
        editor.execute(this.commandName, {
          value: data.value,
          batch: this._undoStepBatch
        });
        editor.editing.view.focus();
      });
      menuView.on("change:isOpen", (evt, name, isVisible2) => {
        if (!contentRendered) {
          contentRendered = true;
          colorSelectorView.appendUI();
        }
        if (isVisible2) {
          if (documentColorsCount !== 0) {
            colorSelectorView.updateDocumentColors(editor.model, this.componentName);
          }
          colorSelectorView.updateSelectedColors();
          colorSelectorView.showColorGridsFragment();
        }
      });
      menuView.panelView.children.add(colorSelectorView);
      return menuView;
    });
  }
};
var fontColorIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
var FontColorUI = class extends ColorUI {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    const t = editor.locale.t;
    super(editor, {
      commandName: FONT_COLOR,
      componentName: FONT_COLOR,
      icon: fontColorIcon,
      dropdownLabel: t("Font Color")
    });
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontColorUI";
  }
};
var FontColor = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FontColorEditing,
      FontColorUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontColor";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var FontBackgroundColorCommand = class extends FontCommand {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor, FONT_BACKGROUND_COLOR);
  }
};
var FontBackgroundColorEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontBackgroundColorEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define(FONT_BACKGROUND_COLOR, {
      colors: [
        {
          color: "hsl(0, 0%, 0%)",
          label: "Black"
        },
        {
          color: "hsl(0, 0%, 30%)",
          label: "Dim grey"
        },
        {
          color: "hsl(0, 0%, 60%)",
          label: "Grey"
        },
        {
          color: "hsl(0, 0%, 90%)",
          label: "Light grey"
        },
        {
          color: "hsl(0, 0%, 100%)",
          label: "White",
          hasBorder: true
        },
        {
          color: "hsl(0, 75%, 60%)",
          label: "Red"
        },
        {
          color: "hsl(30, 75%, 60%)",
          label: "Orange"
        },
        {
          color: "hsl(60, 75%, 60%)",
          label: "Yellow"
        },
        {
          color: "hsl(90, 75%, 60%)",
          label: "Light green"
        },
        {
          color: "hsl(120, 75%, 60%)",
          label: "Green"
        },
        {
          color: "hsl(150, 75%, 60%)",
          label: "Aquamarine"
        },
        {
          color: "hsl(180, 75%, 60%)",
          label: "Turquoise"
        },
        {
          color: "hsl(210, 75%, 60%)",
          label: "Light blue"
        },
        {
          color: "hsl(240, 75%, 60%)",
          label: "Blue"
        },
        {
          color: "hsl(270, 75%, 60%)",
          label: "Purple"
        }
      ],
      columns: 5
    });
    editor.data.addStyleProcessorRules(addBackgroundRules);
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "span",
        styles: {
          "background-color": /[\s\S]+/
        }
      },
      model: {
        key: FONT_BACKGROUND_COLOR,
        value: renderUpcastAttribute("background-color")
      }
    });
    editor.conversion.for("downcast").attributeToElement({
      model: FONT_BACKGROUND_COLOR,
      view: renderDowncastElement("background-color")
    });
    editor.commands.add(FONT_BACKGROUND_COLOR, new FontBackgroundColorCommand(editor));
    editor.model.schema.extend("$text", {
      allowAttributes: FONT_BACKGROUND_COLOR
    });
    editor.model.schema.setAttributeProperties(FONT_BACKGROUND_COLOR, {
      isFormatting: true,
      copyOnEnter: true
    });
  }
};
var fontBackgroundColorIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';
var FontBackgroundColorUI = class extends ColorUI {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    const t = editor.locale.t;
    super(editor, {
      commandName: FONT_BACKGROUND_COLOR,
      componentName: FONT_BACKGROUND_COLOR,
      icon: fontBackgroundColorIcon,
      dropdownLabel: t("Font Background Color")
    });
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontBackgroundColorUI";
  }
};
var FontBackgroundColor = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FontBackgroundColorEditing,
      FontBackgroundColorUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FontBackgroundColor";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var Font = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FontFamily,
      FontSize,
      FontColor,
      FontBackgroundColor
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Font";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-heading/dist/index.js
var HeadingCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor Editor instance.
  * @param modelElements Names of the element which this command can apply in the model.
  */
  constructor(editor, modelElements) {
    super(editor);
    /**
    * Set of defined model's elements names that this command support.
    * See {@link module:heading/headingconfig~HeadingOption}.
    */
    __publicField(this, "modelElements");
    this.modelElements = modelElements;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const block2 = first(this.editor.model.document.selection.getSelectedBlocks());
    this.value = !!block2 && this.modelElements.includes(block2.name) && block2.name;
    this.isEnabled = !!block2 && this.modelElements.some((heading) => checkCanBecomeHeading(block2, heading, this.editor.model.schema));
  }
  /**
  * Executes the command. Applies the heading to the selected blocks or, if the first selected
  * block is a heading already, turns selected headings (of this level only) to paragraphs.
  *
  * @param options.value Name of the element which this command will apply in the model.
  * @fires execute
  */
  execute(options2) {
    const model = this.editor.model;
    const document2 = model.document;
    const modelElement = options2.value;
    model.change((writer) => {
      const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => {
        return checkCanBecomeHeading(block2, modelElement, model.schema);
      });
      for (const block2 of blocks) {
        if (!block2.is("element", modelElement)) {
          writer.rename(block2, modelElement);
        }
      }
    });
  }
};
function checkCanBecomeHeading(block2, heading, schema) {
  return schema.checkChild(block2.parent, heading) && !schema.isObject(block2);
}
var defaultModelElement = "paragraph";
var HeadingEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HeadingEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("heading", {
      options: [
        {
          model: "paragraph",
          title: "Paragraph",
          class: "ck-heading_paragraph"
        },
        {
          model: "heading1",
          view: "h2",
          title: "Heading 1",
          class: "ck-heading_heading1"
        },
        {
          model: "heading2",
          view: "h3",
          title: "Heading 2",
          class: "ck-heading_heading2"
        },
        {
          model: "heading3",
          view: "h4",
          title: "Heading 3",
          class: "ck-heading_heading3"
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Paragraph
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const options2 = editor.config.get("heading.options");
    const modelElements = [];
    for (const option of options2) {
      if (option.model === "paragraph") {
        continue;
      }
      editor.model.schema.register(option.model, {
        inheritAllFrom: "$block"
      });
      editor.conversion.elementToElement(option);
      modelElements.push(option.model);
    }
    this._addDefaultH1Conversion(editor);
    editor.commands.add("heading", new HeadingCommand(editor, modelElements));
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const enterCommand = editor.commands.get("enter");
    const options2 = editor.config.get("heading.options");
    if (enterCommand) {
      this.listenTo(enterCommand, "afterExecute", (evt, data) => {
        const positionParent = editor.model.document.selection.getFirstPosition().parent;
        const isHeading = options2.some((option) => positionParent.is("element", option.model));
        if (isHeading && !positionParent.is("element", defaultModelElement) && positionParent.childCount === 0) {
          data.writer.rename(positionParent, defaultModelElement);
        }
      });
    }
  }
  /**
  * Adds default conversion for `h1` -> `heading1` with a low priority.
  *
  * @param editor Editor instance on which to add the `h1` conversion.
  */
  _addDefaultH1Conversion(editor) {
    editor.conversion.for("upcast").elementToElement({
      model: "heading1",
      view: "h1",
      // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure
      // this listener is called before it. If not, `h1` will be transformed into a paragraph.
      converterPriority: priorities.low + 1
    });
  }
};
function getLocalizedOptions(editor) {
  const t = editor.t;
  const localizedTitles = {
    "Paragraph": t("Paragraph"),
    "Heading 1": t("Heading 1"),
    "Heading 2": t("Heading 2"),
    "Heading 3": t("Heading 3"),
    "Heading 4": t("Heading 4"),
    "Heading 5": t("Heading 5"),
    "Heading 6": t("Heading 6")
  };
  return editor.config.get("heading.options").map((option) => {
    const title = localizedTitles[option.title];
    if (title && title != option.title) {
      option.title = title;
    }
    return option;
  });
}
var HeadingUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HeadingUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const options2 = getLocalizedOptions(editor);
    const defaultTitle = t("Choose heading");
    const accessibleLabel = t("Heading");
    editor.ui.componentFactory.add("heading", (locale) => {
      const titles = {};
      const itemDefinitions = new Collection();
      const headingCommand = editor.commands.get("heading");
      const paragraphCommand = editor.commands.get("paragraph");
      const commands = [
        headingCommand
      ];
      for (const option of options2) {
        const def = {
          type: "button",
          model: new Model2({
            label: option.title,
            class: option.class,
            role: "menuitemradio",
            withText: true
          })
        };
        if (option.model === "paragraph") {
          def.model.bind("isOn").to(paragraphCommand, "value");
          def.model.set("commandName", "paragraph");
          commands.push(paragraphCommand);
        } else {
          def.model.bind("isOn").to(headingCommand, "value", (value) => value === option.model);
          def.model.set({
            commandName: "heading",
            commandValue: option.model
          });
        }
        itemDefinitions.add(def);
        titles[option.model] = option.title;
      }
      const dropdownView = createDropdown(locale);
      addListToDropdown(dropdownView, itemDefinitions, {
        ariaLabel: accessibleLabel,
        role: "menu"
      });
      dropdownView.buttonView.set({
        ariaLabel: accessibleLabel,
        ariaLabelledBy: void 0,
        isOn: false,
        withText: true,
        tooltip: accessibleLabel
      });
      dropdownView.extendTemplate({
        attributes: {
          class: [
            "ck-heading-dropdown"
          ]
        }
      });
      dropdownView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
        return areEnabled.some((isEnabled) => isEnabled);
      });
      dropdownView.buttonView.bind("label").to(headingCommand, "value", paragraphCommand, "value", (heading, paragraph) => {
        const whichModel = paragraph ? "paragraph" : heading;
        if (typeof whichModel === "boolean") {
          return defaultTitle;
        }
        if (!titles[whichModel]) {
          return defaultTitle;
        }
        return titles[whichModel];
      });
      dropdownView.buttonView.bind("ariaLabel").to(headingCommand, "value", paragraphCommand, "value", (heading, paragraph) => {
        const whichModel = paragraph ? "paragraph" : heading;
        if (typeof whichModel === "boolean") {
          return accessibleLabel;
        }
        if (!titles[whichModel]) {
          return accessibleLabel;
        }
        return `${titles[whichModel]}, ${accessibleLabel}`;
      });
      this.listenTo(dropdownView, "execute", (evt) => {
        const { commandName, commandValue } = evt.source;
        editor.execute(commandName, commandValue ? {
          value: commandValue
        } : void 0);
        editor.editing.view.focus();
      });
      return dropdownView;
    });
    editor.ui.componentFactory.add("menuBar:heading", (locale) => {
      const menuView = new MenuBarMenuView(locale);
      const headingCommand = editor.commands.get("heading");
      const paragraphCommand = editor.commands.get("paragraph");
      const commands = [
        headingCommand
      ];
      const listView = new MenuBarMenuListView(locale);
      menuView.set({
        class: "ck-heading-dropdown"
      });
      listView.set({
        ariaLabel: t("Heading"),
        role: "menu"
      });
      menuView.buttonView.set({
        label: t("Heading")
      });
      menuView.panelView.children.add(listView);
      for (const option of options2) {
        const listItemView = new MenuBarMenuListItemView(locale, menuView);
        const buttonView = new MenuBarMenuListItemButtonView(locale);
        listItemView.children.add(buttonView);
        listView.items.add(listItemView);
        buttonView.set({
          isToggleable: true,
          label: option.title,
          role: "menuitemradio",
          class: option.class
        });
        buttonView.delegate("execute").to(menuView);
        buttonView.on("execute", () => {
          const commandName = option.model === "paragraph" ? "paragraph" : "heading";
          editor.execute(commandName, {
            value: option.model
          });
          editor.editing.view.focus();
        });
        if (option.model === "paragraph") {
          buttonView.bind("isOn").to(paragraphCommand, "value");
          commands.push(paragraphCommand);
        } else {
          buttonView.bind("isOn").to(headingCommand, "value", (value) => value === option.model);
        }
      }
      menuView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
        return areEnabled.some((isEnabled) => isEnabled);
      });
      return menuView;
    });
  }
};
var Heading = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      HeadingEditing,
      HeadingUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Heading";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var defaultIcons = (() => ({
  heading1: icons.heading1,
  heading2: icons.heading2,
  heading3: icons.heading3,
  heading4: icons.heading4,
  heading5: icons.heading5,
  heading6: icons.heading6
}))();
var HeadingButtonsUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  init() {
    const options2 = getLocalizedOptions(this.editor);
    options2.filter((item) => item.model !== "paragraph").map((item) => this._createButton(item));
  }
  /**
  * Creates single button view from provided configuration option.
  */
  _createButton(option) {
    const editor = this.editor;
    editor.ui.componentFactory.add(option.model, (locale) => {
      const view = new ButtonView(locale);
      const command = editor.commands.get("heading");
      view.label = option.title;
      view.icon = option.icon || defaultIcons[option.model];
      view.tooltip = true;
      view.isToggleable = true;
      view.bind("isEnabled").to(command);
      view.bind("isOn").to(command, "value", (value) => value == option.model);
      view.on("execute", () => {
        editor.execute("heading", {
          value: option.model
        });
        editor.editing.view.focus();
      });
      return view;
    });
  }
};
var titleLikeElements = /* @__PURE__ */ new Set([
  "paragraph",
  "heading1",
  "heading2",
  "heading3",
  "heading4",
  "heading5",
  "heading6"
]);
var Title = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * A reference to an empty paragraph in the body
    * created when there is no element in the body for the placeholder purposes.
    */
    __publicField(this, "_bodyPlaceholder", /* @__PURE__ */ new Map());
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Title";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "Paragraph"
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    model.schema.register("title", {
      isBlock: true,
      allowIn: "$root"
    });
    model.schema.register("title-content", {
      isBlock: true,
      allowIn: "title",
      allowAttributes: [
        "alignment"
      ]
    });
    model.schema.extend("$text", {
      allowIn: "title-content"
    });
    model.schema.addAttributeCheck((context) => {
      if (context.endsWith("title-content $text")) {
        return false;
      }
    });
    editor.editing.mapper.on("modelToViewPosition", mapModelPositionToView(editor.editing.view));
    editor.data.mapper.on("modelToViewPosition", mapModelPositionToView(editor.editing.view));
    editor.conversion.for("downcast").elementToElement({
      model: "title-content",
      view: "h1"
    });
    editor.conversion.for("downcast").add((dispatcher) => dispatcher.on("insert:title", (evt, data, conversionApi) => {
      conversionApi.consumable.consume(data.item, evt.name);
    }));
    editor.data.upcastDispatcher.on("element:h1", dataViewModelH1Insertion, {
      priority: "high"
    });
    editor.data.upcastDispatcher.on("element:h2", dataViewModelH1Insertion, {
      priority: "high"
    });
    editor.data.upcastDispatcher.on("element:h3", dataViewModelH1Insertion, {
      priority: "high"
    });
    model.document.registerPostFixer((writer) => this._fixTitleContent(writer));
    model.document.registerPostFixer((writer) => this._fixTitleElement(writer));
    model.document.registerPostFixer((writer) => this._fixBodyElement(writer));
    model.document.registerPostFixer((writer) => this._fixExtraParagraph(writer));
    this._attachPlaceholders();
    this._attachTabPressHandling();
  }
  /**
  * Returns the title of the document. Note that because this plugin does not allow any formatting inside
  * the title element, the output of this method will be a plain text, with no HTML tags.
  *
  * It is not recommended to use this method together with features that insert markers to the
  * data output, like comments or track changes features. If such markers start in the title and end in the
  * body, the result of this method might be incorrect.
  *
  * @param options Additional configuration passed to the conversion process.
  * See {@link module:engine/controller/datacontroller~DataController#get `DataController#get`}.
  * @returns The title of the document.
  */
  getTitle(options2 = {}) {
    const rootName = options2.rootName ? options2.rootName : void 0;
    const titleElement = this._getTitleElement(rootName);
    const titleContentElement = titleElement.getChild(0);
    return this.editor.data.stringify(titleContentElement, options2);
  }
  /**
  * Returns the body of the document.
  *
  * Note that it is not recommended to use this method together with features that insert markers to the
  * data output, like comments or track changes features. If such markers start in the title and end in the
  * body, the result of this method might be incorrect.
  *
  * @param options Additional configuration passed to the conversion process.
  * See {@link module:engine/controller/datacontroller~DataController#get `DataController#get`}.
  * @returns The body of the document.
  */
  getBody(options2 = {}) {
    const editor = this.editor;
    const data = editor.data;
    const model = editor.model;
    const rootName = options2.rootName ? options2.rootName : void 0;
    const root2 = editor.model.document.getRoot(rootName);
    const view = editor.editing.view;
    const viewWriter = new DowncastWriter(view.document);
    const rootRange = model.createRangeIn(root2);
    const viewDocumentFragment = viewWriter.createDocumentFragment();
    const bodyStartPosition = model.createPositionAfter(root2.getChild(0));
    const bodyRange = model.createRange(bodyStartPosition, model.createPositionAt(root2, "end"));
    const markers = /* @__PURE__ */ new Map();
    for (const marker of model.markers) {
      const intersection = bodyRange.getIntersection(marker.getRange());
      if (intersection) {
        markers.set(marker.name, intersection);
      }
    }
    data.mapper.clearBindings();
    data.mapper.bindElements(root2, viewDocumentFragment);
    data.downcastDispatcher.convert(rootRange, markers, viewWriter, options2);
    viewWriter.remove(viewWriter.createRangeOn(viewDocumentFragment.getChild(0)));
    return editor.data.processor.toData(viewDocumentFragment);
  }
  /**
  * Returns the `title` element when it is in the document. Returns `undefined` otherwise.
  */
  _getTitleElement(rootName) {
    const root2 = this.editor.model.document.getRoot(rootName);
    for (const child of root2.getChildren()) {
      if (isTitle(child)) {
        return child;
      }
    }
  }
  /**
  * Model post-fixer callback that ensures that `title` has only one `title-content` child.
  * All additional children should be moved after the `title` element and renamed to a paragraph.
  */
  _fixTitleContent(writer) {
    let changed = false;
    for (const rootName of this.editor.model.document.getRootNames()) {
      const title = this._getTitleElement(rootName);
      if (!title || title.maxOffset === 1) {
        continue;
      }
      const titleChildren = Array.from(title.getChildren());
      titleChildren.shift();
      for (const titleChild of titleChildren) {
        writer.move(writer.createRangeOn(titleChild), title, "after");
        writer.rename(titleChild, "paragraph");
      }
      changed = true;
    }
    return changed;
  }
  /**
  * Model post-fixer callback that creates a title element when it is missing,
  * takes care of the correct position of it and removes additional title elements.
  */
  _fixTitleElement(writer) {
    let changed = false;
    const model = this.editor.model;
    for (const modelRoot of this.editor.model.document.getRoots()) {
      const titleElements = Array.from(modelRoot.getChildren()).filter(isTitle);
      const firstTitleElement = titleElements[0];
      const firstRootChild = modelRoot.getChild(0);
      if (firstRootChild.is("element", "title")) {
        if (titleElements.length > 1) {
          fixAdditionalTitleElements(titleElements, writer, model);
          changed = true;
        }
        continue;
      }
      if (!firstTitleElement && !titleLikeElements.has(firstRootChild.name)) {
        const title = writer.createElement("title");
        writer.insert(title, modelRoot);
        writer.insertElement("title-content", title);
        changed = true;
        continue;
      }
      if (titleLikeElements.has(firstRootChild.name)) {
        changeElementToTitle(firstRootChild, writer, model);
      } else {
        writer.move(writer.createRangeOn(firstTitleElement), modelRoot, 0);
      }
      fixAdditionalTitleElements(titleElements, writer, model);
      changed = true;
    }
    return changed;
  }
  /**
  * Model post-fixer callback that adds an empty paragraph at the end of the document
  * when it is needed for the placeholder purposes.
  */
  _fixBodyElement(writer) {
    let changed = false;
    for (const rootName of this.editor.model.document.getRootNames()) {
      const modelRoot = this.editor.model.document.getRoot(rootName);
      if (modelRoot.childCount < 2) {
        const placeholder = writer.createElement("paragraph");
        writer.insert(placeholder, modelRoot, 1);
        this._bodyPlaceholder.set(rootName, placeholder);
        changed = true;
      }
    }
    return changed;
  }
  /**
  * Model post-fixer callback that removes a paragraph from the end of the document
  * if it was created for the placeholder purposes and is not needed anymore.
  */
  _fixExtraParagraph(writer) {
    let changed = false;
    for (const rootName of this.editor.model.document.getRootNames()) {
      const root2 = this.editor.model.document.getRoot(rootName);
      const placeholder = this._bodyPlaceholder.get(rootName);
      if (shouldRemoveLastParagraph(placeholder, root2)) {
        this._bodyPlaceholder.delete(rootName);
        writer.remove(placeholder);
        changed = true;
      }
    }
    return changed;
  }
  /**
  * Attaches the `Title` and `Body` placeholders to the title and/or content.
  */
  _attachPlaceholders() {
    const editor = this.editor;
    const t = editor.t;
    const view = editor.editing.view;
    const sourceElement = editor.sourceElement;
    const titlePlaceholder = editor.config.get("title.placeholder") || t("Type your title");
    const bodyPlaceholder = editor.config.get("placeholder") || sourceElement && sourceElement.tagName.toLowerCase() === "textarea" && sourceElement.getAttribute("placeholder") || t("Type or paste your content here.");
    editor.editing.downcastDispatcher.on("insert:title-content", (evt, data, conversionApi) => {
      const element = conversionApi.mapper.toViewElement(data.item);
      element.placeholder = titlePlaceholder;
      enablePlaceholder({
        view,
        element,
        keepOnFocus: true
      });
    });
    const bodyViewElements = /* @__PURE__ */ new Map();
    view.document.registerPostFixer((writer) => {
      let hasChanged = false;
      for (const viewRoot of view.document.roots) {
        if (viewRoot.isEmpty) {
          continue;
        }
        const body = viewRoot.getChild(1);
        const oldBody = bodyViewElements.get(viewRoot.rootName);
        if (body !== oldBody) {
          if (oldBody) {
            hidePlaceholder(writer, oldBody);
            writer.removeAttribute("data-placeholder", oldBody);
          }
          writer.setAttribute("data-placeholder", bodyPlaceholder, body);
          bodyViewElements.set(viewRoot.rootName, body);
          hasChanged = true;
        }
        if (needsPlaceholder(body, true) && viewRoot.childCount === 2 && body.name === "p") {
          hasChanged = showPlaceholder(writer, body) ? true : hasChanged;
        } else {
          hasChanged = hidePlaceholder(writer, body) ? true : hasChanged;
        }
      }
      return hasChanged;
    });
  }
  /**
  * Creates navigation between the title and body sections using <kbd>Tab</kbd> and <kbd>Shift</kbd>+<kbd>Tab</kbd> keys.
  */
  _attachTabPressHandling() {
    const editor = this.editor;
    const model = editor.model;
    editor.keystrokes.set("TAB", (data, cancel) => {
      model.change((writer) => {
        const selection = model.document.selection;
        const selectedElements = Array.from(selection.getSelectedBlocks());
        if (selectedElements.length === 1 && selectedElements[0].is("element", "title-content")) {
          const root2 = selection.getFirstPosition().root;
          const firstBodyElement = root2.getChild(1);
          writer.setSelection(firstBodyElement, 0);
          cancel();
        }
      });
    });
    editor.keystrokes.set("SHIFT + TAB", (data, cancel) => {
      model.change((writer) => {
        const selection = model.document.selection;
        if (!selection.isCollapsed) {
          return;
        }
        const selectedElement = first(selection.getSelectedBlocks());
        const selectionPosition = selection.getFirstPosition();
        const root2 = editor.model.document.getRoot(selectionPosition.root.rootName);
        const title = root2.getChild(0);
        const body = root2.getChild(1);
        if (selectedElement === body && selectionPosition.isAtStart) {
          writer.setSelection(title.getChild(0), 0);
          cancel();
        }
      });
    });
  }
};
function dataViewModelH1Insertion(evt, data, conversionApi) {
  const modelCursor = data.modelCursor;
  const viewItem = data.viewItem;
  if (!modelCursor.isAtStart || !modelCursor.parent.is("element", "$root")) {
    return;
  }
  if (!conversionApi.consumable.consume(viewItem, {
    name: true
  })) {
    return;
  }
  const modelWriter = conversionApi.writer;
  const title = modelWriter.createElement("title");
  const titleContent = modelWriter.createElement("title-content");
  modelWriter.append(titleContent, title);
  modelWriter.insert(title, modelCursor);
  conversionApi.convertChildren(viewItem, titleContent);
  conversionApi.updateConversionResult(title, data);
}
function mapModelPositionToView(editingView) {
  return (evt, data) => {
    const positionParent = data.modelPosition.parent;
    if (!positionParent.is("element", "title")) {
      return;
    }
    const modelTitleElement = positionParent.parent;
    const viewElement = data.mapper.toViewElement(modelTitleElement);
    data.viewPosition = editingView.createPositionAt(viewElement, 0);
    evt.stop();
  };
}
function isTitle(element) {
  return element.is("element", "title");
}
function changeElementToTitle(element, writer, model) {
  const title = writer.createElement("title");
  writer.insert(title, element, "before");
  writer.insert(element, title, 0);
  writer.rename(element, "title-content");
  model.schema.removeDisallowedAttributes([
    element
  ], writer);
}
function fixAdditionalTitleElements(titleElements, writer, model) {
  let hasChanged = false;
  for (const title of titleElements) {
    if (title.index !== 0) {
      fixTitleElement(title, writer, model);
      hasChanged = true;
    }
  }
  return hasChanged;
}
function fixTitleElement(title, writer, model) {
  const child = title.getChild(0);
  if (child.isEmpty) {
    writer.remove(title);
    return;
  }
  writer.move(writer.createRangeOn(child), title, "before");
  writer.rename(child, "paragraph");
  writer.remove(title);
  model.schema.removeDisallowedAttributes([
    child
  ], writer);
}
function shouldRemoveLastParagraph(placeholder, root2) {
  if (!placeholder || !placeholder.is("element", "paragraph") || placeholder.childCount) {
    return false;
  }
  if (root2.childCount <= 2 || root2.getChild(root2.childCount - 1) !== placeholder) {
    return false;
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-highlight/dist/index.js
var HighlightCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.value = doc.selection.getAttribute("highlight");
    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, "highlight");
  }
  /**
  * Executes the command.
  *
  * @param options Options for the executed command.
  * @param options.value The value to apply.
  *
  * @fires execute
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    const selection = document2.selection;
    const highlighter = options2.value;
    model.change((writer) => {
      if (selection.isCollapsed) {
        const position = selection.getFirstPosition();
        if (selection.hasAttribute("highlight")) {
          const isSameHighlight = (value) => {
            return value.item.hasAttribute("highlight") && value.item.getAttribute("highlight") === this.value;
          };
          const highlightStart = position.getLastMatchingPosition(isSameHighlight, {
            direction: "backward"
          });
          const highlightEnd = position.getLastMatchingPosition(isSameHighlight);
          const highlightRange = writer.createRange(highlightStart, highlightEnd);
          if (!highlighter || this.value === highlighter) {
            if (!position.isEqual(highlightEnd)) {
              writer.removeAttribute("highlight", highlightRange);
            }
            writer.removeSelectionAttribute("highlight");
          } else {
            if (!position.isEqual(highlightEnd)) {
              writer.setAttribute("highlight", highlighter, highlightRange);
            }
            writer.setSelectionAttribute("highlight", highlighter);
          }
        } else if (highlighter) {
          writer.setSelectionAttribute("highlight", highlighter);
        }
      } else {
        const ranges = model.schema.getValidRanges(selection.getRanges(), "highlight");
        for (const range of ranges) {
          if (highlighter) {
            writer.setAttribute("highlight", highlighter, range);
          } else {
            writer.removeAttribute("highlight", range);
          }
        }
      }
    });
  }
};
var HighlightEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HighlightEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("highlight", {
      options: [
        {
          model: "yellowMarker",
          class: "marker-yellow",
          title: "Yellow marker",
          color: "var(--ck-highlight-marker-yellow)",
          type: "marker"
        },
        {
          model: "greenMarker",
          class: "marker-green",
          title: "Green marker",
          color: "var(--ck-highlight-marker-green)",
          type: "marker"
        },
        {
          model: "pinkMarker",
          class: "marker-pink",
          title: "Pink marker",
          color: "var(--ck-highlight-marker-pink)",
          type: "marker"
        },
        {
          model: "blueMarker",
          class: "marker-blue",
          title: "Blue marker",
          color: "var(--ck-highlight-marker-blue)",
          type: "marker"
        },
        {
          model: "redPen",
          class: "pen-red",
          title: "Red pen",
          color: "var(--ck-highlight-pen-red)",
          type: "pen"
        },
        {
          model: "greenPen",
          class: "pen-green",
          title: "Green pen",
          color: "var(--ck-highlight-pen-green)",
          type: "pen"
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", {
      allowAttributes: "highlight"
    });
    const options2 = editor.config.get("highlight.options");
    editor.conversion.attributeToElement(_buildDefinition(options2));
    editor.commands.add("highlight", new HighlightCommand(editor));
  }
};
function _buildDefinition(options2) {
  const definition = {
    model: {
      key: "highlight",
      values: []
    },
    view: {}
  };
  for (const option of options2) {
    definition.model.values.push(option.model);
    definition.view[option.model] = {
      name: "mark",
      classes: option.class
    };
  }
  return definition;
}
var markerIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
var penIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
var HighlightUI = class extends Plugin {
  /**
  * Returns the localized option titles provided by the plugin.
  *
  * The following localized titles corresponding with default
  * {@link module:highlight/highlightconfig~HighlightConfig#options} are available:
  *
  * * `'Yellow marker'`,
  * * `'Green marker'`,
  * * `'Pink marker'`,
  * * `'Blue marker'`,
  * * `'Red pen'`,
  * * `'Green pen'`.
  */
  get localizedOptionTitles() {
    const t = this.editor.t;
    return {
      "Yellow marker": t("Yellow marker"),
      "Green marker": t("Green marker"),
      "Pink marker": t("Pink marker"),
      "Blue marker": t("Blue marker"),
      "Red pen": t("Red pen"),
      "Green pen": t("Green pen")
    };
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HighlightUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const options2 = this.editor.config.get("highlight.options");
    for (const option of options2) {
      this._addHighlighterButton(option);
    }
    this._addRemoveHighlightButton();
    this._addDropdown(options2);
    this._addMenuBarButton(options2);
  }
  /**
  * Creates the "Remove highlight" button.
  */
  _addRemoveHighlightButton() {
    const t = this.editor.t;
    const command = this.editor.commands.get("highlight");
    this._addButton("removeHighlight", t("Remove highlight"), icons.eraser, null, (button) => {
      button.bind("isEnabled").to(command, "isEnabled");
    });
  }
  /**
  * Creates a toolbar button from the provided highlight option.
  */
  _addHighlighterButton(option) {
    const command = this.editor.commands.get("highlight");
    this._addButton("highlight:" + option.model, option.title, getIconForType(option.type), option.model, decorateHighlightButton);
    function decorateHighlightButton(button) {
      button.bind("isEnabled").to(command, "isEnabled");
      button.bind("isOn").to(command, "value", (value) => value === option.model);
      button.iconView.fillColor = option.color;
      button.isToggleable = true;
    }
  }
  /**
  * Internal method for creating highlight buttons.
  *
  * @param name The name of the button.
  * @param label The label for the button.
  * @param icon The button icon.
  * @param value The `value` property passed to the executed command.
  * @param decorateButton A callback getting ButtonView instance so that it can be further customized.
  */
  _addButton(name, label, icon, value, decorateButton) {
    const editor = this.editor;
    editor.ui.componentFactory.add(name, (locale) => {
      const buttonView = new ButtonView(locale);
      const localized = this.localizedOptionTitles[label] ? this.localizedOptionTitles[label] : label;
      buttonView.set({
        label: localized,
        icon,
        tooltip: true
      });
      buttonView.on("execute", () => {
        editor.execute("highlight", {
          value
        });
        editor.editing.view.focus();
      });
      decorateButton(buttonView);
      return buttonView;
    });
  }
  /**
  * Creates the split button dropdown UI from the provided highlight options.
  */
  _addDropdown(options2) {
    const editor = this.editor;
    const t = editor.t;
    const componentFactory = editor.ui.componentFactory;
    const startingHighlighter = options2[0];
    const optionsMap = options2.reduce((retVal, option) => {
      retVal[option.model] = option;
      return retVal;
    }, {});
    componentFactory.add("highlight", (locale) => {
      const command = editor.commands.get("highlight");
      const dropdownView = createDropdown(locale, SplitButtonView);
      const splitButtonView = dropdownView.buttonView;
      splitButtonView.set({
        label: t("Highlight"),
        tooltip: true,
        // Holds last executed highlighter.
        lastExecuted: startingHighlighter.model,
        // Holds current highlighter to execute (might be different then last used).
        commandValue: startingHighlighter.model,
        isToggleable: true
      });
      splitButtonView.bind("icon").to(command, "value", (value) => getIconForType(getActiveOption(value, "type")));
      splitButtonView.bind("color").to(command, "value", (value) => getActiveOption(value, "color"));
      splitButtonView.bind("commandValue").to(command, "value", (value) => getActiveOption(value, "model"));
      splitButtonView.bind("isOn").to(command, "value", (value) => !!value);
      splitButtonView.delegate("execute").to(dropdownView);
      const buttonsCreator = () => {
        const buttons = options2.map((option) => {
          const buttonView = componentFactory.create("highlight:" + option.model);
          this.listenTo(buttonView, "execute", () => {
            dropdownView.buttonView.set({
              lastExecuted: option.model
            });
          });
          return buttonView;
        });
        buttons.push(new ToolbarSeparatorView());
        buttons.push(componentFactory.create("removeHighlight"));
        return buttons;
      };
      dropdownView.bind("isEnabled").to(command, "isEnabled");
      addToolbarToDropdown(dropdownView, buttonsCreator, {
        enableActiveItemFocusOnDropdownOpen: true,
        ariaLabel: t("Text highlight toolbar")
      });
      bindToolbarIconStyleToActiveColor(dropdownView);
      splitButtonView.on("execute", () => {
        editor.execute("highlight", {
          value: splitButtonView.commandValue
        });
      });
      this.listenTo(dropdownView, "execute", () => {
        editor.editing.view.focus();
      });
      function getActiveOption(current, key) {
        const whichHighlighter = !current || current === splitButtonView.lastExecuted ? splitButtonView.lastExecuted : current;
        return optionsMap[whichHighlighter][key];
      }
      return dropdownView;
    });
  }
  /**
  * Creates the menu bar button for highlight including submenu with available options.
  */
  _addMenuBarButton(options2) {
    const editor = this.editor;
    const t = editor.t;
    const command = editor.commands.get("highlight");
    editor.ui.componentFactory.add("menuBar:highlight", (locale) => {
      const menuView = new MenuBarMenuView(locale);
      menuView.buttonView.set({
        label: t("Highlight"),
        icon: getIconForType("marker")
      });
      menuView.bind("isEnabled").to(command);
      menuView.buttonView.iconView.fillColor = "transparent";
      const listView = new MenuBarMenuListView(locale);
      for (const option of options2) {
        const listItemView2 = new MenuBarMenuListItemView(locale, menuView);
        const buttonView2 = new MenuBarMenuListItemButtonView(locale);
        buttonView2.set({
          label: option.title,
          icon: getIconForType(option.type),
          role: "menuitemradio",
          isToggleable: true
        });
        buttonView2.iconView.fillColor = option.color;
        buttonView2.delegate("execute").to(menuView);
        buttonView2.bind("isOn").to(command, "value", (value) => value === option.model);
        buttonView2.on("execute", () => {
          editor.execute("highlight", {
            value: option.model
          });
          editor.editing.view.focus();
        });
        listItemView2.children.add(buttonView2);
        listView.items.add(listItemView2);
      }
      listView.items.add(new ListSeparatorView(locale));
      const listItemView = new MenuBarMenuListItemView(locale, menuView);
      const buttonView = new MenuBarMenuListItemButtonView(locale);
      buttonView.set({
        label: t("Remove highlight"),
        icon: icons.eraser
      });
      buttonView.delegate("execute").to(menuView);
      buttonView.on("execute", () => {
        editor.execute("highlight", {
          value: null
        });
        editor.editing.view.focus();
      });
      listItemView.children.add(buttonView);
      listView.items.add(listItemView);
      menuView.panelView.children.add(listView);
      return menuView;
    });
  }
};
function bindToolbarIconStyleToActiveColor(dropdownView) {
  const actionView = dropdownView.buttonView.actionView;
  actionView.iconView.bind("fillColor").to(dropdownView.buttonView, "color");
}
function getIconForType(type) {
  return type === "marker" ? markerIcon : penIcon;
}
var Highlight = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      HighlightEditing,
      HighlightUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Highlight";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-horizontal-line/dist/index.js
var HorizontalLineCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    this.isEnabled = isHorizontalLineAllowedInParent(selection, schema, model);
  }
  /**
  * Executes the command.
  *
  * @fires execute
  */
  execute() {
    const model = this.editor.model;
    model.change((writer) => {
      const horizontalElement = writer.createElement("horizontalLine");
      model.insertObject(horizontalElement, null, null, {
        setSelection: "after"
      });
    });
  }
};
function isHorizontalLineAllowedInParent(selection, schema, model) {
  const parent = getInsertHorizontalLineParent(selection, model);
  return schema.checkChild(parent, "horizontalLine");
}
function getInsertHorizontalLineParent(selection, model) {
  const insertionRange = findOptimalInsertionRange(selection, model);
  const parent = insertionRange.start.parent;
  if (parent.isEmpty && !parent.is("element", "$root")) {
    return parent.parent;
  }
  return parent;
}
var HorizontalLineEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HorizontalLineEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const t = editor.t;
    const conversion = editor.conversion;
    schema.register("horizontalLine", {
      inheritAllFrom: "$blockObject"
    });
    conversion.for("dataDowncast").elementToElement({
      model: "horizontalLine",
      view: (modelElement, { writer }) => {
        return writer.createEmptyElement("hr");
      }
    });
    conversion.for("editingDowncast").elementToStructure({
      model: "horizontalLine",
      view: (modelElement, { writer }) => {
        const label = t("Horizontal line");
        const viewWrapper = writer.createContainerElement("div", null, writer.createEmptyElement("hr"));
        writer.addClass("ck-horizontal-line", viewWrapper);
        writer.setCustomProperty("hr", true, viewWrapper);
        return toHorizontalLineWidget(viewWrapper, writer, label);
      }
    });
    conversion.for("upcast").elementToElement({
      view: "hr",
      model: "horizontalLine"
    });
    editor.commands.add("horizontalLine", new HorizontalLineCommand(editor));
  }
};
function toHorizontalLineWidget(viewElement, writer, label) {
  writer.setCustomProperty("horizontalLine", true, viewElement);
  return toWidget(viewElement, writer, {
    label
  });
}
var HorizontalLineUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HorizontalLineUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("horizontalLine", () => {
      const buttonView = this._createButton(ButtonView);
      buttonView.set({
        tooltip: true
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:horizontalLine", () => {
      return this._createButton(MenuBarMenuListItemButtonView);
    });
  }
  /**
  * Creates a button for horizontal line command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get("horizontalLine");
    const view = new ButtonClass(editor.locale);
    const t = locale.t;
    view.set({
      label: t("Horizontal line"),
      icon: icons.horizontalLine
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute("horizontalLine");
      editor.editing.view.focus();
    });
    return view;
  }
};
var HorizontalLine = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      HorizontalLineEditing,
      HorizontalLineUI,
      Widget
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HorizontalLine";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-html-embed/dist/index.js
var HtmlEmbedCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    const selectedRawHtmlElement = getSelectedRawHtmlModelWidget(selection);
    this.isEnabled = isHtmlEmbedAllowedInParent(selection, schema, model);
    this.value = selectedRawHtmlElement ? selectedRawHtmlElement.getAttribute("value") || "" : null;
  }
  /**
  * Executes the command, which either:
  *
  * * creates and inserts a new HTML embed element if none was selected,
  * * updates the content of the HTML embed if one was selected.
  *
  * @fires execute
  * @param value When passed, the value (content) will be set on a new embed or a selected one.
  */
  execute(value) {
    const model = this.editor.model;
    const selection = model.document.selection;
    model.change((writer) => {
      let htmlEmbedElement;
      if (this.value !== null) {
        htmlEmbedElement = getSelectedRawHtmlModelWidget(selection);
      } else {
        htmlEmbedElement = writer.createElement("rawHtml");
        model.insertObject(htmlEmbedElement, null, null, {
          setSelection: "on"
        });
      }
      writer.setAttribute("value", value, htmlEmbedElement);
    });
  }
};
function isHtmlEmbedAllowedInParent(selection, schema, model) {
  const parent = getInsertHtmlEmbedParent(selection, model);
  return schema.checkChild(parent, "rawHtml");
}
function getInsertHtmlEmbedParent(selection, model) {
  const insertionRange = findOptimalInsertionRange(selection, model);
  const parent = insertionRange.start.parent;
  if (parent.isEmpty && !parent.is("rootElement")) {
    return parent.parent;
  }
  return parent;
}
function getSelectedRawHtmlModelWidget(selection) {
  const selectedElement = selection.getSelectedElement();
  if (selectedElement && selectedElement.is("element", "rawHtml")) {
    return selectedElement;
  }
  return null;
}
var HtmlEmbedEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * Keeps references to {@link module:ui/button/buttonview~ButtonView edit, save, and cancel} button instances created for
    * each widget so they can be destroyed if they are no longer in DOM after the editing view was re-rendered.
    */
    __publicField(this, "_widgetButtonViewReferences", /* @__PURE__ */ new Set());
    editor.config.define("htmlEmbed", {
      showPreviews: false,
      sanitizeHtml: (rawHtml) => {
        logWarning("html-embed-provide-sanitize-function");
        return {
          html: rawHtml,
          hasChanged: false
        };
      }
    });
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HtmlEmbedEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    schema.register("rawHtml", {
      inheritAllFrom: "$blockObject",
      allowAttributes: [
        "value"
      ]
    });
    editor.commands.add("htmlEmbed", new HtmlEmbedCommand(editor));
    this._setupConversion();
  }
  /**
  * Prepares converters for the feature.
  */
  _setupConversion() {
    const editor = this.editor;
    const t = editor.t;
    const view = editor.editing.view;
    const widgetButtonViewReferences = this._widgetButtonViewReferences;
    const htmlEmbedConfig = editor.config.get("htmlEmbed");
    this.editor.editing.view.on("render", () => {
      for (const buttonView of widgetButtonViewReferences) {
        if (buttonView.element && buttonView.element.isConnected) {
          return;
        }
        buttonView.destroy();
        widgetButtonViewReferences.delete(buttonView);
      }
    }, {
      priority: "lowest"
    });
    editor.data.registerRawContentMatcher({
      name: "div",
      classes: "raw-html-embed"
    });
    editor.conversion.for("upcast").elementToElement({
      view: {
        name: "div",
        classes: "raw-html-embed"
      },
      model: (viewElement, { writer }) => {
        return writer.createElement("rawHtml", {
          value: viewElement.getCustomProperty("$rawContent")
        });
      }
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "rawHtml",
      view: (modelElement, { writer }) => {
        return writer.createRawElement("div", {
          class: "raw-html-embed"
        }, function(domElement) {
          domElement.innerHTML = modelElement.getAttribute("value") || "";
        });
      }
    });
    editor.conversion.for("editingDowncast").elementToStructure({
      model: {
        name: "rawHtml",
        attributes: [
          "value"
        ]
      },
      view: (modelElement, { writer }) => {
        let domContentWrapper;
        let state;
        let props;
        const viewContentWrapper = writer.createRawElement("div", {
          class: "raw-html-embed__content-wrapper"
        }, function(domElement) {
          domContentWrapper = domElement;
          renderContent({
            editor,
            domElement,
            state,
            props
          });
          domContentWrapper.addEventListener("mousedown", () => {
            if (state.isEditable) {
              const model = editor.model;
              const selectedElement = model.document.selection.getSelectedElement();
              if (selectedElement !== modelElement) {
                model.change((writer2) => writer2.setSelection(modelElement, "on"));
              }
            }
          }, true);
        });
        const rawHtmlApi = {
          makeEditable() {
            state = Object.assign({}, state, {
              isEditable: true
            });
            renderContent({
              domElement: domContentWrapper,
              editor,
              state,
              props
            });
            view.change((writer2) => {
              writer2.setAttribute("data-cke-ignore-events", "true", viewContentWrapper);
            });
            domContentWrapper.querySelector("textarea").focus();
          },
          save(newValue) {
            if (newValue !== state.getRawHtmlValue()) {
              editor.execute("htmlEmbed", newValue);
              editor.editing.view.focus();
            } else {
              this.cancel();
            }
          },
          cancel() {
            state = Object.assign({}, state, {
              isEditable: false
            });
            renderContent({
              domElement: domContentWrapper,
              editor,
              state,
              props
            });
            editor.editing.view.focus();
            view.change((writer2) => {
              writer2.removeAttribute("data-cke-ignore-events", viewContentWrapper);
            });
          }
        };
        state = {
          showPreviews: htmlEmbedConfig.showPreviews,
          isEditable: false,
          getRawHtmlValue: () => modelElement.getAttribute("value") || ""
        };
        props = {
          sanitizeHtml: htmlEmbedConfig.sanitizeHtml,
          textareaPlaceholder: t("Paste raw HTML here..."),
          onEditClick() {
            rawHtmlApi.makeEditable();
          },
          onSaveClick(newValue) {
            rawHtmlApi.save(newValue);
          },
          onCancelClick() {
            rawHtmlApi.cancel();
          }
        };
        const viewContainer = writer.createContainerElement("div", {
          class: "raw-html-embed",
          "data-html-embed-label": t("HTML snippet"),
          dir: editor.locale.uiLanguageDirection
        }, viewContentWrapper);
        writer.setCustomProperty("rawHtmlApi", rawHtmlApi, viewContainer);
        writer.setCustomProperty("rawHtml", true, viewContainer);
        return toWidget(viewContainer, writer, {
          label: t("HTML snippet"),
          hasSelectionHandle: true
        });
      }
    });
    function renderContent({ editor: editor2, domElement, state, props }) {
      domElement.textContent = "";
      const domDocument = domElement.ownerDocument;
      let domTextarea;
      if (state.isEditable) {
        const textareaProps = {
          isDisabled: false,
          placeholder: props.textareaPlaceholder
        };
        domTextarea = createDomTextarea({
          domDocument,
          state,
          props: textareaProps
        });
        domElement.append(domTextarea);
      } else if (state.showPreviews) {
        const previewContainerProps = {
          sanitizeHtml: props.sanitizeHtml
        };
        domElement.append(createPreviewContainer({
          domDocument,
          state,
          props: previewContainerProps,
          editor: editor2
        }));
      } else {
        const textareaProps = {
          isDisabled: true,
          placeholder: props.textareaPlaceholder
        };
        domElement.append(createDomTextarea({
          domDocument,
          state,
          props: textareaProps
        }));
      }
      const buttonsWrapperProps = {
        onEditClick: props.onEditClick,
        onSaveClick: () => {
          props.onSaveClick(domTextarea.value);
        },
        onCancelClick: props.onCancelClick
      };
      domElement.prepend(createDomButtonsWrapper({
        editor: editor2,
        domDocument,
        state,
        props: buttonsWrapperProps
      }));
    }
    function createDomButtonsWrapper({ editor: editor2, domDocument, state, props }) {
      const domButtonsWrapper = createElement(domDocument, "div", {
        class: "raw-html-embed__buttons-wrapper"
      });
      if (state.isEditable) {
        const saveButtonView = createUIButton(editor2, "save", props.onSaveClick);
        const cancelButtonView = createUIButton(editor2, "cancel", props.onCancelClick);
        domButtonsWrapper.append(saveButtonView.element, cancelButtonView.element);
        widgetButtonViewReferences.add(saveButtonView).add(cancelButtonView);
      } else {
        const editButtonView = createUIButton(editor2, "edit", props.onEditClick);
        domButtonsWrapper.append(editButtonView.element);
        widgetButtonViewReferences.add(editButtonView);
      }
      return domButtonsWrapper;
    }
    function createDomTextarea({ domDocument, state, props }) {
      const domTextarea = createElement(domDocument, "textarea", {
        placeholder: props.placeholder,
        class: "ck ck-reset ck-input ck-input-text raw-html-embed__source"
      });
      domTextarea.disabled = props.isDisabled;
      domTextarea.value = state.getRawHtmlValue();
      return domTextarea;
    }
    function createPreviewContainer({ editor: editor2, domDocument, state, props }) {
      const sanitizedOutput = props.sanitizeHtml(state.getRawHtmlValue());
      const placeholderText = state.getRawHtmlValue().length > 0 ? t("No preview available") : t("Empty snippet content");
      const domPreviewPlaceholder = createElement(domDocument, "div", {
        class: "ck ck-reset_all raw-html-embed__preview-placeholder"
      }, placeholderText);
      const domPreviewContent = createElement(domDocument, "div", {
        class: "raw-html-embed__preview-content",
        dir: editor2.locale.contentLanguageDirection
      });
      const domRange = domDocument.createRange();
      const domDocumentFragment = domRange.createContextualFragment(sanitizedOutput.html);
      domPreviewContent.appendChild(domDocumentFragment);
      const domPreviewContainer = createElement(domDocument, "div", {
        class: "raw-html-embed__preview"
      }, [
        domPreviewPlaceholder,
        domPreviewContent
      ]);
      return domPreviewContainer;
    }
  }
};
function createUIButton(editor, type, onClick) {
  const { t } = editor.locale;
  const buttonView = new ButtonView(editor.locale);
  const command = editor.commands.get("htmlEmbed");
  buttonView.set({
    class: `raw-html-embed__${type}-button`,
    icon: icons.pencil,
    tooltip: true,
    tooltipPosition: editor.locale.uiLanguageDirection === "rtl" ? "e" : "w"
  });
  buttonView.render();
  if (type === "edit") {
    buttonView.set({
      icon: icons.pencil,
      label: t("Edit source")
    });
    buttonView.bind("isEnabled").to(command);
  } else if (type === "save") {
    buttonView.set({
      icon: icons.check,
      label: t("Save changes")
    });
    buttonView.bind("isEnabled").to(command);
  } else {
    buttonView.set({
      icon: icons.cancel,
      label: t("Cancel")
    });
  }
  buttonView.on("execute", onClick);
  return buttonView;
}
var HtmlEmbedUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HtmlEmbedUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const t = locale.t;
    editor.ui.componentFactory.add("htmlEmbed", () => {
      const buttonView = this._createButton(ButtonView);
      buttonView.set({
        tooltip: true,
        label: t("Insert HTML")
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:htmlEmbed", () => {
      const buttonView = this._createButton(MenuBarMenuListItemButtonView);
      buttonView.set({
        label: t("HTML snippet")
      });
      return buttonView;
    });
  }
  /**
  * Creates a button for html embed command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const command = editor.commands.get("htmlEmbed");
    const view = new ButtonClass(editor.locale);
    view.set({
      icon: icons.html
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute("htmlEmbed");
      editor.editing.view.focus();
      const rawHtmlApi = editor.editing.view.document.selection.getSelectedElement().getCustomProperty("rawHtmlApi");
      rawHtmlApi.makeEditable();
    });
    return view;
  }
};
var HtmlEmbed = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      HtmlEmbedEditing,
      HtmlEmbedUI,
      Widget
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HtmlEmbed";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-html-support/dist/index.js
function updateViewAttributes(writer, oldViewAttributes, newViewAttributes, viewElement) {
  if (oldViewAttributes) {
    removeViewAttributes(writer, oldViewAttributes, viewElement);
  }
  if (newViewAttributes) {
    setViewAttributes(writer, newViewAttributes, viewElement);
  }
}
function setViewAttributes(writer, viewAttributes, viewElement) {
  if (viewAttributes.attributes) {
    for (const [key, value] of Object.entries(viewAttributes.attributes)) {
      writer.setAttribute(key, value, viewElement);
    }
  }
  if (viewAttributes.styles) {
    writer.setStyle(viewAttributes.styles, viewElement);
  }
  if (viewAttributes.classes) {
    writer.addClass(viewAttributes.classes, viewElement);
  }
}
function removeViewAttributes(writer, viewAttributes, viewElement) {
  if (viewAttributes.attributes) {
    for (const [key] of Object.entries(viewAttributes.attributes)) {
      writer.removeAttribute(key, viewElement);
    }
  }
  if (viewAttributes.styles) {
    for (const style of Object.keys(viewAttributes.styles)) {
      writer.removeStyle(style, viewElement);
    }
  }
  if (viewAttributes.classes) {
    writer.removeClass(viewAttributes.classes, viewElement);
  }
}
function mergeViewElementAttributes(target, source) {
  const result = cloneDeep_default(target);
  let key = "attributes";
  for (key in source) {
    if (key == "classes") {
      result[key] = Array.from(/* @__PURE__ */ new Set([
        ...target[key] || [],
        ...source[key]
      ]));
    } else {
      result[key] = {
        ...target[key],
        ...source[key]
      };
    }
  }
  return result;
}
function modifyGhsAttribute(writer, item, ghsAttributeName, subject, callback) {
  const oldValue = item.getAttribute(ghsAttributeName);
  const newValue = {};
  for (const kind of [
    "attributes",
    "styles",
    "classes"
  ]) {
    if (kind != subject) {
      if (oldValue && oldValue[kind]) {
        newValue[kind] = oldValue[kind];
      }
      continue;
    }
    if (subject == "classes") {
      const values2 = new Set(oldValue && oldValue.classes || []);
      callback(values2);
      if (values2.size) {
        newValue[kind] = Array.from(values2);
      }
      continue;
    }
    const values = new Map(Object.entries(oldValue && oldValue[kind] || {}));
    callback(values);
    if (values.size) {
      newValue[kind] = Object.fromEntries(values);
    }
  }
  if (Object.keys(newValue).length) {
    if (item.is("documentSelection")) {
      writer.setSelectionAttribute(ghsAttributeName, newValue);
    } else {
      writer.setAttribute(ghsAttributeName, newValue, item);
    }
  } else if (oldValue) {
    if (item.is("documentSelection")) {
      writer.removeSelectionAttribute(ghsAttributeName);
    } else {
      writer.removeAttribute(ghsAttributeName, item);
    }
  }
}
function toPascalCase(data) {
  return startCase_default(data).replace(/ /g, "");
}
function getHtmlAttributeName(viewElementName) {
  return `html${toPascalCase(viewElementName)}Attributes`;
}
function viewToModelObjectConverter({ model: modelName }) {
  return (viewElement, conversionApi) => {
    return conversionApi.writer.createElement(modelName, {
      htmlContent: viewElement.getCustomProperty("$rawContent")
    });
  };
}
function toObjectWidgetConverter(editor, { view: viewName, isInline }) {
  const t = editor.t;
  return (modelElement, { writer }) => {
    const widgetLabel = t("HTML object");
    const viewElement = createObjectView(viewName, modelElement, writer);
    const viewAttributes = modelElement.getAttribute(getHtmlAttributeName(viewName));
    writer.addClass("html-object-embed__content", viewElement);
    if (viewAttributes) {
      setViewAttributes(writer, viewAttributes, viewElement);
    }
    const viewContainer = writer.createContainerElement(isInline ? "span" : "div", {
      class: "html-object-embed",
      "data-html-object-embed-label": widgetLabel
    }, viewElement);
    return toWidget(viewContainer, writer, {
      label: widgetLabel
    });
  };
}
function createObjectView(viewName, modelElement, writer) {
  return writer.createRawElement(viewName, null, (domElement, domConverter) => {
    domConverter.setContentOf(domElement, modelElement.getAttribute("htmlContent"));
  });
}
function viewToAttributeInlineConverter({ view: viewName, model: attributeKey2, allowEmpty }, dataFilter) {
  return (dispatcher) => {
    dispatcher.on(`element:${viewName}`, (evt, data, conversionApi) => {
      let viewAttributes = dataFilter.processViewAttributes(data.viewItem, conversionApi);
      if (!viewAttributes && !conversionApi.consumable.test(data.viewItem, {
        name: true
      })) {
        return;
      }
      viewAttributes = viewAttributes || {};
      conversionApi.consumable.consume(data.viewItem, {
        name: true
      });
      if (!data.modelRange) {
        data = Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
      }
      if (allowEmpty && data.modelRange.isCollapsed && Object.keys(viewAttributes).length) {
        const modelElement = conversionApi.writer.createElement("htmlEmptyElement");
        if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
          return;
        }
        const parts = conversionApi.getSplitParts(modelElement);
        data.modelRange = conversionApi.writer.createRange(data.modelRange.start, conversionApi.writer.createPositionAfter(parts[parts.length - 1]));
        conversionApi.updateConversionResult(modelElement, data);
        setAttributeOnItem(modelElement, viewAttributes, conversionApi);
        return;
      }
      for (const node of data.modelRange.getItems()) {
        setAttributeOnItem(node, viewAttributes, conversionApi);
      }
    }, {
      priority: "low"
    });
  };
  function setAttributeOnItem(node, viewAttributes, conversionApi) {
    if (conversionApi.schema.checkAttribute(node, attributeKey2)) {
      const nodeAttributes = node.getAttribute(attributeKey2);
      const attributesToAdd = mergeViewElementAttributes(viewAttributes, nodeAttributes || {});
      conversionApi.writer.setAttribute(attributeKey2, attributesToAdd, node);
    }
  }
}
function emptyInlineModelElementToViewConverter({ model: attributeKey2, view: viewName }, asWidget) {
  return (item, { writer, consumable }) => {
    if (!item.hasAttribute(attributeKey2)) {
      return null;
    }
    const viewElement = writer.createContainerElement(viewName);
    const attributeValue = item.getAttribute(attributeKey2);
    consumable.consume(item, `attribute:${attributeKey2}`);
    setViewAttributes(writer, attributeValue, viewElement);
    viewElement.getFillerOffset = () => null;
    return asWidget ? toWidget(viewElement, writer) : viewElement;
  };
}
function attributeToViewInlineConverter({ priority, view: viewName }) {
  return (attributeValue, conversionApi) => {
    if (!attributeValue) {
      return;
    }
    const { writer } = conversionApi;
    const viewElement = writer.createAttributeElement(viewName, null, {
      priority
    });
    setViewAttributes(writer, attributeValue, viewElement);
    return viewElement;
  };
}
function viewToModelBlockAttributeConverter({ view: viewName }, dataFilter) {
  return (dispatcher) => {
    dispatcher.on(`element:${viewName}`, (evt, data, conversionApi) => {
      if (!data.modelRange || data.modelRange.isCollapsed) {
        return;
      }
      const viewAttributes = dataFilter.processViewAttributes(data.viewItem, conversionApi);
      if (!viewAttributes) {
        return;
      }
      conversionApi.writer.setAttribute(getHtmlAttributeName(data.viewItem.name), viewAttributes, data.modelRange);
    }, {
      priority: "low"
    });
  };
}
function modelToViewBlockAttributeConverter({ view: viewName, model: modelName }) {
  return (dispatcher) => {
    dispatcher.on(`attribute:${getHtmlAttributeName(viewName)}:${modelName}`, (evt, data, conversionApi) => {
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const { attributeOldValue, attributeNewValue } = data;
      const viewWriter = conversionApi.writer;
      const viewElement = conversionApi.mapper.toViewElement(data.item);
      updateViewAttributes(viewWriter, attributeOldValue, attributeNewValue, viewElement);
    });
  };
}
var defaultConfig = {
  block: [
    // Existing features.
    {
      model: "codeBlock",
      view: "pre"
    },
    {
      model: "paragraph",
      view: "p"
    },
    {
      model: "blockQuote",
      view: "blockquote"
    },
    {
      model: "listItem",
      view: "li"
    },
    {
      model: "pageBreak",
      view: "div"
    },
    {
      model: "rawHtml",
      view: "div"
    },
    {
      model: "table",
      view: "table"
    },
    {
      model: "tableRow",
      view: "tr"
    },
    {
      model: "tableCell",
      view: "td"
    },
    {
      model: "tableCell",
      view: "th"
    },
    {
      model: "tableColumnGroup",
      view: "colgroup"
    },
    {
      model: "tableColumn",
      view: "col"
    },
    {
      model: "caption",
      view: "caption"
    },
    {
      model: "caption",
      view: "figcaption"
    },
    {
      model: "imageBlock",
      view: "img"
    },
    {
      model: "imageInline",
      view: "img"
    },
    // Compatibility features.
    {
      model: "htmlP",
      view: "p",
      modelSchema: {
        inheritAllFrom: "$block"
      }
    },
    {
      model: "htmlBlockquote",
      view: "blockquote",
      modelSchema: {
        inheritAllFrom: "$container"
      }
    },
    {
      model: "htmlTable",
      view: "table",
      modelSchema: {
        allowWhere: "$block",
        isBlock: true
      }
    },
    {
      model: "htmlTbody",
      view: "tbody",
      modelSchema: {
        allowIn: "htmlTable",
        isBlock: false
      }
    },
    {
      model: "htmlThead",
      view: "thead",
      modelSchema: {
        allowIn: "htmlTable",
        isBlock: false
      }
    },
    {
      model: "htmlTfoot",
      view: "tfoot",
      modelSchema: {
        allowIn: "htmlTable",
        isBlock: false
      }
    },
    {
      model: "htmlCaption",
      view: "caption",
      modelSchema: {
        allowIn: "htmlTable",
        allowChildren: "$text",
        isBlock: false
      }
    },
    {
      model: "htmlColgroup",
      view: "colgroup",
      modelSchema: {
        allowIn: "htmlTable",
        allowChildren: "col",
        isBlock: false
      }
    },
    {
      model: "htmlCol",
      view: "col",
      modelSchema: {
        allowIn: "htmlColgroup",
        isBlock: false
      }
    },
    {
      model: "htmlTr",
      view: "tr",
      modelSchema: {
        allowIn: [
          "htmlTable",
          "htmlThead",
          "htmlTbody"
        ],
        isLimit: true
      }
    },
    // TODO can also include text.
    {
      model: "htmlTd",
      view: "td",
      modelSchema: {
        allowIn: "htmlTr",
        allowContentOf: "$container",
        isLimit: true,
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlTh",
      view: "th",
      modelSchema: {
        allowIn: "htmlTr",
        allowContentOf: "$container",
        isLimit: true,
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlFigure",
      view: "figure",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    // TODO can also include other block elements.
    {
      model: "htmlFigcaption",
      view: "figcaption",
      modelSchema: {
        allowIn: "htmlFigure",
        allowChildren: "$text",
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlAddress",
      view: "address",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlAside",
      view: "aside",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlMain",
      view: "main",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlDetails",
      view: "details",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    {
      model: "htmlSummary",
      view: "summary",
      modelSchema: {
        allowChildren: [
          "htmlH1",
          "htmlH2",
          "htmlH3",
          "htmlH4",
          "htmlH5",
          "htmlH6",
          "$text"
        ],
        allowIn: "htmlDetails",
        isBlock: false
      }
    },
    {
      model: "htmlDiv",
      view: "div",
      paragraphLikeModel: "htmlDivParagraph",
      modelSchema: {
        inheritAllFrom: "$container"
      }
    },
    // TODO can also include text.
    {
      model: "htmlFieldset",
      view: "fieldset",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    // TODO can also include h1-h6.
    {
      model: "htmlLegend",
      view: "legend",
      modelSchema: {
        allowIn: "htmlFieldset",
        allowChildren: "$text"
      }
    },
    // TODO can also include text.
    {
      model: "htmlHeader",
      view: "header",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlFooter",
      view: "footer",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlForm",
      view: "form",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: true
      }
    },
    {
      model: "htmlHgroup",
      view: "hgroup",
      modelSchema: {
        allowIn: [
          "$root",
          "$container"
        ],
        allowChildren: [
          "paragraph",
          "htmlP",
          "htmlH1",
          "htmlH2",
          "htmlH3",
          "htmlH4",
          "htmlH5",
          "htmlH6"
        ],
        isBlock: false
      }
    },
    {
      model: "htmlH1",
      view: "h1",
      modelSchema: {
        inheritAllFrom: "$block"
      }
    },
    {
      model: "htmlH2",
      view: "h2",
      modelSchema: {
        inheritAllFrom: "$block"
      }
    },
    {
      model: "htmlH3",
      view: "h3",
      modelSchema: {
        inheritAllFrom: "$block"
      }
    },
    {
      model: "htmlH4",
      view: "h4",
      modelSchema: {
        inheritAllFrom: "$block"
      }
    },
    {
      model: "htmlH5",
      view: "h5",
      modelSchema: {
        inheritAllFrom: "$block"
      }
    },
    {
      model: "htmlH6",
      view: "h6",
      modelSchema: {
        inheritAllFrom: "$block"
      }
    },
    {
      model: "$htmlList",
      modelSchema: {
        allowWhere: "$container",
        allowChildren: [
          "$htmlList",
          "htmlLi"
        ],
        isBlock: false
      }
    },
    {
      model: "htmlDir",
      view: "dir",
      modelSchema: {
        inheritAllFrom: "$htmlList"
      }
    },
    {
      model: "htmlMenu",
      view: "menu",
      modelSchema: {
        inheritAllFrom: "$htmlList"
      }
    },
    {
      model: "htmlUl",
      view: "ul",
      modelSchema: {
        inheritAllFrom: "$htmlList"
      }
    },
    {
      model: "htmlOl",
      view: "ol",
      modelSchema: {
        inheritAllFrom: "$htmlList"
      }
    },
    // TODO can also include other block elements.
    {
      model: "htmlLi",
      view: "li",
      modelSchema: {
        allowIn: "$htmlList",
        allowChildren: "$text",
        isBlock: false
      }
    },
    {
      model: "htmlPre",
      view: "pre",
      modelSchema: {
        inheritAllFrom: "$block"
      }
    },
    {
      model: "htmlArticle",
      view: "article",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    {
      model: "htmlSection",
      view: "section",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    // TODO can also include text.
    {
      model: "htmlNav",
      view: "nav",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    },
    {
      model: "htmlDivDl",
      view: "div",
      modelSchema: {
        allowChildren: [
          "htmlDt",
          "htmlDd"
        ],
        allowIn: "htmlDl"
      }
    },
    {
      model: "htmlDl",
      view: "dl",
      modelSchema: {
        allowWhere: "$container",
        allowChildren: [
          "htmlDt",
          "htmlDd",
          "htmlDivDl"
        ],
        isBlock: false
      }
    },
    {
      model: "htmlDt",
      view: "dt",
      modelSchema: {
        allowChildren: "$block",
        isBlock: false
      }
    },
    {
      model: "htmlDd",
      view: "dd",
      modelSchema: {
        allowChildren: "$block",
        isBlock: false
      }
    },
    {
      model: "htmlCenter",
      view: "center",
      modelSchema: {
        inheritAllFrom: "$container",
        isBlock: false
      }
    }
  ],
  inline: [
    // Existing features (attribute set on an existing model element).
    {
      model: "htmlLiAttributes",
      view: "li",
      appliesToBlock: true,
      coupledAttribute: "listItemId"
    },
    {
      model: "htmlOlAttributes",
      view: "ol",
      appliesToBlock: true,
      coupledAttribute: "listItemId"
    },
    {
      model: "htmlUlAttributes",
      view: "ul",
      appliesToBlock: true,
      coupledAttribute: "listItemId"
    },
    {
      model: "htmlFigureAttributes",
      view: "figure",
      appliesToBlock: "table"
    },
    {
      model: "htmlTheadAttributes",
      view: "thead",
      appliesToBlock: "table"
    },
    {
      model: "htmlTbodyAttributes",
      view: "tbody",
      appliesToBlock: "table"
    },
    {
      model: "htmlFigureAttributes",
      view: "figure",
      appliesToBlock: "imageBlock"
    },
    // Compatibility features.
    {
      model: "htmlAcronym",
      view: "acronym",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlTt",
      view: "tt",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlFont",
      view: "font",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlTime",
      view: "time",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlVar",
      view: "var",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlBig",
      view: "big",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlSmall",
      view: "small",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlSamp",
      view: "samp",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlQ",
      view: "q",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlOutput",
      view: "output",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlKbd",
      view: "kbd",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlBdi",
      view: "bdi",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlBdo",
      view: "bdo",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlAbbr",
      view: "abbr",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlA",
      view: "a",
      priority: 5,
      coupledAttribute: "linkHref"
    },
    {
      model: "htmlStrong",
      view: "strong",
      coupledAttribute: "bold",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlB",
      view: "b",
      coupledAttribute: "bold",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlI",
      view: "i",
      coupledAttribute: "italic",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlEm",
      view: "em",
      coupledAttribute: "italic",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlS",
      view: "s",
      coupledAttribute: "strikethrough",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    // TODO According to HTML-spec can behave as div-like element, although CKE4 only handles it as an inline element.
    {
      model: "htmlDel",
      view: "del",
      coupledAttribute: "strikethrough",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    // TODO According to HTML-spec can behave as div-like element, although CKE4 only handles it as an inline element.
    {
      model: "htmlIns",
      view: "ins",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlU",
      view: "u",
      coupledAttribute: "underline",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlSub",
      view: "sub",
      coupledAttribute: "subscript",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlSup",
      view: "sup",
      coupledAttribute: "superscript",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlCode",
      view: "code",
      coupledAttribute: "code",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlMark",
      view: "mark",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlSpan",
      view: "span",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlCite",
      view: "cite",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlLabel",
      view: "label",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    {
      model: "htmlDfn",
      view: "dfn",
      attributeProperties: {
        copyOnEnter: true,
        isFormatting: true
      }
    },
    // Objects.
    {
      model: "htmlObject",
      view: "object",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlIframe",
      view: "iframe",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlInput",
      view: "input",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlButton",
      view: "button",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlTextarea",
      view: "textarea",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlSelect",
      view: "select",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlVideo",
      view: "video",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlEmbed",
      view: "embed",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlOembed",
      view: "oembed",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlAudio",
      view: "audio",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlImg",
      view: "img",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlCanvas",
      view: "canvas",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    // TODO it could be probably represented as non-object element, although it has graphical representation,
    // so probably makes more sense to keep it as an object.
    {
      model: "htmlMeter",
      view: "meter",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    // TODO it could be probably represented as non-object element, although it has graphical representation,
    // so probably makes more sense to keep it as an object.
    {
      model: "htmlProgress",
      view: "progress",
      isObject: true,
      modelSchema: {
        inheritAllFrom: "$inlineObject"
      }
    },
    {
      model: "htmlScript",
      view: "script",
      modelSchema: {
        allowWhere: [
          "$text",
          "$block"
        ],
        isInline: true
      }
    },
    {
      model: "htmlStyle",
      view: "style",
      modelSchema: {
        allowWhere: [
          "$text",
          "$block"
        ],
        isInline: true
      }
    },
    {
      model: "htmlCustomElement",
      view: "$customElement",
      modelSchema: {
        allowWhere: [
          "$text",
          "$block"
        ],
        allowAttributesOf: "$inlineObject",
        isInline: true
      }
    }
  ]
};
var DataSchema = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * A map of registered data schema definitions.
    */
    __publicField(this, "_definitions", []);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "DataSchema";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    for (const definition of defaultConfig.block) {
      this.registerBlockElement(definition);
    }
    for (const definition of defaultConfig.inline) {
      this.registerInlineElement(definition);
    }
  }
  /**
  * Add new data schema definition describing block element.
  */
  registerBlockElement(definition) {
    this._definitions.push({
      ...definition,
      isBlock: true
    });
  }
  /**
  * Add new data schema definition describing inline element.
  */
  registerInlineElement(definition) {
    this._definitions.push({
      ...definition,
      isInline: true
    });
  }
  /**
  * Updates schema definition describing block element with new properties.
  *
  * Creates new scheme if it doesn't exist.
  * Array properties are concatenated with original values.
  *
  * @param definition Definition update.
  */
  extendBlockElement(definition) {
    this._extendDefinition({
      ...definition,
      isBlock: true
    });
  }
  /**
  * Updates schema definition describing inline element with new properties.
  *
  * Creates new scheme if it doesn't exist.
  * Array properties are concatenated with original values.
  *
  * @param definition Definition update.
  */
  extendInlineElement(definition) {
    this._extendDefinition({
      ...definition,
      isInline: true
    });
  }
  /**
  * Returns all definitions matching the given view name.
  *
  * @param includeReferences Indicates if this method should also include definitions of referenced models.
  */
  getDefinitionsForView(viewName, includeReferences = false) {
    const definitions = /* @__PURE__ */ new Set();
    for (const definition of this._getMatchingViewDefinitions(viewName)) {
      if (includeReferences) {
        for (const reference of this._getReferences(definition.model)) {
          definitions.add(reference);
        }
      }
      definitions.add(definition);
    }
    return definitions;
  }
  /**
  * Returns definitions matching the given model name.
  */
  getDefinitionsForModel(modelName) {
    return this._definitions.filter((definition) => definition.model == modelName);
  }
  /**
  * Returns definitions matching the given view name.
  */
  _getMatchingViewDefinitions(viewName) {
    return this._definitions.filter((def) => def.view && testViewName(viewName, def.view));
  }
  /**
  * Resolves all definition references registered for the given data schema definition.
  *
  * @param modelName Data schema model name.
  */
  *_getReferences(modelName) {
    const inheritProperties = [
      "inheritAllFrom",
      "inheritTypesFrom",
      "allowWhere",
      "allowContentOf",
      "allowAttributesOf"
    ];
    const definitions = this._definitions.filter((definition) => definition.model == modelName);
    for (const { modelSchema } of definitions) {
      if (!modelSchema) {
        continue;
      }
      for (const property of inheritProperties) {
        for (const referenceName of toArray(modelSchema[property] || [])) {
          const definitions2 = this._definitions.filter((definition) => definition.model == referenceName);
          for (const definition of definitions2) {
            if (referenceName !== modelName) {
              yield* this._getReferences(definition.model);
              yield definition;
            }
          }
        }
      }
    }
  }
  /**
  * Updates schema definition with new properties.
  *
  * Creates new scheme if it doesn't exist.
  * Array properties are concatenated with original values.
  *
  * @param definition Definition update.
  */
  _extendDefinition(definition) {
    const currentDefinitions = Array.from(this._definitions.entries()).filter(([, currentDefinition]) => currentDefinition.model == definition.model);
    if (currentDefinitions.length == 0) {
      this._definitions.push(definition);
      return;
    }
    for (const [idx, currentDefinition] of currentDefinitions) {
      this._definitions[idx] = mergeWith_default({}, currentDefinition, definition, (target, source) => {
        return Array.isArray(target) ? target.concat(source) : void 0;
      });
    }
  }
};
function testViewName(pattern, viewName) {
  if (typeof pattern === "string") {
    return pattern === viewName;
  }
  if (pattern instanceof RegExp) {
    return pattern.test(viewName);
  }
  return false;
}
var DataFilter = class extends Plugin {
  constructor(editor) {
    super(editor);
    /**
    * An instance of the {@link module:html-support/dataschema~DataSchema}.
    */
    __publicField(this, "_dataSchema");
    /**
    * {@link module:engine/view/matcher~Matcher Matcher} instance describing rules upon which
    * content attributes should be allowed.
    */
    __publicField(this, "_allowedAttributes");
    /**
    * {@link module:engine/view/matcher~Matcher Matcher} instance describing rules upon which
    * content attributes should be disallowed.
    */
    __publicField(this, "_disallowedAttributes");
    /**
     * Allowed element definitions by {@link module:html-support/datafilter~DataFilter#allowElement} method.
    */
    __publicField(this, "_allowedElements");
    /**
    * Disallowed element names by {@link module:html-support/datafilter~DataFilter#disallowElement} method.
    */
    __publicField(this, "_disallowedElements");
    /**
     * Indicates if {@link module:engine/controller/datacontroller~DataController editor's data controller}
     * data has been already initialized.
    */
    __publicField(this, "_dataInitialized");
    /**
    * Cached map of coupled attributes. Keys are the feature attributes names
    * and values are arrays with coupled GHS attributes names.
    */
    __publicField(this, "_coupledAttributes");
    this._dataSchema = editor.plugins.get("DataSchema");
    this._allowedAttributes = new Matcher();
    this._disallowedAttributes = new Matcher();
    this._allowedElements = /* @__PURE__ */ new Set();
    this._disallowedElements = /* @__PURE__ */ new Set();
    this._dataInitialized = false;
    this._coupledAttributes = null;
    this._registerElementsAfterInit();
    this._registerElementHandlers();
    this._registerCoupledAttributesPostFixer();
    this._registerAssociatedHtmlAttributesPostFixer();
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "DataFilter";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataSchema,
      Widget
    ];
  }
  /**
  * Load a configuration of one or many elements, where their attributes should be allowed.
  *
  * **Note**: Rules will be applied just before next data pipeline data init or set.
  *
  * @param config Configuration of elements that should have their attributes accepted in the editor.
  */
  loadAllowedConfig(config) {
    for (const pattern of config) {
      const elementName = pattern.name || /[\s\S]+/;
      const rules3 = splitRules(pattern);
      this.allowElement(elementName);
      rules3.forEach((pattern2) => this.allowAttributes(pattern2));
    }
  }
  /**
  * Load a configuration of one or many elements, where their attributes should be disallowed.
  *
  * **Note**: Rules will be applied just before next data pipeline data init or set.
  *
  * @param config Configuration of elements that should have their attributes rejected from the editor.
  */
  loadDisallowedConfig(config) {
    for (const pattern of config) {
      const elementName = pattern.name || /[\s\S]+/;
      const rules3 = splitRules(pattern);
      if (rules3.length == 0) {
        this.disallowElement(elementName);
      } else {
        rules3.forEach((pattern2) => this.disallowAttributes(pattern2));
      }
    }
  }
  /**
  * Load a configuration of one or many elements, where when empty should be allowed.
  *
  * **Note**: It modifies DataSchema so must be loaded before registering filtering rules.
  *
  * @param config Configuration of elements that should be preserved even if empty.
  */
  loadAllowedEmptyElementsConfig(config) {
    for (const elementName of config) {
      this.allowEmptyElement(elementName);
    }
  }
  /**
  * Allow the given element in the editor context.
  *
  * This method will only allow elements described by the {@link module:html-support/dataschema~DataSchema} used
  * to create data filter.
  *
  * **Note**: Rules will be applied just before next data pipeline data init or set.
  *
  * @param viewName String or regular expression matching view name.
  */
  allowElement(viewName) {
    for (const definition of this._dataSchema.getDefinitionsForView(viewName, true)) {
      this._addAllowedElement(definition);
      this._coupledAttributes = null;
    }
  }
  /**
  * Disallow the given element in the editor context.
  *
  * This method will only disallow elements described by the {@link module:html-support/dataschema~DataSchema} used
  * to create data filter.
  *
  * @param viewName String or regular expression matching view name.
  */
  disallowElement(viewName) {
    for (const definition of this._dataSchema.getDefinitionsForView(viewName, false)) {
      this._disallowedElements.add(definition.view);
    }
  }
  /**
  * Allow the given empty element in the editor context.
  *
  * This method will only allow elements described by the {@link module:html-support/dataschema~DataSchema} used
  * to create data filter.
  *
  * **Note**: It modifies DataSchema so must be called before registering filtering rules.
  *
  * @param viewName String or regular expression matching view name.
  */
  allowEmptyElement(viewName) {
    for (const definition of this._dataSchema.getDefinitionsForView(viewName, true)) {
      if (definition.isInline) {
        this._dataSchema.extendInlineElement({
          ...definition,
          allowEmpty: true
        });
      }
    }
  }
  /**
  * Allow the given attributes for view element allowed by {@link #allowElement} method.
  *
  * @param config Pattern matching all attributes which should be allowed.
  */
  allowAttributes(config) {
    this._allowedAttributes.add(config);
  }
  /**
  * Disallow the given attributes for view element allowed by {@link #allowElement} method.
  *
  * @param config Pattern matching all attributes which should be disallowed.
  */
  disallowAttributes(config) {
    this._disallowedAttributes.add(config);
  }
  /**
  * Processes all allowed and disallowed attributes on the view element by consuming them and returning the allowed ones.
  *
  * This method applies the configuration set up by {@link #allowAttributes `allowAttributes()`}
  * and {@link #disallowAttributes `disallowAttributes()`} over the given view element by consuming relevant attributes.
  * It returns the allowed attributes that were found on the given view element for further processing by integration code.
  *
  * ```ts
  * dispatcher.on( 'element:myElement', ( evt, data, conversionApi ) => {
  * 	// Get rid of disallowed and extract all allowed attributes from a viewElement.
  * 	const viewAttributes = dataFilter.processViewAttributes( data.viewItem, conversionApi );
  * 	// Do something with them, i.e. store inside a model as a dictionary.
  * 	if ( viewAttributes ) {
  * 		conversionApi.writer.setAttribute( 'htmlAttributesOfMyElement', viewAttributes, data.modelRange );
  * 	}
  * } );
  * ```
  *
  * @see module:engine/conversion/viewconsumable~ViewConsumable#consume
  *
  * @returns Object with following properties:
  * - attributes Set with matched attribute names.
  * - styles Set with matched style names.
  * - classes Set with matched class names.
  */
  processViewAttributes(viewElement, conversionApi) {
    const { consumable } = conversionApi;
    matchAndConsumeAttributes(viewElement, this._disallowedAttributes, consumable);
    return prepareGHSAttribute(viewElement, matchAndConsumeAttributes(viewElement, this._allowedAttributes, consumable));
  }
  /**
  * Adds allowed element definition and fires registration event.
  */
  _addAllowedElement(definition) {
    if (this._allowedElements.has(definition)) {
      return;
    }
    this._allowedElements.add(definition);
    if ("appliesToBlock" in definition && typeof definition.appliesToBlock == "string") {
      for (const relatedDefinition of this._dataSchema.getDefinitionsForModel(definition.appliesToBlock)) {
        if (relatedDefinition.isBlock) {
          this._addAllowedElement(relatedDefinition);
        }
      }
    }
    if (this._dataInitialized) {
      this.editor.data.once("set", () => {
        this._fireRegisterEvent(definition);
      }, {
        // With the highest priority listener we are able to register elements right before
        // running data conversion.
        priority: priorities.highest + 1
      });
    }
  }
  /**
   * Registers elements allowed by {@link module:html-support/datafilter~DataFilter#allowElement} method
   * once {@link module:engine/controller/datacontroller~DataController editor's data controller} is initialized.
  */
  _registerElementsAfterInit() {
    this.editor.data.on("init", () => {
      this._dataInitialized = true;
      for (const definition of this._allowedElements) {
        this._fireRegisterEvent(definition);
      }
    }, {
      // With highest priority listener we are able to register elements right before
      // running data conversion. Also:
      // * Make sure that priority is higher than the one used by `RealTimeCollaborationClient`,
      // as RTC is stopping event propagation.
      // * Make sure no other features hook into this event before GHS because otherwise the
      // downcast conversion (for these features) could run before GHS registered its converters
      // (https://github.com/ckeditor/ckeditor5/issues/11356).
      priority: priorities.highest + 1
    });
  }
  /**
  * Registers default element handlers.
  */
  _registerElementHandlers() {
    this.on("register", (evt, definition) => {
      const schema = this.editor.model.schema;
      if (definition.isObject && !schema.isRegistered(definition.model)) {
        this._registerObjectElement(definition);
      } else if (definition.isBlock) {
        this._registerBlockElement(definition);
      } else if (definition.isInline) {
        this._registerInlineElement(definition);
      } else {
        throw new CKEditorError("data-filter-invalid-definition", null, definition);
      }
      evt.stop();
    }, {
      priority: "lowest"
    });
  }
  /**
  * Registers a model post-fixer that is removing coupled GHS attributes of inline elements. Those attributes
  * are removed if a coupled feature attribute is removed.
  *
  * For example, consider following HTML:
  *
  * ```html
  * <a href="foo.html" id="myId">bar</a>
  * ```
  *
  * Which would be upcasted to following text node in the model:
  *
  * ```html
  * <$text linkHref="foo.html" htmlA="{ attributes: { id: 'myId' } }">bar</$text>
  * ```
  *
  * When the user removes the link from that text (using UI), only `linkHref` attribute would be removed:
  *
  * ```html
  * <$text htmlA="{ attributes: { id: 'myId' } }">bar</$text>
  * ```
  *
  * The `htmlA` attribute would stay in the model and would cause GHS to generate an `<a>` element.
  * This is incorrect from UX point of view, as the user wanted to remove the whole link (not only `href`).
  */
  _registerCoupledAttributesPostFixer() {
    const model = this.editor.model;
    const selection = model.document.selection;
    model.document.registerPostFixer((writer) => {
      const changes = model.document.differ.getChanges();
      let changed = false;
      const coupledAttributes = this._getCoupledAttributesMap();
      for (const change of changes) {
        if (change.type != "attribute" || change.attributeNewValue !== null) {
          continue;
        }
        const attributeKeys = coupledAttributes.get(change.attributeKey);
        if (!attributeKeys) {
          continue;
        }
        for (const { item } of change.range.getWalker()) {
          for (const attributeKey2 of attributeKeys) {
            if (item.hasAttribute(attributeKey2)) {
              writer.removeAttribute(attributeKey2, item);
              changed = true;
            }
          }
        }
      }
      return changed;
    });
    this.listenTo(selection, "change:attribute", (evt, { attributeKeys }) => {
      const removeAttributes = /* @__PURE__ */ new Set();
      const coupledAttributes = this._getCoupledAttributesMap();
      for (const attributeKey2 of attributeKeys) {
        if (selection.hasAttribute(attributeKey2)) {
          continue;
        }
        const coupledAttributeKeys = coupledAttributes.get(attributeKey2);
        if (!coupledAttributeKeys) {
          continue;
        }
        for (const coupledAttributeKey of coupledAttributeKeys) {
          if (selection.hasAttribute(coupledAttributeKey)) {
            removeAttributes.add(coupledAttributeKey);
          }
        }
      }
      if (removeAttributes.size == 0) {
        return;
      }
      model.change((writer) => {
        for (const attributeKey2 of removeAttributes) {
          writer.removeSelectionAttribute(attributeKey2);
        }
      });
    });
  }
  /**
  * Removes `html*Attributes` attributes from incompatible elements.
  *
  * For example, consider the following HTML:
  *
  * ```html
  * <heading2 htmlH2Attributes="...">foobar[]</heading2>
  * ```
  *
  * Pressing `enter` creates a new `paragraph` element that inherits
  * the `htmlH2Attributes` attribute from `heading2`.
  *
  * ```html
  * <heading2 htmlH2Attributes="...">foobar</heading2>
  * <paragraph htmlH2Attributes="...">[]</paragraph>
  * ```
  *
  * This postfixer ensures that this doesn't happen, and that elements can
  * only have `html*Attributes` associated with them,
  * e.g.: `htmlPAttributes` for `<p>`, `htmlDivAttributes` for `<div>`, etc.
  *
  * With it enabled, pressing `enter` at the end of `<heading2>` will create
  * a new paragraph without the `htmlH2Attributes` attribute.
  *
  * ```html
  * <heading2 htmlH2Attributes="...">foobar</heading2>
  * <paragraph>[]</paragraph>
  * ```
  */
  _registerAssociatedHtmlAttributesPostFixer() {
    const model = this.editor.model;
    model.document.registerPostFixer((writer) => {
      const changes = model.document.differ.getChanges();
      let changed = false;
      for (const change of changes) {
        if (change.type !== "insert" || change.name === "$text") {
          continue;
        }
        for (const attr of change.attributes.keys()) {
          if (!attr.startsWith("html") || !attr.endsWith("Attributes")) {
            continue;
          }
          if (!model.schema.checkAttribute(change.name, attr)) {
            writer.removeAttribute(attr, change.position.nodeAfter);
            changed = true;
          }
        }
      }
      return changed;
    });
  }
  /**
  * Collects the map of coupled attributes. The returned map is keyed by the feature attribute name
  * and coupled GHS attribute names are stored in the value array.
  */
  _getCoupledAttributesMap() {
    if (this._coupledAttributes) {
      return this._coupledAttributes;
    }
    this._coupledAttributes = /* @__PURE__ */ new Map();
    for (const definition of this._allowedElements) {
      if (definition.coupledAttribute && definition.model) {
        const attributeNames = this._coupledAttributes.get(definition.coupledAttribute);
        if (attributeNames) {
          attributeNames.push(definition.model);
        } else {
          this._coupledAttributes.set(definition.coupledAttribute, [
            definition.model
          ]);
        }
      }
    }
    return this._coupledAttributes;
  }
  /**
  * Fires `register` event for the given element definition.
  */
  _fireRegisterEvent(definition) {
    if (definition.view && this._disallowedElements.has(definition.view)) {
      return;
    }
    this.fire(definition.view ? `register:${definition.view}` : "register", definition);
  }
  /**
  * Registers object element and attribute converters for the given data schema definition.
  */
  _registerObjectElement(definition) {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const { view: viewName, model: modelName } = definition;
    schema.register(modelName, definition.modelSchema);
    if (!viewName) {
      return;
    }
    schema.extend(definition.model, {
      allowAttributes: [
        getHtmlAttributeName(viewName),
        "htmlContent"
      ]
    });
    editor.data.registerRawContentMatcher({
      name: viewName
    });
    conversion.for("upcast").elementToElement({
      view: viewName,
      model: viewToModelObjectConverter(definition),
      // With a `low` priority, `paragraph` plugin auto-paragraphing mechanism is executed. Make sure
      // this listener is called before it. If not, some elements will be transformed into a paragraph.
      // `+ 2` is used to take priority over `_addDefaultH1Conversion` in the Heading plugin.
      converterPriority: priorities.low + 2
    });
    conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, this));
    conversion.for("editingDowncast").elementToStructure({
      model: {
        name: modelName,
        attributes: [
          getHtmlAttributeName(viewName)
        ]
      },
      view: toObjectWidgetConverter(editor, definition)
    });
    conversion.for("dataDowncast").elementToElement({
      model: modelName,
      view: (modelElement, { writer }) => {
        return createObjectView(viewName, modelElement, writer);
      }
    });
    conversion.for("dataDowncast").add(modelToViewBlockAttributeConverter(definition));
  }
  /**
  * Registers block element and attribute converters for the given data schema definition.
  */
  _registerBlockElement(definition) {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const { view: viewName, model: modelName } = definition;
    if (!schema.isRegistered(definition.model)) {
      schema.register(definition.model, definition.modelSchema);
      if (!viewName) {
        return;
      }
      conversion.for("upcast").elementToElement({
        model: modelName,
        view: viewName,
        // With a `low` priority, `paragraph` plugin auto-paragraphing mechanism is executed. Make sure
        // this listener is called before it. If not, some elements will be transformed into a paragraph.
        // `+ 2` is used to take priority over `_addDefaultH1Conversion` in the Heading plugin.
        converterPriority: priorities.low + 2
      });
      conversion.for("downcast").elementToElement({
        model: modelName,
        view: viewName
      });
    }
    if (!viewName) {
      return;
    }
    schema.extend(definition.model, {
      allowAttributes: getHtmlAttributeName(viewName)
    });
    conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, this));
    conversion.for("downcast").add(modelToViewBlockAttributeConverter(definition));
  }
  /**
  * Registers inline element and attribute converters for the given data schema definition.
  *
  * Extends `$text` model schema to allow the given definition model attribute and its properties.
  */
  _registerInlineElement(definition) {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const attributeKey2 = definition.model;
    if (definition.appliesToBlock) {
      return;
    }
    schema.extend("$text", {
      allowAttributes: attributeKey2
    });
    if (definition.attributeProperties) {
      schema.setAttributeProperties(attributeKey2, definition.attributeProperties);
    }
    conversion.for("upcast").add(viewToAttributeInlineConverter(definition, this));
    conversion.for("downcast").attributeToElement({
      model: attributeKey2,
      view: attributeToViewInlineConverter(definition)
    });
    if (!definition.allowEmpty) {
      return;
    }
    schema.setAttributeProperties(attributeKey2, {
      copyFromObject: false
    });
    if (!schema.isRegistered("htmlEmptyElement")) {
      schema.register("htmlEmptyElement", {
        inheritAllFrom: "$inlineObject"
      });
    }
    editor.data.htmlProcessor.domConverter.registerInlineObjectMatcher((element) => {
      if (element.name == definition.view && element.isEmpty && Array.from(element.getAttributeKeys()).length) {
        return {
          name: true
        };
      }
      return null;
    });
    conversion.for("editingDowncast").elementToElement({
      model: "htmlEmptyElement",
      view: emptyInlineModelElementToViewConverter(definition, true)
    });
    conversion.for("dataDowncast").elementToElement({
      model: "htmlEmptyElement",
      view: emptyInlineModelElementToViewConverter(definition)
    });
  }
};
function matchAndConsumeAttributes(viewElement, matcher, consumable) {
  const matches = matcher.matchAll(viewElement) || [];
  const stylesProcessor = viewElement.document.stylesProcessor;
  return matches.reduce((result, { match }) => {
    for (const style of match.styles || []) {
      const sortedRelatedStyles = stylesProcessor.getRelatedStyles(style).filter((relatedStyle) => relatedStyle.split("-").length > style.split("-").length).sort((a, b) => b.split("-").length - a.split("-").length);
      for (const relatedStyle of sortedRelatedStyles) {
        if (consumable.consume(viewElement, {
          styles: [
            relatedStyle
          ]
        })) {
          result.styles.push(relatedStyle);
        }
      }
      if (consumable.consume(viewElement, {
        styles: [
          style
        ]
      })) {
        result.styles.push(style);
      }
    }
    for (const className of match.classes || []) {
      if (consumable.consume(viewElement, {
        classes: [
          className
        ]
      })) {
        result.classes.push(className);
      }
    }
    for (const attributeName of match.attributes || []) {
      if (consumable.consume(viewElement, {
        attributes: [
          attributeName
        ]
      })) {
        result.attributes.push(attributeName);
      }
    }
    return result;
  }, {
    attributes: [],
    classes: [],
    styles: []
  });
}
function prepareGHSAttribute(viewElement, { attributes, classes, styles }) {
  if (!attributes.length && !classes.length && !styles.length) {
    return null;
  }
  return {
    ...attributes.length && {
      attributes: getAttributes(viewElement, attributes)
    },
    ...styles.length && {
      styles: getReducedStyles(viewElement, styles)
    },
    ...classes.length && {
      classes
    }
  };
}
function getAttributes(viewElement, attributes) {
  const attributesObject = {};
  for (const key of attributes) {
    const value = viewElement.getAttribute(key);
    if (value !== void 0 && isValidAttributeName(key)) {
      attributesObject[key] = value;
    }
  }
  return attributesObject;
}
function getReducedStyles(viewElement, styles) {
  const stylesMap = new StylesMap(viewElement.document.stylesProcessor);
  for (const key of styles) {
    const styleValue = viewElement.getStyle(key);
    if (styleValue !== void 0) {
      stylesMap.set(key, styleValue);
    }
  }
  return Object.fromEntries(stylesMap.getStylesEntries());
}
function splitPattern(pattern, attributeName) {
  const { name } = pattern;
  const attributeValue = pattern[attributeName];
  if (isPlainObject_default(attributeValue)) {
    return Object.entries(attributeValue).map(([key, value]) => ({
      name,
      [attributeName]: {
        [key]: value
      }
    }));
  }
  if (Array.isArray(attributeValue)) {
    return attributeValue.map((value) => ({
      name,
      [attributeName]: [
        value
      ]
    }));
  }
  return [
    pattern
  ];
}
function splitRules(rules3) {
  const { name, attributes, classes, styles } = rules3;
  const splitRules2 = [];
  if (attributes) {
    splitRules2.push(...splitPattern({
      name,
      attributes
    }, "attributes"));
  }
  if (classes) {
    splitRules2.push(...splitPattern({
      name,
      classes
    }, "classes"));
  }
  if (styles) {
    splitRules2.push(...splitPattern({
      name,
      styles
    }, "styles"));
  }
  return splitRules2;
}
var CodeBlockElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CodeBlockElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    if (!this.editor.plugins.has("CodeBlockEditing")) {
      return;
    }
    const dataFilter = this.editor.plugins.get(DataFilter);
    dataFilter.on("register:pre", (evt, definition) => {
      if (definition.model !== "codeBlock") {
        return;
      }
      const editor = this.editor;
      const schema = editor.model.schema;
      const conversion = editor.conversion;
      schema.extend("codeBlock", {
        allowAttributes: [
          "htmlPreAttributes",
          "htmlContentAttributes"
        ]
      });
      conversion.for("upcast").add(viewToModelCodeBlockAttributeConverter(dataFilter));
      conversion.for("downcast").add(modelToViewCodeBlockAttributeConverter());
      evt.stop();
    });
  }
};
function viewToModelCodeBlockAttributeConverter(dataFilter) {
  return (dispatcher) => {
    dispatcher.on("element:code", (evt, data, conversionApi) => {
      const viewCodeElement = data.viewItem;
      const viewPreElement = viewCodeElement.parent;
      if (!viewPreElement || !viewPreElement.is("element", "pre")) {
        return;
      }
      preserveElementAttributes(viewPreElement, "htmlPreAttributes");
      preserveElementAttributes(viewCodeElement, "htmlContentAttributes");
      function preserveElementAttributes(viewElement, attributeName) {
        const viewAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
        if (viewAttributes) {
          conversionApi.writer.setAttribute(attributeName, viewAttributes, data.modelRange);
        }
      }
    }, {
      priority: "low"
    });
  };
}
function modelToViewCodeBlockAttributeConverter() {
  return (dispatcher) => {
    dispatcher.on("attribute:htmlPreAttributes:codeBlock", (evt, data, conversionApi) => {
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const { attributeOldValue, attributeNewValue } = data;
      const viewCodeElement = conversionApi.mapper.toViewElement(data.item);
      const viewPreElement = viewCodeElement.parent;
      updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewPreElement);
    });
    dispatcher.on("attribute:htmlContentAttributes:codeBlock", (evt, data, conversionApi) => {
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const { attributeOldValue, attributeNewValue } = data;
      const viewCodeElement = conversionApi.mapper.toViewElement(data.item);
      updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewCodeElement);
    });
  };
}
var DualContentModelElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "DualContentModelElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const dataFilter = this.editor.plugins.get(DataFilter);
    dataFilter.on("register", (evt, definition) => {
      const blockDefinition = definition;
      const editor = this.editor;
      const schema = editor.model.schema;
      const conversion = editor.conversion;
      if (!blockDefinition.paragraphLikeModel) {
        return;
      }
      if (schema.isRegistered(blockDefinition.model) || schema.isRegistered(blockDefinition.paragraphLikeModel)) {
        return;
      }
      const paragraphLikeModelDefinition = {
        model: blockDefinition.paragraphLikeModel,
        view: blockDefinition.view
      };
      schema.register(blockDefinition.model, blockDefinition.modelSchema);
      schema.register(paragraphLikeModelDefinition.model, {
        inheritAllFrom: "$block"
      });
      conversion.for("upcast").elementToElement({
        view: blockDefinition.view,
        model: (viewElement, { writer }) => {
          if (this._hasBlockContent(viewElement)) {
            return writer.createElement(blockDefinition.model);
          }
          return writer.createElement(paragraphLikeModelDefinition.model);
        },
        // With a `low` priority, `paragraph` plugin auto-paragraphing mechanism is executed. Make sure
        // this listener is called before it. If not, some elements will be transformed into a paragraph.
        converterPriority: priorities.low + 0.5
      });
      conversion.for("downcast").elementToElement({
        view: blockDefinition.view,
        model: blockDefinition.model
      });
      this._addAttributeConversion(blockDefinition);
      conversion.for("downcast").elementToElement({
        view: paragraphLikeModelDefinition.view,
        model: paragraphLikeModelDefinition.model
      });
      this._addAttributeConversion(paragraphLikeModelDefinition);
      evt.stop();
    });
  }
  /**
  * Checks whether the given view element includes any other block element.
  */
  _hasBlockContent(viewElement) {
    const view = this.editor.editing.view;
    const blockElements2 = view.domConverter.blockElements;
    for (const viewItem of view.createRangeIn(viewElement).getItems()) {
      if (viewItem.is("element") && blockElements2.includes(viewItem.name)) {
        return true;
      }
    }
    return false;
  }
  /**
  * Adds attribute filtering conversion for the given data schema.
  */
  _addAttributeConversion(definition) {
    const editor = this.editor;
    const conversion = editor.conversion;
    const dataFilter = editor.plugins.get(DataFilter);
    editor.model.schema.extend(definition.model, {
      allowAttributes: getHtmlAttributeName(definition.view)
    });
    conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, dataFilter));
    conversion.for("downcast").add(modelToViewBlockAttributeConverter(definition));
  }
};
var HeadingElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataSchema,
      Enter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HeadingElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("HeadingEditing")) {
      return;
    }
    const options2 = editor.config.get("heading.options");
    this.registerHeadingElements(editor, options2);
  }
  /**
  * Registers all elements supported by HeadingEditing to enable custom attributes for those elements.
  */
  registerHeadingElements(editor, options2) {
    const dataSchema = editor.plugins.get(DataSchema);
    const headerModels = [];
    for (const option of options2) {
      if ("model" in option && "view" in option) {
        dataSchema.registerBlockElement({
          view: option.view,
          model: option.model
        });
        headerModels.push(option.model);
      }
    }
    dataSchema.extendBlockElement({
      model: "htmlHgroup",
      modelSchema: {
        allowChildren: headerModels
      }
    });
    dataSchema.extendBlockElement({
      model: "htmlSummary",
      modelSchema: {
        allowChildren: headerModels
      }
    });
  }
};
function getDescendantElement(writer, containerElement, elementName) {
  const range = writer.createRangeOn(containerElement);
  for (const { item } of range.getWalker()) {
    if (item.is("element", elementName)) {
      return item;
    }
  }
}
var ImageElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("ImageInlineEditing") && !editor.plugins.has("ImageBlockEditing")) {
      return;
    }
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const dataFilter = editor.plugins.get(DataFilter);
    dataFilter.on("register:figure", () => {
      conversion.for("upcast").add(viewToModelFigureAttributeConverter$1(dataFilter));
    });
    dataFilter.on("register:img", (evt, definition) => {
      if (definition.model !== "imageBlock" && definition.model !== "imageInline") {
        return;
      }
      if (schema.isRegistered("imageBlock")) {
        schema.extend("imageBlock", {
          allowAttributes: [
            "htmlImgAttributes",
            // Figure and Link don't have model counterpart.
            // We will preserve attributes on image model element using these attribute keys.
            "htmlFigureAttributes",
            "htmlLinkAttributes"
          ]
        });
      }
      if (schema.isRegistered("imageInline")) {
        schema.extend("imageInline", {
          allowAttributes: [
            // `htmlA` is needed for standard GHS link integration.
            "htmlA",
            "htmlImgAttributes"
          ]
        });
      }
      conversion.for("upcast").add(viewToModelImageAttributeConverter(dataFilter));
      conversion.for("downcast").add(modelToViewImageAttributeConverter());
      if (editor.plugins.has("LinkImage")) {
        conversion.for("upcast").add(viewToModelLinkImageAttributeConverter(dataFilter, editor));
      }
      evt.stop();
    });
  }
};
function viewToModelImageAttributeConverter(dataFilter) {
  return (dispatcher) => {
    dispatcher.on("element:img", (evt, data, conversionApi) => {
      if (!data.modelRange) {
        return;
      }
      const viewImageElement = data.viewItem;
      const viewAttributes = dataFilter.processViewAttributes(viewImageElement, conversionApi);
      if (viewAttributes) {
        conversionApi.writer.setAttribute("htmlImgAttributes", viewAttributes, data.modelRange);
      }
    }, {
      priority: "low"
    });
  };
}
function viewToModelLinkImageAttributeConverter(dataFilter, editor) {
  const imageUtils = editor.plugins.get("ImageUtils");
  return (dispatcher) => {
    dispatcher.on("element:a", (evt, data, conversionApi) => {
      const viewLink = data.viewItem;
      const viewImage = imageUtils.findViewImgElement(viewLink);
      if (!viewImage) {
        return;
      }
      const modelImage = data.modelCursor.parent;
      if (!modelImage.is("element", "imageBlock")) {
        return;
      }
      const viewAttributes = dataFilter.processViewAttributes(viewLink, conversionApi);
      if (viewAttributes) {
        conversionApi.writer.setAttribute("htmlLinkAttributes", viewAttributes, modelImage);
      }
    }, {
      priority: "low"
    });
  };
}
function viewToModelFigureAttributeConverter$1(dataFilter) {
  return (dispatcher) => {
    dispatcher.on("element:figure", (evt, data, conversionApi) => {
      const viewFigureElement = data.viewItem;
      if (!data.modelRange || !viewFigureElement.hasClass("image")) {
        return;
      }
      const viewAttributes = dataFilter.processViewAttributes(viewFigureElement, conversionApi);
      if (viewAttributes) {
        conversionApi.writer.setAttribute("htmlFigureAttributes", viewAttributes, data.modelRange);
      }
    }, {
      priority: "low"
    });
  };
}
function modelToViewImageAttributeConverter() {
  return (dispatcher) => {
    addInlineAttributeConversion("htmlImgAttributes");
    addBlockAttributeConversion("img", "htmlImgAttributes");
    addBlockAttributeConversion("figure", "htmlFigureAttributes");
    addBlockAttributeConversion("a", "htmlLinkAttributes");
    function addInlineAttributeConversion(attributeName) {
      dispatcher.on(`attribute:${attributeName}:imageInline`, (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const { attributeOldValue, attributeNewValue } = data;
        const viewElement = conversionApi.mapper.toViewElement(data.item);
        updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewElement);
      }, {
        priority: "low"
      });
    }
    function addBlockAttributeConversion(elementName, attributeName) {
      dispatcher.on(`attribute:${attributeName}:imageBlock`, (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        const { attributeOldValue, attributeNewValue } = data;
        const containerElement = conversionApi.mapper.toViewElement(data.item);
        const viewElement = getDescendantElement(conversionApi.writer, containerElement, elementName);
        if (viewElement) {
          updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewElement);
          conversionApi.consumable.consume(data.item, evt.name);
        }
      }, {
        priority: "low"
      });
      if (elementName === "a") {
        dispatcher.on("attribute:linkHref:imageBlock", (evt, data, conversionApi) => {
          if (!conversionApi.consumable.consume(data.item, "attribute:htmlLinkAttributes:imageBlock")) {
            return;
          }
          const containerElement = conversionApi.mapper.toViewElement(data.item);
          const viewElement = getDescendantElement(conversionApi.writer, containerElement, "a");
          setViewAttributes(conversionApi.writer, data.item.getAttribute("htmlLinkAttributes"), viewElement);
        }, {
          priority: "low"
        });
      }
    }
  };
}
var MediaEmbedElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "MediaEmbedElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("MediaEmbed") || editor.config.get("mediaEmbed.previewsInData")) {
      return;
    }
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const dataFilter = this.editor.plugins.get(DataFilter);
    const dataSchema = this.editor.plugins.get(DataSchema);
    const mediaElementName = editor.config.get("mediaEmbed.elementName");
    dataSchema.registerBlockElement({
      model: "media",
      view: mediaElementName
    });
    dataFilter.on("register:figure", () => {
      conversion.for("upcast").add(viewToModelFigureAttributesConverter(dataFilter));
    });
    dataFilter.on(`register:${mediaElementName}`, (evt, definition) => {
      if (definition.model !== "media") {
        return;
      }
      schema.extend("media", {
        allowAttributes: [
          getHtmlAttributeName(mediaElementName),
          "htmlFigureAttributes"
        ]
      });
      conversion.for("upcast").add(viewToModelMediaAttributesConverter(dataFilter, mediaElementName));
      conversion.for("dataDowncast").add(modelToViewMediaAttributeConverter(mediaElementName));
      evt.stop();
    });
  }
};
function viewToModelMediaAttributesConverter(dataFilter, mediaElementName) {
  const upcastMedia = (evt, data, conversionApi) => {
    const viewMediaElement = data.viewItem;
    preserveElementAttributes(viewMediaElement, getHtmlAttributeName(mediaElementName));
    function preserveElementAttributes(viewElement, attributeName) {
      const viewAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
      if (viewAttributes) {
        conversionApi.writer.setAttribute(attributeName, viewAttributes, data.modelRange);
      }
    }
  };
  return (dispatcher) => {
    dispatcher.on(`element:${mediaElementName}`, upcastMedia, {
      priority: "low"
    });
  };
}
function viewToModelFigureAttributesConverter(dataFilter) {
  return (dispatcher) => {
    dispatcher.on("element:figure", (evt, data, conversionApi) => {
      const viewFigureElement = data.viewItem;
      if (!data.modelRange || !viewFigureElement.hasClass("media")) {
        return;
      }
      const viewAttributes = dataFilter.processViewAttributes(viewFigureElement, conversionApi);
      if (viewAttributes) {
        conversionApi.writer.setAttribute("htmlFigureAttributes", viewAttributes, data.modelRange);
      }
    }, {
      priority: "low"
    });
  };
}
function modelToViewMediaAttributeConverter(mediaElementName) {
  return (dispatcher) => {
    addAttributeConversionDispatcherHandler(mediaElementName, getHtmlAttributeName(mediaElementName));
    addAttributeConversionDispatcherHandler("figure", "htmlFigureAttributes");
    function addAttributeConversionDispatcherHandler(elementName, attributeName) {
      dispatcher.on(`attribute:${attributeName}:media`, (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const { attributeOldValue, attributeNewValue } = data;
        const containerElement = conversionApi.mapper.toViewElement(data.item);
        const viewElement = getDescendantElement(conversionApi.writer, containerElement, elementName);
        updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewElement);
      });
    }
  };
}
var ScriptElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ScriptElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const dataFilter = this.editor.plugins.get(DataFilter);
    dataFilter.on("register:script", (evt, definition) => {
      const editor = this.editor;
      const schema = editor.model.schema;
      const conversion = editor.conversion;
      schema.register("htmlScript", definition.modelSchema);
      schema.extend("htmlScript", {
        allowAttributes: [
          "htmlScriptAttributes",
          "htmlContent"
        ],
        isContent: true
      });
      editor.data.registerRawContentMatcher({
        name: "script"
      });
      conversion.for("upcast").elementToElement({
        view: "script",
        model: viewToModelObjectConverter(definition)
      });
      conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, dataFilter));
      conversion.for("downcast").elementToElement({
        model: "htmlScript",
        view: (modelElement, { writer }) => {
          return createObjectView("script", modelElement, writer);
        }
      });
      conversion.for("downcast").add(modelToViewBlockAttributeConverter(definition));
      evt.stop();
    });
  }
};
var TableElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("TableEditing")) {
      return;
    }
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const dataFilter = editor.plugins.get(DataFilter);
    const tableUtils = editor.plugins.get("TableUtils");
    dataFilter.on("register:figure", () => {
      conversion.for("upcast").add(viewToModelFigureAttributeConverter(dataFilter));
    });
    dataFilter.on("register:table", (evt, definition) => {
      if (definition.model !== "table") {
        return;
      }
      schema.extend("table", {
        allowAttributes: [
          "htmlTableAttributes",
          // Figure, thead and tbody elements don't have model counterparts.
          // We will be preserving attributes on table element using these attribute keys.
          "htmlFigureAttributes",
          "htmlTheadAttributes",
          "htmlTbodyAttributes"
        ]
      });
      conversion.for("upcast").add(viewToModelTableAttributeConverter(dataFilter));
      conversion.for("downcast").add(modelToViewTableAttributeConverter());
      editor.model.document.registerPostFixer(createHeadingRowsPostFixer(editor.model, tableUtils));
      evt.stop();
    });
  }
};
function createHeadingRowsPostFixer(model, tableUtils) {
  return (writer) => {
    const changes = model.document.differ.getChanges();
    let wasFixed = false;
    for (const change of changes) {
      if (change.type != "attribute" || change.attributeKey != "headingRows") {
        continue;
      }
      const table = change.range.start.nodeAfter;
      const hasTHeadAttributes = table.getAttribute("htmlTheadAttributes");
      const hasTBodyAttributes = table.getAttribute("htmlTbodyAttributes");
      if (hasTHeadAttributes && !change.attributeNewValue) {
        writer.removeAttribute("htmlTheadAttributes", table);
        wasFixed = true;
      } else if (hasTBodyAttributes && change.attributeNewValue == tableUtils.getRows(table)) {
        writer.removeAttribute("htmlTbodyAttributes", table);
        wasFixed = true;
      }
    }
    return wasFixed;
  };
}
function viewToModelTableAttributeConverter(dataFilter) {
  return (dispatcher) => {
    dispatcher.on("element:table", (evt, data, conversionApi) => {
      if (!data.modelRange) {
        return;
      }
      const viewTableElement = data.viewItem;
      preserveElementAttributes(viewTableElement, "htmlTableAttributes");
      for (const childNode of viewTableElement.getChildren()) {
        if (childNode.is("element", "thead")) {
          preserveElementAttributes(childNode, "htmlTheadAttributes");
        }
        if (childNode.is("element", "tbody")) {
          preserveElementAttributes(childNode, "htmlTbodyAttributes");
        }
      }
      function preserveElementAttributes(viewElement, attributeName) {
        const viewAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
        if (viewAttributes) {
          conversionApi.writer.setAttribute(attributeName, viewAttributes, data.modelRange);
        }
      }
    }, {
      priority: "low"
    });
  };
}
function viewToModelFigureAttributeConverter(dataFilter) {
  return (dispatcher) => {
    dispatcher.on("element:figure", (evt, data, conversionApi) => {
      const viewFigureElement = data.viewItem;
      if (!data.modelRange || !viewFigureElement.hasClass("table")) {
        return;
      }
      const viewAttributes = dataFilter.processViewAttributes(viewFigureElement, conversionApi);
      if (viewAttributes) {
        conversionApi.writer.setAttribute("htmlFigureAttributes", viewAttributes, data.modelRange);
      }
    }, {
      priority: "low"
    });
  };
}
function modelToViewTableAttributeConverter() {
  return (dispatcher) => {
    addAttributeConversionDispatcherHandler("table", "htmlTableAttributes");
    addAttributeConversionDispatcherHandler("figure", "htmlFigureAttributes");
    addAttributeConversionDispatcherHandler("thead", "htmlTheadAttributes");
    addAttributeConversionDispatcherHandler("tbody", "htmlTbodyAttributes");
    function addAttributeConversionDispatcherHandler(elementName, attributeName) {
      dispatcher.on(`attribute:${attributeName}:table`, (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        const containerElement = conversionApi.mapper.toViewElement(data.item);
        const viewElement = getDescendantElement(conversionApi.writer, containerElement, elementName);
        if (!viewElement) {
          return;
        }
        conversionApi.consumable.consume(data.item, evt.name);
        updateViewAttributes(conversionApi.writer, data.attributeOldValue, data.attributeNewValue, viewElement);
      });
    }
  };
}
var StyleElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StyleElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const dataFilter = this.editor.plugins.get(DataFilter);
    dataFilter.on("register:style", (evt, definition) => {
      const editor = this.editor;
      const schema = editor.model.schema;
      const conversion = editor.conversion;
      schema.register("htmlStyle", definition.modelSchema);
      schema.extend("htmlStyle", {
        allowAttributes: [
          "htmlStyleAttributes",
          "htmlContent"
        ],
        isContent: true
      });
      editor.data.registerRawContentMatcher({
        name: "style"
      });
      conversion.for("upcast").elementToElement({
        view: "style",
        model: viewToModelObjectConverter(definition)
      });
      conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, dataFilter));
      conversion.for("downcast").elementToElement({
        model: "htmlStyle",
        view: (modelElement, { writer }) => {
          return createObjectView("style", modelElement, writer);
        }
      });
      conversion.for("downcast").add(modelToViewBlockAttributeConverter(definition));
      evt.stop();
    });
  }
};
var ListElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("ListEditing")) {
      return;
    }
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const dataFilter = editor.plugins.get(DataFilter);
    const listEditing = editor.plugins.get("ListEditing");
    const listUtils = editor.plugins.get("ListUtils");
    const viewElements = [
      "ul",
      "ol",
      "li"
    ];
    listEditing.registerDowncastStrategy({
      scope: "item",
      attributeName: "htmlLiAttributes",
      setAttributeOnDowncast: setViewAttributes
    });
    listEditing.registerDowncastStrategy({
      scope: "list",
      attributeName: "htmlUlAttributes",
      setAttributeOnDowncast: setViewAttributes
    });
    listEditing.registerDowncastStrategy({
      scope: "list",
      attributeName: "htmlOlAttributes",
      setAttributeOnDowncast: setViewAttributes
    });
    dataFilter.on("register", (evt, definition) => {
      if (!viewElements.includes(definition.view)) {
        return;
      }
      evt.stop();
      if (schema.checkAttribute("$block", "htmlLiAttributes")) {
        return;
      }
      const allowAttributes = viewElements.map((element) => getHtmlAttributeName(element));
      schema.extend("$listItem", {
        allowAttributes
      });
      conversion.for("upcast").add((dispatcher) => {
        dispatcher.on("element:ul", viewToModelListAttributeConverter("htmlUlAttributes", dataFilter), {
          priority: "low"
        });
        dispatcher.on("element:ol", viewToModelListAttributeConverter("htmlOlAttributes", dataFilter), {
          priority: "low"
        });
        dispatcher.on("element:li", viewToModelListAttributeConverter("htmlLiAttributes", dataFilter), {
          priority: "low"
        });
      });
    });
    listEditing.on("postFixer", (evt, { listNodes, writer }) => {
      for (const { node, previousNodeInList } of listNodes) {
        if (!previousNodeInList) {
          continue;
        }
        if (previousNodeInList.getAttribute("listType") == node.getAttribute("listType")) {
          const attribute = getAttributeFromListType(previousNodeInList.getAttribute("listType"));
          const value = previousNodeInList.getAttribute(attribute);
          if (!isEqual_default(node.getAttribute(attribute), value) && writer.model.schema.checkAttribute(node, attribute)) {
            writer.setAttribute(attribute, value, node);
            evt.return = true;
          }
        }
        if (previousNodeInList.getAttribute("listItemId") == node.getAttribute("listItemId")) {
          const value = previousNodeInList.getAttribute("htmlLiAttributes");
          if (!isEqual_default(node.getAttribute("htmlLiAttributes"), value) && writer.model.schema.checkAttribute(node, "htmlLiAttributes")) {
            writer.setAttribute("htmlLiAttributes", value, node);
            evt.return = true;
          }
        }
      }
    });
    listEditing.on("postFixer", (evt, { listNodes, writer }) => {
      for (const { node } of listNodes) {
        const listType = node.getAttribute("listType");
        if (!listUtils.isNumberedListType(listType) && node.getAttribute("htmlOlAttributes")) {
          writer.removeAttribute("htmlOlAttributes", node);
          evt.return = true;
        }
        if (listUtils.isNumberedListType(listType) && node.getAttribute("htmlUlAttributes")) {
          writer.removeAttribute("htmlUlAttributes", node);
          evt.return = true;
        }
      }
    });
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    if (!editor.commands.get("indentList")) {
      return;
    }
    const indentList = editor.commands.get("indentList");
    this.listenTo(indentList, "afterExecute", (evt, changedBlocks) => {
      editor.model.change((writer) => {
        for (const node of changedBlocks) {
          const attribute = getAttributeFromListType(node.getAttribute("listType"));
          if (!editor.model.schema.checkAttribute(node, attribute)) {
            continue;
          }
          writer.setAttribute(attribute, {}, node);
        }
      });
    });
  }
};
function viewToModelListAttributeConverter(attributeName, dataFilter) {
  return (evt, data, conversionApi) => {
    const viewElement = data.viewItem;
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    const viewAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
    for (const item of data.modelRange.getItems({
      shallow: true
    })) {
      if (!item.hasAttribute("listItemId")) {
        continue;
      }
      if (item.hasAttribute("htmlUlAttributes") || item.hasAttribute("htmlOlAttributes")) {
        continue;
      }
      if (conversionApi.writer.model.schema.checkAttribute(item, attributeName)) {
        conversionApi.writer.setAttribute(attributeName, viewAttributes || {}, item);
      }
    }
  };
}
function getAttributeFromListType(listType) {
  return listType === "numbered" || listType == "customNumbered" ? "htmlOlAttributes" : "htmlUlAttributes";
}
var CustomElementSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter,
      DataSchema
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "CustomElementSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const dataFilter = this.editor.plugins.get(DataFilter);
    const dataSchema = this.editor.plugins.get(DataSchema);
    dataFilter.on("register:$customElement", (evt, definition) => {
      evt.stop();
      const editor = this.editor;
      const schema = editor.model.schema;
      const conversion = editor.conversion;
      const unsafeElements = editor.editing.view.domConverter.unsafeElements;
      const preLikeElements = editor.data.htmlProcessor.domConverter.preElements;
      schema.register(definition.model, definition.modelSchema);
      schema.extend(definition.model, {
        allowAttributes: [
          "htmlElementName",
          "htmlCustomElementAttributes",
          "htmlContent"
        ],
        isContent: true
      });
      editor.data.htmlProcessor.domConverter.registerRawContentMatcher({
        name: "template"
      });
      conversion.for("upcast").elementToElement({
        view: /.*/,
        model: (viewElement, conversionApi) => {
          if (viewElement.name == "$comment") {
            return null;
          }
          if (!isValidElementName(viewElement.name)) {
            return null;
          }
          if (dataSchema.getDefinitionsForView(viewElement.name).size) {
            return null;
          }
          if (!unsafeElements.includes(viewElement.name)) {
            unsafeElements.push(viewElement.name);
          }
          if (!preLikeElements.includes(viewElement.name)) {
            preLikeElements.push(viewElement.name);
          }
          const modelElement = conversionApi.writer.createElement(definition.model, {
            htmlElementName: viewElement.name
          });
          const htmlAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
          if (htmlAttributes) {
            conversionApi.writer.setAttribute("htmlCustomElementAttributes", htmlAttributes, modelElement);
          }
          let htmlContent;
          if (viewElement.is("element", "template") && viewElement.getCustomProperty("$rawContent")) {
            htmlContent = viewElement.getCustomProperty("$rawContent");
          } else {
            const viewWriter = new UpcastWriter(viewElement.document);
            const documentFragment = viewWriter.createDocumentFragment(viewElement);
            const domFragment = editor.data.htmlProcessor.domConverter.viewToDom(documentFragment);
            const domElement = domFragment.firstChild;
            while (domElement.firstChild) {
              domFragment.appendChild(domElement.firstChild);
            }
            domElement.remove();
            htmlContent = editor.data.htmlProcessor.htmlWriter.getHtml(domFragment);
          }
          conversionApi.writer.setAttribute("htmlContent", htmlContent, modelElement);
          for (const { item } of editor.editing.view.createRangeIn(viewElement)) {
            conversionApi.consumable.consume(item, {
              name: true
            });
          }
          return modelElement;
        },
        converterPriority: "low"
      });
      conversion.for("editingDowncast").elementToElement({
        model: {
          name: definition.model,
          attributes: [
            "htmlElementName",
            "htmlCustomElementAttributes",
            "htmlContent"
          ]
        },
        view: (modelElement, { writer }) => {
          const viewName = modelElement.getAttribute("htmlElementName");
          const viewElement = writer.createRawElement(viewName);
          if (modelElement.hasAttribute("htmlCustomElementAttributes")) {
            setViewAttributes(writer, modelElement.getAttribute("htmlCustomElementAttributes"), viewElement);
          }
          return viewElement;
        }
      });
      conversion.for("dataDowncast").elementToElement({
        model: {
          name: definition.model,
          attributes: [
            "htmlElementName",
            "htmlCustomElementAttributes",
            "htmlContent"
          ]
        },
        view: (modelElement, { writer }) => {
          const viewName = modelElement.getAttribute("htmlElementName");
          const htmlContent = modelElement.getAttribute("htmlContent");
          const viewElement = writer.createRawElement(viewName, null, (domElement, domConverter) => {
            domConverter.setContentOf(domElement, htmlContent);
          });
          if (modelElement.hasAttribute("htmlCustomElementAttributes")) {
            setViewAttributes(writer, modelElement.getAttribute("htmlCustomElementAttributes"), viewElement);
          }
          return viewElement;
        }
      });
    });
  }
};
function isValidElementName(name) {
  try {
    document.createElement(name);
  } catch (error) {
    return false;
  }
  return true;
}
var GeneralHtmlSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "GeneralHtmlSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      DataFilter,
      CodeBlockElementSupport,
      DualContentModelElementSupport,
      HeadingElementSupport,
      ImageElementSupport,
      MediaEmbedElementSupport,
      ScriptElementSupport,
      TableElementSupport,
      StyleElementSupport,
      ListElementSupport,
      CustomElementSupport
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const dataFilter = editor.plugins.get(DataFilter);
    dataFilter.loadAllowedEmptyElementsConfig(editor.config.get("htmlSupport.allowEmpty") || []);
    dataFilter.loadAllowedConfig(editor.config.get("htmlSupport.allow") || []);
    dataFilter.loadDisallowedConfig(editor.config.get("htmlSupport.disallow") || []);
  }
  /**
  * Returns a GHS model attribute name related to a given view element name.
  *
  * @internal
  * @param viewElementName A view element name.
  */
  getGhsAttributeNameForElement(viewElementName) {
    const dataSchema = this.editor.plugins.get("DataSchema");
    const definitions = Array.from(dataSchema.getDefinitionsForView(viewElementName, false));
    const inlineDefinition = definitions.find((definition) => definition.isInline && !definitions[0].isObject);
    if (inlineDefinition) {
      return inlineDefinition.model;
    }
    return getHtmlAttributeName(viewElementName);
  }
  /**
  * Updates GHS model attribute for a specified view element name, so it includes the given class name.
  *
  * @internal
  * @param viewElementName A view element name.
  * @param className The css class to add.
  * @param selectable The selection or element to update.
  */
  addModelHtmlClass(viewElementName, className, selectable) {
    const model = this.editor.model;
    const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
    model.change((writer) => {
      for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
        modifyGhsAttribute(writer, item, ghsAttributeName, "classes", (classes) => {
          for (const value of toArray(className)) {
            classes.add(value);
          }
        });
      }
    });
  }
  /**
  * Updates GHS model attribute for a specified view element name, so it does not include the given class name.
  *
  * @internal
  * @param viewElementName A view element name.
  * @param className The css class to remove.
  * @param selectable The selection or element to update.
  */
  removeModelHtmlClass(viewElementName, className, selectable) {
    const model = this.editor.model;
    const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
    model.change((writer) => {
      for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
        modifyGhsAttribute(writer, item, ghsAttributeName, "classes", (classes) => {
          for (const value of toArray(className)) {
            classes.delete(value);
          }
        });
      }
    });
  }
  /**
  * Updates GHS model attribute for a specified view element name, so it includes the given attribute.
  *
  * @param viewElementName A view element name.
  * @param attributes The object with attributes to set.
  * @param selectable The selection or element to update.
  */
  setModelHtmlAttributes(viewElementName, attributes, selectable) {
    const model = this.editor.model;
    const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
    model.change((writer) => {
      for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
        modifyGhsAttribute(writer, item, ghsAttributeName, "attributes", (attributesMap) => {
          for (const [key, value] of Object.entries(attributes)) {
            attributesMap.set(key, value);
          }
        });
      }
    });
  }
  /**
  * Updates GHS model attribute for a specified view element name, so it does not include the given attribute.
  *
  * @param viewElementName A view element name.
  * @param attributeName The attribute name (or names) to remove.
  * @param selectable The selection or element to update.
  */
  removeModelHtmlAttributes(viewElementName, attributeName, selectable) {
    const model = this.editor.model;
    const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
    model.change((writer) => {
      for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
        modifyGhsAttribute(writer, item, ghsAttributeName, "attributes", (attributesMap) => {
          for (const key of toArray(attributeName)) {
            attributesMap.delete(key);
          }
        });
      }
    });
  }
  /**
  * Updates GHS model attribute for a specified view element name, so it includes a given style.
  *
  * @param viewElementName A view element name.
  * @param styles The object with styles to set.
  * @param selectable The selection or element to update.
  */
  setModelHtmlStyles(viewElementName, styles, selectable) {
    const model = this.editor.model;
    const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
    model.change((writer) => {
      for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
        modifyGhsAttribute(writer, item, ghsAttributeName, "styles", (stylesMap) => {
          for (const [key, value] of Object.entries(styles)) {
            stylesMap.set(key, value);
          }
        });
      }
    });
  }
  /**
  * Updates GHS model attribute for a specified view element name, so it does not include a given style.
  *
  * @param viewElementName A view element name.
  * @param properties The style (or styles list) to remove.
  * @param selectable The selection or element to update.
  */
  removeModelHtmlStyles(viewElementName, properties, selectable) {
    const model = this.editor.model;
    const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
    model.change((writer) => {
      for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
        modifyGhsAttribute(writer, item, ghsAttributeName, "styles", (stylesMap) => {
          for (const key of toArray(properties)) {
            stylesMap.delete(key);
          }
        });
      }
    });
  }
};
function* getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName) {
  if (!selectable) {
    return;
  }
  if (!(Symbol.iterator in selectable) && selectable.is("documentSelection") && selectable.isCollapsed) {
    if (model.schema.checkAttributeInSelection(selectable, ghsAttributeName)) {
      yield selectable;
    }
  } else {
    for (const range of getValidRangesForSelectable(model, selectable, ghsAttributeName)) {
      yield* range.getItems({
        shallow: true
      });
    }
  }
}
function getValidRangesForSelectable(model, selectable, ghsAttributeName) {
  if (!(Symbol.iterator in selectable) && (selectable.is("node") || selectable.is("$text") || selectable.is("$textProxy"))) {
    if (model.schema.checkAttribute(selectable, ghsAttributeName)) {
      return [
        model.createRangeOn(selectable)
      ];
    } else {
      return [];
    }
  } else {
    return model.schema.getValidRanges(model.createSelection(selectable).getRanges(), ghsAttributeName);
  }
}
var HtmlComment = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "HtmlComment";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const loadedCommentsContent = /* @__PURE__ */ new Map();
    editor.data.processor.skipComments = false;
    editor.model.schema.addAttributeCheck((context, attributeName) => {
      if (context.endsWith("$root") && attributeName.startsWith("$comment")) {
        return true;
      }
    });
    editor.conversion.for("upcast").elementToMarker({
      view: "$comment",
      model: (viewElement) => {
        const markerUid = uid();
        const markerName = `$comment:${markerUid}`;
        const commentContent = viewElement.getCustomProperty("$rawContent");
        loadedCommentsContent.set(markerName, commentContent);
        return markerName;
      }
    });
    editor.conversion.for("dataDowncast").markerToElement({
      model: "$comment",
      view: (modelElement, { writer }) => {
        let root2 = void 0;
        for (const rootName of this.editor.model.document.getRootNames()) {
          root2 = this.editor.model.document.getRoot(rootName);
          if (root2.hasAttribute(modelElement.markerName)) {
            break;
          }
        }
        const markerName = modelElement.markerName;
        const commentContent = root2.getAttribute(markerName);
        const comment = writer.createUIElement("$comment");
        writer.setCustomProperty("$rawContent", commentContent, comment);
        return comment;
      }
    });
    editor.model.document.registerPostFixer((writer) => {
      let changed = false;
      const markers = editor.model.document.differ.getChangedMarkers().filter((marker) => marker.name.startsWith("$comment:"));
      for (const marker of markers) {
        const { oldRange, newRange } = marker.data;
        if (oldRange && newRange && oldRange.root == newRange.root) {
          continue;
        }
        if (oldRange) {
          const oldRoot = oldRange.root;
          if (oldRoot.hasAttribute(marker.name)) {
            writer.removeAttribute(marker.name, oldRoot);
            changed = true;
          }
        }
        if (newRange) {
          const newRoot = newRange.root;
          if (newRoot.rootName == "$graveyard") {
            writer.removeMarker(marker.name);
            changed = true;
          } else if (!newRoot.hasAttribute(marker.name)) {
            writer.setAttribute(marker.name, loadedCommentsContent.get(marker.name) || "", newRoot);
            changed = true;
          }
        }
      }
      return changed;
    });
    editor.data.on("set", () => {
      for (const commentMarker of editor.model.markers.getMarkersGroup("$comment")) {
        this.removeHtmlComment(commentMarker.name);
      }
    }, {
      priority: "high"
    });
    editor.model.on("deleteContent", (evt, [selection]) => {
      for (const range of selection.getRanges()) {
        const limitElement = editor.model.schema.getLimitElement(range);
        const firstPosition = editor.model.createPositionAt(limitElement, 0);
        const lastPosition = editor.model.createPositionAt(limitElement, "end");
        let affectedCommentIDs;
        if (firstPosition.isTouching(range.start) && lastPosition.isTouching(range.end)) {
          affectedCommentIDs = this.getHtmlCommentsInRange(editor.model.createRange(firstPosition, lastPosition));
        } else {
          affectedCommentIDs = this.getHtmlCommentsInRange(range, {
            skipBoundaries: true
          });
        }
        for (const commentMarkerID of affectedCommentIDs) {
          this.removeHtmlComment(commentMarkerID);
        }
      }
    }, {
      priority: "high"
    });
  }
  /**
  * Creates an HTML comment on the specified position and returns its ID.
  *
  * *Note*: If two comments are created at the same position, the second comment will be inserted before the first one.
  *
  * @returns Comment ID. This ID can be later used to e.g. remove the comment from the content.
  */
  createHtmlComment(position, content) {
    const id = uid();
    const editor = this.editor;
    const model = editor.model;
    const root2 = model.document.getRoot(position.root.rootName);
    const markerName = `$comment:${id}`;
    return model.change((writer) => {
      const range = writer.createRange(position);
      writer.addMarker(markerName, {
        usingOperation: true,
        affectsData: true,
        range
      });
      writer.setAttribute(markerName, content, root2);
      return markerName;
    });
  }
  /**
  * Removes an HTML comment with the given comment ID.
  *
  * It does nothing and returns `false` if the comment with the given ID does not exist.
  * Otherwise it removes the comment and returns `true`.
  *
  * Note that a comment can be removed also by removing the content around the comment.
  *
  * @param commentID The ID of the comment to be removed.
  * @returns `true` when the comment with the given ID was removed, `false` otherwise.
  */
  removeHtmlComment(commentID) {
    const editor = this.editor;
    const marker = editor.model.markers.get(commentID);
    if (!marker) {
      return false;
    }
    editor.model.change((writer) => {
      writer.removeMarker(marker);
    });
    return true;
  }
  /**
  * Gets the HTML comment data for the comment with a given ID.
  *
  * Returns `null` if the comment does not exist.
  */
  getHtmlCommentData(commentID) {
    const editor = this.editor;
    const marker = editor.model.markers.get(commentID);
    if (!marker) {
      return null;
    }
    let content = "";
    for (const root2 of this.editor.model.document.getRoots()) {
      if (root2.hasAttribute(commentID)) {
        content = root2.getAttribute(commentID);
        break;
      }
    }
    return {
      content,
      position: marker.getStart()
    };
  }
  /**
  * Gets all HTML comments in the given range.
  *
  * By default, it includes comments at the range boundaries.
  *
  * @param range
  * @param options.skipBoundaries When set to `true` the range boundaries will be skipped.
  * @returns HTML comment IDs
  */
  getHtmlCommentsInRange(range, { skipBoundaries = false } = {}) {
    const includeBoundaries = !skipBoundaries;
    return Array.from(this.editor.model.markers.getMarkersGroup("$comment")).filter((marker) => isCommentMarkerInRange(marker, range)).map((marker) => marker.name);
    function isCommentMarkerInRange(commentMarker, range2) {
      const position = commentMarker.getRange().start;
      return (position.isAfter(range2.start) || includeBoundaries && position.isEqual(range2.start)) && (position.isBefore(range2.end) || includeBoundaries && position.isEqual(range2.end));
    }
  }
};
var HtmlPageDataProcessor = class extends HtmlDataProcessor {
  /**
  * @inheritDoc
  */
  toView(data) {
    if (!/<(?:html|body|head|meta)(?:\s[^>]*)?>/i.test(data.trim().slice(0, 1e4))) {
      return super.toView(data);
    }
    let docType = "";
    let xmlDeclaration = "";
    data = data.trim().replace(/<\?xml\s[^?]*\?>/i, (match) => {
      xmlDeclaration = match;
      return "";
    });
    data = data.trim().replace(/^<!DOCTYPE\s[^>]*?>/i, (match) => {
      docType = match;
      return "";
    });
    const domFragment = this._toDom(data);
    const viewFragment = this.domConverter.domToView(domFragment, {
      skipComments: this.skipComments
    });
    const writer = new UpcastWriter(viewFragment.document);
    writer.setCustomProperty("$fullPageDocument", domFragment.ownerDocument.documentElement.outerHTML, viewFragment);
    if (docType) {
      writer.setCustomProperty("$fullPageDocType", docType, viewFragment);
    }
    if (xmlDeclaration) {
      writer.setCustomProperty("$fullPageXmlDeclaration", xmlDeclaration, viewFragment);
    }
    return viewFragment;
  }
  /**
  * @inheritDoc
  */
  toData(viewFragment) {
    let data = super.toData(viewFragment);
    const page = viewFragment.getCustomProperty("$fullPageDocument");
    const docType = viewFragment.getCustomProperty("$fullPageDocType");
    const xmlDeclaration = viewFragment.getCustomProperty("$fullPageXmlDeclaration");
    if (page) {
      data = page.replace(/<\/body\s*>/, data + "$&");
      if (docType) {
        data = docType + "\n" + data;
      }
      if (xmlDeclaration) {
        data = xmlDeclaration + "\n" + data;
      }
    }
    return data;
  }
};
var FullPage = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "FullPage";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const properties = [
      "$fullPageDocument",
      "$fullPageDocType",
      "$fullPageXmlDeclaration"
    ];
    editor.data.processor = new HtmlPageDataProcessor(editor.data.viewDocument);
    editor.model.schema.extend("$root", {
      allowAttributes: properties
    });
    editor.data.on("toModel", (evt, [viewElementOrFragment]) => {
      const root2 = editor.model.document.getRoot();
      editor.model.change((writer) => {
        for (const name of properties) {
          const value = viewElementOrFragment.getCustomProperty(name);
          if (value) {
            writer.setAttribute(name, value, root2);
          }
        }
      });
    }, {
      priority: "low"
    });
    editor.data.on("toView", (evt, [modelElementOrFragment]) => {
      if (!modelElementOrFragment.is("rootElement")) {
        return;
      }
      const root2 = modelElementOrFragment;
      const viewFragment = evt.return;
      if (!root2.hasAttribute("$fullPageDocument")) {
        return;
      }
      const writer = new UpcastWriter(viewFragment.document);
      for (const name of properties) {
        const value = root2.getAttribute(name);
        if (value) {
          writer.setCustomProperty(name, value, viewFragment);
        }
      }
    }, {
      priority: "low"
    });
    editor.data.on("set", () => {
      const root2 = editor.model.document.getRoot();
      editor.model.change((writer) => {
        for (const name of properties) {
          if (root2.hasAttribute(name)) {
            writer.removeAttribute(name, root2);
          }
        }
      });
    }, {
      priority: "high"
    });
    editor.data.on("get", (evt, args) => {
      if (!args[0]) {
        args[0] = {};
      }
      args[0].trim = false;
    }, {
      priority: "high"
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/dist/index.js
function createInlineImageViewElement(writer) {
  return writer.createContainerElement("span", {
    class: "image-inline"
  }, writer.createEmptyElement("img"));
}
function createBlockImageViewElement(writer) {
  return writer.createContainerElement("figure", {
    class: "image"
  }, [
    writer.createEmptyElement("img"),
    writer.createSlot("children")
  ]);
}
function getImgViewElementMatcher(editor, matchImageType) {
  const imageUtils = editor.plugins.get("ImageUtils");
  const areBothImagePluginsLoaded = editor.plugins.has("ImageInlineEditing") && editor.plugins.has("ImageBlockEditing");
  return (element) => {
    if (!imageUtils.isInlineImageView(element)) {
      return null;
    }
    if (!areBothImagePluginsLoaded) {
      return getPositiveMatchPattern(element);
    }
    const imageType = element.getStyle("display") == "block" || element.findAncestor(imageUtils.isBlockImageView) ? "imageBlock" : "imageInline";
    if (imageType !== matchImageType) {
      return null;
    }
    return getPositiveMatchPattern(element);
  };
  function getPositiveMatchPattern(element) {
    const pattern = {
      name: true
    };
    if (element.hasAttribute("src")) {
      pattern.attributes = [
        "src"
      ];
    }
    return pattern;
  }
}
function determineImageTypeForInsertionAtSelection(schema, selection) {
  const firstBlock = first(selection.getSelectedBlocks());
  if (!firstBlock || schema.isObject(firstBlock)) {
    return "imageBlock";
  }
  if (firstBlock.isEmpty && firstBlock.name != "listItem") {
    return "imageBlock";
  }
  return "imageInline";
}
function getSizeValueIfInPx(size) {
  if (size && size.endsWith("px")) {
    return parseInt(size);
  }
  return null;
}
function widthAndHeightStylesAreBothSet(viewElement) {
  const widthStyle = getSizeValueIfInPx(viewElement.getStyle("width"));
  const heightStyle = getSizeValueIfInPx(viewElement.getStyle("height"));
  return !!(widthStyle && heightStyle);
}
var IMAGE_WIDGETS_CLASSES_MATCH_REGEXP = /^(image|image-inline)$/;
var ImageUtils = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * DOM Emitter.
    */
    __publicField(this, "_domEmitter", new (DomEmitterMixin())());
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Checks if the provided model element is an `image` or `imageInline`.
  */
  isImage(modelElement) {
    return this.isInlineImage(modelElement) || this.isBlockImage(modelElement);
  }
  /**
  * Checks if the provided view element represents an inline image.
  *
  * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
  */
  isInlineImageView(element) {
    return !!element && element.is("element", "img");
  }
  /**
  * Checks if the provided view element represents a block image.
  *
  * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
  */
  isBlockImageView(element) {
    return !!element && element.is("element", "figure") && element.hasClass("image");
  }
  /**
  * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}
  * method.
  *
  * ```ts
  * const imageUtils = editor.plugins.get( 'ImageUtils' );
  *
  * imageUtils.insertImage( { src: 'path/to/image.jpg' } );
  * ```
  *
  * @param attributes Attributes of the inserted image.
  * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.
  * @param selectable Place to insert the image. If not specified,
  * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images
  * and `model.document.selection` for the inline images.
  *
  * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)
  * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.
  *
  * @param imageType Image type of inserted image. If not specified,
  * it will be determined automatically depending of editor config or place of the insertion.
  * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
  * The default is `true`.
  * @return The inserted model image element.
  */
  insertImage(attributes = {}, selectable = null, imageType = null, options2 = {}) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const determinedImageType = determineImageTypeForInsertion(editor, selectable || selection, imageType);
    attributes = {
      ...Object.fromEntries(selection.getAttributes()),
      ...attributes
    };
    for (const attributeName in attributes) {
      if (!model.schema.checkAttribute(determinedImageType, attributeName)) {
        delete attributes[attributeName];
      }
    }
    return model.change((writer) => {
      const { setImageSizes = true } = options2;
      const imageElement = writer.createElement(determinedImageType, attributes);
      model.insertObject(imageElement, selectable, null, {
        setSelection: "on",
        // If we want to insert a block image (for whatever reason) then we don't want to split text blocks.
        // This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).
        findOptimalPosition: !selectable && determinedImageType != "imageInline" ? "auto" : void 0
      });
      if (imageElement.parent) {
        if (setImageSizes) {
          this.setImageNaturalSizeAttributes(imageElement);
        }
        return imageElement;
      }
      return null;
    });
  }
  /**
  * Reads original image sizes and sets them as `width` and `height`.
  *
  * The `src` attribute may not be available if the user is using an upload adapter. In such a case,
  * this method is called again after the upload process is complete and the `src` attribute is available.
  */
  setImageNaturalSizeAttributes(imageElement) {
    const src = imageElement.getAttribute("src");
    if (!src) {
      return;
    }
    if (imageElement.getAttribute("width") || imageElement.getAttribute("height")) {
      return;
    }
    this.editor.model.change((writer) => {
      const img = new global.window.Image();
      this._domEmitter.listenTo(img, "load", () => {
        if (!imageElement.getAttribute("width") && !imageElement.getAttribute("height")) {
          this.editor.model.enqueueChange(writer.batch, (writer2) => {
            writer2.setAttribute("width", img.naturalWidth, imageElement);
            writer2.setAttribute("height", img.naturalHeight, imageElement);
          });
        }
        this._domEmitter.stopListening(img, "load");
      });
      img.src = src;
    });
  }
  /**
  * Returns an image widget editing view element if one is selected or is among the selection's ancestors.
  */
  getClosestSelectedImageWidget(selection) {
    const selectionPosition = selection.getFirstPosition();
    if (!selectionPosition) {
      return null;
    }
    const viewElement = selection.getSelectedElement();
    if (viewElement && this.isImageWidget(viewElement)) {
      return viewElement;
    }
    let parent = selectionPosition.parent;
    while (parent) {
      if (parent.is("element") && this.isImageWidget(parent)) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
  * Returns a image model element if one is selected or is among the selection's ancestors.
  */
  getClosestSelectedImageElement(selection) {
    const selectedElement = selection.getSelectedElement();
    return this.isImage(selectedElement) ? selectedElement : selection.getFirstPosition().findAncestor("imageBlock");
  }
  /**
  * Returns an image widget editing view based on the passed image view.
  */
  getImageWidgetFromImageView(imageView) {
    return imageView.findAncestor({
      classes: IMAGE_WIDGETS_CLASSES_MATCH_REGEXP
    });
  }
  /**
  * Checks if image can be inserted at current model selection.
  *
  * @internal
  */
  isImageAllowed() {
    const model = this.editor.model;
    const selection = model.document.selection;
    return isImageAllowedInParent(this.editor, selection) && isNotInsideImage(selection);
  }
  /**
  * Converts a given {@link module:engine/view/element~Element} to an image widget:
  * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget
  * element.
  * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
  *
  * @param writer An instance of the view writer.
  * @param label The element's label. It will be concatenated with the image `alt` attribute if one is present.
  */
  toImageWidget(viewElement, writer, label) {
    writer.setCustomProperty("image", true, viewElement);
    const labelCreator = () => {
      const imgElement = this.findViewImgElement(viewElement);
      const altText = imgElement.getAttribute("alt");
      return altText ? `${altText} ${label}` : label;
    };
    return toWidget(viewElement, writer, {
      label: labelCreator
    });
  }
  /**
  * Checks if a given view element is an image widget.
  */
  isImageWidget(viewElement) {
    return !!viewElement.getCustomProperty("image") && isWidget(viewElement);
  }
  /**
  * Checks if the provided model element is an `image`.
  */
  isBlockImage(modelElement) {
    return !!modelElement && modelElement.is("element", "imageBlock");
  }
  /**
  * Checks if the provided model element is an `imageInline`.
  */
  isInlineImage(modelElement) {
    return !!modelElement && modelElement.is("element", "imageInline");
  }
  /**
  * Get the view `<img>` from another view element, e.g. a widget (`<figure class="image">`), a link (`<a>`).
  *
  * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.
  */
  findViewImgElement(figureView) {
    if (this.isInlineImageView(figureView)) {
      return figureView;
    }
    const editingView = this.editor.editing.view;
    for (const { item } of editingView.createRangeIn(figureView)) {
      if (this.isInlineImageView(item)) {
        return item;
      }
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._domEmitter.stopListening();
    return super.destroy();
  }
};
function isImageAllowedInParent(editor, selection) {
  const imageType = determineImageTypeForInsertion(editor, selection, null);
  if (imageType == "imageBlock") {
    const parent = getInsertImageParent(selection, editor.model);
    if (editor.model.schema.checkChild(parent, "imageBlock")) {
      return true;
    }
  } else if (editor.model.schema.checkChild(selection.focus, "imageInline")) {
    return true;
  }
  return false;
}
function isNotInsideImage(selection) {
  return [
    ...selection.focus.getAncestors()
  ].every((ancestor) => !ancestor.is("element", "imageBlock"));
}
function getInsertImageParent(selection, model) {
  const insertionRange = findOptimalInsertionRange(selection, model);
  const parent = insertionRange.start.parent;
  if (parent.isEmpty && !parent.is("element", "$root")) {
    return parent.parent;
  }
  return parent;
}
function determineImageTypeForInsertion(editor, selectable, imageType) {
  const schema = editor.model.schema;
  const configImageInsertType = editor.config.get("image.insert.type");
  if (!editor.plugins.has("ImageBlockEditing")) {
    return "imageInline";
  }
  if (!editor.plugins.has("ImageInlineEditing")) {
    return "imageBlock";
  }
  if (imageType) {
    return imageType;
  }
  if (configImageInsertType === "inline") {
    return "imageInline";
  }
  if (configImageInsertType !== "auto") {
    return "imageBlock";
  }
  if (selectable.is("selection")) {
    return determineImageTypeForInsertionAtSelection(schema, selectable);
  }
  return schema.checkChild(selectable, "imageInline") ? "imageInline" : "imageBlock";
}
var IMAGE_URL_REGEXP = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));
var AutoImage = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The pastetoembed `setTimeout` ID. Stored as a property to allow
    * cleaning of the timeout.
    */
    __publicField(this, "_timeoutId");
    /**
    * The position where the `<imageBlock>` element will be inserted after the timeout,
    * determined each time a new content is pasted into the document.
    */
    __publicField(this, "_positionToInsert");
    this._timeoutId = null;
    this._positionToInsert = null;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Clipboard,
      ImageUtils,
      Undo,
      Delete
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "AutoImage";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const modelDocument = editor.model.document;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    this.listenTo(clipboardPipeline, "inputTransformation", () => {
      const firstRange = modelDocument.selection.getFirstRange();
      const leftLivePosition = LivePosition.fromPosition(firstRange.start);
      leftLivePosition.stickiness = "toPrevious";
      const rightLivePosition = LivePosition.fromPosition(firstRange.end);
      rightLivePosition.stickiness = "toNext";
      modelDocument.once("change:data", () => {
        this._embedImageBetweenPositions(leftLivePosition, rightLivePosition);
        leftLivePosition.detach();
        rightLivePosition.detach();
      }, {
        priority: "high"
      });
    });
    editor.commands.get("undo").on("execute", () => {
      if (this._timeoutId) {
        global.window.clearTimeout(this._timeoutId);
        this._positionToInsert.detach();
        this._timeoutId = null;
        this._positionToInsert = null;
      }
    }, {
      priority: "high"
    });
  }
  /**
  * Analyzes the part of the document between provided positions in search for a URL representing an image.
  * When the URL is found, it is automatically converted into an image.
  *
  * @param leftPosition Left position of the selection.
  * @param rightPosition Right position of the selection.
  */
  _embedImageBetweenPositions(leftPosition, rightPosition) {
    const editor = this.editor;
    const urlRange = new LiveRange(leftPosition, rightPosition);
    const walker = urlRange.getWalker({
      ignoreElementEnd: true
    });
    const selectionAttributes = Object.fromEntries(editor.model.document.selection.getAttributes());
    const imageUtils = this.editor.plugins.get("ImageUtils");
    let src = "";
    for (const node of walker) {
      if (node.item.is("$textProxy")) {
        src += node.item.data;
      }
    }
    src = src.trim();
    if (!src.match(IMAGE_URL_REGEXP)) {
      urlRange.detach();
      return;
    }
    this._positionToInsert = LivePosition.fromPosition(leftPosition);
    this._timeoutId = setTimeout(() => {
      const imageCommand = editor.commands.get("insertImage");
      if (!imageCommand.isEnabled) {
        urlRange.detach();
        return;
      }
      editor.model.change((writer) => {
        this._timeoutId = null;
        writer.remove(urlRange);
        urlRange.detach();
        let insertionPosition;
        if (this._positionToInsert.root.rootName !== "$graveyard") {
          insertionPosition = this._positionToInsert.toPosition();
        }
        imageUtils.insertImage({
          ...selectionAttributes,
          src
        }, insertionPosition);
        this._positionToInsert.detach();
        this._positionToInsert = null;
      });
      const deletePlugin = editor.plugins.get("Delete");
      deletePlugin.requestUndoOnBackspace();
    }, 100);
  }
};
var ImageTextAlternativeCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!element;
    if (this.isEnabled && element.hasAttribute("alt")) {
      this.value = element.getAttribute("alt");
    } else {
      this.value = false;
    }
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options
  * @param options.newValue The new value of the `alt` attribute to set.
  */
  execute(options2) {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const model = editor.model;
    const imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
    model.change((writer) => {
      writer.setAttribute("alt", options2.newValue, imageElement);
    });
  }
};
var ImageTextAlternativeEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageTextAlternativeEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this.editor.commands.add("imageTextAlternative", new ImageTextAlternativeCommand(this.editor));
  }
};
var TextAlternativeFormView = class extends View2 {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * Tracks information about the DOM focus in the form.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * An input with a label.
    */
    __publicField(this, "labeledInput");
    /**
    * A button used to submit the form.
    */
    __publicField(this, "saveButtonView");
    /**
    * A button used to cancel the form.
    */
    __publicField(this, "cancelButtonView");
    /**
    * A collection of views which can be focused in the form.
    */
    __publicField(this, "_focusables");
    /**
    * Helps cycling over {@link #_focusables} in the form.
    */
    __publicField(this, "_focusCycler");
    const t = this.locale.t;
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.labeledInput = this._createLabeledInputView();
    this.saveButtonView = this._createButton(t("Save"), icons.check, "ck-button-save");
    this.saveButtonView.type = "submit";
    this.cancelButtonView = this._createButton(t("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-text-alternative-form",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-image/issues/40
        tabindex: "-1"
      },
      children: [
        this.labeledInput,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
    submitHandler({
      view: this
    });
    [
      this.labeledInput,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Creates the button view.
  *
  * @param label The button label
  * @param icon The button's icon.
  * @param className The additional button CSS class name.
  * @param eventName The event name that the ButtonView#execute event will be delegated to.
  * @returns The button view instance.
  */
  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.locale);
    button.set({
      label,
      icon,
      tooltip: true
    });
    button.extendTemplate({
      attributes: {
        class: className
      }
    });
    if (eventName) {
      button.delegate("execute").to(this, eventName);
    }
    return button;
  }
  /**
  * Creates an input with a label.
  *
  * @returns Labeled field view instance.
  */
  _createLabeledInputView() {
    const t = this.locale.t;
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    labeledInput.label = t("Text alternative");
    return labeledInput;
  }
};
function repositionContextualBalloon(editor) {
  const balloon = editor.plugins.get("ContextualBalloon");
  const imageUtils = editor.plugins.get("ImageUtils");
  if (imageUtils.getClosestSelectedImageWidget(editor.editing.view.document.selection)) {
    const position = getBalloonPositionData(editor);
    balloon.updatePosition(position);
  }
}
function getBalloonPositionData(editor) {
  const editingView = editor.editing.view;
  const defaultPositions = BalloonPanelView.defaultPositions;
  const imageUtils = editor.plugins.get("ImageUtils");
  return {
    target: editingView.domConverter.mapViewToDom(imageUtils.getClosestSelectedImageWidget(editingView.document.selection)),
    positions: [
      defaultPositions.northArrowSouth,
      defaultPositions.northArrowSouthWest,
      defaultPositions.northArrowSouthEast,
      defaultPositions.southArrowNorth,
      defaultPositions.southArrowNorthWest,
      defaultPositions.southArrowNorthEast,
      defaultPositions.viewportStickyNorth
    ]
  };
}
var ImageTextAlternativeUI = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * The contextual balloon plugin instance.
    */
    __publicField(this, "_balloon");
    /**
    * A form containing a textarea and buttons, used to change the `alt` text value.
    */
    __publicField(this, "_form");
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ContextualBalloon
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageTextAlternativeUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this._createButton();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    if (this._form) {
      this._form.destroy();
    }
  }
  /**
  * Creates a button showing the balloon panel for changing the image text alternative and
  * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
  */
  _createButton() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("imageTextAlternative", (locale) => {
      const command = editor.commands.get("imageTextAlternative");
      const view = new ButtonView(locale);
      view.set({
        label: t("Change image text alternative"),
        icon: icons.textAlternative,
        tooltip: true
      });
      view.bind("isEnabled").to(command, "isEnabled");
      view.bind("isOn").to(command, "value", (value) => !!value);
      this.listenTo(view, "execute", () => {
        this._showForm();
      });
      return view;
    });
  }
  /**
  * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
  * form.
  */
  _createForm() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const imageUtils = editor.plugins.get("ImageUtils");
    this._balloon = this.editor.plugins.get("ContextualBalloon");
    this._form = new (CssTransitionDisablerMixin(TextAlternativeFormView))(editor.locale);
    this._form.render();
    this.listenTo(this._form, "submit", () => {
      editor.execute("imageTextAlternative", {
        newValue: this._form.labeledInput.fieldView.element.value
      });
      this._hideForm(true);
    });
    this.listenTo(this._form, "cancel", () => {
      this._hideForm(true);
    });
    this._form.keystrokes.set("Esc", (data, cancel) => {
      this._hideForm(true);
      cancel();
    });
    this.listenTo(editor.ui, "update", () => {
      if (!imageUtils.getClosestSelectedImageWidget(viewDocument.selection)) {
        this._hideForm(true);
      } else if (this._isVisible) {
        repositionContextualBalloon(editor);
      }
    });
    clickOutsideHandler({
      emitter: this._form,
      activator: () => this._isVisible,
      contextElements: () => [
        this._balloon.view.element
      ],
      callback: () => this._hideForm()
    });
  }
  /**
  * Shows the {@link #_form} in the {@link #_balloon}.
  */
  _showForm() {
    if (this._isVisible) {
      return;
    }
    if (!this._form) {
      this._createForm();
    }
    const editor = this.editor;
    const command = editor.commands.get("imageTextAlternative");
    const labeledInput = this._form.labeledInput;
    this._form.disableCssTransitions();
    if (!this._isInBalloon) {
      this._balloon.add({
        view: this._form,
        position: getBalloonPositionData(editor)
      });
    }
    labeledInput.fieldView.value = labeledInput.fieldView.element.value = command.value || "";
    this._form.labeledInput.fieldView.select();
    this._form.enableCssTransitions();
  }
  /**
  * Removes the {@link #_form} from the {@link #_balloon}.
  *
  * @param focusEditable Controls whether the editing view is focused afterwards.
  */
  _hideForm(focusEditable = false) {
    if (!this._isInBalloon) {
      return;
    }
    if (this._form.focusTracker.isFocused) {
      this._form.saveButtonView.focus();
    }
    this._balloon.remove(this._form);
    if (focusEditable) {
      this.editor.editing.view.focus();
    }
  }
  /**
  * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
  */
  get _isVisible() {
    return !!this._balloon && this._balloon.visibleView === this._form;
  }
  /**
  * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
  */
  get _isInBalloon() {
    return !!this._balloon && this._balloon.hasView(this._form);
  }
};
var ImageTextAlternative = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageTextAlternativeEditing,
      ImageTextAlternativeUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageTextAlternative";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
function upcastImageFigure(imageUtils) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.viewItem, {
      name: true,
      classes: "image"
    })) {
      return;
    }
    const viewImage = imageUtils.findViewImgElement(data.viewItem);
    if (!viewImage || !conversionApi.consumable.test(viewImage, {
      name: true
    })) {
      return;
    }
    conversionApi.consumable.consume(data.viewItem, {
      name: true,
      classes: "image"
    });
    const conversionResult = conversionApi.convertItem(viewImage, data.modelCursor);
    const modelImage = first(conversionResult.modelRange.getItems());
    if (!modelImage) {
      conversionApi.consumable.revert(data.viewItem, {
        name: true,
        classes: "image"
      });
      return;
    }
    conversionApi.convertChildren(data.viewItem, modelImage);
    conversionApi.updateConversionResult(modelImage, data);
  };
  return (dispatcher) => {
    dispatcher.on("element:figure", converter);
  };
}
function upcastPicture(imageUtils) {
  const sourceAttributeNames = [
    "srcset",
    "media",
    "type",
    "sizes"
  ];
  const converter = (evt, data, conversionApi) => {
    const pictureViewElement = data.viewItem;
    if (!conversionApi.consumable.test(pictureViewElement, {
      name: true
    })) {
      return;
    }
    const sources = /* @__PURE__ */ new Map();
    for (const childSourceElement of pictureViewElement.getChildren()) {
      if (childSourceElement.is("element", "source")) {
        const attributes = {};
        for (const name of sourceAttributeNames) {
          if (childSourceElement.hasAttribute(name)) {
            if (conversionApi.consumable.test(childSourceElement, {
              attributes: name
            })) {
              attributes[name] = childSourceElement.getAttribute(name);
            }
          }
        }
        if (Object.keys(attributes).length) {
          sources.set(childSourceElement, attributes);
        }
      }
    }
    const imgViewElement = imageUtils.findViewImgElement(pictureViewElement);
    if (!imgViewElement) {
      return;
    }
    let modelImage = data.modelCursor.parent;
    if (!modelImage.is("element", "imageBlock")) {
      const conversionResult = conversionApi.convertItem(imgViewElement, data.modelCursor);
      data.modelRange = conversionResult.modelRange;
      data.modelCursor = conversionResult.modelCursor;
      modelImage = first(conversionResult.modelRange.getItems());
    }
    conversionApi.consumable.consume(pictureViewElement, {
      name: true
    });
    for (const [sourceElement, attributes] of sources) {
      conversionApi.consumable.consume(sourceElement, {
        attributes: Object.keys(attributes)
      });
    }
    if (sources.size) {
      conversionApi.writer.setAttribute("sources", Array.from(sources.values()), modelImage);
    }
    conversionApi.convertChildren(pictureViewElement, modelImage);
  };
  return (dispatcher) => {
    dispatcher.on("element:picture", converter);
  };
}
function downcastSrcsetAttribute(imageUtils, imageType) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const writer = conversionApi.writer;
    const element = conversionApi.mapper.toViewElement(data.item);
    const img = imageUtils.findViewImgElement(element);
    if (data.attributeNewValue === null) {
      writer.removeAttribute("srcset", img);
      writer.removeAttribute("sizes", img);
    } else {
      if (data.attributeNewValue) {
        writer.setAttribute("srcset", data.attributeNewValue, img);
        writer.setAttribute("sizes", "100vw", img);
      }
    }
  };
  return (dispatcher) => {
    dispatcher.on(`attribute:srcset:${imageType}`, converter);
  };
}
function downcastSourcesAttribute(imageUtils) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const element = conversionApi.mapper.toViewElement(data.item);
    const imgElement = imageUtils.findViewImgElement(element);
    const attributeNewValue = data.attributeNewValue;
    if (attributeNewValue && attributeNewValue.length) {
      const attributeElements = [];
      let viewElement = imgElement.parent;
      while (viewElement && viewElement.is("attributeElement")) {
        const parentElement = viewElement.parent;
        viewWriter.unwrap(viewWriter.createRangeOn(imgElement), viewElement);
        attributeElements.unshift(viewElement);
        viewElement = parentElement;
      }
      const hasPictureElement = imgElement.parent.is("element", "picture");
      const pictureElement = hasPictureElement ? imgElement.parent : viewWriter.createContainerElement("picture", null);
      if (!hasPictureElement) {
        viewWriter.insert(viewWriter.createPositionBefore(imgElement), pictureElement);
      }
      viewWriter.remove(viewWriter.createRangeIn(pictureElement));
      viewWriter.insert(viewWriter.createPositionAt(pictureElement, "end"), attributeNewValue.map((sourceAttributes) => {
        return viewWriter.createEmptyElement("source", sourceAttributes);
      }));
      viewWriter.move(viewWriter.createRangeOn(imgElement), viewWriter.createPositionAt(pictureElement, "end"));
      for (const attributeElement of attributeElements) {
        viewWriter.wrap(viewWriter.createRangeOn(pictureElement), attributeElement);
      }
    } else if (imgElement.parent.is("element", "picture")) {
      const pictureElement = imgElement.parent;
      viewWriter.move(viewWriter.createRangeOn(imgElement), viewWriter.createPositionBefore(pictureElement));
      viewWriter.remove(pictureElement);
    }
  };
  return (dispatcher) => {
    dispatcher.on("attribute:sources:imageBlock", converter);
    dispatcher.on("attribute:sources:imageInline", converter);
  };
}
function downcastImageAttribute(imageUtils, imageType, attributeKey2) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const element = conversionApi.mapper.toViewElement(data.item);
    const img = imageUtils.findViewImgElement(element);
    viewWriter.setAttribute(data.attributeKey, data.attributeNewValue || "", img);
  };
  return (dispatcher) => {
    dispatcher.on(`attribute:${attributeKey2}:${imageType}`, converter);
  };
}
var ImageLoadObserver = class extends Observer {
  /**
  * @inheritDoc
  */
  observe(domRoot) {
    this.listenTo(domRoot, "load", (event, domEvent) => {
      const domElement = domEvent.target;
      if (this.checkShouldIgnoreEventFromTarget(domElement)) {
        return;
      }
      if (domElement.tagName == "IMG") {
        this._fireEvents(domEvent);
      }
    }, {
      useCapture: true
    });
  }
  /**
  * @inheritDoc
  */
  stopObserving(domRoot) {
    this.stopListening(domRoot);
  }
  /**
  * Fires {@link module:engine/view/document~Document#event:layoutChanged} and
  * {@link module:engine/view/document~Document#event:imageLoaded}
  * if observer {@link #isEnabled is enabled}.
  *
  * @param domEvent The DOM event.
  */
  _fireEvents(domEvent) {
    if (this.isEnabled) {
      this.document.fire("layoutChanged");
      this.document.fire("imageLoaded", domEvent);
    }
  }
};
var InsertImageCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    const configImageInsertType = editor.config.get("image.insert.type");
    if (!editor.plugins.has("ImageBlockEditing")) {
      if (configImageInsertType === "block") {
        logWarning("image-block-plugin-required");
      }
    }
    if (!editor.plugins.has("ImageInlineEditing")) {
      if (configImageInsertType === "inline") {
        logWarning("image-inline-plugin-required");
      }
    }
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const imageUtils = this.editor.plugins.get("ImageUtils");
    this.isEnabled = imageUtils.isImageAllowed();
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options Options for the executed command.
  * @param options.imageType The type of the image to insert. If not specified, the type will be determined automatically.
  * @param options.source The image source or an array of image sources to insert.
  * See the documentation of the command to learn more about accepted formats.
  */
  execute(options2) {
    const sourceDefinitions = toArray(options2.source);
    const selection = this.editor.model.document.selection;
    const imageUtils = this.editor.plugins.get("ImageUtils");
    const selectionAttributes = Object.fromEntries(selection.getAttributes());
    sourceDefinitions.forEach((sourceDefinition, index) => {
      const selectedElement = selection.getSelectedElement();
      if (typeof sourceDefinition === "string") {
        sourceDefinition = {
          src: sourceDefinition
        };
      }
      if (index && selectedElement && imageUtils.isImage(selectedElement)) {
        const position = this.editor.model.createPositionAfter(selectedElement);
        imageUtils.insertImage({
          ...sourceDefinition,
          ...selectionAttributes
        }, position, options2.imageType);
      } else {
        imageUtils.insertImage({
          ...sourceDefinition,
          ...selectionAttributes
        }, null, options2.imageType);
      }
    });
  }
};
var ReplaceImageSourceCommand = class extends Command {
  constructor(editor) {
    super(editor);
    this.decorate("cleanupImage");
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = this.editor.model.document.selection.getSelectedElement();
    this.isEnabled = imageUtils.isImage(element);
    this.value = this.isEnabled ? element.getAttribute("src") : null;
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options Options for the executed command.
  * @param options.source The image source to replace.
  */
  execute(options2) {
    const image = this.editor.model.document.selection.getSelectedElement();
    const imageUtils = this.editor.plugins.get("ImageUtils");
    this.editor.model.change((writer) => {
      writer.setAttribute("src", options2.source, image);
      this.cleanupImage(writer, image);
      imageUtils.setImageNaturalSizeAttributes(image);
    });
  }
  /**
  * Cleanup image attributes that are not relevant to the new source.
  *
  * Removed attributes are: 'srcset', 'sizes', 'sources', 'width', 'height', 'alt'.
  *
  * This method is decorated, to allow custom cleanup logic.
  * For example, to remove 'myImageId' attribute after 'src' has changed:
  *
  * ```ts
  * replaceImageSourceCommand.on( 'cleanupImage', ( eventInfo, [ writer, image ] ) => {
  * 	writer.removeAttribute( 'myImageId', image );
  * } );
  * ```
  */
  cleanupImage(writer, image) {
    writer.removeAttribute("srcset", image);
    writer.removeAttribute("sizes", image);
    writer.removeAttribute("sources", image);
    writer.removeAttribute("width", image);
    writer.removeAttribute("height", image);
    writer.removeAttribute("alt", image);
  }
};
var ImageEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const conversion = editor.conversion;
    editor.editing.view.addObserver(ImageLoadObserver);
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "img",
        key: "alt"
      },
      model: "alt"
    }).attributeToAttribute({
      view: {
        name: "img",
        key: "srcset"
      },
      model: "srcset"
    });
    const insertImageCommand = new InsertImageCommand(editor);
    const replaceImageSourceCommand = new ReplaceImageSourceCommand(editor);
    editor.commands.add("insertImage", insertImageCommand);
    editor.commands.add("replaceImageSource", replaceImageSourceCommand);
    editor.commands.add("imageInsert", insertImageCommand);
  }
};
var ImageSizeAttributes = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageSizeAttributes";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    this._registerSchema();
    this._registerConverters("imageBlock");
    this._registerConverters("imageInline");
  }
  /**
  * Registers the `width` and `height` attributes for inline and block images.
  */
  _registerSchema() {
    if (this.editor.plugins.has("ImageBlockEditing")) {
      this.editor.model.schema.extend("imageBlock", {
        allowAttributes: [
          "width",
          "height"
        ]
      });
    }
    if (this.editor.plugins.has("ImageInlineEditing")) {
      this.editor.model.schema.extend("imageInline", {
        allowAttributes: [
          "width",
          "height"
        ]
      });
    }
  }
  /**
  * Registers converters for `width` and `height` attributes.
  */
  _registerConverters(imageType) {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const viewElementName = imageType === "imageBlock" ? "figure" : "img";
    editor.conversion.for("upcast").attributeToAttribute({
      view: {
        name: viewElementName,
        styles: {
          width: /.+/
        }
      },
      model: {
        key: "width",
        value: (viewElement) => {
          if (widthAndHeightStylesAreBothSet(viewElement)) {
            return getSizeValueIfInPx(viewElement.getStyle("width"));
          }
          return null;
        }
      }
    }).attributeToAttribute({
      view: {
        name: viewElementName,
        key: "width"
      },
      model: "width"
    }).attributeToAttribute({
      view: {
        name: viewElementName,
        styles: {
          height: /.+/
        }
      },
      model: {
        key: "height",
        value: (viewElement) => {
          if (widthAndHeightStylesAreBothSet(viewElement)) {
            return getSizeValueIfInPx(viewElement.getStyle("height"));
          }
          return null;
        }
      }
    }).attributeToAttribute({
      view: {
        name: viewElementName,
        key: "height"
      },
      model: "height"
    });
    editor.conversion.for("editingDowncast").add((dispatcher) => {
      attachDowncastConverter(dispatcher, "width", "width", true);
      attachDowncastConverter(dispatcher, "height", "height", true);
    });
    editor.conversion.for("dataDowncast").add((dispatcher) => {
      attachDowncastConverter(dispatcher, "width", "width", false);
      attachDowncastConverter(dispatcher, "height", "height", false);
    });
    function attachDowncastConverter(dispatcher, modelAttributeName, viewAttributeName, setRatioForInlineImage) {
      dispatcher.on(`attribute:${modelAttributeName}:${imageType}`, (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const viewElement = conversionApi.mapper.toViewElement(data.item);
        const img = imageUtils.findViewImgElement(viewElement);
        if (data.attributeNewValue !== null) {
          viewWriter.setAttribute(viewAttributeName, data.attributeNewValue, img);
        } else {
          viewWriter.removeAttribute(viewAttributeName, img);
        }
        if (data.item.hasAttribute("sources")) {
          return;
        }
        const isResized = data.item.hasAttribute("resizedWidth");
        if (imageType === "imageInline" && !isResized && !setRatioForInlineImage) {
          return;
        }
        const width = data.item.getAttribute("width");
        const height = data.item.getAttribute("height");
        if (width && height) {
          viewWriter.setStyle("aspect-ratio", `${width}/${height}`, img);
        }
      });
    }
  }
};
var ImageTypeCommand = class extends Command {
  /**
  * @inheritDoc
  *
  * @param modelElementName Model element name the command converts to.
  */
  constructor(editor, modelElementName) {
    super(editor);
    /**
    * Model element name the command converts to.
    */
    __publicField(this, "_modelElementName");
    this._modelElementName = modelElementName;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);
    if (this._modelElementName === "imageBlock") {
      this.isEnabled = imageUtils.isInlineImage(element);
    } else {
      this.isEnabled = imageUtils.isBlockImage(element);
    }
  }
  /**
  * Executes the command and changes the type of a selected image.
  *
  * @fires execute
  * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
  * The default is `true`.
  * @returns An object containing references to old and new model image elements
  * (for before and after the change) so external integrations can hook into the decorated
  * `execute` event and handle this change. `null` if the type change failed.
  */
  execute(options2 = {}) {
    const editor = this.editor;
    const model = this.editor.model;
    const imageUtils = editor.plugins.get("ImageUtils");
    const oldElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
    const attributes = Object.fromEntries(oldElement.getAttributes());
    if (!attributes.src && !attributes.uploadId) {
      return null;
    }
    return model.change((writer) => {
      const { setImageSizes = true } = options2;
      const markers = Array.from(model.markers).filter((marker) => marker.getRange().containsItem(oldElement));
      const newElement = imageUtils.insertImage(attributes, model.createSelection(oldElement, "on"), this._modelElementName, {
        setImageSizes
      });
      if (!newElement) {
        return null;
      }
      const newElementRange = writer.createRangeOn(newElement);
      for (const marker of markers) {
        const markerRange = marker.getRange();
        const range = markerRange.root.rootName != "$graveyard" ? markerRange.getJoined(newElementRange, true) : newElementRange;
        writer.updateMarker(marker, {
          range
        });
      }
      return {
        oldElement,
        newElement
      };
    });
  }
};
var ImagePlaceholder = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImagePlaceholder";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    this._setupSchema();
    this._setupConversion();
    this._setupLoadListener();
  }
  /**
  * Extends model schema.
  */
  _setupSchema() {
    const schema = this.editor.model.schema;
    if (schema.isRegistered("imageBlock")) {
      schema.extend("imageBlock", {
        allowAttributes: [
          "placeholder"
        ]
      });
    }
    if (schema.isRegistered("imageInline")) {
      schema.extend("imageInline", {
        allowAttributes: [
          "placeholder"
        ]
      });
    }
  }
  /**
  * Registers converters.
  */
  _setupConversion() {
    const editor = this.editor;
    const conversion = editor.conversion;
    const imageUtils = editor.plugins.get("ImageUtils");
    conversion.for("editingDowncast").add((dispatcher) => {
      dispatcher.on("attribute:placeholder", (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        if (!data.item.is("element", "imageBlock") && !data.item.is("element", "imageInline")) {
          return;
        }
        conversionApi.consumable.consume(data.item, evt.name);
        const viewWriter = conversionApi.writer;
        const element = conversionApi.mapper.toViewElement(data.item);
        const img = imageUtils.findViewImgElement(element);
        if (data.attributeNewValue) {
          viewWriter.addClass("image_placeholder", img);
          viewWriter.setStyle("background-image", `url(${data.attributeNewValue})`, img);
          viewWriter.setCustomProperty("editingPipeline:doNotReuseOnce", true, img);
        } else {
          viewWriter.removeClass("image_placeholder", img);
          viewWriter.removeStyle("background-image", img);
        }
      });
    });
  }
  /**
  * Prepares listener for image load.
  */
  _setupLoadListener() {
    const editor = this.editor;
    const model = editor.model;
    const editing = editor.editing;
    const editingView = editing.view;
    const imageUtils = editor.plugins.get("ImageUtils");
    editingView.addObserver(ImageLoadObserver);
    this.listenTo(editingView.document, "imageLoaded", (evt, domEvent) => {
      const imgViewElement = editingView.domConverter.mapDomToView(domEvent.target);
      if (!imgViewElement) {
        return;
      }
      const viewElement = imageUtils.getImageWidgetFromImageView(imgViewElement);
      if (!viewElement) {
        return;
      }
      const modelElement = editing.mapper.toModelElement(viewElement);
      if (!modelElement || !modelElement.hasAttribute("placeholder")) {
        return;
      }
      model.enqueueChange({
        isUndoable: false
      }, (writer) => {
        writer.removeAttribute("placeholder", modelElement);
      });
    });
  }
};
var ImageBlockEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageEditing,
      ImageSizeAttributes,
      ImageUtils,
      ImagePlaceholder,
      ClipboardPipeline
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageBlockEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    schema.register("imageBlock", {
      inheritAllFrom: "$blockObject",
      allowAttributes: [
        "alt",
        "src",
        "srcset"
      ]
    });
    this._setupConversion();
    if (editor.plugins.has("ImageInlineEditing")) {
      editor.commands.add("imageTypeBlock", new ImageTypeCommand(this.editor, "imageBlock"));
      this._setupClipboardIntegration();
    }
  }
  /**
  * Configures conversion pipelines to support upcasting and downcasting
  * block images (block image widgets) and their attributes.
  */
  _setupConversion() {
    const editor = this.editor;
    const t = editor.t;
    const conversion = editor.conversion;
    const imageUtils = editor.plugins.get("ImageUtils");
    conversion.for("dataDowncast").elementToStructure({
      model: "imageBlock",
      view: (modelElement, { writer }) => createBlockImageViewElement(writer)
    });
    conversion.for("editingDowncast").elementToStructure({
      model: "imageBlock",
      view: (modelElement, { writer }) => imageUtils.toImageWidget(createBlockImageViewElement(writer), writer, t("image widget"))
    });
    conversion.for("downcast").add(downcastImageAttribute(imageUtils, "imageBlock", "src")).add(downcastImageAttribute(imageUtils, "imageBlock", "alt")).add(downcastSrcsetAttribute(imageUtils, "imageBlock"));
    conversion.for("upcast").elementToElement({
      view: getImgViewElementMatcher(editor, "imageBlock"),
      model: (viewImage, { writer }) => writer.createElement("imageBlock", viewImage.hasAttribute("src") ? {
        src: viewImage.getAttribute("src")
      } : void 0)
    }).add(upcastImageFigure(imageUtils));
  }
  /**
  * Integrates the plugin with the clipboard pipeline.
  *
  * Idea is that the feature should recognize the user's intent when an **inline** image is
  * pasted or dropped. If such an image is pasted/dropped:
  *
  * * into an empty block (e.g. an empty paragraph),
  * * on another object (e.g. some block widget).
  *
  * it gets converted into a block image on the fly. We assume this is the user's intent
  * if they decided to put their image there.
  *
  * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.
  *
  * The feature also sets image `width` and `height` attributes on paste.
  */
  _setupClipboardIntegration() {
    const editor = this.editor;
    const model = editor.model;
    const editingView = editor.editing.view;
    const imageUtils = editor.plugins.get("ImageUtils");
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
      const docFragmentChildren = Array.from(data.content.getChildren());
      let modelRange;
      if (!docFragmentChildren.every(imageUtils.isInlineImageView)) {
        return;
      }
      if (data.targetRanges) {
        modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
      } else {
        modelRange = model.document.selection.getFirstRange();
      }
      const selection = model.createSelection(modelRange);
      if (determineImageTypeForInsertionAtSelection(model.schema, selection) === "imageBlock") {
        const writer = new UpcastWriter(editingView.document);
        const blockViewImages = docFragmentChildren.map((inlineViewImage) => writer.createElement("figure", {
          class: "image"
        }, inlineViewImage));
        data.content = writer.createDocumentFragment(blockViewImages);
      }
    });
    this.listenTo(clipboardPipeline, "contentInsertion", (evt, data) => {
      if (data.method !== "paste") {
        return;
      }
      model.change((writer) => {
        const range = writer.createRangeIn(data.content);
        for (const item of range.getItems()) {
          if (item.is("element", "imageBlock")) {
            imageUtils.setImageNaturalSizeAttributes(item);
          }
        }
      });
    });
  }
};
var ImageInsertFormView = class extends View2 {
  /**
  * Creates a view for the dropdown panel of {@link module:image/imageinsert/imageinsertui~ImageInsertUI}.
  *
  * @param locale The localization services instance.
  * @param integrations An integrations object that contains components (or tokens for components) to be shown in the panel view.
  */
  constructor(locale, integrations = []) {
    super(locale);
    /**
    * Tracks information about DOM focus in the form.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * A collection of views that can be focused in the form.
    */
    __publicField(this, "_focusables");
    /**
    * Helps cycling over {@link #_focusables} in the form.
    */
    __publicField(this, "_focusCycler");
    /**
    * A collection of the defined integrations for inserting the images.
    */
    __publicField(this, "children");
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusables = new ViewCollection();
    this.children = this.createCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    for (const view of integrations) {
      this.children.add(view);
      this._focusables.add(view);
      if (view instanceof CollapsibleView) {
        this._focusables.addMany(view.children);
      }
    }
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-image-insert-form"
        ],
        tabindex: -1
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    for (const view of this._focusables) {
      this.focusTracker.add(view.element);
    }
    this.keystrokes.listenTo(this.element);
    const stopPropagation = (data) => data.stopPropagation();
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the first {@link #_focusables focusable} in the form.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
};
var ImageInsertUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The dropdown view responsible for displaying the image insert UI.
    */
    __publicField(this, "dropdownView");
    /**
    * Registered integrations map.
    */
    __publicField(this, "_integrations", /* @__PURE__ */ new Map());
    editor.config.define("image.insert.integrations", [
      "upload",
      "assetManager",
      "url"
    ]);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageInsertUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const imageUtils = editor.plugins.get("ImageUtils");
    this.set("isImageSelected", false);
    this.listenTo(editor.model.document, "change", () => {
      this.isImageSelected = imageUtils.isImage(selection.getSelectedElement());
    });
    const componentCreator = (locale) => this._createToolbarComponent(locale);
    const menuBarComponentCreator = (locale) => this._createMenuBarComponent(locale);
    editor.ui.componentFactory.add("insertImage", componentCreator);
    editor.ui.componentFactory.add("imageInsert", componentCreator);
    editor.ui.componentFactory.add("menuBar:insertImage", menuBarComponentCreator);
  }
  /**
  * Registers the insert image dropdown integration.
  */
  registerIntegration({ name, observable, buttonViewCreator, formViewCreator, menuBarButtonViewCreator, requiresForm = false }) {
    if (this._integrations.has(name)) {
      logWarning("image-insert-integration-exists", {
        name
      });
    }
    this._integrations.set(name, {
      observable,
      buttonViewCreator,
      menuBarButtonViewCreator,
      formViewCreator,
      requiresForm
    });
  }
  /**
  * Creates the toolbar component.
  */
  _createToolbarComponent(locale) {
    const editor = this.editor;
    const t = locale.t;
    const integrations = this._prepareIntegrations();
    if (!integrations.length) {
      return null;
    }
    let dropdownButton;
    const firstIntegration = integrations[0];
    if (integrations.length == 1) {
      if (!firstIntegration.requiresForm) {
        return firstIntegration.buttonViewCreator(true);
      }
      dropdownButton = firstIntegration.buttonViewCreator(true);
    } else {
      const actionButton = firstIntegration.buttonViewCreator(false);
      dropdownButton = new SplitButtonView(locale, actionButton);
      dropdownButton.tooltip = true;
      dropdownButton.bind("label").to(this, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace image") : t("Insert image"));
    }
    const dropdownView = this.dropdownView = createDropdown(locale, dropdownButton);
    const observables = integrations.map(({ observable }) => typeof observable == "function" ? observable() : observable);
    dropdownView.bind("isEnabled").toMany(observables, "isEnabled", (...isEnabled) => isEnabled.some((isEnabled2) => isEnabled2));
    dropdownView.once("change:isOpen", () => {
      const integrationViews = integrations.map(({ formViewCreator }) => formViewCreator(integrations.length == 1));
      const imageInsertFormView = new ImageInsertFormView(editor.locale, integrationViews);
      dropdownView.panelView.children.add(imageInsertFormView);
    });
    return dropdownView;
  }
  /**
  * Creates the menu bar component.
  */
  _createMenuBarComponent(locale) {
    const t = locale.t;
    const integrations = this._prepareIntegrations();
    if (!integrations.length) {
      return null;
    }
    let resultView;
    const firstIntegration = integrations[0];
    if (integrations.length == 1) {
      resultView = firstIntegration.menuBarButtonViewCreator(true);
    } else {
      resultView = new MenuBarMenuView(locale);
      const listView = new MenuBarMenuListView(locale);
      resultView.panelView.children.add(listView);
      resultView.buttonView.set({
        icon: icons.image,
        label: t("Image")
      });
      for (const integration of integrations) {
        const listItemView = new MenuBarMenuListItemView(locale, resultView);
        const buttonView = integration.menuBarButtonViewCreator(false);
        listItemView.children.add(buttonView);
        listView.items.add(listItemView);
      }
    }
    return resultView;
  }
  /**
  * Validates the integrations list.
  */
  _prepareIntegrations() {
    const editor = this.editor;
    const items = editor.config.get("image.insert.integrations");
    const result = [];
    if (!items.length) {
      logWarning("image-insert-integrations-not-specified");
      return result;
    }
    for (const item of items) {
      if (!this._integrations.has(item)) {
        if (![
          "upload",
          "assetManager",
          "url"
        ].includes(item)) {
          logWarning("image-insert-unknown-integration", {
            item
          });
        }
        continue;
      }
      result.push(this._integrations.get(item));
    }
    if (!result.length) {
      logWarning("image-insert-integrations-not-registered");
    }
    return result;
  }
};
var ImageBlock = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageBlockEditing,
      Widget,
      ImageTextAlternative,
      ImageInsertUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageBlock";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var ImageInlineEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageEditing,
      ImageSizeAttributes,
      ImageUtils,
      ImagePlaceholder,
      ClipboardPipeline
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageInlineEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    schema.register("imageInline", {
      inheritAllFrom: "$inlineObject",
      allowAttributes: [
        "alt",
        "src",
        "srcset"
      ],
      // Disallow inline images in captions (at least for now).
      // This is the best spot to do that because independent packages can introduce captions (ImageCaption, TableCaption, etc.).
      disallowIn: [
        "caption"
      ]
    });
    this._setupConversion();
    if (editor.plugins.has("ImageBlockEditing")) {
      editor.commands.add("imageTypeInline", new ImageTypeCommand(this.editor, "imageInline"));
      this._setupClipboardIntegration();
    }
  }
  /**
  * Configures conversion pipelines to support upcasting and downcasting
  * inline images (inline image widgets) and their attributes.
  */
  _setupConversion() {
    const editor = this.editor;
    const t = editor.t;
    const conversion = editor.conversion;
    const imageUtils = editor.plugins.get("ImageUtils");
    conversion.for("dataDowncast").elementToElement({
      model: "imageInline",
      view: (modelElement, { writer }) => writer.createEmptyElement("img")
    });
    conversion.for("editingDowncast").elementToStructure({
      model: "imageInline",
      view: (modelElement, { writer }) => imageUtils.toImageWidget(createInlineImageViewElement(writer), writer, t("image widget"))
    });
    conversion.for("downcast").add(downcastImageAttribute(imageUtils, "imageInline", "src")).add(downcastImageAttribute(imageUtils, "imageInline", "alt")).add(downcastSrcsetAttribute(imageUtils, "imageInline"));
    conversion.for("upcast").elementToElement({
      view: getImgViewElementMatcher(editor, "imageInline"),
      model: (viewImage, { writer }) => writer.createElement("imageInline", viewImage.hasAttribute("src") ? {
        src: viewImage.getAttribute("src")
      } : void 0)
    });
  }
  /**
  * Integrates the plugin with the clipboard pipeline.
  *
  * Idea is that the feature should recognize the user's intent when an **block** image is
  * pasted or dropped. If such an image is pasted/dropped into a non-empty block
  * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.
  *
  * We assume this is the user's intent if they decided to put their image there.
  *
  * **Note**: If a block image has a caption, it will not be converted to an inline image
  * to avoid the confusion. Captions are added on purpose and they should never be lost
  * in the clipboard pipeline.
  *
  * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.
  *
  * The feature also sets image `width` and `height` attributes when pasting.
  */
  _setupClipboardIntegration() {
    const editor = this.editor;
    const model = editor.model;
    const editingView = editor.editing.view;
    const imageUtils = editor.plugins.get("ImageUtils");
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
      const docFragmentChildren = Array.from(data.content.getChildren());
      let modelRange;
      if (!docFragmentChildren.every(imageUtils.isBlockImageView)) {
        return;
      }
      if (data.targetRanges) {
        modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
      } else {
        modelRange = model.document.selection.getFirstRange();
      }
      const selection = model.createSelection(modelRange);
      if (determineImageTypeForInsertionAtSelection(model.schema, selection) === "imageInline") {
        const writer = new UpcastWriter(editingView.document);
        const inlineViewImages = docFragmentChildren.map((blockViewImage) => {
          if (blockViewImage.childCount === 1) {
            Array.from(blockViewImage.getAttributes()).forEach((attribute) => writer.setAttribute(...attribute, imageUtils.findViewImgElement(blockViewImage)));
            return blockViewImage.getChild(0);
          } else {
            return blockViewImage;
          }
        });
        data.content = writer.createDocumentFragment(inlineViewImages);
      }
    });
    this.listenTo(clipboardPipeline, "contentInsertion", (evt, data) => {
      if (data.method !== "paste") {
        return;
      }
      model.change((writer) => {
        const range = writer.createRangeIn(data.content);
        for (const item of range.getItems()) {
          if (item.is("element", "imageInline")) {
            imageUtils.setImageNaturalSizeAttributes(item);
          }
        }
      });
    });
  }
};
var ImageInline = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageInlineEditing,
      Widget,
      ImageTextAlternative,
      ImageInsertUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageInline";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var Image = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageBlock,
      ImageInline
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Image";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var ImageCaptionUtils = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageCaptionUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils
    ];
  }
  /**
  * Returns the caption model element from a given image element. Returns `null` if no caption is found.
  */
  getCaptionFromImageModelElement(imageModelElement) {
    for (const node of imageModelElement.getChildren()) {
      if (!!node && node.is("element", "caption")) {
        return node;
      }
    }
    return null;
  }
  /**
  * Returns the caption model element for a model selection. Returns `null` if the selection has no caption element ancestor.
  */
  getCaptionFromModelSelection(selection) {
    const imageUtils = this.editor.plugins.get("ImageUtils");
    const captionElement = selection.getFirstPosition().findAncestor("caption");
    if (!captionElement) {
      return null;
    }
    if (imageUtils.isBlockImage(captionElement.parent)) {
      return captionElement;
    }
    return null;
  }
  /**
  * {@link module:engine/view/matcher~Matcher} pattern. Checks if a given element is a `<figcaption>` element that is placed
  * inside the image `<figure>` element.
  * @returns Returns the object accepted by {@link module:engine/view/matcher~Matcher} or `null` if the element
  * cannot be matched.
  */
  matchImageCaptionViewElement(element) {
    const imageUtils = this.editor.plugins.get("ImageUtils");
    if (element.name == "figcaption" && imageUtils.isBlockImageView(element.parent)) {
      return {
        name: true
      };
    }
    return null;
  }
};
var ToggleImageCaptionCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    const imageUtils = editor.plugins.get("ImageUtils");
    if (!editor.plugins.has(ImageBlockEditing)) {
      this.isEnabled = false;
      this.value = false;
      return;
    }
    const selection = editor.model.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (!selectedElement) {
      const ancestorCaptionElement = imageCaptionUtils.getCaptionFromModelSelection(selection);
      this.isEnabled = !!ancestorCaptionElement;
      this.value = !!ancestorCaptionElement;
      return;
    }
    this.isEnabled = imageUtils.isImage(selectedElement);
    if (!this.isEnabled) {
      this.value = false;
    } else {
      this.value = !!imageCaptionUtils.getCaptionFromImageModelElement(selectedElement);
    }
  }
  /**
  * Executes the command.
  *
  * ```ts
  * editor.execute( 'toggleImageCaption' );
  * ```
  *
  * @param options Options for the executed command.
  * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
  * @fires execute
  */
  execute(options2 = {}) {
    const { focusCaptionOnShow } = options2;
    this.editor.model.change((writer) => {
      if (this.value) {
        this._hideImageCaption(writer);
      } else {
        this._showImageCaption(writer, focusCaptionOnShow);
      }
    });
  }
  /**
  * Shows the caption of the `<imageBlock>` or `<imageInline>`. Also:
  *
  * * it converts `<imageInline>` to `<imageBlock>` to show the caption,
  * * it attempts to restore the caption content from the `ImageCaptionEditing` caption registry,
  * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
  */
  _showImageCaption(writer, focusCaptionOnShow) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const imageCaptionEditing = this.editor.plugins.get("ImageCaptionEditing");
    const imageUtils = this.editor.plugins.get("ImageUtils");
    let selectedImage = selection.getSelectedElement();
    const savedCaption = imageCaptionEditing._getSavedCaption(selectedImage);
    if (imageUtils.isInlineImage(selectedImage)) {
      this.editor.execute("imageTypeBlock");
      selectedImage = selection.getSelectedElement();
    }
    const newCaptionElement = savedCaption || writer.createElement("caption");
    writer.append(newCaptionElement, selectedImage);
    if (focusCaptionOnShow) {
      writer.setSelection(newCaptionElement, "in");
    }
  }
  /**
  * Hides the caption of a selected image (or an image caption the selection is anchored to).
  *
  * The content of the caption is stored in the `ImageCaptionEditing` caption registry to make this
  * a reversible action.
  */
  _hideImageCaption(writer) {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const imageCaptionEditing = editor.plugins.get("ImageCaptionEditing");
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    let selectedImage = selection.getSelectedElement();
    let captionElement;
    if (selectedImage) {
      captionElement = imageCaptionUtils.getCaptionFromImageModelElement(selectedImage);
    } else {
      captionElement = imageCaptionUtils.getCaptionFromModelSelection(selection);
      selectedImage = captionElement.parent;
    }
    imageCaptionEditing._saveCaption(selectedImage, captionElement);
    writer.setSelection(selectedImage, "on");
    writer.remove(captionElement);
  }
};
var ImageCaptionEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * A map that keeps saved JSONified image captions and image model elements they are
    * associated with.
    *
    * To learn more about this system, see {@link #_saveCaption}.
    */
    __publicField(this, "_savedCaptionsMap");
    this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils,
      ImageCaptionUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageCaptionEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    if (!schema.isRegistered("caption")) {
      schema.register("caption", {
        allowIn: "imageBlock",
        allowContentOf: "$block",
        isLimit: true
      });
    } else {
      schema.extend("caption", {
        allowIn: "imageBlock"
      });
    }
    editor.commands.add("toggleImageCaption", new ToggleImageCaptionCommand(this.editor));
    this._setupConversion();
    this._setupImageTypeCommandsIntegration();
    this._registerCaptionReconversion();
  }
  /**
  * Configures conversion pipelines to support upcasting and downcasting
  * image captions.
  */
  _setupConversion() {
    const editor = this.editor;
    const view = editor.editing.view;
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    const t = editor.t;
    editor.conversion.for("upcast").elementToElement({
      view: (element) => imageCaptionUtils.matchImageCaptionViewElement(element),
      model: "caption"
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "caption",
      view: (modelElement, { writer }) => {
        if (!imageUtils.isBlockImage(modelElement.parent)) {
          return null;
        }
        return writer.createContainerElement("figcaption");
      }
    });
    editor.conversion.for("editingDowncast").elementToElement({
      model: "caption",
      view: (modelElement, { writer }) => {
        if (!imageUtils.isBlockImage(modelElement.parent)) {
          return null;
        }
        const figcaptionElement = writer.createEditableElement("figcaption");
        writer.setCustomProperty("imageCaption", true, figcaptionElement);
        figcaptionElement.placeholder = t("Enter image caption");
        enablePlaceholder({
          view,
          element: figcaptionElement,
          keepOnFocus: true
        });
        const imageAlt = modelElement.parent.getAttribute("alt");
        const label = imageAlt ? t("Caption for image: %0", [
          imageAlt
        ]) : t("Caption for the image");
        return toWidgetEditable(figcaptionElement, writer, {
          label
        });
      }
    });
  }
  /**
  * Integrates with {@link module:image/image/imagetypecommand~ImageTypeCommand image type commands}
  * to make sure the caption is preserved when the type of an image changes so it can be restored
  * in the future if the user decides they want their caption back.
  */
  _setupImageTypeCommandsIntegration() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    const imageTypeInlineCommand = editor.commands.get("imageTypeInline");
    const imageTypeBlockCommand = editor.commands.get("imageTypeBlock");
    const handleImageTypeChange = (evt) => {
      if (!evt.return) {
        return;
      }
      const { oldElement, newElement } = evt.return;
      if (!oldElement) {
        return;
      }
      if (imageUtils.isBlockImage(oldElement)) {
        const oldCaptionElement = imageCaptionUtils.getCaptionFromImageModelElement(oldElement);
        if (oldCaptionElement) {
          this._saveCaption(newElement, oldCaptionElement);
          return;
        }
      }
      const savedOldElementCaption = this._getSavedCaption(oldElement);
      if (savedOldElementCaption) {
        this._saveCaption(newElement, savedOldElementCaption);
      }
    };
    if (imageTypeInlineCommand) {
      this.listenTo(imageTypeInlineCommand, "execute", handleImageTypeChange, {
        priority: "low"
      });
    }
    if (imageTypeBlockCommand) {
      this.listenTo(imageTypeBlockCommand, "execute", handleImageTypeChange, {
        priority: "low"
      });
    }
  }
  /**
  * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
  * of an image model element.
  *
  * See {@link #_saveCaption}.
  *
  * @internal
  * @param imageModelElement The model element the caption should be returned for.
  * @returns The model caption element or `null` if there is none.
  */
  _getSavedCaption(imageModelElement) {
    const jsonObject = this._savedCaptionsMap.get(imageModelElement);
    return jsonObject ? Element.fromJSON(jsonObject) : null;
  }
  /**
  * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
  * an image element to allow restoring it in the future.
  *
  * A caption is saved every time it gets hidden and/or the type of an image changes. The
  * user should be able to restore it on demand.
  *
  * **Note**: The caption cannot be stored in the image model element attribute because,
  * for instance, when the model state propagates to collaborators, the attribute would get
  * lost (mainly because it does not convert to anything when the caption is hidden) and
  * the states of collaborators' models would de-synchronize causing numerous issues.
  *
  * See {@link #_getSavedCaption}.
  *
  * @internal
  * @param imageModelElement The model element the caption is saved for.
  * @param caption The caption model element to be saved.
  */
  _saveCaption(imageModelElement, caption) {
    this._savedCaptionsMap.set(imageModelElement, caption.toJSON());
  }
  /**
  * Reconverts image caption when image alt attribute changes.
  * The change of alt attribute is reflected in caption's aria-label attribute.
  */
  _registerCaptionReconversion() {
    const editor = this.editor;
    const model = editor.model;
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    model.document.on("change:data", () => {
      const changes = model.document.differ.getChanges();
      for (const change of changes) {
        if (change.attributeKey !== "alt") {
          continue;
        }
        const image = change.range.start.nodeAfter;
        if (imageUtils.isBlockImage(image)) {
          const caption = imageCaptionUtils.getCaptionFromImageModelElement(image);
          if (!caption) {
            return;
          }
          editor.editing.reconvertItem(caption);
        }
      }
    });
  }
};
var ImageCaptionUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageCaptionUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageCaptionUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    const t = editor.t;
    editor.ui.componentFactory.add("toggleImageCaption", (locale) => {
      const command = editor.commands.get("toggleImageCaption");
      const view = new ButtonView(locale);
      view.set({
        icon: icons.caption,
        tooltip: true,
        isToggleable: true
      });
      view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      view.bind("label").to(command, "value", (value) => value ? t("Toggle caption off") : t("Toggle caption on"));
      this.listenTo(view, "execute", () => {
        editor.execute("toggleImageCaption", {
          focusCaptionOnShow: true
        });
        const modelCaptionElement = imageCaptionUtils.getCaptionFromModelSelection(editor.model.document.selection);
        if (modelCaptionElement) {
          const figcaptionElement = editor.editing.mapper.toViewElement(modelCaptionElement);
          editingView.scrollToTheSelection();
          editingView.change((writer) => {
            writer.addClass("image__caption_highlighted", figcaptionElement);
          });
        }
        editor.editing.view.focus();
      });
      return view;
    });
  }
};
var ImageCaption = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageCaptionEditing,
      ImageCaptionUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageCaption";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
function createImageTypeRegExp(types) {
  const regExpSafeNames = types.map((type) => type.replace("+", "\\+"));
  return new RegExp(`^image\\/(${regExpSafeNames.join("|")})$`);
}
function fetchLocalImage(image) {
  return new Promise((resolve, reject) => {
    const imageSrc = image.getAttribute("src");
    fetch(imageSrc).then((resource) => resource.blob()).then((blob) => {
      const mimeType = getImageMimeType(blob, imageSrc);
      const ext = mimeType.replace("image/", "");
      const filename = `image.${ext}`;
      const file = new File([
        blob
      ], filename, {
        type: mimeType
      });
      resolve(file);
    }).catch((err) => {
      return err && err.name === "TypeError" ? convertLocalImageOnCanvas(imageSrc).then(resolve).catch(reject) : reject(err);
    });
  });
}
function isLocalImage(imageUtils, node) {
  if (!imageUtils.isInlineImageView(node) || !node.getAttribute("src")) {
    return false;
  }
  return !!node.getAttribute("src").match(/^data:image\/\w+;base64,/g) || !!node.getAttribute("src").match(/^blob:/g);
}
function getImageMimeType(blob, src) {
  if (blob.type) {
    return blob.type;
  } else if (src.match(/data:(image\/\w+);base64/)) {
    return src.match(/data:(image\/\w+);base64/)[1].toLowerCase();
  } else {
    return "image/jpeg";
  }
}
function convertLocalImageOnCanvas(imageSrc) {
  return getBlobFromCanvas(imageSrc).then((blob) => {
    const mimeType = getImageMimeType(blob, imageSrc);
    const ext = mimeType.replace("image/", "");
    const filename = `image.${ext}`;
    return new File([
      blob
    ], filename, {
      type: mimeType
    });
  });
}
function getBlobFromCanvas(imageSrc) {
  return new Promise((resolve, reject) => {
    const image = global.document.createElement("img");
    image.addEventListener("load", () => {
      const canvas = global.document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0);
      canvas.toBlob((blob) => blob ? resolve(blob) : reject());
    });
    image.addEventListener("error", () => reject());
    image.src = imageSrc;
  });
}
var ImageUploadUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageUploadUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("uploadImage", () => this._createToolbarButton());
    editor.ui.componentFactory.add("imageUpload", () => this._createToolbarButton());
    editor.ui.componentFactory.add("menuBar:uploadImage", () => this._createMenuBarButton("standalone"));
    if (editor.plugins.has("ImageInsertUI")) {
      editor.plugins.get("ImageInsertUI").registerIntegration({
        name: "upload",
        observable: () => editor.commands.get("uploadImage"),
        buttonViewCreator: () => this._createToolbarButton(),
        formViewCreator: () => this._createDropdownButton(),
        menuBarButtonViewCreator: (isOnly) => this._createMenuBarButton(isOnly ? "insertOnly" : "insertNested")
      });
    }
  }
  /**
  * Creates the base for various kinds of the button component provided by this feature.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get("uploadImage");
    const imageTypes = editor.config.get("image.upload.types");
    const imageTypesRegExp = createImageTypeRegExp(imageTypes);
    const view = new ButtonClass(editor.locale);
    const t = locale.t;
    view.set({
      acceptedType: imageTypes.map((type) => `image/${type}`).join(","),
      allowMultipleFiles: true,
      label: t("Upload from computer"),
      icon: icons.imageUpload
    });
    view.bind("isEnabled").to(command);
    view.on("done", (evt, files) => {
      const imagesToUpload = Array.from(files).filter((file) => imageTypesRegExp.test(file.type));
      if (imagesToUpload.length) {
        editor.execute("uploadImage", {
          file: imagesToUpload
        });
        editor.editing.view.focus();
      }
    });
    return view;
  }
  /**
  * Creates a simple toolbar button, with an icon and a tooltip.
  */
  _createToolbarButton() {
    const t = this.editor.locale.t;
    const imageInsertUI = this.editor.plugins.get("ImageInsertUI");
    const uploadImageCommand = this.editor.commands.get("uploadImage");
    const button = this._createButton(FileDialogButtonView);
    button.tooltip = true;
    button.bind("label").to(imageInsertUI, "isImageSelected", uploadImageCommand, "isAccessAllowed", (isImageSelected, isAccessAllowed) => {
      if (!isAccessAllowed) {
        return t("You have no image upload permissions.");
      }
      return isImageSelected ? t("Replace image from computer") : t("Upload image from computer");
    });
    return button;
  }
  /**
  * Creates a button for the dropdown view, with an icon, text and no tooltip.
  */
  _createDropdownButton() {
    const t = this.editor.locale.t;
    const imageInsertUI = this.editor.plugins.get("ImageInsertUI");
    const button = this._createButton(FileDialogButtonView);
    button.withText = true;
    button.bind("label").to(imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace from computer") : t("Upload from computer"));
    button.on("execute", () => {
      imageInsertUI.dropdownView.isOpen = false;
    });
    return button;
  }
  /**
  * Creates a button for the menu bar.
  */
  _createMenuBarButton(type) {
    const t = this.editor.locale.t;
    const button = this._createButton(MenuBarMenuListItemFileDialogButtonView);
    button.withText = true;
    switch (type) {
      case "standalone":
        button.label = t("Image from computer");
        break;
      case "insertOnly":
        button.label = t("Image");
        break;
      case "insertNested":
        button.label = t("From computer");
        break;
    }
    return button;
  }
};
var ImageUploadProgress = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The image placeholder that is displayed before real image data can be accessed.
    *
    * For the record, this image is a 1x1 px GIF with an aspect ratio set by CSS.
    */
    __publicField(this, "placeholder");
    /**
    * This method is called each time the image `uploadStatus` attribute is changed.
    *
    * @param evt An object containing information about the fired event.
    * @param data Additional information about the change.
    */
    __publicField(this, "uploadStatusChange", (evt, data, conversionApi) => {
      const editor = this.editor;
      const modelImage = data.item;
      const uploadId = modelImage.getAttribute("uploadId");
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const imageUtils = editor.plugins.get("ImageUtils");
      const fileRepository = editor.plugins.get(FileRepository);
      const status = uploadId ? data.attributeNewValue : null;
      const placeholder = this.placeholder;
      const viewFigure = editor.editing.mapper.toViewElement(modelImage);
      const viewWriter = conversionApi.writer;
      if (status == "reading") {
        _startAppearEffect(viewFigure, viewWriter);
        _showPlaceholder(imageUtils, placeholder, viewFigure, viewWriter);
        return;
      }
      if (status == "uploading") {
        const loader = fileRepository.loaders.get(uploadId);
        _startAppearEffect(viewFigure, viewWriter);
        if (!loader) {
          _showPlaceholder(imageUtils, placeholder, viewFigure, viewWriter);
        } else {
          _hidePlaceholder(viewFigure, viewWriter);
          _showProgressBar(viewFigure, viewWriter, loader, editor.editing.view);
          _displayLocalImage(imageUtils, viewFigure, viewWriter, loader);
        }
        return;
      }
      if (status == "complete" && fileRepository.loaders.get(uploadId)) {
        _showCompleteIcon(viewFigure, viewWriter, editor.editing.view);
      }
      _hideProgressBar(viewFigure, viewWriter);
      _hidePlaceholder(viewFigure, viewWriter);
      _stopAppearEffect(viewFigure, viewWriter);
    });
    this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageUploadProgress";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (editor.plugins.has("ImageBlockEditing")) {
      editor.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange);
    }
    if (editor.plugins.has("ImageInlineEditing")) {
      editor.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
    }
  }
};
function _startAppearEffect(viewFigure, writer) {
  if (!viewFigure.hasClass("ck-appear")) {
    writer.addClass("ck-appear", viewFigure);
  }
}
function _stopAppearEffect(viewFigure, writer) {
  writer.removeClass("ck-appear", viewFigure);
}
function _showPlaceholder(imageUtils, placeholder, viewFigure, writer) {
  if (!viewFigure.hasClass("ck-image-upload-placeholder")) {
    writer.addClass("ck-image-upload-placeholder", viewFigure);
  }
  const viewImg = imageUtils.findViewImgElement(viewFigure);
  if (viewImg.getAttribute("src") !== placeholder) {
    writer.setAttribute("src", placeholder, viewImg);
  }
  if (!_getUIElement(viewFigure, "placeholder")) {
    writer.insert(writer.createPositionAfter(viewImg), _createPlaceholder(writer));
  }
}
function _hidePlaceholder(viewFigure, writer) {
  if (viewFigure.hasClass("ck-image-upload-placeholder")) {
    writer.removeClass("ck-image-upload-placeholder", viewFigure);
  }
  _removeUIElement(viewFigure, writer, "placeholder");
}
function _showProgressBar(viewFigure, writer, loader, view) {
  const progressBar = _createProgressBar(writer);
  writer.insert(writer.createPositionAt(viewFigure, "end"), progressBar);
  loader.on("change:uploadedPercent", (evt, name, value) => {
    view.change((writer2) => {
      writer2.setStyle("width", value + "%", progressBar);
    });
  });
}
function _hideProgressBar(viewFigure, writer) {
  _removeUIElement(viewFigure, writer, "progressBar");
}
function _showCompleteIcon(viewFigure, writer, view) {
  const completeIcon = writer.createUIElement("div", {
    class: "ck-image-upload-complete-icon"
  });
  writer.insert(writer.createPositionAt(viewFigure, "end"), completeIcon);
  setTimeout(() => {
    view.change((writer2) => writer2.remove(writer2.createRangeOn(completeIcon)));
  }, 3e3);
}
function _createProgressBar(writer) {
  const progressBar = writer.createUIElement("div", {
    class: "ck-progress-bar"
  });
  writer.setCustomProperty("progressBar", true, progressBar);
  return progressBar;
}
function _createPlaceholder(writer) {
  const placeholder = writer.createUIElement("div", {
    class: "ck-upload-placeholder-loader"
  });
  writer.setCustomProperty("placeholder", true, placeholder);
  return placeholder;
}
function _getUIElement(imageFigure, uniqueProperty) {
  for (const child of imageFigure.getChildren()) {
    if (child.getCustomProperty(uniqueProperty)) {
      return child;
    }
  }
}
function _removeUIElement(viewFigure, writer, uniqueProperty) {
  const element = _getUIElement(viewFigure, uniqueProperty);
  if (element) {
    writer.remove(writer.createRangeOn(element));
  }
}
function _displayLocalImage(imageUtils, viewFigure, writer, loader) {
  if (loader.data) {
    const viewImg = imageUtils.findViewImgElement(viewFigure);
    writer.setAttribute("src", loader.data, viewImg);
  }
}
var UploadImageCommand = class extends Command {
  /**
  * Creates an instance of the `imageUlpoad` command. When executed, the command upload one of
  * the currently selected image from computer.
  *
  * @param editor The editor instance.
  */
  constructor(editor) {
    super(editor);
    this.set("isAccessAllowed", true);
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const selectedElement = editor.model.document.selection.getSelectedElement();
    this.isEnabled = imageUtils.isImageAllowed() || imageUtils.isImage(selectedElement);
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options Options for the executed command.
  * @param options.file The image file or an array of image files to upload.
  */
  execute(options2) {
    const files = toArray(options2.file);
    const selection = this.editor.model.document.selection;
    const imageUtils = this.editor.plugins.get("ImageUtils");
    const selectionAttributes = Object.fromEntries(selection.getAttributes());
    files.forEach((file, index) => {
      const selectedElement = selection.getSelectedElement();
      if (index && selectedElement && imageUtils.isImage(selectedElement)) {
        const position = this.editor.model.createPositionAfter(selectedElement);
        this._uploadImage(file, selectionAttributes, position);
      } else {
        this._uploadImage(file, selectionAttributes);
      }
    });
  }
  /**
  * Handles uploading single file.
  */
  _uploadImage(file, attributes, position) {
    const editor = this.editor;
    const fileRepository = editor.plugins.get(FileRepository);
    const loader = fileRepository.createLoader(file);
    const imageUtils = editor.plugins.get("ImageUtils");
    if (!loader) {
      return;
    }
    imageUtils.insertImage({
      ...attributes,
      uploadId: loader.id
    }, position);
  }
};
var ImageUploadEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * An internal mapping of {@link module:upload/filerepository~FileLoader#id file loader UIDs} and
    * model elements during the upload.
    *
    * Model element of the uploaded image can change, for instance, when {@link module:image/image/imagetypecommand~ImageTypeCommand}
    * is executed as a result of adding caption or changing image style. As a result, the upload logic must keep track of the model
    * element (reference) and resolve the upload for the correct model element (instead of the one that landed in the `$graveyard`
    * after image type changed).
    */
    __publicField(this, "_uploadImageElements");
    editor.config.define("image", {
      upload: {
        types: [
          "jpeg",
          "png",
          "gif",
          "bmp",
          "webp",
          "tiff"
        ]
      }
    });
    this._uploadImageElements = /* @__PURE__ */ new Map();
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      FileRepository,
      Notification,
      ClipboardPipeline,
      ImageUtils
    ];
  }
  static get pluginName() {
    return "ImageUploadEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const doc = editor.model.document;
    const conversion = editor.conversion;
    const fileRepository = editor.plugins.get(FileRepository);
    const imageUtils = editor.plugins.get("ImageUtils");
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    const imageTypes = createImageTypeRegExp(editor.config.get("image.upload.types"));
    const uploadImageCommand = new UploadImageCommand(editor);
    editor.commands.add("uploadImage", uploadImageCommand);
    editor.commands.add("imageUpload", uploadImageCommand);
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "img",
        key: "uploadId"
      },
      model: "uploadId"
    });
    this.listenTo(editor.editing.view.document, "clipboardInput", (evt, data) => {
      if (isHtmlIncluded(data.dataTransfer)) {
        return;
      }
      const images = Array.from(data.dataTransfer.files).filter((file) => {
        if (!file) {
          return false;
        }
        return imageTypes.test(file.type);
      });
      if (!images.length) {
        return;
      }
      evt.stop();
      editor.model.change((writer) => {
        if (data.targetRanges) {
          writer.setSelection(data.targetRanges.map((viewRange) => editor.editing.mapper.toModelRange(viewRange)));
        }
        editor.execute("uploadImage", {
          file: images
        });
      });
      const uploadImageCommand2 = editor.commands.get("uploadImage");
      if (!uploadImageCommand2.isAccessAllowed) {
        const notification = editor.plugins.get("Notification");
        const t = editor.locale.t;
        notification.showWarning(t("You have no image upload permissions."), {
          namespace: "image"
        });
      }
    });
    this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
      const fetchableImages = Array.from(editor.editing.view.createRangeIn(data.content)).map((value) => value.item).filter((viewElement) => isLocalImage(imageUtils, viewElement) && !viewElement.getAttribute("uploadProcessed")).map((viewElement) => {
        return {
          promise: fetchLocalImage(viewElement),
          imageElement: viewElement
        };
      });
      if (!fetchableImages.length) {
        return;
      }
      const writer = new UpcastWriter(editor.editing.view.document);
      for (const fetchableImage of fetchableImages) {
        writer.setAttribute("uploadProcessed", true, fetchableImage.imageElement);
        const loader = fileRepository.createLoader(fetchableImage.promise);
        if (loader) {
          writer.setAttribute("src", "", fetchableImage.imageElement);
          writer.setAttribute("uploadId", loader.id, fetchableImage.imageElement);
        }
      }
    });
    editor.editing.view.document.on("dragover", (evt, data) => {
      data.preventDefault();
    });
    doc.on("change", () => {
      const changes = doc.differ.getChanges({
        includeChangesInGraveyard: true
      }).reverse();
      const insertedImagesIds = /* @__PURE__ */ new Set();
      for (const entry of changes) {
        if (entry.type == "insert" && entry.name != "$text") {
          const item = entry.position.nodeAfter;
          const isInsertedInGraveyard = entry.position.root.rootName == "$graveyard";
          for (const imageElement of getImagesFromChangeItem(editor, item)) {
            const uploadId = imageElement.getAttribute("uploadId");
            if (!uploadId) {
              continue;
            }
            const loader = fileRepository.loaders.get(uploadId);
            if (!loader) {
              continue;
            }
            if (isInsertedInGraveyard) {
              if (!insertedImagesIds.has(uploadId)) {
                loader.abort();
              }
            } else {
              insertedImagesIds.add(uploadId);
              this._uploadImageElements.set(uploadId, imageElement);
              if (loader.status == "idle") {
                this._readAndUpload(loader);
              }
            }
          }
        }
      }
    });
    this.on("uploadComplete", (evt, { imageElement, data }) => {
      const urls = data.urls ? data.urls : data;
      this.editor.model.change((writer) => {
        writer.setAttribute("src", urls.default, imageElement);
        this._parseAndSetSrcsetAttributeOnImage(urls, imageElement, writer);
        imageUtils.setImageNaturalSizeAttributes(imageElement);
      });
    }, {
      priority: "low"
    });
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const schema = this.editor.model.schema;
    if (this.editor.plugins.has("ImageBlockEditing")) {
      schema.extend("imageBlock", {
        allowAttributes: [
          "uploadId",
          "uploadStatus"
        ]
      });
    }
    if (this.editor.plugins.has("ImageInlineEditing")) {
      schema.extend("imageInline", {
        allowAttributes: [
          "uploadId",
          "uploadStatus"
        ]
      });
    }
  }
  /**
  * Reads and uploads an image.
  *
  * The image is read from the disk and as a Base64-encoded string it is set temporarily to
  * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target
  * image's URL (the URL to the uploaded image on the server).
  */
  _readAndUpload(loader) {
    const editor = this.editor;
    const model = editor.model;
    const t = editor.locale.t;
    const fileRepository = editor.plugins.get(FileRepository);
    const notification = editor.plugins.get(Notification);
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageUploadElements = this._uploadImageElements;
    model.enqueueChange({
      isUndoable: false
    }, (writer) => {
      writer.setAttribute("uploadStatus", "reading", imageUploadElements.get(loader.id));
    });
    return loader.read().then(() => {
      const promise = loader.upload();
      const imageElement = imageUploadElements.get(loader.id);
      if (env.isSafari) {
        const viewFigure = editor.editing.mapper.toViewElement(imageElement);
        const viewImg = imageUtils.findViewImgElement(viewFigure);
        editor.editing.view.once("render", () => {
          if (!viewImg.parent) {
            return;
          }
          const domFigure = editor.editing.view.domConverter.mapViewToDom(viewImg.parent);
          if (!domFigure) {
            return;
          }
          const originalDisplay = domFigure.style.display;
          domFigure.style.display = "none";
          domFigure._ckHack = domFigure.offsetHeight;
          domFigure.style.display = originalDisplay;
        });
      }
      if (editor.ui) {
        editor.ui.ariaLiveAnnouncer.announce(t("Uploading image"));
      }
      model.enqueueChange({
        isUndoable: false
      }, (writer) => {
        writer.setAttribute("uploadStatus", "uploading", imageElement);
      });
      return promise;
    }).then((data) => {
      model.enqueueChange({
        isUndoable: false
      }, (writer) => {
        const imageElement = imageUploadElements.get(loader.id);
        writer.setAttribute("uploadStatus", "complete", imageElement);
        if (editor.ui) {
          editor.ui.ariaLiveAnnouncer.announce(t("Image upload complete"));
        }
        this.fire("uploadComplete", {
          data,
          imageElement
        });
      });
      clean();
    }).catch((error) => {
      if (editor.ui) {
        editor.ui.ariaLiveAnnouncer.announce(t("Error during image upload"));
      }
      if (loader.status !== "error" && loader.status !== "aborted") {
        throw error;
      }
      if (loader.status == "error" && error) {
        notification.showWarning(error, {
          title: t("Upload failed"),
          namespace: "upload"
        });
      }
      model.enqueueChange({
        isUndoable: false
      }, (writer) => {
        writer.remove(imageUploadElements.get(loader.id));
      });
      clean();
    });
    function clean() {
      model.enqueueChange({
        isUndoable: false
      }, (writer) => {
        const imageElement = imageUploadElements.get(loader.id);
        writer.removeAttribute("uploadId", imageElement);
        writer.removeAttribute("uploadStatus", imageElement);
        imageUploadElements.delete(loader.id);
      });
      fileRepository.destroyLoader(loader);
    }
  }
  /**
  * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.
  *
  * @param data Data object from which `srcset` will be created.
  * @param image The image element on which the `srcset` attribute will be set.
  */
  _parseAndSetSrcsetAttributeOnImage(data, image, writer) {
    let maxWidth = 0;
    const srcsetAttribute = Object.keys(data).filter((key) => {
      const width = parseInt(key, 10);
      if (!isNaN(width)) {
        maxWidth = Math.max(maxWidth, width);
        return true;
      }
    }).map((key) => `${data[key]} ${key}w`).join(", ");
    if (srcsetAttribute != "") {
      const attributes = {
        srcset: srcsetAttribute
      };
      if (!image.hasAttribute("width") && !image.hasAttribute("height")) {
        attributes.width = maxWidth;
      }
      writer.setAttributes(attributes, image);
    }
  }
};
function isHtmlIncluded(dataTransfer) {
  return Array.from(dataTransfer.types).includes("text/html") && dataTransfer.getData("text/html") !== "";
}
function getImagesFromChangeItem(editor, item) {
  const imageUtils = editor.plugins.get("ImageUtils");
  return Array.from(editor.model.createRangeOn(item)).filter((value) => imageUtils.isImage(value.item)).map((value) => value.item);
}
var ImageUpload = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageUpload";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUploadEditing,
      ImageUploadUI,
      ImageUploadProgress
    ];
  }
};
var ImageInsertUrlView = class extends View2 {
  /**
  * Creates a view for the dropdown panel of {@link module:image/imageinsert/imageinsertui~ImageInsertUI}.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * The URL input field view.
    */
    __publicField(this, "urlInputView");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    this.set("imageURLInputValue", "");
    this.set("isImageSelected", false);
    this.set("isEnabled", true);
    this.keystrokes = new KeystrokeHandler();
    this.urlInputView = this._createUrlInputView();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-image-insert-url"
        ]
      },
      children: [
        this.urlInputView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-image-insert-url__action-row"
            ]
          }
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Creates the {@link #urlInputView}.
  */
  _createUrlInputView() {
    const locale = this.locale;
    const t = locale.t;
    const urlInputView = new LabeledFieldView(locale, createLabeledInputText);
    urlInputView.bind("label").to(this, "isImageSelected", (value) => value ? t("Update image URL") : t("Insert image via URL"));
    urlInputView.bind("isEnabled").to(this);
    urlInputView.fieldView.inputMode = "url";
    urlInputView.fieldView.placeholder = "https://example.com/image.png";
    urlInputView.fieldView.bind("value").to(this, "imageURLInputValue", (value) => value || "");
    urlInputView.fieldView.on("input", () => {
      this.imageURLInputValue = urlInputView.fieldView.element.value.trim();
    });
    return urlInputView;
  }
  /**
  * Focuses the view.
  */
  focus() {
    this.urlInputView.focus();
  }
};
var ImageInsertViaUrlUI = class extends Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "_imageInsertUI");
    __publicField(this, "_formView");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageInsertViaUrlUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageInsertUI,
      Dialog
    ];
  }
  init() {
    this.editor.ui.componentFactory.add("insertImageViaUrl", () => this._createToolbarButton());
    this.editor.ui.componentFactory.add("menuBar:insertImageViaUrl", () => this._createMenuBarButton("standalone"));
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    this._imageInsertUI = this.editor.plugins.get("ImageInsertUI");
    this._imageInsertUI.registerIntegration({
      name: "url",
      observable: () => this.editor.commands.get("insertImage"),
      buttonViewCreator: () => this._createToolbarButton(),
      formViewCreator: () => this._createDropdownButton(),
      menuBarButtonViewCreator: (isOnly) => this._createMenuBarButton(isOnly ? "insertOnly" : "insertNested")
    });
  }
  /**
  * Creates the base for various kinds of the button component provided by this feature.
  */
  _createInsertUrlButton(ButtonClass) {
    const button = new ButtonClass(this.editor.locale);
    button.icon = icons.imageUrl;
    button.on("execute", () => {
      this._showModal();
    });
    return button;
  }
  /**
  * Creates a simple toolbar button, with an icon and a tooltip.
  */
  _createToolbarButton() {
    const t = this.editor.locale.t;
    const button = this._createInsertUrlButton(ButtonView);
    button.tooltip = true;
    button.bind("label").to(this._imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Update image URL") : t("Insert image via URL"));
    return button;
  }
  /**
  * Creates a button for the dropdown view, with an icon, text and no tooltip.
  */
  _createDropdownButton() {
    const t = this.editor.locale.t;
    const button = this._createInsertUrlButton(ButtonView);
    button.withText = true;
    button.bind("label").to(this._imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Update image URL") : t("Insert via URL"));
    return button;
  }
  /**
  * Creates a button for the menu bar.
  */
  _createMenuBarButton(type) {
    const t = this.editor.locale.t;
    const button = this._createInsertUrlButton(MenuBarMenuListItemButtonView);
    button.withText = true;
    switch (type) {
      case "standalone":
        button.label = t("Image via URL");
        break;
      case "insertOnly":
        button.label = t("Image");
        break;
      case "insertNested":
        button.label = t("Via URL");
        break;
    }
    return button;
  }
  /**
  * Creates the form view used to submit the image URL.
  */
  _createInsertUrlView() {
    const editor = this.editor;
    const locale = editor.locale;
    const replaceImageSourceCommand = editor.commands.get("replaceImageSource");
    const insertImageCommand = editor.commands.get("insertImage");
    const imageInsertUrlView = new ImageInsertUrlView(locale);
    imageInsertUrlView.bind("isImageSelected").to(this._imageInsertUI);
    imageInsertUrlView.bind("isEnabled").toMany([
      insertImageCommand,
      replaceImageSourceCommand
    ], "isEnabled", (...isEnabled) => isEnabled.some((isCommandEnabled) => isCommandEnabled));
    return imageInsertUrlView;
  }
  /**
  * Shows the insert image via URL form view in a modal.
  */
  _showModal() {
    const editor = this.editor;
    const locale = editor.locale;
    const t = locale.t;
    const dialog = editor.plugins.get("Dialog");
    if (!this._formView) {
      this._formView = this._createInsertUrlView();
      this._formView.on("submit", () => this._handleSave());
    }
    const replaceImageSourceCommand = editor.commands.get("replaceImageSource");
    this._formView.imageURLInputValue = replaceImageSourceCommand.value || "";
    dialog.show({
      id: "insertImageViaUrl",
      title: this._imageInsertUI.isImageSelected ? t("Update image URL") : t("Insert image via URL"),
      isModal: true,
      content: this._formView,
      actionButtons: [
        {
          label: t("Cancel"),
          withText: true,
          onExecute: () => dialog.hide()
        },
        {
          label: t("Accept"),
          class: "ck-button-action",
          withText: true,
          onExecute: () => this._handleSave()
        }
      ]
    });
  }
  /**
  * Executes appropriate command depending on selection and form value.
  */
  _handleSave() {
    const replaceImageSourceCommand = this.editor.commands.get("replaceImageSource");
    if (replaceImageSourceCommand.isEnabled) {
      this.editor.execute("replaceImageSource", {
        source: this._formView.imageURLInputValue
      });
    } else {
      this.editor.execute("insertImage", {
        source: this._formView.imageURLInputValue
      });
    }
    this.editor.plugins.get("Dialog").hide();
  }
};
var ImageInsertViaUrl = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageInsertViaUrl";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageInsertViaUrlUI,
      ImageInsertUI
    ];
  }
};
var ImageInsert = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageInsert";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUpload,
      ImageInsertViaUrl,
      ImageInsertUI
    ];
  }
};
var ResizeImageCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = imageUtils.getClosestSelectedImageElement(editor.model.document.selection);
    this.isEnabled = !!element;
    if (!element || !element.hasAttribute("resizedWidth")) {
      this.value = null;
    } else {
      this.value = {
        width: element.getAttribute("resizedWidth"),
        height: null
      };
    }
  }
  /**
  * Executes the command.
  *
  * ```ts
  * // Sets the width to 50%:
  * editor.execute( 'resizeImage', { width: '50%' } );
  *
  * // Removes the width attribute:
  * editor.execute( 'resizeImage', { width: null } );
  * ```
  *
  * @param options
  * @param options.width The new width of the image.
  * @fires execute
  */
  execute(options2) {
    const editor = this.editor;
    const model = editor.model;
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
    this.value = {
      width: options2.width,
      height: null
    };
    if (imageElement) {
      model.change((writer) => {
        writer.setAttribute("resizedWidth", options2.width, imageElement);
        writer.removeAttribute("resizedHeight", imageElement);
        imageUtils.setImageNaturalSizeAttributes(imageElement);
      });
    }
  }
};
var ImageResizeEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageResizeEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("image", {
      resizeUnit: "%",
      resizeOptions: [
        {
          name: "resizeImage:original",
          value: null,
          icon: "original"
        },
        {
          name: "resizeImage:custom",
          value: "custom",
          icon: "custom"
        },
        {
          name: "resizeImage:25",
          value: "25",
          icon: "small"
        },
        {
          name: "resizeImage:50",
          value: "50",
          icon: "medium"
        },
        {
          name: "resizeImage:75",
          value: "75",
          icon: "large"
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const resizeImageCommand = new ResizeImageCommand(editor);
    this._registerConverters("imageBlock");
    this._registerConverters("imageInline");
    editor.commands.add("resizeImage", resizeImageCommand);
    editor.commands.add("imageResize", resizeImageCommand);
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    this._registerSchema();
  }
  _registerSchema() {
    if (this.editor.plugins.has("ImageBlockEditing")) {
      this.editor.model.schema.extend("imageBlock", {
        allowAttributes: [
          "resizedWidth",
          "resizedHeight"
        ]
      });
    }
    if (this.editor.plugins.has("ImageInlineEditing")) {
      this.editor.model.schema.extend("imageInline", {
        allowAttributes: [
          "resizedWidth",
          "resizedHeight"
        ]
      });
    }
  }
  /**
  * Registers image resize converters.
  *
  * @param imageType The type of the image.
  */
  _registerConverters(imageType) {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    editor.conversion.for("downcast").add((dispatcher) => dispatcher.on(`attribute:resizedWidth:${imageType}`, (evt, data, conversionApi) => {
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const viewWriter = conversionApi.writer;
      const viewImg = conversionApi.mapper.toViewElement(data.item);
      if (data.attributeNewValue !== null) {
        viewWriter.setStyle("width", data.attributeNewValue, viewImg);
        viewWriter.addClass("image_resized", viewImg);
      } else {
        viewWriter.removeStyle("width", viewImg);
        viewWriter.removeClass("image_resized", viewImg);
      }
    }));
    editor.conversion.for("dataDowncast").attributeToAttribute({
      model: {
        name: imageType,
        key: "resizedHeight"
      },
      view: (modelAttributeValue) => ({
        key: "style",
        value: {
          "height": modelAttributeValue
        }
      })
    });
    editor.conversion.for("editingDowncast").add((dispatcher) => dispatcher.on(`attribute:resizedHeight:${imageType}`, (evt, data, conversionApi) => {
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const viewWriter = conversionApi.writer;
      const viewImg = conversionApi.mapper.toViewElement(data.item);
      const target = imageType === "imageInline" ? imageUtils.findViewImgElement(viewImg) : viewImg;
      if (data.attributeNewValue !== null) {
        viewWriter.setStyle("height", data.attributeNewValue, target);
      } else {
        viewWriter.removeStyle("height", target);
      }
    }));
    editor.conversion.for("upcast").attributeToAttribute({
      view: {
        name: imageType === "imageBlock" ? "figure" : "img",
        styles: {
          width: /.+/
        }
      },
      model: {
        key: "resizedWidth",
        value: (viewElement) => {
          if (widthAndHeightStylesAreBothSet(viewElement)) {
            return null;
          }
          return viewElement.getStyle("width");
        }
      }
    });
    editor.conversion.for("upcast").attributeToAttribute({
      view: {
        name: imageType === "imageBlock" ? "figure" : "img",
        styles: {
          height: /.+/
        }
      },
      model: {
        key: "resizedHeight",
        value: (viewElement) => {
          if (widthAndHeightStylesAreBothSet(viewElement)) {
            return null;
          }
          return viewElement.getStyle("height");
        }
      }
    });
  }
};
var RESIZE_ICONS = (() => ({
  small: icons.objectSizeSmall,
  medium: icons.objectSizeMedium,
  large: icons.objectSizeLarge,
  custom: icons.objectSizeCustom,
  original: icons.objectSizeFull
}))();
var ImageResizeButtons = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The resize unit.
    * @default '%'
    */
    __publicField(this, "_resizeUnit");
    this._resizeUnit = editor.config.get("image.resizeUnit");
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageResizeEditing
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageResizeButtons";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const options2 = editor.config.get("image.resizeOptions");
    const command = editor.commands.get("resizeImage");
    this.bind("isEnabled").to(command);
    for (const option of options2) {
      this._registerImageResizeButton(option);
    }
    this._registerImageResizeDropdown(options2);
  }
  /**
  * A helper function that creates a standalone button component for the plugin.
  *
  * @param resizeOption A model of the resize option.
  */
  _registerImageResizeButton(option) {
    const editor = this.editor;
    const { name, value, icon } = option;
    editor.ui.componentFactory.add(name, (locale) => {
      const button = new ButtonView(locale);
      const command = editor.commands.get("resizeImage");
      const labelText = this._getOptionLabelValue(option, true);
      if (!RESIZE_ICONS[icon]) {
        throw new CKEditorError("imageresizebuttons-missing-icon", editor, option);
      }
      button.set({
        // Use the `label` property for a verbose description (because of ARIA).
        label: labelText,
        icon: RESIZE_ICONS[icon],
        tooltip: labelText,
        isToggleable: true
      });
      button.bind("isEnabled").to(this);
      if (editor.plugins.has("ImageCustomResizeUI") && isCustomImageResizeOption(option)) {
        const customResizeUI = editor.plugins.get("ImageCustomResizeUI");
        this.listenTo(button, "execute", () => {
          customResizeUI._showForm(this._resizeUnit);
        });
      } else {
        const optionValueWithUnit = value ? value + this._resizeUnit : null;
        button.bind("isOn").to(command, "value", getIsOnButtonCallback(optionValueWithUnit));
        this.listenTo(button, "execute", () => {
          editor.execute("resizeImage", {
            width: optionValueWithUnit
          });
        });
      }
      return button;
    });
  }
  /**
  * A helper function that creates a dropdown component for the plugin containing all the resize options defined in
  * the editor configuration.
  *
  * @param options An array of configured options.
  */
  _registerImageResizeDropdown(options2) {
    const editor = this.editor;
    const t = editor.t;
    const originalSizeOption = options2.find((option) => !option.value);
    const componentCreator = (locale) => {
      const command = editor.commands.get("resizeImage");
      const dropdownView = createDropdown(locale, DropdownButtonView);
      const dropdownButton = dropdownView.buttonView;
      const accessibleLabel = t("Resize image");
      dropdownButton.set({
        tooltip: accessibleLabel,
        commandValue: originalSizeOption.value,
        icon: RESIZE_ICONS.medium,
        isToggleable: true,
        label: this._getOptionLabelValue(originalSizeOption),
        withText: true,
        class: "ck-resize-image-button",
        ariaLabel: accessibleLabel,
        ariaLabelledBy: void 0
      });
      dropdownButton.bind("label").to(command, "value", (commandValue) => {
        if (commandValue && commandValue.width) {
          return commandValue.width;
        } else {
          return this._getOptionLabelValue(originalSizeOption);
        }
      });
      dropdownView.bind("isEnabled").to(this);
      addListToDropdown(dropdownView, () => this._getResizeDropdownListItemDefinitions(options2, command), {
        ariaLabel: t("Image resize list"),
        role: "menu"
      });
      this.listenTo(dropdownView, "execute", (evt) => {
        if ("onClick" in evt.source) {
          evt.source.onClick();
        } else {
          editor.execute(evt.source.commandName, {
            width: evt.source.commandValue
          });
          editor.editing.view.focus();
        }
      });
      return dropdownView;
    };
    editor.ui.componentFactory.add("resizeImage", componentCreator);
    editor.ui.componentFactory.add("imageResize", componentCreator);
  }
  /**
  * A helper function for creating an option label value string.
  *
  * @param option A resize option object.
  * @param forTooltip An optional flag for creating a tooltip label.
  * @returns A user-defined label combined from the numeric value and the resize unit or the default label
  * for reset options (`Original`).
  */
  _getOptionLabelValue(option, forTooltip = false) {
    const t = this.editor.t;
    if (option.label) {
      return option.label;
    } else if (forTooltip) {
      if (isCustomImageResizeOption(option)) {
        return t("Custom image size");
      } else if (option.value) {
        return t("Resize image to %0", option.value + this._resizeUnit);
      } else {
        return t("Resize image to the original size");
      }
    } else {
      if (isCustomImageResizeOption(option)) {
        return t("Custom");
      } else if (option.value) {
        return option.value + this._resizeUnit;
      } else {
        return t("Original");
      }
    }
  }
  /**
  * A helper function that parses the resize options and returns list item definitions ready for use in the dropdown.
  *
  * @param options The resize options.
  * @param command The resize image command.
  * @returns Dropdown item definitions.
  */
  _getResizeDropdownListItemDefinitions(options2, command) {
    const { editor } = this;
    const itemDefinitions = new Collection();
    const optionsWithSerializedValues = options2.map((option) => {
      if (isCustomImageResizeOption(option)) {
        return {
          ...option,
          valueWithUnits: "custom"
        };
      }
      if (!option.value) {
        return {
          ...option,
          valueWithUnits: null
        };
      }
      return {
        ...option,
        valueWithUnits: `${option.value}${this._resizeUnit}`
      };
    });
    for (const option of optionsWithSerializedValues) {
      let definition = null;
      if (editor.plugins.has("ImageCustomResizeUI") && isCustomImageResizeOption(option)) {
        const customResizeUI = editor.plugins.get("ImageCustomResizeUI");
        definition = {
          type: "button",
          model: new Model2({
            label: this._getOptionLabelValue(option),
            role: "menuitemradio",
            withText: true,
            icon: null,
            onClick: () => {
              customResizeUI._showForm(this._resizeUnit);
            }
          })
        };
        const allDropdownValues = map_default(optionsWithSerializedValues, "valueWithUnits");
        definition.model.bind("isOn").to(command, "value", getIsOnCustomButtonCallback(allDropdownValues));
      } else {
        definition = {
          type: "button",
          model: new Model2({
            commandName: "resizeImage",
            commandValue: option.valueWithUnits,
            label: this._getOptionLabelValue(option),
            role: "menuitemradio",
            withText: true,
            icon: null
          })
        };
        definition.model.bind("isOn").to(command, "value", getIsOnButtonCallback(option.valueWithUnits));
      }
      definition.model.bind("isEnabled").to(command, "isEnabled");
      itemDefinitions.add(definition);
    }
    return itemDefinitions;
  }
};
function isCustomImageResizeOption(option) {
  return option.value === "custom";
}
function getIsOnButtonCallback(value) {
  return (commandValue) => {
    const objectCommandValue = commandValue;
    if (value === null && objectCommandValue === value) {
      return true;
    }
    return objectCommandValue !== null && objectCommandValue.width === value;
  };
}
function getIsOnCustomButtonCallback(allDropdownValues) {
  return (commandValue) => !allDropdownValues.some((dropdownValue) => getIsOnButtonCallback(dropdownValue)(commandValue));
}
var RESIZABLE_IMAGES_CSS_SELECTOR = "figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img";
var RESIZED_IMAGE_CLASS = "image_resized";
var ImageResizeHandles = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      WidgetResize,
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageResizeHandles";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const command = this.editor.commands.get("resizeImage");
    this.bind("isEnabled").to(command);
    this._setupResizerCreator();
  }
  /**
  * Attaches the listeners responsible for creating a resizer for each image, except for images inside the HTML embed preview.
  */
  _setupResizerCreator() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const imageUtils = editor.plugins.get("ImageUtils");
    editingView.addObserver(ImageLoadObserver);
    this.listenTo(editingView.document, "imageLoaded", (evt, domEvent) => {
      if (!domEvent.target.matches(RESIZABLE_IMAGES_CSS_SELECTOR)) {
        return;
      }
      const domConverter = editor.editing.view.domConverter;
      const imageView = domConverter.domToView(domEvent.target);
      const widgetView = imageUtils.getImageWidgetFromImageView(imageView);
      let resizer = this.editor.plugins.get(WidgetResize).getResizerByViewElement(widgetView);
      if (resizer) {
        resizer.redraw();
        return;
      }
      const mapper = editor.editing.mapper;
      const imageModel = mapper.toModelElement(widgetView);
      resizer = editor.plugins.get(WidgetResize).attachTo({
        unit: editor.config.get("image.resizeUnit"),
        modelElement: imageModel,
        viewElement: widgetView,
        editor,
        getHandleHost(domWidgetElement) {
          return domWidgetElement.querySelector("img");
        },
        getResizeHost() {
          return domConverter.mapViewToDom(mapper.toViewElement(imageModel));
        },
        isCentered() {
          const imageStyle = imageModel.getAttribute("imageStyle");
          return imageStyle == "alignCenter";
        },
        onCommit(newValue) {
          editingView.change((writer) => {
            writer.removeClass(RESIZED_IMAGE_CLASS, widgetView);
          });
          editor.execute("resizeImage", {
            width: newValue
          });
        }
      });
      resizer.on("updateSize", () => {
        if (!widgetView.hasClass(RESIZED_IMAGE_CLASS)) {
          editingView.change((writer) => {
            writer.addClass(RESIZED_IMAGE_CLASS, widgetView);
          });
        }
        const target = imageModel.name === "imageInline" ? imageView : widgetView;
        if (target.getStyle("height")) {
          editingView.change((writer) => {
            writer.removeStyle("height", target);
          });
        }
      });
      resizer.bind("isEnabled").to(this);
    });
  }
};
function tryParseDimensionWithUnit(dimension) {
  if (!dimension) {
    return null;
  }
  const [, rawValue, unit] = dimension.trim().match(/([.,\d]+)(%|px)$/) || [];
  const parsedValue = Number.parseFloat(rawValue);
  if (Number.isNaN(parsedValue)) {
    return null;
  }
  return {
    value: parsedValue,
    unit
  };
}
function tryCastDimensionsToUnit(parentDimensionPx, dimension, targetUnit) {
  if (targetUnit === "px") {
    return {
      value: dimension.value,
      unit: "px"
    };
  }
  return {
    value: dimension.value / parentDimensionPx * 100,
    unit: "%"
  };
}
function getSelectedImageEditorNodes(editor) {
  const { editing } = editor;
  const imageUtils = editor.plugins.get("ImageUtils");
  const imageModelElement = imageUtils.getClosestSelectedImageElement(editor.model.document.selection);
  if (!imageModelElement) {
    return null;
  }
  const imageViewElement = editing.mapper.toViewElement(imageModelElement);
  const imageDOMElement = editing.view.domConverter.mapViewToDom(imageViewElement);
  return {
    model: imageModelElement,
    view: imageViewElement,
    dom: imageDOMElement
  };
}
function getSelectedImageWidthInUnits(editor, targetUnit) {
  const imageNodes = getSelectedImageEditorNodes(editor);
  if (!imageNodes) {
    return null;
  }
  const parsedResizedWidth = tryParseDimensionWithUnit(imageNodes.model.getAttribute("resizedWidth") || null);
  if (!parsedResizedWidth) {
    return null;
  }
  if (parsedResizedWidth.unit === targetUnit) {
    return parsedResizedWidth;
  }
  const imageParentWidthPx = calculateResizeHostAncestorWidth(imageNodes.dom);
  const imageHolderDimension = {
    unit: "px",
    value: new Rect(imageNodes.dom).width
  };
  return tryCastDimensionsToUnit(imageParentWidthPx, imageHolderDimension, targetUnit);
}
var ImageCustomResizeFormView = class extends View2 {
  /**
  * @inheritDoc
  */
  constructor(locale, unit, validators) {
    super(locale);
    /**
    * Tracks information about the DOM focus in the form.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * Resize unit shortcut.
    */
    __publicField(this, "unit");
    /**
    * An input with a label.
    */
    __publicField(this, "labeledInput");
    /**
    * A button used to submit the form.
    */
    __publicField(this, "saveButtonView");
    /**
    * A button used to cancel the form.
    */
    __publicField(this, "cancelButtonView");
    /**
    * A collection of views which can be focused in the form.
    */
    __publicField(this, "_focusables");
    /**
    * Helps cycling over {@link #_focusables} in the form.
    */
    __publicField(this, "_focusCycler");
    /**
    * An array of form validators used by {@link #isValid}.
    */
    __publicField(this, "_validators");
    const t = this.locale.t;
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.unit = unit;
    this.labeledInput = this._createLabeledInputView();
    this.saveButtonView = this._createButton(t("Save"), icons.check, "ck-button-save");
    this.saveButtonView.type = "submit";
    this.cancelButtonView = this._createButton(t("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
    this._focusables = new ViewCollection();
    this._validators = validators;
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-image-custom-resize-form",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-image/issues/40
        tabindex: "-1"
      },
      children: [
        this.labeledInput,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
    submitHandler({
      view: this
    });
    [
      this.labeledInput,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Creates the button view.
  *
  * @param label The button label
  * @param icon The button's icon.
  * @param className The additional button CSS class name.
  * @param eventName The event name that the ButtonView#execute event will be delegated to.
  * @returns The button view instance.
  */
  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.locale);
    button.set({
      label,
      icon,
      tooltip: true
    });
    button.extendTemplate({
      attributes: {
        class: className
      }
    });
    if (eventName) {
      button.delegate("execute").to(this, eventName);
    }
    return button;
  }
  /**
  * Creates an input with a label.
  *
  * @returns Labeled field view instance.
  */
  _createLabeledInputView() {
    const t = this.locale.t;
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputNumber);
    labeledInput.label = t("Resize image (in %0)", this.unit);
    labeledInput.fieldView.set({
      step: 0.1
    });
    return labeledInput;
  }
  /**
  * Validates the form and returns `false` when some fields are invalid.
  */
  isValid() {
    this.resetFormStatus();
    for (const validator of this._validators) {
      const errorText = validator(this);
      if (errorText) {
        this.labeledInput.errorText = errorText;
        return false;
      }
    }
    return true;
  }
  /**
  * Cleans up the supplementary error and information text of the {@link #labeledInput}
  * bringing them back to the state when the form has been displayed for the first time.
  *
  * See {@link #isValid}.
  */
  resetFormStatus() {
    this.labeledInput.errorText = null;
  }
  /**
  * The native DOM `value` of the input element of {@link #labeledInput}.
  */
  get rawSize() {
    const { element } = this.labeledInput.fieldView;
    if (!element) {
      return null;
    }
    return element.value;
  }
  /**
  * Get numeric value of size. Returns `null` if value of size input element in {@link #labeledInput}.is not a number.
  */
  get parsedSize() {
    const { rawSize } = this;
    if (rawSize === null) {
      return null;
    }
    const parsed = Number.parseFloat(rawSize);
    if (Number.isNaN(parsed)) {
      return null;
    }
    return parsed;
  }
  /**
  * Returns serialized image input size with unit.
  * Returns `null` if value of size input element in {@link #labeledInput}.is not a number.
  */
  get sizeWithUnits() {
    const { parsedSize, unit } = this;
    if (parsedSize === null) {
      return null;
    }
    return `${parsedSize}${unit}`;
  }
};
function getSelectedImagePossibleResizeRange(editor, targetUnit) {
  const imageNodes = getSelectedImageEditorNodes(editor);
  if (!imageNodes) {
    return null;
  }
  const imageParentWidthPx = calculateResizeHostAncestorWidth(imageNodes.dom);
  const minimumImageWidth = tryParseDimensionWithUnit(window.getComputedStyle(imageNodes.dom).minWidth) || {
    value: 1,
    unit: "px"
  };
  const lower = Math.max(0.1, tryCastDimensionsToUnit(imageParentWidthPx, minimumImageWidth, targetUnit).value);
  const upper = targetUnit === "px" ? imageParentWidthPx : 100;
  return {
    unit: targetUnit,
    lower,
    upper
  };
}
var ImageCustomResizeUI = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * The contextual balloon plugin instance.
    */
    __publicField(this, "_balloon");
    /**
    * A form containing a textarea and buttons, used to change the `alt` text value.
    */
    __publicField(this, "_form");
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ContextualBalloon
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageCustomResizeUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    if (this._form) {
      this._form.destroy();
    }
  }
  /**
  * Creates the {@link module:image/imageresize/ui/imagecustomresizeformview~ImageCustomResizeFormView}
  * form.
  */
  _createForm(unit) {
    const editor = this.editor;
    this._balloon = this.editor.plugins.get("ContextualBalloon");
    this._form = new (CssTransitionDisablerMixin(ImageCustomResizeFormView))(editor.locale, unit, getFormValidators(editor));
    this._form.render();
    this.listenTo(this._form, "submit", () => {
      if (this._form.isValid()) {
        editor.execute("resizeImage", {
          width: this._form.sizeWithUnits
        });
        this._hideForm(true);
      }
    });
    this.listenTo(this._form.labeledInput, "change:errorText", () => {
      editor.ui.update();
    });
    this.listenTo(this._form, "cancel", () => {
      this._hideForm(true);
    });
    this._form.keystrokes.set("Esc", (data, cancel) => {
      this._hideForm(true);
      cancel();
    });
    clickOutsideHandler({
      emitter: this._form,
      activator: () => this._isVisible,
      contextElements: () => [
        this._balloon.view.element
      ],
      callback: () => this._hideForm()
    });
  }
  /**
  * Shows the {@link #_form} in the {@link #_balloon}.
  *
  * @internal
  */
  _showForm(unit) {
    if (this._isVisible) {
      return;
    }
    if (!this._form) {
      this._createForm(unit);
    }
    const editor = this.editor;
    const labeledInput = this._form.labeledInput;
    this._form.disableCssTransitions();
    this._form.resetFormStatus();
    if (!this._isInBalloon) {
      this._balloon.add({
        view: this._form,
        position: getBalloonPositionData(editor)
      });
    }
    const currentParsedWidth = getSelectedImageWidthInUnits(editor, unit);
    const initialInputValue = currentParsedWidth ? currentParsedWidth.value.toFixed(1) : "";
    const possibleRange = getSelectedImagePossibleResizeRange(editor, unit);
    labeledInput.fieldView.value = labeledInput.fieldView.element.value = initialInputValue;
    if (possibleRange) {
      Object.assign(labeledInput.fieldView, {
        min: possibleRange.lower.toFixed(1),
        max: Math.ceil(possibleRange.upper).toFixed(1)
      });
    }
    this._form.labeledInput.fieldView.select();
    this._form.enableCssTransitions();
  }
  /**
  * Removes the {@link #_form} from the {@link #_balloon}.
  *
  * @param focusEditable Controls whether the editing view is focused afterwards.
  */
  _hideForm(focusEditable = false) {
    if (!this._isInBalloon) {
      return;
    }
    if (this._form.focusTracker.isFocused) {
      this._form.saveButtonView.focus();
    }
    this._balloon.remove(this._form);
    if (focusEditable) {
      this.editor.editing.view.focus();
    }
  }
  /**
  * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
  */
  get _isVisible() {
    return !!this._balloon && this._balloon.visibleView === this._form;
  }
  /**
  * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
  */
  get _isInBalloon() {
    return !!this._balloon && this._balloon.hasView(this._form);
  }
};
function getFormValidators(editor) {
  const t = editor.t;
  return [
    (form) => {
      if (form.rawSize.trim() === "") {
        return t("The value must not be empty.");
      }
      if (form.parsedSize === null) {
        return t("The value should be a plain number.");
      }
    }
  ];
}
var ImageResize = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageResizeEditing,
      ImageResizeHandles,
      ImageCustomResizeUI,
      ImageResizeButtons
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageResize";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var ImageStyleCommand = class extends Command {
  /**
  * Creates an instance of the image style command. When executed, the command applies one of
  * {@link module:image/imageconfig~ImageStyleConfig#options style options} to the currently selected image.
  *
  * @param editor The editor instance.
  * @param styles The style options that this command supports.
  */
  constructor(editor, styles) {
    super(editor);
    /**
    * An object containing names of default style options for the inline and block images.
    * If there is no default style option for the given image type in the configuration,
    * the name will be `false`.
    */
    __publicField(this, "_defaultStyles");
    /**
    * The styles handled by this command.
    */
    __publicField(this, "_styles");
    this._defaultStyles = {
      imageBlock: false,
      imageInline: false
    };
    this._styles = new Map(styles.map((style) => {
      if (style.isDefault) {
        for (const modelElementName of style.modelElements) {
          this._defaultStyles[modelElementName] = style.name;
        }
      }
      return [
        style.name,
        style
      ];
    }));
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!element;
    if (!this.isEnabled) {
      this.value = false;
    } else if (element.hasAttribute("imageStyle")) {
      this.value = element.getAttribute("imageStyle");
    } else {
      this.value = this._defaultStyles[element.name];
    }
  }
  /**
  * Executes the command and applies the style to the currently selected image:
  *
  * ```ts
  * editor.execute( 'imageStyle', { value: 'side' } );
  * ```
  *
  * **Note**: Executing this command may change the image model element if the desired style requires an image
  * of a different type. Learn more about {@link module:image/imageconfig~ImageStyleOptionDefinition#modelElements model element}
  * configuration for the style option.
  *
  * @param options.value The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
  * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
  * The default is `true`.
  * @fires execute
  */
  execute(options2 = {}) {
    const editor = this.editor;
    const model = editor.model;
    const imageUtils = editor.plugins.get("ImageUtils");
    model.change((writer) => {
      const requestedStyle = options2.value;
      const { setImageSizes = true } = options2;
      let imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
      if (requestedStyle && this.shouldConvertImageType(requestedStyle, imageElement)) {
        this.editor.execute(imageUtils.isBlockImage(imageElement) ? "imageTypeInline" : "imageTypeBlock", {
          setImageSizes
        });
        imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
      }
      if (!requestedStyle || this._styles.get(requestedStyle).isDefault) {
        writer.removeAttribute("imageStyle", imageElement);
      } else {
        writer.setAttribute("imageStyle", requestedStyle, imageElement);
      }
      if (setImageSizes) {
        imageUtils.setImageNaturalSizeAttributes(imageElement);
      }
    });
  }
  /**
  * Returns `true` if requested style change would trigger the image type change.
  *
  * @param requestedStyle The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
  * @param imageElement The image model element.
  */
  shouldConvertImageType(requestedStyle, imageElement) {
    const supportedTypes = this._styles.get(requestedStyle).modelElements;
    return !supportedTypes.includes(imageElement.name);
  }
};
var DEFAULT_OPTIONS2 = {
  // This style represents an image placed in the line of text.
  get inline() {
    return {
      name: "inline",
      title: "In line",
      icon: icons.objectInline,
      modelElements: [
        "imageInline"
      ],
      isDefault: true
    };
  },
  // This style represents an image aligned to the left and wrapped with text.
  get alignLeft() {
    return {
      name: "alignLeft",
      title: "Left aligned image",
      icon: icons.objectLeft,
      modelElements: [
        "imageBlock",
        "imageInline"
      ],
      className: "image-style-align-left"
    };
  },
  // This style represents an image aligned to the left.
  get alignBlockLeft() {
    return {
      name: "alignBlockLeft",
      title: "Left aligned image",
      icon: icons.objectBlockLeft,
      modelElements: [
        "imageBlock"
      ],
      className: "image-style-block-align-left"
    };
  },
  // This style represents a centered image.
  get alignCenter() {
    return {
      name: "alignCenter",
      title: "Centered image",
      icon: icons.objectCenter,
      modelElements: [
        "imageBlock"
      ],
      className: "image-style-align-center"
    };
  },
  // This style represents an image aligned to the right and wrapped with text.
  get alignRight() {
    return {
      name: "alignRight",
      title: "Right aligned image",
      icon: icons.objectRight,
      modelElements: [
        "imageBlock",
        "imageInline"
      ],
      className: "image-style-align-right"
    };
  },
  // This style represents an image aligned to the right.
  get alignBlockRight() {
    return {
      name: "alignBlockRight",
      title: "Right aligned image",
      icon: icons.objectBlockRight,
      modelElements: [
        "imageBlock"
      ],
      className: "image-style-block-align-right"
    };
  },
  // This option is equal to the situation when no style is applied.
  get block() {
    return {
      name: "block",
      title: "Centered image",
      icon: icons.objectCenter,
      modelElements: [
        "imageBlock"
      ],
      isDefault: true
    };
  },
  // This represents a side image.
  get side() {
    return {
      name: "side",
      title: "Side image",
      icon: icons.objectRight,
      modelElements: [
        "imageBlock"
      ],
      className: "image-style-side"
    };
  }
};
var DEFAULT_ICONS = (() => ({
  full: icons.objectFullWidth,
  left: icons.objectBlockLeft,
  right: icons.objectBlockRight,
  center: icons.objectCenter,
  inlineLeft: icons.objectLeft,
  inlineRight: icons.objectRight,
  inline: icons.objectInline
}))();
var DEFAULT_DROPDOWN_DEFINITIONS = [
  {
    name: "imageStyle:wrapText",
    title: "Wrap text",
    defaultItem: "imageStyle:alignLeft",
    items: [
      "imageStyle:alignLeft",
      "imageStyle:alignRight"
    ]
  },
  {
    name: "imageStyle:breakText",
    title: "Break text",
    defaultItem: "imageStyle:block",
    items: [
      "imageStyle:alignBlockLeft",
      "imageStyle:block",
      "imageStyle:alignBlockRight"
    ]
  }
];
function normalizeStyles(config) {
  const configuredStyles = config.configuredStyles.options || [];
  const styles = configuredStyles.map((arrangement) => normalizeDefinition(arrangement)).filter((arrangement) => isValidOption(arrangement, config));
  return styles;
}
function getDefaultStylesConfiguration(isBlockPluginLoaded, isInlinePluginLoaded) {
  if (isBlockPluginLoaded && isInlinePluginLoaded) {
    return {
      options: [
        "inline",
        "alignLeft",
        "alignRight",
        "alignCenter",
        "alignBlockLeft",
        "alignBlockRight",
        "block",
        "side"
      ]
    };
  } else if (isBlockPluginLoaded) {
    return {
      options: [
        "block",
        "side"
      ]
    };
  } else if (isInlinePluginLoaded) {
    return {
      options: [
        "inline",
        "alignLeft",
        "alignRight"
      ]
    };
  }
  return {};
}
function getDefaultDropdownDefinitions(pluginCollection) {
  if (pluginCollection.has("ImageBlockEditing") && pluginCollection.has("ImageInlineEditing")) {
    return [
      ...DEFAULT_DROPDOWN_DEFINITIONS
    ];
  } else {
    return [];
  }
}
function normalizeDefinition(definition) {
  if (typeof definition === "string") {
    if (!DEFAULT_OPTIONS2[definition]) {
      definition = {
        name: definition
      };
    } else {
      definition = {
        ...DEFAULT_OPTIONS2[definition]
      };
    }
  } else {
    definition = extendStyle(DEFAULT_OPTIONS2[definition.name], definition);
  }
  if (typeof definition.icon === "string") {
    definition.icon = DEFAULT_ICONS[definition.icon] || definition.icon;
  }
  return definition;
}
function isValidOption(option, { isBlockPluginLoaded, isInlinePluginLoaded }) {
  const { modelElements, name } = option;
  if (!modelElements || !modelElements.length || !name) {
    warnInvalidStyle({
      style: option
    });
    return false;
  } else {
    const supportedElements = [
      isBlockPluginLoaded ? "imageBlock" : null,
      isInlinePluginLoaded ? "imageInline" : null
    ];
    if (!modelElements.some((elementName) => supportedElements.includes(elementName))) {
      logWarning("image-style-missing-dependency", {
        style: option,
        missingPlugins: modelElements.map((name2) => name2 === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")
      });
      return false;
    }
  }
  return true;
}
function extendStyle(source, style) {
  const extendedStyle = {
    ...style
  };
  for (const prop in source) {
    if (!Object.prototype.hasOwnProperty.call(style, prop)) {
      extendedStyle[prop] = source[prop];
    }
  }
  return extendedStyle;
}
function warnInvalidStyle(info) {
  logWarning("image-style-configuration-definition-invalid", info);
}
var utils = {
  normalizeStyles,
  getDefaultStylesConfiguration,
  getDefaultDropdownDefinitions,
  warnInvalidStyle,
  DEFAULT_OPTIONS: DEFAULT_OPTIONS2,
  DEFAULT_ICONS,
  DEFAULT_DROPDOWN_DEFINITIONS
};
function modelToViewStyleAttribute(styles) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const newStyle = getStyleDefinitionByName(data.attributeNewValue, styles);
    const oldStyle = getStyleDefinitionByName(data.attributeOldValue, styles);
    const viewElement = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    if (oldStyle) {
      viewWriter.removeClass(oldStyle.className, viewElement);
    }
    if (newStyle) {
      viewWriter.addClass(newStyle.className, viewElement);
    }
  };
}
function viewToModelStyleAttribute(styles) {
  const nonDefaultStyles = {
    imageInline: styles.filter((style) => !style.isDefault && style.modelElements.includes("imageInline")),
    imageBlock: styles.filter((style) => !style.isDefault && style.modelElements.includes("imageBlock"))
  };
  return (evt, data, conversionApi) => {
    if (!data.modelRange) {
      return;
    }
    const viewElement = data.viewItem;
    const modelImageElement = first(data.modelRange.getItems());
    if (!modelImageElement) {
      return;
    }
    if (!conversionApi.schema.checkAttribute(modelImageElement, "imageStyle")) {
      return;
    }
    for (const style of nonDefaultStyles[modelImageElement.name]) {
      if (conversionApi.consumable.consume(viewElement, {
        classes: style.className
      })) {
        conversionApi.writer.setAttribute("imageStyle", style.name, modelImageElement);
      }
    }
  };
}
function getStyleDefinitionByName(name, styles) {
  for (const style of styles) {
    if (style.name === name) {
      return style;
    }
  }
}
var ImageStyleEditing = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * It contains a list of the normalized and validated style options.
    *
    * * Each option contains a complete icon markup.
    * * The style options not supported by any of the loaded image editing plugins (
    * {@link module:image/image/imageinlineediting~ImageInlineEditing `ImageInlineEditing`} or
    * {@link module:image/image/imageblockediting~ImageBlockEditing `ImageBlockEditing`}) are filtered out.
    *
    * @internal
    * @readonly
    */
    __publicField(this, "normalizedStyles");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageStyleEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const { normalizeStyles: normalizeStyles2, getDefaultStylesConfiguration: getDefaultStylesConfiguration2 } = utils;
    const editor = this.editor;
    const isBlockPluginLoaded = editor.plugins.has("ImageBlockEditing");
    const isInlinePluginLoaded = editor.plugins.has("ImageInlineEditing");
    editor.config.define("image.styles", getDefaultStylesConfiguration2(isBlockPluginLoaded, isInlinePluginLoaded));
    this.normalizedStyles = normalizeStyles2({
      configuredStyles: editor.config.get("image.styles"),
      isBlockPluginLoaded,
      isInlinePluginLoaded
    });
    this._setupConversion(isBlockPluginLoaded, isInlinePluginLoaded);
    this._setupPostFixer();
    editor.commands.add("imageStyle", new ImageStyleCommand(editor, this.normalizedStyles));
  }
  /**
  * Sets the editor conversion taking the presence of
  * {@link module:image/image/imageinlineediting~ImageInlineEditing `ImageInlineEditing`}
  * and {@link module:image/image/imageblockediting~ImageBlockEditing `ImageBlockEditing`} plugins into consideration.
  */
  _setupConversion(isBlockPluginLoaded, isInlinePluginLoaded) {
    const editor = this.editor;
    const schema = editor.model.schema;
    const modelToViewConverter = modelToViewStyleAttribute(this.normalizedStyles);
    const viewToModelConverter = viewToModelStyleAttribute(this.normalizedStyles);
    editor.editing.downcastDispatcher.on("attribute:imageStyle", modelToViewConverter);
    editor.data.downcastDispatcher.on("attribute:imageStyle", modelToViewConverter);
    if (isBlockPluginLoaded) {
      schema.extend("imageBlock", {
        allowAttributes: "imageStyle"
      });
      editor.data.upcastDispatcher.on("element:figure", viewToModelConverter, {
        priority: "low"
      });
    }
    if (isInlinePluginLoaded) {
      schema.extend("imageInline", {
        allowAttributes: "imageStyle"
      });
      editor.data.upcastDispatcher.on("element:img", viewToModelConverter, {
        priority: "low"
      });
    }
  }
  /**
  * Registers a post-fixer that will make sure that the style attribute value is correct for a specific image type (block vs inline).
  */
  _setupPostFixer() {
    const editor = this.editor;
    const document2 = editor.model.document;
    const imageUtils = editor.plugins.get(ImageUtils);
    const stylesMap = new Map(this.normalizedStyles.map((style) => [
      style.name,
      style
    ]));
    document2.registerPostFixer((writer) => {
      let changed = false;
      for (const change of document2.differ.getChanges()) {
        if (change.type == "insert" || change.type == "attribute" && change.attributeKey == "imageStyle") {
          let element = change.type == "insert" ? change.position.nodeAfter : change.range.start.nodeAfter;
          if (element && element.is("element", "paragraph") && element.childCount > 0) {
            element = element.getChild(0);
          }
          if (!imageUtils.isImage(element)) {
            continue;
          }
          const imageStyle = element.getAttribute("imageStyle");
          if (!imageStyle) {
            continue;
          }
          const imageStyleDefinition = stylesMap.get(imageStyle);
          if (!imageStyleDefinition || !imageStyleDefinition.modelElements.includes(element.name)) {
            writer.removeAttribute("imageStyle", element);
            changed = true;
          }
        }
      }
      return changed;
    });
  }
};
var ImageStyleUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageStyleEditing
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageStyleUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Returns the default localized style titles provided by the plugin.
  *
  * The following localized titles corresponding with
  * {@link module:image/imagestyle/utils#DEFAULT_OPTIONS} are available:
  *
  * * `'Wrap text'`,
  * * `'Break text'`,
  * * `'In line'`,
  * * `'Full size image'`,
  * * `'Side image'`,
  * * `'Left aligned image'`,
  * * `'Centered image'`,
  * * `'Right aligned image'`
  */
  get localizedDefaultStylesTitles() {
    const t = this.editor.t;
    return {
      "Wrap text": t("Wrap text"),
      "Break text": t("Break text"),
      "In line": t("In line"),
      "Full size image": t("Full size image"),
      "Side image": t("Side image"),
      "Left aligned image": t("Left aligned image"),
      "Centered image": t("Centered image"),
      "Right aligned image": t("Right aligned image")
    };
  }
  /**
  * @inheritDoc
  */
  init() {
    const plugins = this.editor.plugins;
    const toolbarConfig = this.editor.config.get("image.toolbar") || [];
    const imageStyleEditing = plugins.get("ImageStyleEditing");
    const definedStyles = translateStyles(imageStyleEditing.normalizedStyles, this.localizedDefaultStylesTitles);
    for (const styleConfig of definedStyles) {
      this._createButton(styleConfig);
    }
    const definedDropdowns = translateStyles([
      ...toolbarConfig.filter(isObject_default),
      ...utils.getDefaultDropdownDefinitions(plugins)
    ], this.localizedDefaultStylesTitles);
    for (const dropdownConfig of definedDropdowns) {
      this._createDropdown(dropdownConfig, definedStyles);
    }
  }
  /**
  * Creates a dropdown and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
  */
  _createDropdown(dropdownConfig, definedStyles) {
    const factory = this.editor.ui.componentFactory;
    factory.add(dropdownConfig.name, (locale) => {
      let defaultButton;
      const { defaultItem, items, title } = dropdownConfig;
      const buttonViews = items.filter((itemName) => definedStyles.find(({ name }) => getUIComponentName(name) === itemName)).map((buttonName) => {
        const button = factory.create(buttonName);
        if (buttonName === defaultItem) {
          defaultButton = button;
        }
        return button;
      });
      if (items.length !== buttonViews.length) {
        utils.warnInvalidStyle({
          dropdown: dropdownConfig
        });
      }
      const dropdownView = createDropdown(locale, SplitButtonView);
      const splitButtonView = dropdownView.buttonView;
      const splitButtonViewArrow = splitButtonView.arrowView;
      addToolbarToDropdown(dropdownView, buttonViews, {
        enableActiveItemFocusOnDropdownOpen: true
      });
      splitButtonView.set({
        label: getDropdownButtonTitle(title, defaultButton.label),
        class: null,
        tooltip: true
      });
      splitButtonViewArrow.unbind("label");
      splitButtonViewArrow.set({
        label: title
      });
      splitButtonView.bind("icon").toMany(buttonViews, "isOn", (...areOn) => {
        const index = areOn.findIndex(identity_default);
        return index < 0 ? defaultButton.icon : buttonViews[index].icon;
      });
      splitButtonView.bind("label").toMany(buttonViews, "isOn", (...areOn) => {
        const index = areOn.findIndex(identity_default);
        return getDropdownButtonTitle(title, index < 0 ? defaultButton.label : buttonViews[index].label);
      });
      splitButtonView.bind("isOn").toMany(buttonViews, "isOn", (...areOn) => areOn.some(identity_default));
      splitButtonView.bind("class").toMany(buttonViews, "isOn", (...areOn) => areOn.some(identity_default) ? "ck-splitbutton_flatten" : void 0);
      splitButtonView.on("execute", () => {
        if (!buttonViews.some(({ isOn }) => isOn)) {
          defaultButton.fire("execute");
        } else {
          dropdownView.isOpen = !dropdownView.isOpen;
        }
      });
      dropdownView.bind("isEnabled").toMany(buttonViews, "isEnabled", (...areEnabled) => areEnabled.some(identity_default));
      this.listenTo(dropdownView, "execute", () => {
        this.editor.editing.view.focus();
      });
      return dropdownView;
    });
  }
  /**
  * Creates a button and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
  */
  _createButton(buttonConfig) {
    const buttonName = buttonConfig.name;
    this.editor.ui.componentFactory.add(getUIComponentName(buttonName), (locale) => {
      const command = this.editor.commands.get("imageStyle");
      const view = new ButtonView(locale);
      view.set({
        label: buttonConfig.title,
        icon: buttonConfig.icon,
        tooltip: true,
        isToggleable: true
      });
      view.bind("isEnabled").to(command, "isEnabled");
      view.bind("isOn").to(command, "value", (value) => value === buttonName);
      view.on("execute", this._executeCommand.bind(this, buttonName));
      return view;
    });
  }
  _executeCommand(name) {
    this.editor.execute("imageStyle", {
      value: name
    });
    this.editor.editing.view.focus();
  }
};
function translateStyles(styles, titles) {
  for (const style of styles) {
    if (titles[style.title]) {
      style.title = titles[style.title];
    }
  }
  return styles;
}
function getUIComponentName(name) {
  return `imageStyle:${name}`;
}
function getDropdownButtonTitle(dropdownTitle, buttonTitle) {
  return (dropdownTitle ? dropdownTitle + ": " : "") + buttonTitle;
}
var ImageStyle = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageStyleEditing,
      ImageStyleUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageStyle";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var ImageToolbar = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      WidgetToolbarRepository,
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ImageToolbar";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const t = editor.t;
    const widgetToolbarRepository = editor.plugins.get(WidgetToolbarRepository);
    const imageUtils = editor.plugins.get("ImageUtils");
    widgetToolbarRepository.register("image", {
      ariaLabel: t("Image toolbar"),
      items: normalizeDeclarativeConfig(editor.config.get("image.toolbar") || []),
      getRelatedElement: (selection) => imageUtils.getClosestSelectedImageWidget(selection)
    });
  }
};
function normalizeDeclarativeConfig(config) {
  return config.map((item) => isObject_default(item) ? item.name : item);
}
var PictureEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ImageEditing,
      ImageUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PictureEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    if (editor.plugins.has("ImageBlockEditing")) {
      editor.model.schema.extend("imageBlock", {
        allowAttributes: [
          "sources"
        ]
      });
    }
    if (editor.plugins.has("ImageInlineEditing")) {
      editor.model.schema.extend("imageInline", {
        allowAttributes: [
          "sources"
        ]
      });
    }
    this._setupConversion();
    this._setupImageUploadEditingIntegration();
  }
  /**
  * Configures conversion pipelines to support upcasting and downcasting images using the `<picture>` view element
  * and the model `sources` attribute.
  */
  _setupConversion() {
    const editor = this.editor;
    const conversion = editor.conversion;
    const imageUtils = editor.plugins.get("ImageUtils");
    conversion.for("upcast").add(upcastPicture(imageUtils));
    conversion.for("downcast").add(downcastSourcesAttribute(imageUtils));
  }
  /**
  * Makes it possible for uploaded images to get the `sources` model attribute and the `<picture>...</picture>`
  * view structure out-of-the-box if relevant data is provided along the
  * {@link module:image/imageupload/imageuploadediting~ImageUploadEditing#event:uploadComplete} event.
  */
  _setupImageUploadEditingIntegration() {
    const editor = this.editor;
    if (!editor.plugins.has("ImageUploadEditing")) {
      return;
    }
    const imageUploadEditing = editor.plugins.get("ImageUploadEditing");
    this.listenTo(imageUploadEditing, "uploadComplete", (evt, { imageElement, data }) => {
      const sources = data.sources;
      if (!sources) {
        return;
      }
      editor.model.change((writer) => {
        writer.setAttributes({
          sources
        }, imageElement);
      });
    });
  }
};

// node_modules/@ckeditor/ckeditor5-indent/dist/index.js
var IndentEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "IndentEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.commands.add("indent", new MultiCommand(editor));
    editor.commands.add("outdent", new MultiCommand(editor));
  }
};
var IndentUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "IndentUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const t = editor.t;
    const localizedIndentIcon = locale.uiLanguageDirection == "ltr" ? icons.indent : icons.outdent;
    const localizedOutdentIcon = locale.uiLanguageDirection == "ltr" ? icons.outdent : icons.indent;
    this._defineButton("indent", t("Increase indent"), localizedIndentIcon);
    this._defineButton("outdent", t("Decrease indent"), localizedOutdentIcon);
  }
  /**
  * Defines UI buttons for both toolbar and menu bar.
  */
  _defineButton(commandName, label, icon) {
    const editor = this.editor;
    editor.ui.componentFactory.add(commandName, () => {
      const buttonView = this._createButton(ButtonView, commandName, label, icon);
      buttonView.set({
        tooltip: true
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:" + commandName, () => {
      return this._createButton(MenuBarMenuListItemButtonView, commandName, label, icon);
    });
  }
  /**
  * Creates a button to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass, commandName, label, icon) {
    const editor = this.editor;
    const command = editor.commands.get(commandName);
    const view = new ButtonClass(editor.locale);
    view.set({
      label,
      icon
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute(commandName);
      editor.editing.view.focus();
    });
    return view;
  }
};
var Indent = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Indent";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      IndentEditing,
      IndentUI
    ];
  }
};
var IndentBlockCommand = class extends Command {
  /**
  * Creates an instance of the command.
  */
  constructor(editor, indentBehavior) {
    super(editor);
    /**
    * The command's indentation behavior.
    */
    __publicField(this, "_indentBehavior");
    this._indentBehavior = indentBehavior;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const model = editor.model;
    const block2 = first(model.document.selection.getSelectedBlocks());
    if (!block2 || !this._isIndentationChangeAllowed(block2)) {
      this.isEnabled = false;
      return;
    }
    this.isEnabled = this._indentBehavior.checkEnabled(block2.getAttribute("blockIndent"));
  }
  /**
  * @inheritDoc
  */
  execute() {
    const model = this.editor.model;
    const blocksToChange = this._getBlocksToChange();
    model.change((writer) => {
      for (const block2 of blocksToChange) {
        const currentIndent = block2.getAttribute("blockIndent");
        const nextIndent = this._indentBehavior.getNextIndent(currentIndent);
        if (nextIndent) {
          writer.setAttribute("blockIndent", nextIndent, block2);
        } else {
          writer.removeAttribute("blockIndent", block2);
        }
      }
    });
  }
  /**
  * Returns blocks from selection that should have blockIndent selection set.
  */
  _getBlocksToChange() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const blocksInSelection = Array.from(selection.getSelectedBlocks());
    return blocksInSelection.filter((block2) => this._isIndentationChangeAllowed(block2));
  }
  /**
  * Returns false if indentation cannot be applied, i.e.:
  * - for blocks disallowed by schema declaration
  * - for blocks in Document Lists (disallowed forward indentation only). See https://github.com/ckeditor/ckeditor5/issues/14155.
  * Otherwise returns true.
  */
  _isIndentationChangeAllowed(element) {
    const editor = this.editor;
    if (!editor.model.schema.checkAttribute(element, "blockIndent")) {
      return false;
    }
    if (!editor.plugins.has("ListUtils")) {
      return true;
    }
    if (!this._indentBehavior.isForward) {
      return true;
    }
    const documentListUtils = editor.plugins.get("ListUtils");
    return !documentListUtils.isListItemBlock(element);
  }
};
var IndentUsingOffset = class {
  /**
  * Creates an instance of the indentation behavior.
  *
  * @param config.direction The direction of indentation.
  * @param config.offset The offset of the next indentation step.
  * @param config.unit Indentation unit.
  */
  constructor(config) {
    /**
    * The direction of indentation.
    */
    __publicField(this, "isForward");
    /**
    * The offset of the next indentation step.
    */
    __publicField(this, "offset");
    /**
    * Indentation unit.
    */
    __publicField(this, "unit");
    this.isForward = config.direction === "forward";
    this.offset = config.offset;
    this.unit = config.unit;
  }
  /**
  * @inheritDoc
  */
  checkEnabled(indentAttributeValue) {
    const currentOffset = parseFloat(indentAttributeValue || "0");
    return this.isForward || currentOffset > 0;
  }
  /**
  * @inheritDoc
  */
  getNextIndent(indentAttributeValue) {
    const currentOffset = parseFloat(indentAttributeValue || "0");
    const isSameUnit = !indentAttributeValue || indentAttributeValue.endsWith(this.unit);
    if (!isSameUnit) {
      return this.isForward ? this.offset + this.unit : void 0;
    }
    const nextOffset = this.isForward ? this.offset : -this.offset;
    const offsetToSet = currentOffset + nextOffset;
    return offsetToSet > 0 ? offsetToSet + this.unit : void 0;
  }
};
var IndentUsingClasses = class {
  /**
  * Creates an instance of the indentation behavior.
  *
  * @param config.direction The direction of indentation.
  * @param config.classes A list of classes used for indentation.
  */
  constructor(config) {
    /**
    * The direction of indentation.
    */
    __publicField(this, "isForward");
    /**
    * A list of classes used for indentation.
    */
    __publicField(this, "classes");
    this.isForward = config.direction === "forward";
    this.classes = config.classes;
  }
  /**
  * @inheritDoc
  */
  checkEnabled(indentAttributeValue) {
    const currentIndex = this.classes.indexOf(indentAttributeValue);
    if (this.isForward) {
      return currentIndex < this.classes.length - 1;
    } else {
      return currentIndex >= 0;
    }
  }
  /**
  * @inheritDoc
  */
  getNextIndent(indentAttributeValue) {
    const currentIndex = this.classes.indexOf(indentAttributeValue);
    const indexStep = this.isForward ? 1 : -1;
    return this.classes[currentIndex + indexStep];
  }
};
var DEFAULT_ELEMENTS = [
  "paragraph",
  "heading1",
  "heading2",
  "heading3",
  "heading4",
  "heading5",
  "heading6"
];
var IndentBlock = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("indentBlock", {
      offset: 40,
      unit: "px"
    });
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "IndentBlock";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const configuration = editor.config.get("indentBlock");
    if (configuration.classes && configuration.classes.length) {
      this._setupConversionUsingClasses(configuration.classes);
      editor.commands.add("indentBlock", new IndentBlockCommand(editor, new IndentUsingClasses({
        direction: "forward",
        classes: configuration.classes
      })));
      editor.commands.add("outdentBlock", new IndentBlockCommand(editor, new IndentUsingClasses({
        direction: "backward",
        classes: configuration.classes
      })));
    } else {
      editor.data.addStyleProcessorRules(addMarginRules);
      this._setupConversionUsingOffset();
      editor.commands.add("indentBlock", new IndentBlockCommand(editor, new IndentUsingOffset({
        direction: "forward",
        offset: configuration.offset,
        unit: configuration.unit
      })));
      editor.commands.add("outdentBlock", new IndentBlockCommand(editor, new IndentUsingOffset({
        direction: "backward",
        offset: configuration.offset,
        unit: configuration.unit
      })));
    }
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const indentCommand = editor.commands.get("indent");
    const outdentCommand = editor.commands.get("outdent");
    const options2 = editor.config.get("heading.options");
    const configuredElements = options2 && options2.map((option) => option.model);
    const knownElements = configuredElements || DEFAULT_ELEMENTS;
    knownElements.forEach((elementName) => {
      if (schema.isRegistered(elementName)) {
        schema.extend(elementName, {
          allowAttributes: "blockIndent"
        });
      }
    });
    schema.setAttributeProperties("blockIndent", {
      isFormatting: true
    });
    indentCommand.registerChildCommand(editor.commands.get("indentBlock"));
    outdentCommand.registerChildCommand(editor.commands.get("outdentBlock"));
  }
  /**
  * Setups conversion for using offset indents.
  */
  _setupConversionUsingOffset() {
    const conversion = this.editor.conversion;
    const locale = this.editor.locale;
    const marginProperty = locale.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
    conversion.for("upcast").attributeToAttribute({
      view: {
        styles: {
          [marginProperty]: /[\s\S]+/
        }
      },
      model: {
        key: "blockIndent",
        value: (viewElement) => {
          if (!viewElement.is("element", "li")) {
            return viewElement.getStyle(marginProperty);
          }
        }
      }
    });
    conversion.for("downcast").attributeToAttribute({
      model: "blockIndent",
      view: (modelAttributeValue) => {
        return {
          key: "style",
          value: {
            [marginProperty]: modelAttributeValue
          }
        };
      }
    });
  }
  /**
  * Setups conversion for using classes.
  */
  _setupConversionUsingClasses(classes) {
    const definition = {
      model: {
        key: "blockIndent",
        values: []
      },
      view: {}
    };
    for (const className of classes) {
      definition.model.values.push(className);
      definition.view[className] = {
        key: "class",
        value: [
          className
        ]
      };
    }
    this.editor.conversion.attributeToAttribute(definition);
  }
};

// node_modules/@ckeditor/ckeditor5-language/dist/index.js
function stringifyLanguageAttribute(languageCode, textDirection) {
  textDirection = textDirection || getLanguageDirection(languageCode);
  return `${languageCode}:${textDirection}`;
}
function parseLanguageAttribute(str) {
  const [languageCode, textDirection] = str.split(":");
  return {
    languageCode,
    textDirection
  };
}
var TextPartLanguageCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.value = this._getValueFromFirstAllowedNode();
    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, "language");
  }
  /**
  * Executes the command. Applies the attribute to the selection or removes it from the selection.
  *
  * If `languageCode` is set to `false` or a `null` value, it will remove attributes. Otherwise, it will set
  * the attribute in the `{@link #value value}` format.
  *
  * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
  *
  * * If the selection is on a range, the command applies the attribute to all nodes in that range
  * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
  * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
  * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
  * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
  * that the selection inherits all attributes from a node if it is in an empty node).
  *
  * @fires execute
  * @param options Command options.
  * @param options.languageCode The language code to be applied to the model.
  * @param options.textDirection The language text direction.
  */
  execute({ languageCode, textDirection } = {}) {
    const model = this.editor.model;
    const doc = model.document;
    const selection = doc.selection;
    const value = languageCode ? stringifyLanguageAttribute(languageCode, textDirection) : false;
    model.change((writer) => {
      if (selection.isCollapsed) {
        if (value) {
          writer.setSelectionAttribute("language", value);
        } else {
          writer.removeSelectionAttribute("language");
        }
      } else {
        const ranges = model.schema.getValidRanges(selection.getRanges(), "language");
        for (const range of ranges) {
          if (value) {
            writer.setAttribute("language", value, range);
          } else {
            writer.removeAttribute("language", range);
          }
        }
      }
    });
  }
  /**
  * Returns the attribute value of the first node in the selection that allows the attribute.
  * For a collapsed selection it returns the selection attribute.
  *
  * @returns The attribute value.
  */
  _getValueFromFirstAllowedNode() {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    if (selection.isCollapsed) {
      return selection.getAttribute("language") || false;
    }
    for (const range of selection.getRanges()) {
      for (const item of range.getItems()) {
        if (schema.checkAttribute(item, "language")) {
          return item.getAttribute("language") || false;
        }
      }
    }
    return false;
  }
};
var TextPartLanguageEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TextPartLanguageEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("language", {
      textPartLanguage: [
        {
          title: "Arabic",
          languageCode: "ar"
        },
        {
          title: "French",
          languageCode: "fr"
        },
        {
          title: "Spanish",
          languageCode: "es"
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", {
      allowAttributes: "language"
    });
    editor.model.schema.setAttributeProperties("language", {
      copyOnEnter: true
    });
    this._defineConverters();
    editor.commands.add("textPartLanguage", new TextPartLanguageCommand(editor));
  }
  /**
  * @private
  */
  _defineConverters() {
    const conversion = this.editor.conversion;
    conversion.for("upcast").elementToAttribute({
      model: {
        key: "language",
        value: (viewElement) => {
          const languageCode = viewElement.getAttribute("lang");
          const textDirection = viewElement.getAttribute("dir");
          return stringifyLanguageAttribute(languageCode, textDirection);
        }
      },
      view: {
        name: "span",
        attributes: {
          lang: /[\s\S]+/
        }
      }
    });
    conversion.for("downcast").attributeToElement({
      model: "language",
      view: (attributeValue, { writer }, data) => {
        if (!attributeValue) {
          return;
        }
        if (!data.item.is("$textProxy") && !data.item.is("documentSelection")) {
          return;
        }
        const { languageCode, textDirection } = parseLanguageAttribute(attributeValue);
        return writer.createAttributeElement("span", {
          lang: languageCode,
          dir: textDirection
        });
      }
    });
  }
};
var TextPartLanguageUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TextPartLanguageUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const defaultTitle = t("Choose language");
    const accessibleLabel = t("Language");
    editor.ui.componentFactory.add("textPartLanguage", (locale) => {
      const { definitions, titles } = this._getItemMetadata();
      const languageCommand = editor.commands.get("textPartLanguage");
      const dropdownView = createDropdown(locale);
      addListToDropdown(dropdownView, definitions, {
        ariaLabel: accessibleLabel,
        role: "menu"
      });
      dropdownView.buttonView.set({
        ariaLabel: accessibleLabel,
        ariaLabelledBy: void 0,
        isOn: false,
        withText: true,
        tooltip: accessibleLabel
      });
      dropdownView.extendTemplate({
        attributes: {
          class: [
            "ck-text-fragment-language-dropdown"
          ]
        }
      });
      dropdownView.bind("isEnabled").to(languageCommand, "isEnabled");
      dropdownView.buttonView.bind("label").to(languageCommand, "value", (value) => {
        return value && titles[value] || defaultTitle;
      });
      dropdownView.buttonView.bind("ariaLabel").to(languageCommand, "value", (value) => {
        const selectedLanguageTitle = value && titles[value];
        if (!selectedLanguageTitle) {
          return accessibleLabel;
        }
        return `${selectedLanguageTitle}, ${accessibleLabel}`;
      });
      this.listenTo(dropdownView, "execute", (evt) => {
        languageCommand.execute({
          languageCode: evt.source.languageCode,
          textDirection: evt.source.textDirection
        });
        editor.editing.view.focus();
      });
      return dropdownView;
    });
    editor.ui.componentFactory.add("menuBar:textPartLanguage", (locale) => {
      const { definitions } = this._getItemMetadata();
      const languageCommand = editor.commands.get("textPartLanguage");
      const menuView = new MenuBarMenuView(locale);
      menuView.buttonView.set({
        label: accessibleLabel
      });
      const listView = new MenuBarMenuListView(locale);
      listView.set({
        ariaLabel: t("Language"),
        role: "menu"
      });
      for (const definition of definitions) {
        if (definition.type != "button") {
          listView.items.add(new ListSeparatorView(locale));
          continue;
        }
        const listItemView = new MenuBarMenuListItemView(locale, menuView);
        const buttonView = new MenuBarMenuListItemButtonView(locale);
        buttonView.set({
          role: "menuitemradio",
          isToggleable: true
        });
        buttonView.bind(...Object.keys(definition.model)).to(definition.model);
        buttonView.delegate("execute").to(menuView);
        listItemView.children.add(buttonView);
        listView.items.add(listItemView);
      }
      menuView.bind("isEnabled").to(languageCommand, "isEnabled");
      menuView.panelView.children.add(listView);
      menuView.on("execute", (evt) => {
        languageCommand.execute({
          languageCode: evt.source.languageCode,
          textDirection: evt.source.textDirection
        });
        editor.editing.view.focus();
      });
      return menuView;
    });
  }
  /**
  * Returns metadata for dropdown and menu items.
  */
  _getItemMetadata() {
    const editor = this.editor;
    const itemDefinitions = new Collection();
    const titles = {};
    const languageCommand = editor.commands.get("textPartLanguage");
    const options2 = editor.config.get("language.textPartLanguage");
    const t = editor.locale.t;
    const removeTitle = t("Remove language");
    itemDefinitions.add({
      type: "button",
      model: new Model2({
        label: removeTitle,
        languageCode: false,
        withText: true
      })
    });
    itemDefinitions.add({
      type: "separator"
    });
    for (const option of options2) {
      const def = {
        type: "button",
        model: new Model2({
          label: option.title,
          languageCode: option.languageCode,
          role: "menuitemradio",
          textDirection: option.textDirection,
          withText: true
        })
      };
      const language = stringifyLanguageAttribute(option.languageCode, option.textDirection);
      def.model.bind("isOn").to(languageCommand, "value", (value) => value === language);
      itemDefinitions.add(def);
      titles[language] = option.title;
    }
    return {
      definitions: itemDefinitions,
      titles
    };
  }
};
var TextPartLanguage = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TextPartLanguageEditing,
      TextPartLanguageUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TextPartLanguage";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-link/dist/index.js
var AutomaticDecorators = class {
  constructor() {
    /**
    * Stores the definition of {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}.
    * This data is used as a source for a downcast dispatcher to create a proper conversion to output data.
    */
    __publicField(this, "_definitions", /* @__PURE__ */ new Set());
  }
  /**
  * Gives information about the number of decorators stored in the {@link module:link/utils/automaticdecorators~AutomaticDecorators}
  * instance.
  */
  get length() {
    return this._definitions.size;
  }
  /**
  * Adds automatic decorator objects or an array with them to be used during downcasting.
  *
  * @param item A configuration object of automatic rules for decorating links. It might also be an array of such objects.
  */
  add(item) {
    if (Array.isArray(item)) {
      item.forEach((item2) => this._definitions.add(item2));
    } else {
      this._definitions.add(item);
    }
  }
  /**
  * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
  *
  * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
  */
  getDispatcher() {
    return (dispatcher) => {
      dispatcher.on("attribute:linkHref", (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, "attribute:linkHref")) {
          return;
        }
        if (!(data.item.is("selection") || conversionApi.schema.isInline(data.item))) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const viewSelection = viewWriter.document.selection;
        for (const item of this._definitions) {
          const viewElement = viewWriter.createAttributeElement("a", item.attributes, {
            priority: 5
          });
          if (item.classes) {
            viewWriter.addClass(item.classes, viewElement);
          }
          for (const key in item.styles) {
            viewWriter.setStyle(key, item.styles[key], viewElement);
          }
          viewWriter.setCustomProperty("link", true, viewElement);
          if (item.callback(data.attributeNewValue)) {
            if (data.item.is("selection")) {
              viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
            } else {
              viewWriter.wrap(conversionApi.mapper.toViewRange(data.range), viewElement);
            }
          } else {
            viewWriter.unwrap(conversionApi.mapper.toViewRange(data.range), viewElement);
          }
        }
      }, {
        priority: "high"
      });
    };
  }
  /**
  * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method
  * when linking images.
  *
  * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
  */
  getDispatcherForLinkedImage() {
    return (dispatcher) => {
      dispatcher.on("attribute:linkHref:imageBlock", (evt, data, { writer, mapper }) => {
        const viewFigure = mapper.toViewElement(data.item);
        const linkInImage = Array.from(viewFigure.getChildren()).find((child) => child.is("element", "a"));
        if (!linkInImage) {
          return;
        }
        for (const item of this._definitions) {
          const attributes = toMap(item.attributes);
          if (item.callback(data.attributeNewValue)) {
            for (const [key, val] of attributes) {
              if (key === "class") {
                writer.addClass(val, linkInImage);
              } else {
                writer.setAttribute(key, val, linkInImage);
              }
            }
            if (item.classes) {
              writer.addClass(item.classes, linkInImage);
            }
            for (const key in item.styles) {
              writer.setStyle(key, item.styles[key], linkInImage);
            }
          } else {
            for (const [key, val] of attributes) {
              if (key === "class") {
                writer.removeClass(val, linkInImage);
              } else {
                writer.removeAttribute(key, linkInImage);
              }
            }
            if (item.classes) {
              writer.removeClass(item.classes, linkInImage);
            }
            for (const key in item.styles) {
              writer.removeStyle(key, linkInImage);
            }
          }
        }
      });
    };
  }
};
var ATTRIBUTE_WHITESPACES = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var SAFE_URL_TEMPLATE = "^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))";
var EMAIL_REG_EXP = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
var PROTOCOL_REG_EXP = /^((\w+:(\/{2,})?)|(\W))/i;
var DEFAULT_LINK_PROTOCOLS = [
  "https?",
  "ftps?",
  "mailto"
];
var LINK_KEYSTROKE = "Ctrl+K";
function isLinkElement(node) {
  return node.is("attributeElement") && !!node.getCustomProperty("link");
}
function createLinkElement2(href, { writer }) {
  const linkElement = writer.createAttributeElement("a", {
    href
  }, {
    priority: 5
  });
  writer.setCustomProperty("link", true, linkElement);
  return linkElement;
}
function ensureSafeUrl(url, allowedProtocols = DEFAULT_LINK_PROTOCOLS) {
  const urlString = String(url);
  const protocolsList = allowedProtocols.join("|");
  const customSafeRegex = new RegExp(`${SAFE_URL_TEMPLATE.replace("<protocols>", protocolsList)}`, "i");
  return isSafeUrl(urlString, customSafeRegex) ? urlString : "#";
}
function isSafeUrl(url, customRegexp) {
  const normalizedUrl = url.replace(ATTRIBUTE_WHITESPACES, "");
  return !!normalizedUrl.match(customRegexp);
}
function getLocalizedDecorators(t, decorators) {
  const localizedDecoratorsLabels = {
    "Open in a new tab": t("Open in a new tab"),
    "Downloadable": t("Downloadable")
  };
  decorators.forEach((decorator) => {
    if ("label" in decorator && localizedDecoratorsLabels[decorator.label]) {
      decorator.label = localizedDecoratorsLabels[decorator.label];
    }
    return decorator;
  });
  return decorators;
}
function normalizeDecorators(decorators) {
  const retArray = [];
  if (decorators) {
    for (const [key, value] of Object.entries(decorators)) {
      const decorator = Object.assign({}, value, {
        id: `link${upperFirst_default(key)}`
      });
      retArray.push(decorator);
    }
  }
  return retArray;
}
function isLinkableElement(element, schema) {
  if (!element) {
    return false;
  }
  return schema.checkAttribute(element.name, "linkHref");
}
function isEmail(value) {
  return EMAIL_REG_EXP.test(value);
}
function addLinkProtocolIfApplicable(link, defaultProtocol) {
  const protocol2 = isEmail(link) ? "mailto:" : defaultProtocol;
  const isProtocolNeeded = !!protocol2 && !linkHasProtocol(link);
  return link && isProtocolNeeded ? protocol2 + link : link;
}
function linkHasProtocol(link) {
  return PROTOCOL_REG_EXP.test(link);
}
function openLink(link) {
  window.open(link, "_blank", "noopener");
}
var LinkCommand = class extends Command {
  constructor() {
    super(...arguments);
    /**
    * A collection of {@link module:link/utils/manualdecorator~ManualDecorator manual decorators}
    * corresponding to the {@link module:link/linkconfig~LinkConfig#decorators decorator configuration}.
    *
    * You can consider it a model with states of manual decorators added to the currently selected link.
    */
    __publicField(this, "manualDecorators", new Collection());
    /**
    * An instance of the helper that ties together all {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition}
    * that are used by the {@glink features/link link} and the {@glink features/images/images-linking linking images} features.
    */
    __publicField(this, "automaticDecorators", new AutomaticDecorators());
  }
  /**
  * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
  */
  restoreManualDecoratorStates() {
    for (const manualDecorator of this.manualDecorators) {
      manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
    }
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedElement = selection.getSelectedElement() || first(selection.getSelectedBlocks());
    if (isLinkableElement(selectedElement, model.schema)) {
      this.value = selectedElement.getAttribute("linkHref");
      this.isEnabled = model.schema.checkAttribute(selectedElement, "linkHref");
    } else {
      this.value = selection.getAttribute("linkHref");
      this.isEnabled = model.schema.checkAttributeInSelection(selection, "linkHref");
    }
    for (const manualDecorator of this.manualDecorators) {
      manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
    }
  }
  /**
  * Executes the command.
  *
  * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
  * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
  *
  * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
  * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
  * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
  * The selection will be updated to wrap the just inserted text node.
  *
  * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
  *
  * # Decorators and model attribute management
  *
  * There is an optional argument to this command that applies or removes model
  * {@glink framework/architecture/editing-engine#text-attributes text attributes} brought by
  * {@link module:link/utils/manualdecorator~ManualDecorator manual link decorators}.
  *
  * Text attribute names in the model correspond to the entries in the {@link module:link/linkconfig~LinkConfig#decorators
  * configuration}.
  * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
  * corresponds to `'myDecorator'` in the configuration.
  *
  * To learn more about link decorators, check out the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`}
  * documentation.
  *
  * Here is how to manage decorator attributes with the link command:
  *
  * ```ts
  * const linkCommand = editor.commands.get( 'link' );
  *
  * // Adding a new decorator attribute.
  * linkCommand.execute( 'http://example.com', {
  * 	linkIsExternal: true
  * } );
  *
  * // Removing a decorator attribute from the selection.
  * linkCommand.execute( 'http://example.com', {
  * 	linkIsExternal: false
  * } );
  *
  * // Adding multiple decorator attributes at the same time.
  * linkCommand.execute( 'http://example.com', {
  * 	linkIsExternal: true,
  * 	linkIsDownloadable: true,
  * } );
  *
  * // Removing and adding decorator attributes at the same time.
  * linkCommand.execute( 'http://example.com', {
  * 	linkIsExternal: false,
  * 	linkFoo: true,
  * 	linkIsDownloadable: false,
  * } );
  * ```
  *
  * **Note**: If the decorator attribute name is not specified, its state remains untouched.
  *
  * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
  * decorator attributes.
  *
  * @fires execute
  * @param href Link destination.
  * @param manualDecoratorIds The information about manual decorator attributes to be applied or removed upon execution.
  */
  execute(href, manualDecoratorIds = {}) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const truthyManualDecorators = [];
    const falsyManualDecorators = [];
    for (const name in manualDecoratorIds) {
      if (manualDecoratorIds[name]) {
        truthyManualDecorators.push(name);
      } else {
        falsyManualDecorators.push(name);
      }
    }
    model.change((writer) => {
      if (selection.isCollapsed) {
        const position = selection.getFirstPosition();
        if (selection.hasAttribute("linkHref")) {
          const linkText = extractTextFromSelection(selection);
          let linkRange = findAttributeRange(position, "linkHref", selection.getAttribute("linkHref"), model);
          if (selection.getAttribute("linkHref") === linkText) {
            linkRange = this._updateLinkContent(model, writer, linkRange, href);
          }
          writer.setAttribute("linkHref", href, linkRange);
          truthyManualDecorators.forEach((item) => {
            writer.setAttribute(item, true, linkRange);
          });
          falsyManualDecorators.forEach((item) => {
            writer.removeAttribute(item, linkRange);
          });
          writer.setSelection(writer.createPositionAfter(linkRange.end.nodeBefore));
        } else if (href !== "") {
          const attributes = toMap(selection.getAttributes());
          attributes.set("linkHref", href);
          truthyManualDecorators.forEach((item) => {
            attributes.set(item, true);
          });
          const { end: positionAfter } = model.insertContent(writer.createText(href, attributes), position);
          writer.setSelection(positionAfter);
        }
        [
          "linkHref",
          ...truthyManualDecorators,
          ...falsyManualDecorators
        ].forEach((item) => {
          writer.removeSelectionAttribute(item);
        });
      } else {
        const ranges = model.schema.getValidRanges(selection.getRanges(), "linkHref");
        const allowedRanges = [];
        for (const element of selection.getSelectedBlocks()) {
          if (model.schema.checkAttribute(element, "linkHref")) {
            allowedRanges.push(writer.createRangeOn(element));
          }
        }
        const rangesToUpdate = allowedRanges.slice();
        for (const range of ranges) {
          if (this._isRangeToUpdate(range, allowedRanges)) {
            rangesToUpdate.push(range);
          }
        }
        for (const range of rangesToUpdate) {
          let linkRange = range;
          if (rangesToUpdate.length === 1) {
            const linkText = extractTextFromSelection(selection);
            if (selection.getAttribute("linkHref") === linkText) {
              linkRange = this._updateLinkContent(model, writer, range, href);
              writer.setSelection(writer.createSelection(linkRange));
            }
          }
          writer.setAttribute("linkHref", href, linkRange);
          truthyManualDecorators.forEach((item) => {
            writer.setAttribute(item, true, linkRange);
          });
          falsyManualDecorators.forEach((item) => {
            writer.removeAttribute(item, linkRange);
          });
        }
      }
    });
  }
  /**
  * Provides information whether a decorator with a given name is present in the currently processed selection.
  *
  * @param decoratorName The name of the manual decorator used in the model
  * @returns The information whether a given decorator is currently present in the selection.
  */
  _getDecoratorStateFromModel(decoratorName) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (isLinkableElement(selectedElement, model.schema)) {
      return selectedElement.getAttribute(decoratorName);
    }
    return selection.getAttribute(decoratorName);
  }
  /**
  * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
  *
  * @param range A range to check.
  * @param allowedRanges An array of ranges created on elements where the attribute is accepted.
  */
  _isRangeToUpdate(range, allowedRanges) {
    for (const allowedRange of allowedRanges) {
      if (allowedRange.containsRange(range)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Updates selected link with a new value as its content and as its href attribute.
  *
  * @param model Model is need to insert content.
  * @param writer Writer is need to create text element in model.
  * @param range A range where should be inserted content.
  * @param href A link value which should be in the href attribute and in the content.
  */
  _updateLinkContent(model, writer, range, href) {
    const text = writer.createText(href, {
      linkHref: href
    });
    return model.insertContent(text, range);
  }
};
function extractTextFromSelection(selection) {
  if (selection.isCollapsed) {
    const firstPosition = selection.getFirstPosition();
    return firstPosition.textNode && firstPosition.textNode.data;
  } else {
    const rangeItems = Array.from(selection.getFirstRange().getItems());
    if (rangeItems.length > 1) {
      return null;
    }
    const firstNode = rangeItems[0];
    if (firstNode.is("$text") || firstNode.is("$textProxy")) {
      return firstNode.data;
    }
    return null;
  }
}
var UnlinkCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (isLinkableElement(selectedElement, model.schema)) {
      this.isEnabled = model.schema.checkAttribute(selectedElement, "linkHref");
    } else {
      this.isEnabled = model.schema.checkAttributeInSelection(selection, "linkHref");
    }
  }
  /**
  * Executes the command.
  *
  * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
  * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
  *
  * # Decorators
  *
  * If {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} is specified,
  * all configured decorators are removed together with the `linkHref` attribute.
  *
  * @fires execute
  */
  execute() {
    const editor = this.editor;
    const model = this.editor.model;
    const selection = model.document.selection;
    const linkCommand = editor.commands.get("link");
    model.change((writer) => {
      const rangesToUnlink = selection.isCollapsed ? [
        findAttributeRange(selection.getFirstPosition(), "linkHref", selection.getAttribute("linkHref"), model)
      ] : model.schema.getValidRanges(selection.getRanges(), "linkHref");
      for (const range of rangesToUnlink) {
        writer.removeAttribute("linkHref", range);
        if (linkCommand) {
          for (const manualDecorator of linkCommand.manualDecorators) {
            writer.removeAttribute(manualDecorator.id, range);
          }
        }
      }
    });
  }
};
var ManualDecorator = class extends ObservableMixin() {
  /**
  * Creates a new instance of {@link module:link/utils/manualdecorator~ManualDecorator}.
  *
  * @param config.id The name of the attribute used in the model that represents a given manual decorator.
  * For example: `'linkIsExternal'`.
  * @param config.label The label used in the user interface to toggle the manual decorator.
  * @param config.attributes A set of attributes added to output data when the decorator is active for a specific link.
  * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
  * @param [config.defaultValue] Controls whether the decorator is "on" by default.
  */
  constructor({ id, label, attributes, classes, styles, defaultValue }) {
    super();
    /**
    * An ID of a manual decorator which is the name of the attribute in the model, for example: 'linkManualDecorator0'.
    */
    __publicField(this, "id");
    /**
    * The default value of manual decorator.
    */
    __publicField(this, "defaultValue");
    /**
    * The label used in the user interface to toggle the manual decorator.
    */
    __publicField(this, "label");
    /**
    * A set of attributes added to downcasted data when the decorator is activated for a specific link.
    * Attributes should be added in a form of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
    */
    __publicField(this, "attributes");
    /**
    * A set of classes added to downcasted data when the decorator is activated for a specific link.
    * Classes should be added in a form of classes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
    */
    __publicField(this, "classes");
    /**
    * A set of styles added to downcasted data when the decorator is activated for a specific link.
    * Styles should be added in a form of styles defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
    */
    __publicField(this, "styles");
    this.id = id;
    this.set("value", void 0);
    this.defaultValue = defaultValue;
    this.label = label;
    this.attributes = attributes;
    this.classes = classes;
    this.styles = styles;
  }
  /**
  * Returns {@link module:engine/view/matcher~MatcherPattern} with decorator attributes.
  *
  * @internal
  */
  _createPattern() {
    return {
      attributes: this.attributes,
      classes: this.classes,
      styles: this.styles
    };
  }
};
var HIGHLIGHT_CLASS3 = "ck-link_selected";
var DECORATOR_AUTOMATIC = "automatic";
var DECORATOR_MANUAL = "manual";
var EXTERNAL_LINKS_REGEXP = /^(https?:)?\/\//;
var LinkEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LinkEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TwoStepCaretMovement,
      Input,
      ClipboardPipeline
    ];
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("link", {
      allowCreatingEmptyLinks: false,
      addTargetToExternalLinks: false
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const allowedProtocols = this.editor.config.get("link.allowedProtocols");
    editor.model.schema.extend("$text", {
      allowAttributes: "linkHref"
    });
    editor.conversion.for("dataDowncast").attributeToElement({
      model: "linkHref",
      view: createLinkElement2
    });
    editor.conversion.for("editingDowncast").attributeToElement({
      model: "linkHref",
      view: (href, conversionApi) => {
        return createLinkElement2(ensureSafeUrl(href, allowedProtocols), conversionApi);
      }
    });
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "a",
        attributes: {
          href: true
        }
      },
      model: {
        key: "linkHref",
        value: (viewElement) => viewElement.getAttribute("href")
      }
    });
    editor.commands.add("link", new LinkCommand(editor));
    editor.commands.add("unlink", new UnlinkCommand(editor));
    const linkDecorators = getLocalizedDecorators(editor.t, normalizeDecorators(editor.config.get("link.decorators")));
    this._enableAutomaticDecorators(linkDecorators.filter((item) => item.mode === DECORATOR_AUTOMATIC));
    this._enableManualDecorators(linkDecorators.filter((item) => item.mode === DECORATOR_MANUAL));
    const twoStepCaretMovementPlugin = editor.plugins.get(TwoStepCaretMovement);
    twoStepCaretMovementPlugin.registerAttribute("linkHref");
    inlineHighlight(editor, "linkHref", "a", HIGHLIGHT_CLASS3);
    this._enableLinkOpen();
    this._enableSelectionAttributesFixer();
    this._enableClipboardIntegration();
  }
  /**
  * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}
  * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
  * for each one of them. Downcast dispatchers are obtained using the
  * {@link module:link/utils/automaticdecorators~AutomaticDecorators#getDispatcher} method.
  *
  * **Note**: This method also activates the automatic external link decorator if enabled with
  * {@link module:link/linkconfig~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
  */
  _enableAutomaticDecorators(automaticDecoratorDefinitions) {
    const editor = this.editor;
    const command = editor.commands.get("link");
    const automaticDecorators = command.automaticDecorators;
    if (editor.config.get("link.addTargetToExternalLinks")) {
      automaticDecorators.add({
        id: "linkIsExternal",
        mode: DECORATOR_AUTOMATIC,
        callback: (url) => !!url && EXTERNAL_LINKS_REGEXP.test(url),
        attributes: {
          target: "_blank",
          rel: "noopener noreferrer"
        }
      });
    }
    automaticDecorators.add(automaticDecoratorDefinitions);
    if (automaticDecorators.length) {
      editor.conversion.for("downcast").add(automaticDecorators.getDispatcher());
    }
  }
  /**
  * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorManualDefinition manual decorators},
  * transforms them into {@link module:link/utils/manualdecorator~ManualDecorator} instances and stores them in the
  * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
  *
  * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
  * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
  * with adequate model attributes.
  */
  _enableManualDecorators(manualDecoratorDefinitions) {
    if (!manualDecoratorDefinitions.length) {
      return;
    }
    const editor = this.editor;
    const command = editor.commands.get("link");
    const manualDecorators = command.manualDecorators;
    manualDecoratorDefinitions.forEach((decoratorDefinition) => {
      editor.model.schema.extend("$text", {
        allowAttributes: decoratorDefinition.id
      });
      const decorator = new ManualDecorator(decoratorDefinition);
      manualDecorators.add(decorator);
      editor.conversion.for("downcast").attributeToElement({
        model: decorator.id,
        view: (manualDecoratorValue, { writer, schema }, { item }) => {
          if (!(item.is("selection") || schema.isInline(item))) {
            return;
          }
          if (manualDecoratorValue) {
            const element = writer.createAttributeElement("a", decorator.attributes, {
              priority: 5
            });
            if (decorator.classes) {
              writer.addClass(decorator.classes, element);
            }
            for (const key in decorator.styles) {
              writer.setStyle(key, decorator.styles[key], element);
            }
            writer.setCustomProperty("link", true, element);
            return element;
          }
        }
      });
      editor.conversion.for("upcast").elementToAttribute({
        view: {
          name: "a",
          ...decorator._createPattern()
        },
        model: {
          key: decorator.id
        }
      });
    });
  }
  /**
  * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and
  * {@link module:engine/view/document~Document#event:click} to enable link following.
  */
  _enableLinkOpen() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "click", (evt, data) => {
      const shouldOpen = env.isMac ? data.domEvent.metaKey : data.domEvent.ctrlKey;
      if (!shouldOpen) {
        return;
      }
      let clickedElement = data.domTarget;
      if (clickedElement.tagName.toLowerCase() != "a") {
        clickedElement = clickedElement.closest("a");
      }
      if (!clickedElement) {
        return;
      }
      const url = clickedElement.getAttribute("href");
      if (!url) {
        return;
      }
      evt.stop();
      data.preventDefault();
      openLink(url);
    }, {
      context: "$capture"
    });
    this.listenTo(viewDocument, "keydown", (evt, data) => {
      const linkCommand = editor.commands.get("link");
      const url = linkCommand.value;
      const shouldOpen = !!url && data.keyCode === keyCodes.enter && data.altKey;
      if (!shouldOpen) {
        return;
      }
      evt.stop();
      openLink(url);
    });
  }
  /**
  * Watches the DocumentSelection attribute changes and removes link decorator attributes when the linkHref attribute is removed.
  *
  * This is to ensure that there is no left-over link decorator attributes on the document selection that is no longer in a link.
  */
  _enableSelectionAttributesFixer() {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    this.listenTo(selection, "change:attribute", (evt, { attributeKeys }) => {
      if (!attributeKeys.includes("linkHref") || selection.hasAttribute("linkHref")) {
        return;
      }
      model.change((writer) => {
        removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));
      });
    });
  }
  /**
  * Enables URL fixing on pasting.
  */
  _enableClipboardIntegration() {
    const editor = this.editor;
    const model = editor.model;
    const defaultProtocol = this.editor.config.get("link.defaultProtocol");
    if (!defaultProtocol) {
      return;
    }
    this.listenTo(editor.plugins.get("ClipboardPipeline"), "contentInsertion", (evt, data) => {
      model.change((writer) => {
        const range = writer.createRangeIn(data.content);
        for (const item of range.getItems()) {
          if (item.hasAttribute("linkHref")) {
            const newLink = addLinkProtocolIfApplicable(item.getAttribute("linkHref"), defaultProtocol);
            writer.setAttribute("linkHref", newLink, item);
          }
        }
      });
    });
  }
};
function removeLinkAttributesFromSelection(writer, linkAttributes) {
  writer.removeSelectionAttribute("linkHref");
  for (const attribute of linkAttributes) {
    writer.removeSelectionAttribute(attribute);
  }
}
function getLinkAttributesAllowedOnText(schema) {
  const textAttributes = schema.getDefinition("$text").allowAttributes;
  return textAttributes.filter((attribute) => attribute.startsWith("link"));
}
var LinkFormView = class extends View2 {
  /**
  * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
  *
  * Also see {@link #render}.
  *
  * @param locale The localization services instance.
  * @param linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
  * @param validators  Form validators used by {@link #isValid}.
  */
  constructor(locale, linkCommand, validators) {
    super(locale);
    /**
    * Tracks information about DOM focus in the form.
    */
    __publicField(this, "focusTracker", new FocusTracker());
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes", new KeystrokeHandler());
    /**
    * The URL input view.
    */
    __publicField(this, "urlInputView");
    /**
    * The Save button view.
    */
    __publicField(this, "saveButtonView");
    /**
    * The Cancel button view.
    */
    __publicField(this, "cancelButtonView");
    /**
    * A collection of {@link module:ui/button/switchbuttonview~SwitchButtonView},
    * which corresponds to {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators}
    * configured in the editor.
    */
    __publicField(this, "_manualDecoratorSwitches");
    /**
    * A collection of child views in the form.
    */
    __publicField(this, "children");
    /**
    * An array of form validators used by {@link #isValid}.
    */
    __publicField(this, "_validators");
    /**
    * A collection of views that can be focused in the form.
    */
    __publicField(this, "_focusables", new ViewCollection());
    /**
    * Helps cycling over {@link #_focusables} in the form.
    */
    __publicField(this, "_focusCycler");
    const t = locale.t;
    this._validators = validators;
    this.urlInputView = this._createUrlInput();
    this.saveButtonView = this._createButton(t("Save"), icons.check, "ck-button-save");
    this.saveButtonView.type = "submit";
    this.cancelButtonView = this._createButton(t("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
    this._manualDecoratorSwitches = this._createManualDecoratorSwitches(linkCommand);
    this.children = this._createFormChildren(linkCommand.manualDecorators);
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    const classList = [
      "ck",
      "ck-link-form",
      "ck-responsive-form"
    ];
    if (linkCommand.manualDecorators.length) {
      classList.push("ck-link-form_layout-vertical", "ck-vertical-form");
    }
    this.setTemplate({
      tag: "form",
      attributes: {
        class: classList,
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
  * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
  * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
  * in the {@link module:link/ui/linkformview~LinkFormView}.
  *
  * @returns Key-value pairs, where the key is the name of the decorator and the value is its state.
  */
  getDecoratorSwitchesState() {
    return Array.from(this._manualDecoratorSwitches).reduce((accumulator, switchButton) => {
      accumulator[switchButton.name] = switchButton.isOn;
      return accumulator;
    }, {});
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    const childViews = [
      this.urlInputView,
      ...this._manualDecoratorSwitches,
      this.saveButtonView,
      this.cancelButtonView
    ];
    childViews.forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the fist {@link #_focusables} in the form.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Validates the form and returns `false` when some fields are invalid.
  */
  isValid() {
    this.resetFormStatus();
    for (const validator of this._validators) {
      const errorText = validator(this);
      if (errorText) {
        this.urlInputView.errorText = errorText;
        return false;
      }
    }
    return true;
  }
  /**
  * Cleans up the supplementary error and information text of the {@link #urlInputView}
  * bringing them back to the state when the form has been displayed for the first time.
  *
  * See {@link #isValid}.
  */
  resetFormStatus() {
    this.urlInputView.errorText = null;
  }
  /**
  * Creates a labeled input view.
  *
  * @returns Labeled field view instance.
  */
  _createUrlInput() {
    const t = this.locale.t;
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    labeledInput.fieldView.inputMode = "url";
    labeledInput.label = t("Link URL");
    return labeledInput;
  }
  /**
  * Creates a button view.
  *
  * @param label The button label.
  * @param icon The button icon.
  * @param className The additional button CSS class name.
  * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
  * @returns The button view instance.
  */
  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.locale);
    button.set({
      label,
      icon,
      tooltip: true
    });
    button.extendTemplate({
      attributes: {
        class: className
      }
    });
    if (eventName) {
      button.delegate("execute").to(this, eventName);
    }
    return button;
  }
  /**
  * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
  * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
  *
  * @param linkCommand A reference to the link command.
  * @returns ViewCollection of switch buttons.
  */
  _createManualDecoratorSwitches(linkCommand) {
    const switches = this.createCollection();
    for (const manualDecorator of linkCommand.manualDecorators) {
      const switchButton = new SwitchButtonView(this.locale);
      switchButton.set({
        name: manualDecorator.id,
        label: manualDecorator.label,
        withText: true
      });
      switchButton.bind("isOn").toMany([
        manualDecorator,
        linkCommand
      ], "value", (decoratorValue, commandValue) => {
        return commandValue === void 0 && decoratorValue === void 0 ? !!manualDecorator.defaultValue : !!decoratorValue;
      });
      switchButton.on("execute", () => {
        manualDecorator.set("value", !switchButton.isOn);
      });
      switches.add(switchButton);
    }
    return switches;
  }
  /**
  * Populates the {@link #children} collection of the form.
  *
  * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
  * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
  * to these decorators.
  *
  * @param manualDecorators A reference to
  * the collection of manual decorators stored in the link command.
  * @returns The children of link form view.
  */
  _createFormChildren(manualDecorators) {
    const children = this.createCollection();
    children.add(this.urlInputView);
    if (manualDecorators.length) {
      const additionalButtonsView = new View2();
      additionalButtonsView.setTemplate({
        tag: "ul",
        children: this._manualDecoratorSwitches.map((switchButton) => ({
          tag: "li",
          children: [
            switchButton
          ],
          attributes: {
            class: [
              "ck",
              "ck-list__item"
            ]
          }
        })),
        attributes: {
          class: [
            "ck",
            "ck-reset",
            "ck-list"
          ]
        }
      });
      children.add(additionalButtonsView);
    }
    children.add(this.saveButtonView);
    children.add(this.cancelButtonView);
    return children;
  }
  /**
  * The native DOM `value` of the {@link #urlInputView} element.
  *
  * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
  * which works one way only and may not represent the actual state of the component in the DOM.
  */
  get url() {
    const { element } = this.urlInputView.fieldView;
    if (!element) {
      return null;
    }
    return element.value.trim();
  }
};
var unlinkIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
var LinkActionsView = class extends View2 {
  /**
  * @inheritDoc
  */
  constructor(locale, linkConfig = {}) {
    super(locale);
    /**
    * Tracks information about DOM focus in the actions.
    */
    __publicField(this, "focusTracker", new FocusTracker());
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes", new KeystrokeHandler());
    /**
    * The href preview view.
    */
    __publicField(this, "previewButtonView");
    /**
    * The unlink button view.
    */
    __publicField(this, "unlinkButtonView");
    /**
    * The edit link button view.
    */
    __publicField(this, "editButtonView");
    /**
    * A collection of views that can be focused in the view.
    */
    __publicField(this, "_focusables", new ViewCollection());
    /**
    * Helps cycling over {@link #_focusables} in the view.
    */
    __publicField(this, "_focusCycler");
    __publicField(this, "_linkConfig");
    const t = locale.t;
    this.previewButtonView = this._createPreviewButton();
    this.unlinkButtonView = this._createButton(t("Unlink"), unlinkIcon, "unlink");
    this.editButtonView = this._createButton(t("Edit link"), icons.pencil, "edit");
    this.set("href", void 0);
    this._linkConfig = linkConfig;
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-link-actions",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: [
        this.previewButtonView,
        this.editButtonView,
        this.unlinkButtonView
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    const childViews = [
      this.previewButtonView,
      this.editButtonView,
      this.unlinkButtonView
    ];
    childViews.forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the fist {@link #_focusables} in the actions.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Creates a button view.
  *
  * @param label The button label.
  * @param icon The button icon.
  * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
  * @returns The button view instance.
  */
  _createButton(label, icon, eventName) {
    const button = new ButtonView(this.locale);
    button.set({
      label,
      icon,
      tooltip: true
    });
    button.delegate("execute").to(this, eventName);
    return button;
  }
  /**
  * Creates a link href preview button.
  *
  * @returns The button view instance.
  */
  _createPreviewButton() {
    const button = new ButtonView(this.locale);
    const bind = this.bindTemplate;
    const t = this.t;
    button.set({
      withText: true,
      tooltip: t("Open link in new tab")
    });
    button.extendTemplate({
      attributes: {
        class: [
          "ck",
          "ck-link-actions__preview"
        ],
        href: bind.to("href", (href) => href && ensureSafeUrl(href, this._linkConfig.allowedProtocols)),
        target: "_blank",
        rel: "noopener noreferrer"
      }
    });
    button.bind("label").to(this, "href", (href) => {
      return href || t("This link has no URL");
    });
    button.bind("isEnabled").to(this, "href", (href) => !!href);
    button.template.tag = "a";
    button.template.eventListeners = {};
    return button;
  }
};
var linkIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
var VISUAL_SELECTION_MARKER_NAME = "link-ui";
var LinkUI = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * The actions view displayed inside of the balloon.
    */
    __publicField(this, "actionsView", null);
    /**
    * The form view displayed inside the balloon.
    */
    __publicField(this, "formView", null);
    /**
    * The contextual balloon plugin instance.
    */
    __publicField(this, "_balloon");
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ContextualBalloon
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LinkUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    editor.editing.view.addObserver(ClickObserver);
    this._balloon = editor.plugins.get(ContextualBalloon);
    this._createToolbarLinkButton();
    this._enableBalloonActivators();
    editor.conversion.for("editingDowncast").markerToHighlight({
      model: VISUAL_SELECTION_MARKER_NAME,
      view: {
        classes: [
          "ck-fake-link-selection"
        ]
      }
    });
    editor.conversion.for("editingDowncast").markerToElement({
      model: VISUAL_SELECTION_MARKER_NAME,
      view: (data, { writer }) => {
        if (!data.markerRange.isCollapsed) {
          return null;
        }
        const markerElement = writer.createUIElement("span");
        writer.addClass([
          "ck-fake-link-selection",
          "ck-fake-link-selection_collapsed"
        ], markerElement);
        return markerElement;
      }
    });
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Create link"),
          keystroke: LINK_KEYSTROKE
        },
        {
          label: t("Move out of a link"),
          keystroke: [
            [
              "arrowleft",
              "arrowleft"
            ],
            [
              "arrowright",
              "arrowright"
            ]
          ]
        }
      ]
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    if (this.formView) {
      this.formView.destroy();
    }
    if (this.actionsView) {
      this.actionsView.destroy();
    }
  }
  /**
  * Creates views.
  */
  _createViews() {
    this.actionsView = this._createActionsView();
    this.formView = this._createFormView();
    this._enableUserBalloonInteractions();
  }
  /**
  * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
  */
  _createActionsView() {
    const editor = this.editor;
    const actionsView = new LinkActionsView(editor.locale, editor.config.get("link"));
    const linkCommand = editor.commands.get("link");
    const unlinkCommand = editor.commands.get("unlink");
    actionsView.bind("href").to(linkCommand, "value");
    actionsView.editButtonView.bind("isEnabled").to(linkCommand);
    actionsView.unlinkButtonView.bind("isEnabled").to(unlinkCommand);
    this.listenTo(actionsView, "edit", () => {
      this._addFormView();
    });
    this.listenTo(actionsView, "unlink", () => {
      editor.execute("unlink");
      this._hideUI();
    });
    actionsView.keystrokes.set("Esc", (data, cancel) => {
      this._hideUI();
      cancel();
    });
    actionsView.keystrokes.set(LINK_KEYSTROKE, (data, cancel) => {
      this._addFormView();
      cancel();
    });
    return actionsView;
  }
  /**
  * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
  */
  _createFormView() {
    const editor = this.editor;
    const linkCommand = editor.commands.get("link");
    const defaultProtocol = editor.config.get("link.defaultProtocol");
    const formView = new (CssTransitionDisablerMixin(LinkFormView))(editor.locale, linkCommand, getFormValidators2(editor));
    formView.urlInputView.fieldView.bind("value").to(linkCommand, "value");
    formView.urlInputView.bind("isEnabled").to(linkCommand, "isEnabled");
    formView.saveButtonView.bind("isEnabled").to(linkCommand, "isEnabled");
    this.listenTo(formView, "submit", () => {
      if (formView.isValid()) {
        const { value } = formView.urlInputView.fieldView.element;
        const parsedUrl = addLinkProtocolIfApplicable(value, defaultProtocol);
        editor.execute("link", parsedUrl, formView.getDecoratorSwitchesState());
        this._closeFormView();
      }
    });
    this.listenTo(formView.urlInputView, "change:errorText", () => {
      editor.ui.update();
    });
    this.listenTo(formView, "cancel", () => {
      this._closeFormView();
    });
    formView.keystrokes.set("Esc", (data, cancel) => {
      this._closeFormView();
      cancel();
    });
    return formView;
  }
  /**
  * Creates a toolbar Link button. Clicking this button will show
  * a {@link #_balloon} attached to the selection.
  */
  _createToolbarLinkButton() {
    const editor = this.editor;
    editor.ui.componentFactory.add("link", () => {
      const button = this._createButton(ButtonView);
      button.set({
        tooltip: true
      });
      return button;
    });
    editor.ui.componentFactory.add("menuBar:link", () => {
      const button = this._createButton(MenuBarMenuListItemButtonView);
      button.set({
        role: "menuitemcheckbox"
      });
      return button;
    });
  }
  /**
  * Creates a button for link command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get("link");
    const view = new ButtonClass(editor.locale);
    const t = locale.t;
    view.set({
      label: t("Link"),
      icon: linkIcon,
      keystroke: LINK_KEYSTROKE,
      isToggleable: true
    });
    view.bind("isEnabled").to(command, "isEnabled");
    view.bind("isOn").to(command, "value", (value) => !!value);
    this.listenTo(view, "execute", () => this._showUI(true));
    return view;
  }
  /**
  * Attaches actions that control whether the balloon panel containing the
  * {@link #formView} should be displayed.
  */
  _enableBalloonActivators() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this.listenTo(viewDocument, "click", () => {
      const parentLink = this._getSelectedLinkElement();
      if (parentLink) {
        this._showUI();
      }
    });
    editor.keystrokes.set(LINK_KEYSTROKE, (keyEvtData, cancel) => {
      cancel();
      if (editor.commands.get("link").isEnabled) {
        this._showUI(true);
      }
    });
  }
  /**
  * Attaches actions that control whether the balloon panel containing the
  * {@link #formView} is visible or not.
  */
  _enableUserBalloonInteractions() {
    this.editor.keystrokes.set("Tab", (data, cancel) => {
      if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
        this.actionsView.focus();
        cancel();
      }
    }, {
      // Use the high priority because the link UI navigation is more important
      // than other feature's actions, e.g. list indentation.
      // https://github.com/ckeditor/ckeditor5-link/issues/146
      priority: "high"
    });
    this.editor.keystrokes.set("Esc", (data, cancel) => {
      if (this._isUIVisible) {
        this._hideUI();
        cancel();
      }
    });
    clickOutsideHandler({
      emitter: this.formView,
      activator: () => this._isUIInPanel,
      contextElements: () => [
        this._balloon.view.element
      ],
      callback: () => this._hideUI()
    });
  }
  /**
  * Adds the {@link #actionsView} to the {@link #_balloon}.
  *
  * @internal
  */
  _addActionsView() {
    if (!this.actionsView) {
      this._createViews();
    }
    if (this._areActionsInPanel) {
      return;
    }
    this._balloon.add({
      view: this.actionsView,
      position: this._getBalloonPositionData()
    });
  }
  /**
  * Adds the {@link #formView} to the {@link #_balloon}.
  */
  _addFormView() {
    if (!this.formView) {
      this._createViews();
    }
    if (this._isFormInPanel) {
      return;
    }
    const editor = this.editor;
    const linkCommand = editor.commands.get("link");
    this.formView.disableCssTransitions();
    this.formView.resetFormStatus();
    this._balloon.add({
      view: this.formView,
      position: this._getBalloonPositionData()
    });
    this.formView.urlInputView.fieldView.value = linkCommand.value || "";
    if (this._balloon.visibleView === this.formView) {
      this.formView.urlInputView.fieldView.select();
    }
    this.formView.enableCssTransitions();
  }
  /**
  * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
  * decided upon the link command value (which has a value if the document selection is in the link).
  *
  * Additionally, if any {@link module:link/linkconfig~LinkConfig#decorators} are defined in the editor configuration, the state of
  * switch buttons responsible for manual decorator handling is restored.
  */
  _closeFormView() {
    const linkCommand = this.editor.commands.get("link");
    linkCommand.restoreManualDecoratorStates();
    if (linkCommand.value !== void 0) {
      this._removeFormView();
    } else {
      this._hideUI();
    }
  }
  /**
  * Removes the {@link #formView} from the {@link #_balloon}.
  */
  _removeFormView() {
    if (this._isFormInPanel) {
      this.formView.saveButtonView.focus();
      this.formView.urlInputView.fieldView.reset();
      this._balloon.remove(this.formView);
      this.editor.editing.view.focus();
      this._hideFakeVisualSelection();
    }
  }
  /**
  * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
  *
  * @internal
  */
  _showUI(forceVisible = false) {
    if (!this.formView) {
      this._createViews();
    }
    if (!this._getSelectedLinkElement()) {
      this._showFakeVisualSelection();
      this._addActionsView();
      if (forceVisible) {
        this._balloon.showStack("main");
      }
      this._addFormView();
    } else {
      if (this._areActionsVisible) {
        this._addFormView();
      } else {
        this._addActionsView();
      }
      if (forceVisible) {
        this._balloon.showStack("main");
      }
    }
    this._startUpdatingUI();
  }
  /**
  * Removes the {@link #formView} from the {@link #_balloon}.
  *
  * See {@link #_addFormView}, {@link #_addActionsView}.
  */
  _hideUI() {
    if (!this._isUIInPanel) {
      return;
    }
    const editor = this.editor;
    this.stopListening(editor.ui, "update");
    this.stopListening(this._balloon, "change:visibleView");
    editor.editing.view.focus();
    this._removeFormView();
    this._balloon.remove(this.actionsView);
    this._hideFakeVisualSelection();
  }
  /**
  * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
  * reposition itself when the editor UI should be refreshed.
  *
  * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
  */
  _startUpdatingUI() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    let prevSelectedLink = this._getSelectedLinkElement();
    let prevSelectionParent = getSelectionParent();
    const update = () => {
      const selectedLink = this._getSelectedLinkElement();
      const selectionParent = getSelectionParent();
      if (prevSelectedLink && !selectedLink || !prevSelectedLink && selectionParent !== prevSelectionParent) {
        this._hideUI();
      } else if (this._isUIVisible) {
        this._balloon.updatePosition(this._getBalloonPositionData());
      }
      prevSelectedLink = selectedLink;
      prevSelectionParent = selectionParent;
    };
    function getSelectionParent() {
      return viewDocument.selection.focus.getAncestors().reverse().find((node) => node.is("element"));
    }
    this.listenTo(editor.ui, "update", update);
    this.listenTo(this._balloon, "change:visibleView", update);
  }
  /**
  * Returns `true` when {@link #formView} is in the {@link #_balloon}.
  */
  get _isFormInPanel() {
    return !!this.formView && this._balloon.hasView(this.formView);
  }
  /**
  * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
  */
  get _areActionsInPanel() {
    return !!this.actionsView && this._balloon.hasView(this.actionsView);
  }
  /**
  * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
  * currently visible.
  */
  get _areActionsVisible() {
    return !!this.actionsView && this._balloon.visibleView === this.actionsView;
  }
  /**
  * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
  */
  get _isUIInPanel() {
    return this._isFormInPanel || this._areActionsInPanel;
  }
  /**
  * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
  * currently visible.
  */
  get _isUIVisible() {
    const visibleView = this._balloon.visibleView;
    return !!this.formView && visibleView == this.formView || this._areActionsVisible;
  }
  /**
  * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
  * to the target element or selection.
  *
  * If the selection is collapsed and inside a link element, the panel will be attached to the
  * entire link element. Otherwise, it will be attached to the selection.
  */
  _getBalloonPositionData() {
    const view = this.editor.editing.view;
    const model = this.editor.model;
    const viewDocument = view.document;
    let target;
    if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
      const markerViewElements = Array.from(this.editor.editing.mapper.markerNameToElements(VISUAL_SELECTION_MARKER_NAME));
      const newRange = view.createRange(view.createPositionBefore(markerViewElements[0]), view.createPositionAfter(markerViewElements[markerViewElements.length - 1]));
      target = view.domConverter.viewRangeToDom(newRange);
    } else {
      target = () => {
        const targetLink = this._getSelectedLinkElement();
        return targetLink ? (
          // When selection is inside link element, then attach panel to this element.
          view.domConverter.mapViewToDom(targetLink)
        ) : (
          // Otherwise attach panel to the selection.
          view.domConverter.viewRangeToDom(viewDocument.selection.getFirstRange())
        );
      };
    }
    return {
      target
    };
  }
  /**
  * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
  * the {@link module:engine/view/document~Document editing view's} selection or `null`
  * if there is none.
  *
  * **Note**: For a noncollapsed selection, the link element is returned when **fully**
  * selected and the **only** element within the selection boundaries, or when
  * a linked widget is selected.
  */
  _getSelectedLinkElement() {
    const view = this.editor.editing.view;
    const selection = view.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (selection.isCollapsed || selectedElement && isWidget(selectedElement)) {
      return findLinkElementAncestor(selection.getFirstPosition());
    } else {
      const range = selection.getFirstRange().getTrimmed();
      const startLink = findLinkElementAncestor(range.start);
      const endLink = findLinkElementAncestor(range.end);
      if (!startLink || startLink != endLink) {
        return null;
      }
      if (view.createRangeIn(startLink).getTrimmed().isEqual(range)) {
        return startLink;
      } else {
        return null;
      }
    }
  }
  /**
  * Displays a fake visual selection when the contextual balloon is displayed.
  *
  * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
  */
  _showFakeVisualSelection() {
    const model = this.editor.model;
    model.change((writer) => {
      const range = model.document.selection.getFirstRange();
      if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
        writer.updateMarker(VISUAL_SELECTION_MARKER_NAME, {
          range
        });
      } else {
        if (range.start.isAtEnd) {
          const startPosition = range.start.getLastMatchingPosition(({ item }) => !model.schema.isContent(item), {
            boundaries: range
          });
          writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
            usingOperation: false,
            affectsData: false,
            range: writer.createRange(startPosition, range.end)
          });
        } else {
          writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
            usingOperation: false,
            affectsData: false,
            range
          });
        }
      }
    });
  }
  /**
  * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
  */
  _hideFakeVisualSelection() {
    const model = this.editor.model;
    if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
      model.change((writer) => {
        writer.removeMarker(VISUAL_SELECTION_MARKER_NAME);
      });
    }
  }
};
function findLinkElementAncestor(position) {
  return position.getAncestors().find((ancestor) => isLinkElement(ancestor)) || null;
}
function getFormValidators2(editor) {
  const t = editor.t;
  const allowCreatingEmptyLinks = editor.config.get("link.allowCreatingEmptyLinks");
  return [
    (form) => {
      if (!allowCreatingEmptyLinks && !form.url.length) {
        return t("Link URL must not be empty.");
      }
    }
  ];
}
var MIN_LINK_LENGTH_WITH_SPACE_AT_END = 4;
var URL_REG_EXP = new RegExp(
  // Group 1: Line start or after a space.
  "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
  "i"
);
var URL_GROUP_IN_MATCH = 2;
var AutoLink = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Delete,
      LinkEditing
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "AutoLink";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    selection.on("change:range", () => {
      this.isEnabled = !selection.anchor.parent.is("element", "codeBlock");
    });
    this._enableTypingHandling();
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    this._enableEnterHandling();
    this._enableShiftEnterHandling();
    this._enablePasteLinking();
  }
  /**
  * For given position, returns a range that includes the whole link that contains the position.
  *
  * If position is not inside a link, returns `null`.
  */
  _expandLinkRange(model, position) {
    if (position.textNode && position.textNode.hasAttribute("linkHref")) {
      return findAttributeRange(position, "linkHref", position.textNode.getAttribute("linkHref"), model);
    } else {
      return null;
    }
  }
  /**
  * Extends the document selection to includes all links that intersects with given `selectedRange`.
  */
  _selectEntireLinks(writer, selectedRange) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const selStart = selection.getFirstPosition();
    const selEnd = selection.getLastPosition();
    let updatedSelection = selectedRange.getJoined(this._expandLinkRange(model, selStart) || selectedRange);
    if (updatedSelection) {
      updatedSelection = updatedSelection.getJoined(this._expandLinkRange(model, selEnd) || selectedRange);
    }
    if (updatedSelection && (updatedSelection.start.isBefore(selStart) || updatedSelection.end.isAfter(selEnd))) {
      writer.setSelection(updatedSelection);
    }
  }
  /**
  * Enables autolinking on pasting a URL when some content is selected.
  */
  _enablePasteLinking() {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    const linkCommand = editor.commands.get("link");
    clipboardPipeline.on("inputTransformation", (evt, data) => {
      if (!this.isEnabled || !linkCommand.isEnabled || selection.isCollapsed || data.method !== "paste") {
        return;
      }
      if (selection.rangeCount > 1) {
        return;
      }
      const selectedRange = selection.getFirstRange();
      const newLink = data.dataTransfer.getData("text/plain");
      if (!newLink) {
        return;
      }
      const matches = newLink.match(URL_REG_EXP);
      if (matches && matches[2] === newLink) {
        model.change((writer) => {
          this._selectEntireLinks(writer, selectedRange);
          linkCommand.execute(newLink);
        });
        evt.stop();
      }
    }, {
      priority: "high"
    });
  }
  /**
  * Enables autolinking on typing.
  */
  _enableTypingHandling() {
    const editor = this.editor;
    const watcher = new TextWatcher(editor.model, (text) => {
      if (!isSingleSpaceAtTheEnd(text)) {
        return;
      }
      const url = getUrlAtTextEnd(text.substr(0, text.length - 1));
      if (url) {
        return {
          url
        };
      }
    });
    watcher.on("matched:data", (evt, data) => {
      const { batch, range, url } = data;
      if (!batch.isTyping) {
        return;
      }
      const linkEnd = range.end.getShiftedBy(-1);
      const linkStart = linkEnd.getShiftedBy(-url.length);
      const linkRange = editor.model.createRange(linkStart, linkEnd);
      this._applyAutoLink(url, linkRange);
    });
    watcher.bind("isEnabled").to(this);
  }
  /**
  * Enables autolinking on the <kbd>Enter</kbd> key.
  */
  _enableEnterHandling() {
    const editor = this.editor;
    const model = editor.model;
    const enterCommand = editor.commands.get("enter");
    if (!enterCommand) {
      return;
    }
    enterCommand.on("execute", () => {
      const position = model.document.selection.getFirstPosition();
      if (!position.parent.previousSibling) {
        return;
      }
      const rangeToCheck = model.createRangeIn(position.parent.previousSibling);
      this._checkAndApplyAutoLinkOnRange(rangeToCheck);
    });
  }
  /**
  * Enables autolinking on the <kbd>Shift</kbd>+<kbd>Enter</kbd> keyboard shortcut.
  */
  _enableShiftEnterHandling() {
    const editor = this.editor;
    const model = editor.model;
    const shiftEnterCommand = editor.commands.get("shiftEnter");
    if (!shiftEnterCommand) {
      return;
    }
    shiftEnterCommand.on("execute", () => {
      const position = model.document.selection.getFirstPosition();
      const rangeToCheck = model.createRange(model.createPositionAt(position.parent, 0), position.getShiftedBy(-1));
      this._checkAndApplyAutoLinkOnRange(rangeToCheck);
    });
  }
  /**
  * Checks if the passed range contains a linkable text.
  */
  _checkAndApplyAutoLinkOnRange(rangeToCheck) {
    const model = this.editor.model;
    const { text, range } = getLastTextLine(rangeToCheck, model);
    const url = getUrlAtTextEnd(text);
    if (url) {
      const linkRange = model.createRange(range.end.getShiftedBy(-url.length), range.end);
      this._applyAutoLink(url, linkRange);
    }
  }
  /**
  * Applies a link on a given range if the link should be applied.
  *
  * @param url The URL to link.
  * @param range The text range to apply the link attribute to.
  */
  _applyAutoLink(url, range) {
    const model = this.editor.model;
    const defaultProtocol = this.editor.config.get("link.defaultProtocol");
    const fullUrl = addLinkProtocolIfApplicable(url, defaultProtocol);
    if (!this.isEnabled || !isLinkAllowedOnRange(range, model) || !linkHasProtocol(fullUrl) || linkIsAlreadySet(range)) {
      return;
    }
    this._persistAutoLink(fullUrl, range);
  }
  /**
  * Enqueues autolink changes in the model.
  *
  * @param url The URL to link.
  * @param range The text range to apply the link attribute to.
  */
  _persistAutoLink(url, range) {
    const model = this.editor.model;
    const deletePlugin = this.editor.plugins.get("Delete");
    model.enqueueChange((writer) => {
      writer.setAttribute("linkHref", url, range);
      model.enqueueChange(() => {
        deletePlugin.requestUndoOnBackspace();
      });
    });
  }
};
function isSingleSpaceAtTheEnd(text) {
  return text.length > MIN_LINK_LENGTH_WITH_SPACE_AT_END && text[text.length - 1] === " " && text[text.length - 2] !== " ";
}
function getUrlAtTextEnd(text) {
  const match = URL_REG_EXP.exec(text);
  return match ? match[URL_GROUP_IN_MATCH] : null;
}
function isLinkAllowedOnRange(range, model) {
  return model.schema.checkAttributeInSelection(model.createSelection(range), "linkHref");
}
function linkIsAlreadySet(range) {
  const item = range.start.nodeAfter;
  return !!item && item.hasAttribute("linkHref");
}
var Link = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      LinkEditing,
      LinkUI,
      AutoLink
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Link";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var LinkImageEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "ImageEditing",
      "ImageUtils",
      LinkEditing
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LinkImageEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const schema = editor.model.schema;
    if (editor.plugins.has("ImageBlockEditing")) {
      schema.extend("imageBlock", {
        allowAttributes: [
          "linkHref"
        ]
      });
    }
    editor.conversion.for("upcast").add(upcastLink(editor));
    editor.conversion.for("downcast").add(downcastImageLink(editor));
    this._enableAutomaticDecorators();
    this._enableManualDecorators();
  }
  /**
  * Processes {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators} definitions and
  * attaches proper converters that will work when linking an image.`
  */
  _enableAutomaticDecorators() {
    const editor = this.editor;
    const command = editor.commands.get("link");
    const automaticDecorators = command.automaticDecorators;
    if (automaticDecorators.length) {
      editor.conversion.for("downcast").add(automaticDecorators.getDispatcherForLinkedImage());
    }
  }
  /**
  * Processes transformed {@link module:link/utils/manualdecorator~ManualDecorator} instances and attaches proper converters
  * that will work when linking an image.
  */
  _enableManualDecorators() {
    const editor = this.editor;
    const command = editor.commands.get("link");
    for (const decorator of command.manualDecorators) {
      if (editor.plugins.has("ImageBlockEditing")) {
        editor.model.schema.extend("imageBlock", {
          allowAttributes: decorator.id
        });
      }
      if (editor.plugins.has("ImageInlineEditing")) {
        editor.model.schema.extend("imageInline", {
          allowAttributes: decorator.id
        });
      }
      editor.conversion.for("downcast").add(downcastImageLinkManualDecorator(decorator));
      editor.conversion.for("upcast").add(upcastImageLinkManualDecorator(editor, decorator));
    }
  }
};
function upcastLink(editor) {
  const isImageInlinePluginLoaded = editor.plugins.has("ImageInlineEditing");
  const imageUtils = editor.plugins.get("ImageUtils");
  return (dispatcher) => {
    dispatcher.on("element:a", (evt, data, conversionApi) => {
      const viewLink = data.viewItem;
      const imageInLink = imageUtils.findViewImgElement(viewLink);
      if (!imageInLink) {
        return;
      }
      const blockImageView = imageInLink.findAncestor((element) => imageUtils.isBlockImageView(element));
      if (isImageInlinePluginLoaded && !blockImageView) {
        return;
      }
      const consumableAttributes = {
        attributes: [
          "href"
        ]
      };
      if (!conversionApi.consumable.consume(viewLink, consumableAttributes)) {
        return;
      }
      const linkHref = viewLink.getAttribute("href");
      if (!linkHref) {
        return;
      }
      let modelElement = data.modelCursor.parent;
      if (!modelElement.is("element", "imageBlock")) {
        const conversionResult = conversionApi.convertItem(imageInLink, data.modelCursor);
        data.modelRange = conversionResult.modelRange;
        data.modelCursor = conversionResult.modelCursor;
        modelElement = data.modelCursor.nodeBefore;
      }
      if (modelElement && modelElement.is("element", "imageBlock")) {
        conversionApi.writer.setAttribute("linkHref", linkHref, modelElement);
      }
    }, {
      priority: "high"
    });
  };
}
function downcastImageLink(editor) {
  const imageUtils = editor.plugins.get("ImageUtils");
  return (dispatcher) => {
    dispatcher.on("attribute:linkHref:imageBlock", (evt, data, conversionApi) => {
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const viewFigure = conversionApi.mapper.toViewElement(data.item);
      const writer = conversionApi.writer;
      const linkInImage = Array.from(viewFigure.getChildren()).find((child) => child.is("element", "a"));
      const viewImage = imageUtils.findViewImgElement(viewFigure);
      const viewImgOrPicture = viewImage.parent.is("element", "picture") ? viewImage.parent : viewImage;
      if (linkInImage) {
        if (data.attributeNewValue) {
          writer.setAttribute("href", data.attributeNewValue, linkInImage);
        } else {
          writer.move(writer.createRangeOn(viewImgOrPicture), writer.createPositionAt(viewFigure, 0));
          writer.remove(linkInImage);
        }
      } else {
        const linkElement = writer.createContainerElement("a", {
          href: data.attributeNewValue
        });
        writer.insert(writer.createPositionAt(viewFigure, 0), linkElement);
        writer.move(writer.createRangeOn(viewImgOrPicture), writer.createPositionAt(linkElement, 0));
      }
    }, {
      priority: "high"
    });
  };
}
function downcastImageLinkManualDecorator(decorator) {
  return (dispatcher) => {
    dispatcher.on(`attribute:${decorator.id}:imageBlock`, (evt, data, conversionApi) => {
      const viewFigure = conversionApi.mapper.toViewElement(data.item);
      const linkInImage = Array.from(viewFigure.getChildren()).find((child) => child.is("element", "a"));
      if (!linkInImage) {
        return;
      }
      for (const [key, val] of toMap(decorator.attributes)) {
        conversionApi.writer.setAttribute(key, val, linkInImage);
      }
      if (decorator.classes) {
        conversionApi.writer.addClass(decorator.classes, linkInImage);
      }
      for (const key in decorator.styles) {
        conversionApi.writer.setStyle(key, decorator.styles[key], linkInImage);
      }
    });
  };
}
function upcastImageLinkManualDecorator(editor, decorator) {
  const isImageInlinePluginLoaded = editor.plugins.has("ImageInlineEditing");
  const imageUtils = editor.plugins.get("ImageUtils");
  return (dispatcher) => {
    dispatcher.on("element:a", (evt, data, conversionApi) => {
      const viewLink = data.viewItem;
      const imageInLink = imageUtils.findViewImgElement(viewLink);
      if (!imageInLink) {
        return;
      }
      const blockImageView = imageInLink.findAncestor((element) => imageUtils.isBlockImageView(element));
      if (isImageInlinePluginLoaded && !blockImageView) {
        return;
      }
      const matcher = new Matcher(decorator._createPattern());
      const result = matcher.match(viewLink);
      if (!result) {
        return;
      }
      if (!conversionApi.consumable.consume(viewLink, result.match)) {
        return;
      }
      const modelElement = data.modelCursor.nodeBefore || data.modelCursor.parent;
      conversionApi.writer.setAttribute(decorator.id, true, modelElement);
    }, {
      priority: "high"
    });
  };
}
var LinkImageUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      LinkEditing,
      LinkUI,
      "ImageBlockEditing"
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LinkImageUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this.listenTo(viewDocument, "click", (evt, data) => {
      if (this._isSelectedLinkedImage(editor.model.document.selection)) {
        data.preventDefault();
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this._createToolbarLinkImageButton();
  }
  /**
  * Creates a `LinkImageUI` button view.
  *
  * Clicking this button shows a {@link module:link/linkui~LinkUI#_balloon} attached to the selection.
  * When an image is already linked, the view shows {@link module:link/linkui~LinkUI#actionsView} or
  * {@link module:link/linkui~LinkUI#formView} if it is not.
  */
  _createToolbarLinkImageButton() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("linkImage", (locale) => {
      const button = new ButtonView(locale);
      const plugin = editor.plugins.get("LinkUI");
      const linkCommand = editor.commands.get("link");
      button.set({
        isEnabled: true,
        label: t("Link image"),
        icon: linkIcon,
        keystroke: LINK_KEYSTROKE,
        tooltip: true,
        isToggleable: true
      });
      button.bind("isEnabled").to(linkCommand, "isEnabled");
      button.bind("isOn").to(linkCommand, "value", (value) => !!value);
      this.listenTo(button, "execute", () => {
        if (this._isSelectedLinkedImage(editor.model.document.selection)) {
          plugin._addActionsView();
        } else {
          plugin._showUI(true);
        }
      });
      return button;
    });
  }
  /**
  * Returns true if a linked image (either block or inline) is the only selected element
  * in the model document.
  */
  _isSelectedLinkedImage(selection) {
    const selectedModelElement = selection.getSelectedElement();
    const imageUtils = this.editor.plugins.get("ImageUtils");
    return imageUtils.isImage(selectedModelElement) && selectedModelElement.hasAttribute("linkHref");
  }
};
var LinkImage = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      LinkImageEditing,
      LinkImageUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LinkImage";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-list/dist/index.js
var ListWalker = class {
  /**
  * Creates a document list iterator.
  *
  * @param startElement The start list item block element.
  * @param options.direction The iterating direction.
  * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
  * @param options.sameAttributes Additional attributes that must be the same for each block.
  * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
  * in the result.
  * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
  * in the result.
  * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
  * in the result.
  */
  constructor(startElement, options2) {
    /**
    * The start list item block element.
    */
    __publicField(this, "_startElement");
    /**
    * The reference indent. Initialized by the indent of the start block.
    */
    __publicField(this, "_referenceIndent");
    /**
    * The iterating direction.
    */
    __publicField(this, "_isForward");
    /**
    * Whether start block should be included in the result (if it's matching other criteria).
    */
    __publicField(this, "_includeSelf");
    /**
    * Additional attributes that must be the same for each block.
    */
    __publicField(this, "_sameAttributes");
    /**
    * Whether blocks with the same indent level as the start block should be included in the result.
    */
    __publicField(this, "_sameIndent");
    /**
    * Whether blocks with a lower indent level than the start block should be included in the result.
    */
    __publicField(this, "_lowerIndent");
    /**
    * Whether blocks with a higher indent level than the start block should be included in the result.
    */
    __publicField(this, "_higherIndent");
    this._startElement = startElement;
    this._referenceIndent = startElement.getAttribute("listIndent");
    this._isForward = options2.direction == "forward";
    this._includeSelf = !!options2.includeSelf;
    this._sameAttributes = toArray(options2.sameAttributes || []);
    this._sameIndent = !!options2.sameIndent;
    this._lowerIndent = !!options2.lowerIndent;
    this._higherIndent = !!options2.higherIndent;
  }
  /**
  * Performs only first step of iteration and returns the result.
  *
  * @param startElement The start list item block element.
  * @param options.direction The iterating direction.
  * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
  * @param options.sameAttributes Additional attributes that must be the same for each block.
  * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
  * in the result.
  * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
  * in the result.
  * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
  * in the result.
  */
  static first(startElement, options2) {
    const walker = new this(startElement, options2);
    const iterator = walker[Symbol.iterator]();
    return first(iterator);
  }
  /**
  * Iterable interface.
  */
  *[Symbol.iterator]() {
    const nestedItems = [];
    for (const { node } of iterateSiblingListBlocks(this._getStartNode(), this._isForward ? "forward" : "backward")) {
      const indent = node.getAttribute("listIndent");
      if (indent < this._referenceIndent) {
        if (!this._lowerIndent) {
          break;
        }
        this._referenceIndent = indent;
      } else if (indent > this._referenceIndent) {
        if (!this._higherIndent) {
          continue;
        }
        if (!this._isForward) {
          nestedItems.push(node);
          continue;
        }
      } else {
        if (!this._sameIndent) {
          if (this._higherIndent) {
            if (nestedItems.length) {
              yield* nestedItems;
              nestedItems.length = 0;
            }
            break;
          }
          continue;
        }
        if (this._sameAttributes.some((attr) => node.getAttribute(attr) !== this._startElement.getAttribute(attr))) {
          break;
        }
      }
      if (nestedItems.length) {
        yield* nestedItems;
        nestedItems.length = 0;
      }
      yield node;
    }
  }
  /**
  * Returns the model element to start iterating.
  */
  _getStartNode() {
    if (this._includeSelf) {
      return this._startElement;
    }
    return this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling;
  }
};
function* iterateSiblingListBlocks(node, direction = "forward") {
  const isForward = direction == "forward";
  const previousNodesByIndent = [];
  let previous = null;
  while (isListItemBlock(node)) {
    let previousNodeInList = null;
    if (previous) {
      const nodeIndent = node.getAttribute("listIndent");
      const previousNodeIndent = previous.getAttribute("listIndent");
      if (nodeIndent > previousNodeIndent) {
        previousNodesByIndent[previousNodeIndent] = previous;
      } else if (nodeIndent < previousNodeIndent) {
        previousNodeInList = previousNodesByIndent[nodeIndent];
        previousNodesByIndent.length = nodeIndent;
      } else {
        previousNodeInList = previous;
      }
    }
    yield {
      node,
      previous,
      previousNodeInList
    };
    previous = node;
    node = isForward ? node.nextSibling : node.previousSibling;
  }
}
var ListBlocksIterable = class {
  /**
  * @param listHead The head element of a list.
  */
  constructor(listHead) {
    __publicField(this, "_listHead");
    this._listHead = listHead;
  }
  /**
  * List blocks iterator.
  *
  * Iterates over all blocks of a list.
  */
  [Symbol.iterator]() {
    return iterateSiblingListBlocks(this._listHead, "forward");
  }
};
var ListItemUid = class {
  /**
  * Returns the next ID.
  *
  * @internal
  */
  /* istanbul ignore next: static function definition -- @preserve */
  static next() {
    return uid();
  }
};
function isListItemBlock(node) {
  return !!node && node.is("element") && node.hasAttribute("listItemId");
}
function getAllListItemBlocks(listItem, options2 = {}) {
  return [
    ...getListItemBlocks(listItem, {
      ...options2,
      direction: "backward"
    }),
    ...getListItemBlocks(listItem, {
      ...options2,
      direction: "forward"
    })
  ];
}
function getListItemBlocks(listItem, options2 = {}) {
  const isForward = options2.direction == "forward";
  const items = Array.from(new ListWalker(listItem, {
    ...options2,
    includeSelf: isForward,
    sameIndent: true,
    sameAttributes: "listItemId"
  }));
  return isForward ? items : items.reverse();
}
function getNestedListBlocks(listItem) {
  return Array.from(new ListWalker(listItem, {
    direction: "forward",
    higherIndent: true
  }));
}
function getListItems(listItem, options2) {
  const backwardBlocks = new ListWalker(listItem, {
    sameIndent: true,
    sameAttributes: "listType",
    ...options2
  });
  const forwardBlocks = new ListWalker(listItem, {
    sameIndent: true,
    sameAttributes: "listType",
    includeSelf: true,
    direction: "forward",
    ...options2
  });
  return [
    ...Array.from(backwardBlocks).reverse(),
    ...forwardBlocks
  ];
}
function isFirstBlockOfListItem(listBlock) {
  const previousSibling = ListWalker.first(listBlock, {
    sameIndent: true,
    sameAttributes: "listItemId"
  });
  if (!previousSibling) {
    return true;
  }
  return false;
}
function isLastBlockOfListItem(listBlock) {
  const nextSibling = ListWalker.first(listBlock, {
    direction: "forward",
    sameIndent: true,
    sameAttributes: "listItemId"
  });
  if (!nextSibling) {
    return true;
  }
  return false;
}
function expandListBlocksToCompleteItems(blocks, options2 = {}) {
  blocks = toArray(blocks);
  const higherIndent = options2.withNested !== false;
  const allBlocks = /* @__PURE__ */ new Set();
  for (const block2 of blocks) {
    for (const itemBlock of getAllListItemBlocks(block2, {
      higherIndent
    })) {
      allBlocks.add(itemBlock);
    }
  }
  return sortBlocks(allBlocks);
}
function expandListBlocksToCompleteList(blocks) {
  blocks = toArray(blocks);
  const allBlocks = /* @__PURE__ */ new Set();
  for (const block2 of blocks) {
    for (const itemBlock of getListItems(block2)) {
      allBlocks.add(itemBlock);
    }
  }
  return sortBlocks(allBlocks);
}
function splitListItemBefore(listBlock, writer) {
  const blocks = getListItemBlocks(listBlock, {
    direction: "forward"
  });
  const id = ListItemUid.next();
  for (const block2 of blocks) {
    writer.setAttribute("listItemId", id, block2);
  }
  return blocks;
}
function mergeListItemBefore(listBlock, parentBlock, writer) {
  const attributes = {};
  for (const [key, value] of parentBlock.getAttributes()) {
    if (key.startsWith("list")) {
      attributes[key] = value;
    }
  }
  const blocks = getListItemBlocks(listBlock, {
    direction: "forward"
  });
  for (const block2 of blocks) {
    writer.setAttributes(attributes, block2);
  }
  return blocks;
}
function indentBlocks(blocks, writer, { expand, indentBy = 1 } = {}) {
  blocks = toArray(blocks);
  const allBlocks = expand ? expandListBlocksToCompleteItems(blocks) : blocks;
  for (const block2 of allBlocks) {
    const blockIndent = block2.getAttribute("listIndent") + indentBy;
    if (blockIndent < 0) {
      removeListAttributes(block2, writer);
    } else {
      writer.setAttribute("listIndent", blockIndent, block2);
    }
  }
  return allBlocks;
}
function outdentBlocksWithMerge(blocks, writer) {
  blocks = toArray(blocks);
  const allBlocks = expandListBlocksToCompleteItems(blocks);
  const visited = /* @__PURE__ */ new Set();
  const referenceIndent = Math.min(...allBlocks.map((block2) => block2.getAttribute("listIndent")));
  const parentBlocks = /* @__PURE__ */ new Map();
  for (const block2 of allBlocks) {
    parentBlocks.set(block2, ListWalker.first(block2, {
      lowerIndent: true
    }));
  }
  for (const block2 of allBlocks) {
    if (visited.has(block2)) {
      continue;
    }
    visited.add(block2);
    const blockIndent = block2.getAttribute("listIndent") - 1;
    if (blockIndent < 0) {
      removeListAttributes(block2, writer);
      continue;
    }
    if (block2.getAttribute("listIndent") == referenceIndent) {
      const mergedBlocks = mergeListItemIfNotLast(block2, parentBlocks.get(block2), writer);
      for (const mergedBlock of mergedBlocks) {
        visited.add(mergedBlock);
      }
      if (mergedBlocks.length) {
        continue;
      }
    }
    writer.setAttribute("listIndent", blockIndent, block2);
  }
  return sortBlocks(visited);
}
function removeListAttributes(blocks, writer) {
  blocks = toArray(blocks);
  for (const block2 of blocks) {
    if (block2.is("element", "listItem")) {
      writer.rename(block2, "paragraph");
    }
  }
  for (const block2 of blocks) {
    for (const attributeKey2 of block2.getAttributeKeys()) {
      if (attributeKey2.startsWith("list")) {
        writer.removeAttribute(attributeKey2, block2);
      }
    }
  }
  return blocks;
}
function isSingleListItem(blocks) {
  if (!blocks.length) {
    return false;
  }
  const firstItemId = blocks[0].getAttribute("listItemId");
  if (!firstItemId) {
    return false;
  }
  return !blocks.some((item) => item.getAttribute("listItemId") != firstItemId);
}
function outdentFollowingItems(lastBlock, writer) {
  const changedBlocks = [];
  let currentIndent = Number.POSITIVE_INFINITY;
  for (const { node } of iterateSiblingListBlocks(lastBlock.nextSibling, "forward")) {
    const indent = node.getAttribute("listIndent");
    if (indent == 0) {
      break;
    }
    if (indent < currentIndent) {
      currentIndent = indent;
    }
    const newIndent = indent - currentIndent;
    writer.setAttribute("listIndent", newIndent, node);
    changedBlocks.push(node);
  }
  return changedBlocks;
}
function sortBlocks(blocks) {
  return Array.from(blocks).filter((block2) => block2.root.rootName !== "$graveyard").sort((a, b) => a.index - b.index);
}
function getSelectedBlockObject(model) {
  const selectedElement = model.document.selection.getSelectedElement();
  if (!selectedElement) {
    return null;
  }
  if (model.schema.isObject(selectedElement) && model.schema.isBlock(selectedElement)) {
    return selectedElement;
  }
  return null;
}
function canBecomeSimpleListItem(block2, schema) {
  return schema.checkChild(block2.parent, "listItem") && schema.checkChild(block2, "$text") && !schema.isObject(block2);
}
function isNumberedListType(listType) {
  return listType == "numbered" || listType == "customNumbered";
}
function mergeListItemIfNotLast(block2, parentBlock, writer) {
  const parentItemBlocks = getListItemBlocks(parentBlock, {
    direction: "forward"
  });
  if (parentItemBlocks.pop().index > block2.index) {
    return mergeListItemBefore(block2, parentBlock, writer);
  }
  return [];
}
var ListIndentCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param indentDirection The direction of indent. If it is equal to `backward`, the command
  * will outdent a list item.
  */
  constructor(editor, indentDirection) {
    super(editor);
    /**
    * Determines by how much the command will change the list item's indent attribute.
    */
    __publicField(this, "_direction");
    this._direction = indentDirection;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
  *
  * @fires execute
  * @fires afterExecute
  */
  execute() {
    const model = this.editor.model;
    const blocks = getSelectedListBlocks(model.document.selection);
    model.change((writer) => {
      const changedBlocks = [];
      if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
        if (this._direction == "forward") {
          changedBlocks.push(...indentBlocks(blocks, writer));
        }
        changedBlocks.push(...splitListItemBefore(blocks[0], writer));
      } else {
        if (this._direction == "forward") {
          changedBlocks.push(...indentBlocks(blocks, writer, {
            expand: true
          }));
        } else {
          changedBlocks.push(...outdentBlocksWithMerge(blocks, writer));
        }
      }
      for (const block2 of changedBlocks) {
        if (!block2.hasAttribute("listType")) {
          continue;
        }
        const previousItemBlock = ListWalker.first(block2, {
          sameIndent: true
        });
        if (previousItemBlock) {
          writer.setAttribute("listType", previousItemBlock.getAttribute("listType"), block2);
        }
      }
      this._fireAfterExecute(changedBlocks);
    });
  }
  /**
  * Fires the `afterExecute` event.
  *
  * @param changedBlocks The changed list elements.
  */
  _fireAfterExecute(changedBlocks) {
    this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    let blocks = getSelectedListBlocks(this.editor.model.document.selection);
    let firstBlock = blocks[0];
    if (!firstBlock) {
      return false;
    }
    if (this._direction == "backward") {
      return true;
    }
    if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
      return true;
    }
    blocks = expandListBlocksToCompleteItems(blocks);
    firstBlock = blocks[0];
    const siblingItem = ListWalker.first(firstBlock, {
      sameIndent: true
    });
    if (!siblingItem) {
      return false;
    }
    if (siblingItem.getAttribute("listType") == firstBlock.getAttribute("listType")) {
      return true;
    }
    return false;
  }
};
function getSelectedListBlocks(selection) {
  const blocks = Array.from(selection.getSelectedBlocks());
  const firstNonListBlockIndex = blocks.findIndex((block2) => !isListItemBlock(block2));
  if (firstNonListBlockIndex != -1) {
    blocks.length = firstNonListBlockIndex;
  }
  return blocks;
}
var ListCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param type List type that will be handled by this command.
  */
  constructor(editor, type, options2 = {}) {
    super(editor);
    /**
    * The type of the list created by the command.
    */
    __publicField(this, "type");
    /**
    * List Walker options that change the range of the list items to be changed when the selection is collapsed within a list item.
    *
    * In a multi-level list, when the selection is collapsed within a list item, instead of changing only the list items of the same list
    * type and current indent level, the entire list structure is changed (all list items at all indent levels of any list type).
    */
    __publicField(this, "_listWalkerOptions");
    this.type = type;
    this._listWalkerOptions = options2.multiLevel ? {
      higherIndent: true,
      lowerIndent: true,
      sameAttributes: []
    } : void 0;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the list command.
  *
  * @fires execute
  * @fires afterExecute
  * @param options Command options.
  * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
  * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements
  * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
  * @param options.additionalAttributes Additional attributes that are set for list items when the command is executed.
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    const selectedBlockObject = getSelectedBlockObject(model);
    const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => model.schema.checkAttribute(block2, "listType") || canBecomeSimpleListItem(block2, model.schema));
    const turnOff = options2.forceValue !== void 0 ? !options2.forceValue : this.value;
    model.change((writer) => {
      if (turnOff) {
        const lastBlock = blocks[blocks.length - 1];
        const itemBlocks = getListItemBlocks(lastBlock, {
          direction: "forward"
        });
        const changedBlocks = [];
        if (itemBlocks.length > 1) {
          changedBlocks.push(...splitListItemBefore(itemBlocks[1], writer));
        }
        changedBlocks.push(...removeListAttributes(blocks, writer));
        changedBlocks.push(...outdentFollowingItems(lastBlock, writer));
        this._fireAfterExecute(changedBlocks);
      } else if ((selectedBlockObject || document2.selection.isCollapsed) && isListItemBlock(blocks[0])) {
        const changedBlocks = getListItems(selectedBlockObject || blocks[0], this._listWalkerOptions);
        for (const block2 of changedBlocks) {
          writer.setAttributes({
            ...options2.additionalAttributes,
            listType: this.type
          }, block2);
        }
        this._fireAfterExecute(changedBlocks);
      } else {
        const changedBlocks = [];
        for (const block2 of blocks) {
          if (!block2.hasAttribute("listType")) {
            if (!block2.is("element", "listItem") && canBecomeSimpleListItem(block2, model.schema)) {
              writer.rename(block2, "listItem");
            }
            writer.setAttributes({
              ...options2.additionalAttributes,
              listIndent: 0,
              listItemId: ListItemUid.next(),
              listType: this.type
            }, block2);
            changedBlocks.push(block2);
          } else {
            for (const node of expandListBlocksToCompleteItems(block2, {
              withNested: false
            })) {
              if (node.getAttribute("listType") != this.type) {
                writer.setAttributes({
                  ...options2.additionalAttributes,
                  listType: this.type
                }, node);
                changedBlocks.push(node);
              }
            }
          }
        }
        this._fireAfterExecute(changedBlocks);
      }
    });
  }
  /**
  * Fires the `afterExecute` event.
  *
  * @param changedBlocks The changed list elements.
  */
  _fireAfterExecute(changedBlocks) {
    this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
  }
  /**
  * Checks the command's {@link #value}.
  *
  * @returns The current value.
  */
  _getValue() {
    const selection = this.editor.model.document.selection;
    const blocks = Array.from(selection.getSelectedBlocks());
    if (!blocks.length) {
      return false;
    }
    for (const block2 of blocks) {
      if (block2.getAttribute("listType") != this.type) {
        return false;
      }
    }
    return true;
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    const blocks = Array.from(selection.getSelectedBlocks());
    if (!blocks.length) {
      return false;
    }
    if (this.value) {
      return true;
    }
    for (const block2 of blocks) {
      if (schema.checkAttribute(block2, "listType") || canBecomeSimpleListItem(block2, schema)) {
        return true;
      }
    }
    return false;
  }
};
var ListMergeCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param direction Whether list item should be merged before or after the selected block.
  */
  constructor(editor, direction) {
    super(editor);
    /**
    * Whether list item should be merged before or after the selected block.
    */
    __publicField(this, "_direction");
    this._direction = direction;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Merges list blocks together (depending on the {@link #constructor}'s `direction` parameter).
  *
  * @fires execute
  * @fires afterExecute
  * @param options Command options.
  * @param options.shouldMergeOnBlocksContentLevel When set `true`, merging will be performed together
  * with {@link module:engine/model/model~Model#deleteContent} to get rid of the inline content in the selection or take advantage
  * of the heuristics in `deleteContent()` that helps convert lists into paragraphs in certain cases.
  */
  execute({ shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel2 = false } = {}) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const changedBlocks = [];
    model.change((writer) => {
      const { firstElement, lastElement } = this._getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel2);
      const firstIndent = firstElement.getAttribute("listIndent") || 0;
      const lastIndent = lastElement.getAttribute("listIndent");
      const lastElementId = lastElement.getAttribute("listItemId");
      if (firstIndent != lastIndent) {
        const nestedLastElementBlocks = getNestedListBlocks(lastElement);
        changedBlocks.push(...indentBlocks([
          lastElement,
          ...nestedLastElementBlocks
        ], writer, {
          indentBy: firstIndent - lastIndent,
          // If outdenting, the entire sub-tree that follows must be included.
          expand: firstIndent < lastIndent
        }));
      }
      if (shouldMergeOnBlocksContentLevel2) {
        let sel = selection;
        if (selection.isCollapsed) {
          sel = writer.createSelection(writer.createRange(writer.createPositionAt(firstElement, "end"), writer.createPositionAt(lastElement, 0)));
        }
        model.deleteContent(sel, {
          doNotResetEntireContent: selection.isCollapsed
        });
        const lastElementAfterDelete = sel.getLastPosition().parent;
        const nextSibling = lastElementAfterDelete.nextSibling;
        changedBlocks.push(lastElementAfterDelete);
        if (nextSibling && nextSibling !== lastElement && nextSibling.getAttribute("listItemId") == lastElementId) {
          changedBlocks.push(...mergeListItemBefore(nextSibling, lastElementAfterDelete, writer));
        }
      } else {
        changedBlocks.push(...mergeListItemBefore(lastElement, firstElement, writer));
      }
      this._fireAfterExecute(changedBlocks);
    });
  }
  /**
  * Fires the `afterExecute` event.
  *
  * @param changedBlocks The changed list elements.
  */
  _fireAfterExecute(changedBlocks) {
    this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedBlockObject = getSelectedBlockObject(model);
    if (selection.isCollapsed || selectedBlockObject) {
      const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
      if (!isListItemBlock(positionParent)) {
        return false;
      }
      const siblingNode = this._direction == "backward" ? positionParent.previousSibling : positionParent.nextSibling;
      if (!siblingNode) {
        return false;
      }
      if (isSingleListItem([
        positionParent,
        siblingNode
      ])) {
        return false;
      }
    } else {
      const lastPosition = selection.getLastPosition();
      const firstPosition = selection.getFirstPosition();
      if (lastPosition.parent === firstPosition.parent) {
        return false;
      }
      if (!isListItemBlock(lastPosition.parent)) {
        return false;
      }
    }
    return true;
  }
  /**
  * Returns the boundary elements the merge should be executed for. These are not necessarily selection's first
  * and last position parents but sometimes sibling or even further blocks depending on the context.
  *
  * @param selection The selection the merge is executed for.
  * @param shouldMergeOnBlocksContentLevel When `true`, merge is performed together with
  * {@link module:engine/model/model~Model#deleteContent} to remove the inline content within the selection.
  */
  _getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel2) {
    const model = this.editor.model;
    const selectedBlockObject = getSelectedBlockObject(model);
    let firstElement, lastElement;
    if (selection.isCollapsed || selectedBlockObject) {
      const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
      const isFirstBlock = isFirstBlockOfListItem(positionParent);
      if (this._direction == "backward") {
        lastElement = positionParent;
        if (isFirstBlock && !shouldMergeOnBlocksContentLevel2) {
          firstElement = ListWalker.first(positionParent, {
            sameIndent: true,
            lowerIndent: true
          });
        } else {
          firstElement = positionParent.previousSibling;
        }
      } else {
        firstElement = positionParent;
        lastElement = positionParent.nextSibling;
      }
    } else {
      firstElement = selection.getFirstPosition().parent;
      lastElement = selection.getLastPosition().parent;
    }
    return {
      firstElement,
      lastElement
    };
  }
};
var ListSplitCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param direction Whether list item should be split before or after the selected block.
  */
  constructor(editor, direction) {
    super(editor);
    /**
    * Whether list item should be split before or after the selected block.
    */
    __publicField(this, "_direction");
    this._direction = direction;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Splits the list item at the selection.
  *
  * @fires execute
  * @fires afterExecute
  */
  execute() {
    const editor = this.editor;
    editor.model.change((writer) => {
      const changedBlocks = splitListItemBefore(this._getStartBlock(), writer);
      this._fireAfterExecute(changedBlocks);
    });
  }
  /**
  * Fires the `afterExecute` event.
  *
  * @param changedBlocks The changed list elements.
  */
  _fireAfterExecute(changedBlocks) {
    this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    const selection = this.editor.model.document.selection;
    const block2 = this._getStartBlock();
    return selection.isCollapsed && isListItemBlock(block2) && !isFirstBlockOfListItem(block2);
  }
  /**
  * Returns the model element that is the main focus of the command (according to the current selection and command direction).
  */
  _getStartBlock() {
    const doc = this.editor.model.document;
    const positionParent = doc.selection.getFirstPosition().parent;
    return this._direction == "before" ? positionParent : positionParent.nextSibling;
  }
};
var ListUtils = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Expands the given list of selected blocks to include all the items of the lists they're in.
  *
  * @param blocks The list of selected blocks.
  */
  expandListBlocksToCompleteList(blocks) {
    return expandListBlocksToCompleteList(blocks);
  }
  /**
  * Check if the given block is the first in the list item.
  *
  * @param listBlock The list block element.
  */
  isFirstBlockOfListItem(listBlock) {
    return isFirstBlockOfListItem(listBlock);
  }
  /**
  * Returns true if the given model node is a list item block.
  *
  * @param node A model node.
  */
  isListItemBlock(node) {
    return isListItemBlock(node);
  }
  /**
  * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.
  *
  * @param blocks The list of selected blocks.
  * @param options.withNested Whether should include nested list items.
  */
  expandListBlocksToCompleteItems(blocks, options2 = {}) {
    return expandListBlocksToCompleteItems(blocks, options2);
  }
  /**
  * Returns true if listType is of type `numbered` or `customNumbered`.
  */
  isNumberedListType(listType) {
    return isNumberedListType(listType);
  }
};
function isListView(viewElement) {
  return viewElement.is("element", "ol") || viewElement.is("element", "ul");
}
function isListItemView(viewElement) {
  return viewElement.is("element", "li");
}
function getIndent$1(listItem) {
  let indent = 0;
  let parent = listItem.parent;
  while (parent) {
    if (isListItemView(parent)) {
      indent++;
    } else {
      const previousSibling = parent.previousSibling;
      if (previousSibling && isListItemView(previousSibling)) {
        indent++;
      }
    }
    parent = parent.parent;
  }
  return indent;
}
function createListElement(writer, indent, type, id = getViewElementIdForListType(type, indent)) {
  return writer.createAttributeElement(getViewElementNameForListType(type), null, {
    priority: 2 * indent / 100 - 100,
    id
  });
}
function createListItemElement(writer, indent, id) {
  return writer.createAttributeElement("li", null, {
    priority: (2 * indent + 1) / 100 - 100,
    id
  });
}
function getViewElementNameForListType(type) {
  return type == "numbered" || type == "customNumbered" ? "ol" : "ul";
}
function getViewElementIdForListType(type, indent) {
  return `list-${type}-${indent}`;
}
function findAndAddListHeadToMap(position, itemToListHead) {
  const previousNode = position.nodeBefore;
  if (!isListItemBlock(previousNode)) {
    const item = position.nodeAfter;
    if (isListItemBlock(item)) {
      itemToListHead.set(item, item);
    }
  } else {
    let listHead = previousNode;
    for (const { node } of iterateSiblingListBlocks(listHead, "backward")) {
      listHead = node;
      if (itemToListHead.has(listHead)) {
        return;
      }
    }
    itemToListHead.set(previousNode, listHead);
  }
}
function fixListIndents(listNodes, writer) {
  let maxIndent = 0;
  let prevIndent = -1;
  let fixBy = null;
  let applied = false;
  for (const { node } of listNodes) {
    const itemIndent = node.getAttribute("listIndent");
    if (itemIndent > maxIndent) {
      let newIndent;
      if (fixBy === null) {
        fixBy = itemIndent - maxIndent;
        newIndent = maxIndent;
      } else {
        if (fixBy > itemIndent) {
          fixBy = itemIndent;
        }
        newIndent = itemIndent - fixBy;
      }
      if (newIndent > prevIndent + 1) {
        newIndent = prevIndent + 1;
      }
      writer.setAttribute("listIndent", newIndent, node);
      applied = true;
      prevIndent = newIndent;
    } else {
      fixBy = null;
      maxIndent = itemIndent + 1;
      prevIndent = itemIndent;
    }
  }
  return applied;
}
function fixListItemIds(listNodes, seenIds, writer) {
  const visited = /* @__PURE__ */ new Set();
  let applied = false;
  for (const { node } of listNodes) {
    if (visited.has(node)) {
      continue;
    }
    let listType = node.getAttribute("listType");
    let listItemId = node.getAttribute("listItemId");
    if (seenIds.has(listItemId)) {
      listItemId = ListItemUid.next();
    }
    seenIds.add(listItemId);
    if (node.is("element", "listItem")) {
      if (node.getAttribute("listItemId") != listItemId) {
        writer.setAttribute("listItemId", listItemId, node);
        applied = true;
      }
      continue;
    }
    for (const block2 of getListItemBlocks(node, {
      direction: "forward"
    })) {
      visited.add(block2);
      if (block2.getAttribute("listType") != listType) {
        listItemId = ListItemUid.next();
        listType = block2.getAttribute("listType");
      }
      if (block2.getAttribute("listItemId") != listItemId) {
        writer.setAttribute("listItemId", listItemId, block2);
        applied = true;
      }
    }
  }
  return applied;
}
function listItemUpcastConverter() {
  return (evt, data, conversionApi) => {
    const { writer, schema } = conversionApi;
    if (!data.modelRange) {
      return;
    }
    const items = Array.from(data.modelRange.getItems({
      shallow: true
    })).filter((item) => schema.checkAttribute(item, "listItemId"));
    if (!items.length) {
      return;
    }
    const listItemId = ListItemUid.next();
    const listIndent = getIndent$1(data.viewItem);
    let listType = data.viewItem.parent && data.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted";
    const firstItemListType = items[0].getAttribute("listType");
    if (firstItemListType) {
      listType = firstItemListType;
    }
    const attributes = {
      listItemId,
      listIndent,
      listType
    };
    for (const item of items) {
      if (!item.hasAttribute("listItemId")) {
        writer.setAttributes(attributes, item);
      }
    }
    if (items.length > 1) {
      if (items[1].getAttribute("listItemId") != attributes.listItemId) {
        conversionApi.keepEmptyElement(items[0]);
      }
    }
  };
}
function reconvertItemsOnDataChange(model, editing, attributeNames, listEditing) {
  return () => {
    const changes = model.document.differ.getChanges();
    const itemsToRefresh = [];
    const itemToListHead = /* @__PURE__ */ new Map();
    const changedItems = /* @__PURE__ */ new Set();
    for (const entry of changes) {
      if (entry.type == "insert" && entry.name != "$text") {
        findAndAddListHeadToMap(entry.position, itemToListHead);
        if (!entry.attributes.has("listItemId")) {
          findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);
        } else {
          changedItems.add(entry.position.nodeAfter);
        }
      } else if (entry.type == "remove" && entry.attributes.has("listItemId")) {
        findAndAddListHeadToMap(entry.position, itemToListHead);
      } else if (entry.type == "attribute") {
        const item = entry.range.start.nodeAfter;
        if (attributeNames.includes(entry.attributeKey)) {
          findAndAddListHeadToMap(entry.range.start, itemToListHead);
          if (entry.attributeNewValue === null) {
            findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);
            if (doesItemBlockRequiresRefresh(item)) {
              itemsToRefresh.push(item);
            }
          } else {
            changedItems.add(item);
          }
        } else if (isListItemBlock(item)) {
          if (doesItemBlockRequiresRefresh(item)) {
            itemsToRefresh.push(item);
          }
        }
      }
    }
    for (const listHead of itemToListHead.values()) {
      itemsToRefresh.push(...collectListItemsToRefresh(listHead, changedItems));
    }
    for (const item of new Set(itemsToRefresh)) {
      editing.reconvertItem(item);
    }
  };
  function collectListItemsToRefresh(listHead, changedItems) {
    const itemsToRefresh = [];
    const visited = /* @__PURE__ */ new Set();
    const stack = [];
    for (const { node, previous } of iterateSiblingListBlocks(listHead, "forward")) {
      if (visited.has(node)) {
        continue;
      }
      const itemIndent = node.getAttribute("listIndent");
      if (previous && itemIndent < previous.getAttribute("listIndent")) {
        stack.length = itemIndent + 1;
      }
      stack[itemIndent] = Object.fromEntries(Array.from(node.getAttributes()).filter(([key]) => attributeNames.includes(key)));
      const blocks = getListItemBlocks(node, {
        direction: "forward"
      });
      for (const block2 of blocks) {
        visited.add(block2);
        if (doesItemBlockRequiresRefresh(block2, blocks)) {
          itemsToRefresh.push(block2);
        } else if (doesItemWrappingRequiresRefresh(block2, stack, changedItems)) {
          itemsToRefresh.push(block2);
        }
      }
    }
    return itemsToRefresh;
  }
  function doesItemBlockRequiresRefresh(item, blocks) {
    const viewElement = editing.mapper.toViewElement(item);
    if (!viewElement) {
      return false;
    }
    const needsRefresh = listEditing.fire("checkElement", {
      modelElement: item,
      viewElement
    });
    if (needsRefresh) {
      return true;
    }
    if (!item.is("element", "paragraph") && !item.is("element", "listItem")) {
      return false;
    }
    const useBogus = shouldUseBogusParagraph(item, attributeNames, blocks);
    if (useBogus && viewElement.is("element", "p")) {
      return true;
    } else if (!useBogus && viewElement.is("element", "span")) {
      return true;
    }
    return false;
  }
  function doesItemWrappingRequiresRefresh(item, stack, changedItems) {
    if (changedItems.has(item)) {
      return false;
    }
    const viewElement = editing.mapper.toViewElement(item);
    let indent = stack.length - 1;
    for (let element = viewElement.parent; !element.is("editableElement"); element = element.parent) {
      const isListItemElement = isListItemView(element);
      const isListElement = isListView(element);
      if (!isListElement && !isListItemElement) {
        continue;
      }
      const eventName = `checkAttributes:${isListItemElement ? "item" : "list"}`;
      const needsRefresh = listEditing.fire(eventName, {
        viewElement: element,
        modelAttributes: stack[indent]
      });
      if (needsRefresh) {
        break;
      }
      if (isListElement) {
        indent--;
        if (indent < 0) {
          return false;
        }
      }
    }
    return true;
  }
}
function listItemDowncastConverter(attributeNames, strategies, model, { dataPipeline } = {}) {
  const consumer = createAttributesConsumer(attributeNames);
  return (evt, data, conversionApi) => {
    const { writer, mapper, consumable } = conversionApi;
    const listItem = data.item;
    if (!attributeNames.includes(data.attributeKey)) {
      return;
    }
    if (!consumer(listItem, consumable)) {
      return;
    }
    const viewElement = findMappedViewElement(listItem, mapper, model);
    removeCustomMarkerElements(viewElement, writer, mapper);
    unwrapListItemBlock(viewElement, writer);
    const viewRange = insertCustomMarkerElements(listItem, viewElement, strategies, writer, {
      dataPipeline
    });
    wrapListItemBlock(listItem, viewRange, strategies, writer);
  };
}
function listItemDowncastRemoveConverter(schema) {
  return (evt, data, conversionApi) => {
    const { writer, mapper } = conversionApi;
    const elementName = evt.name.split(":")[1];
    if (!schema.checkAttribute(elementName, "listItemId")) {
      return;
    }
    const viewStart = mapper.toViewPosition(data.position);
    const modelEnd = data.position.getShiftedBy(data.length);
    const viewEnd = mapper.toViewPosition(modelEnd, {
      isPhantom: true
    });
    const viewRange = writer.createRange(viewStart, viewEnd).getTrimmed();
    const viewElement = viewRange.end.nodeBefore;
    if (!viewElement) {
      return;
    }
    removeCustomMarkerElements(viewElement, writer, mapper);
  };
}
function bogusParagraphCreator(attributeNames, { dataPipeline } = {}) {
  return (modelElement, { writer }) => {
    if (!shouldUseBogusParagraph(modelElement, attributeNames)) {
      return null;
    }
    if (!dataPipeline) {
      return writer.createContainerElement("span", {
        class: "ck-list-bogus-paragraph"
      });
    }
    const viewElement = writer.createContainerElement("p");
    writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
    return viewElement;
  };
}
function findMappedViewElement(element, mapper, model) {
  const modelRange = model.createRangeOn(element);
  const viewRange = mapper.toViewRange(modelRange).getTrimmed();
  return viewRange.end.nodeBefore;
}
function createModelToViewPositionMapper(strategies, view) {
  return (evt, data) => {
    if (data.modelPosition.offset > 0) {
      return;
    }
    const positionParent = data.modelPosition.parent;
    if (!isListItemBlock(positionParent)) {
      return;
    }
    if (!strategies.some((strategy) => strategy.scope == "itemMarker" && strategy.canInjectMarkerIntoElement && strategy.canInjectMarkerIntoElement(positionParent))) {
      return;
    }
    const viewElement = data.mapper.toViewElement(positionParent);
    const viewRange = view.createRangeIn(viewElement);
    const viewWalker = viewRange.getWalker();
    let positionAfterLastMarker = viewRange.start;
    for (const { item } of viewWalker) {
      if (item.is("element") && data.mapper.toModelElement(item) || item.is("$textProxy")) {
        break;
      }
      if (item.is("element") && item.getCustomProperty("listItemMarker")) {
        positionAfterLastMarker = view.createPositionAfter(item);
        viewWalker.skip(({ previousPosition }) => !previousPosition.isEqual(positionAfterLastMarker));
      }
    }
    data.viewPosition = positionAfterLastMarker;
  };
}
function removeCustomMarkerElements(viewElement, viewWriter, mapper) {
  while (viewElement.parent.is("attributeElement") && viewElement.parent.getCustomProperty("listItemWrapper")) {
    viewWriter.unwrap(viewWriter.createRangeOn(viewElement), viewElement.parent);
  }
  const markersToRemove = [];
  collectMarkersToRemove(viewWriter.createPositionBefore(viewElement).getWalker({
    direction: "backward"
  }));
  collectMarkersToRemove(viewWriter.createRangeIn(viewElement).getWalker());
  for (const marker of markersToRemove) {
    viewWriter.remove(marker);
  }
  function collectMarkersToRemove(viewWalker) {
    for (const { item } of viewWalker) {
      if (item.is("element") && mapper.toModelElement(item)) {
        break;
      }
      if (item.is("element") && item.getCustomProperty("listItemMarker")) {
        markersToRemove.push(item);
      }
    }
  }
}
function insertCustomMarkerElements(listItem, viewElement, strategies, writer, { dataPipeline }) {
  let viewRange = writer.createRangeOn(viewElement);
  if (!isFirstBlockOfListItem(listItem)) {
    return viewRange;
  }
  for (const strategy of strategies) {
    if (strategy.scope != "itemMarker") {
      continue;
    }
    const markerElement = strategy.createElement(writer, listItem, {
      dataPipeline
    });
    if (!markerElement) {
      continue;
    }
    writer.setCustomProperty("listItemMarker", true, markerElement);
    if (strategy.canInjectMarkerIntoElement && strategy.canInjectMarkerIntoElement(listItem)) {
      writer.insert(writer.createPositionAt(viewElement, 0), markerElement);
    } else {
      writer.insert(viewRange.start, markerElement);
      viewRange = writer.createRange(writer.createPositionBefore(markerElement), writer.createPositionAfter(viewElement));
    }
    if (!strategy.createWrapperElement || !strategy.canWrapElement) {
      continue;
    }
    const wrapper = strategy.createWrapperElement(writer, listItem, {
      dataPipeline
    });
    writer.setCustomProperty("listItemWrapper", true, wrapper);
    if (strategy.canWrapElement(listItem)) {
      viewRange = writer.wrap(viewRange, wrapper);
    } else {
      viewRange = writer.wrap(writer.createRangeOn(markerElement), wrapper);
      viewRange = writer.createRange(viewRange.start, writer.createPositionAfter(viewElement));
    }
  }
  return viewRange;
}
function unwrapListItemBlock(viewElement, viewWriter) {
  let attributeElement = viewElement.parent;
  while (attributeElement.is("attributeElement") && [
    "ul",
    "ol",
    "li"
  ].includes(attributeElement.name)) {
    const parentElement = attributeElement.parent;
    viewWriter.unwrap(viewWriter.createRangeOn(viewElement), attributeElement);
    attributeElement = parentElement;
  }
}
function wrapListItemBlock(listItem, viewRange, strategies, writer) {
  if (!listItem.hasAttribute("listIndent")) {
    return;
  }
  const listItemIndent = listItem.getAttribute("listIndent");
  let currentListItem = listItem;
  for (let indent = listItemIndent; indent >= 0; indent--) {
    const listItemViewElement = createListItemElement(writer, indent, currentListItem.getAttribute("listItemId"));
    const listViewElement = createListElement(writer, indent, currentListItem.getAttribute("listType"));
    for (const strategy of strategies) {
      if ((strategy.scope == "list" || strategy.scope == "item") && currentListItem.hasAttribute(strategy.attributeName)) {
        strategy.setAttributeOnDowncast(writer, currentListItem.getAttribute(strategy.attributeName), strategy.scope == "list" ? listViewElement : listItemViewElement);
      }
    }
    viewRange = writer.wrap(viewRange, listItemViewElement);
    viewRange = writer.wrap(viewRange, listViewElement);
    if (indent == 0) {
      break;
    }
    currentListItem = ListWalker.first(currentListItem, {
      lowerIndent: true
    });
    if (!currentListItem) {
      break;
    }
  }
}
function createAttributesConsumer(attributeNames) {
  return (node, consumable) => {
    const events = [];
    for (const attributeName of attributeNames) {
      if (node.hasAttribute(attributeName)) {
        events.push(`attribute:${attributeName}`);
      }
    }
    if (!events.every((event) => consumable.test(node, event) !== false)) {
      return false;
    }
    events.forEach((event) => consumable.consume(node, event));
    return true;
  };
}
function shouldUseBogusParagraph(item, attributeNames, blocks = getAllListItemBlocks(item)) {
  if (!isListItemBlock(item)) {
    return false;
  }
  for (const attributeKey2 of item.getAttributeKeys()) {
    if (attributeKey2.startsWith("selection:")) {
      continue;
    }
    if (!attributeNames.includes(attributeKey2)) {
      return false;
    }
  }
  return blocks.length < 2;
}
var LIST_BASE_ATTRIBUTES = [
  "listType",
  "listIndent",
  "listItemId"
];
var ListEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The list of registered downcast strategies.
    */
    __publicField(this, "_downcastStrategies", []);
    editor.config.define("list.multiBlock", true);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Enter,
      Delete,
      ListUtils,
      ClipboardPipeline
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const multiBlock = editor.config.get("list.multiBlock");
    if (editor.plugins.has("LegacyListEditing")) {
      throw new CKEditorError("list-feature-conflict", this, {
        conflictPlugin: "LegacyListEditing"
      });
    }
    model.schema.register("$listItem", {
      allowAttributes: LIST_BASE_ATTRIBUTES
    });
    if (multiBlock) {
      model.schema.extend("$container", {
        allowAttributesOf: "$listItem"
      });
      model.schema.extend("$block", {
        allowAttributesOf: "$listItem"
      });
      model.schema.extend("$blockObject", {
        allowAttributesOf: "$listItem"
      });
    } else {
      model.schema.register("listItem", {
        inheritAllFrom: "$block",
        allowAttributesOf: "$listItem"
      });
    }
    for (const attribute of LIST_BASE_ATTRIBUTES) {
      model.schema.setAttributeProperties(attribute, {
        copyOnReplace: true
      });
    }
    editor.commands.add("numberedList", new ListCommand(editor, "numbered"));
    editor.commands.add("bulletedList", new ListCommand(editor, "bulleted"));
    editor.commands.add("customNumberedList", new ListCommand(editor, "customNumbered", {
      multiLevel: true
    }));
    editor.commands.add("customBulletedList", new ListCommand(editor, "customBulleted", {
      multiLevel: true
    }));
    editor.commands.add("indentList", new ListIndentCommand(editor, "forward"));
    editor.commands.add("outdentList", new ListIndentCommand(editor, "backward"));
    editor.commands.add("splitListItemBefore", new ListSplitCommand(editor, "before"));
    editor.commands.add("splitListItemAfter", new ListSplitCommand(editor, "after"));
    if (multiBlock) {
      editor.commands.add("mergeListItemBackward", new ListMergeCommand(editor, "backward"));
      editor.commands.add("mergeListItemForward", new ListMergeCommand(editor, "forward"));
    }
    this._setupDeleteIntegration();
    this._setupEnterIntegration();
    this._setupTabIntegration();
    this._setupClipboardIntegration();
    this._setupAccessibilityIntegration();
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const commands = editor.commands;
    const indent = commands.get("indent");
    const outdent = commands.get("outdent");
    if (indent) {
      indent.registerChildCommand(commands.get("indentList"), {
        priority: "high"
      });
    }
    if (outdent) {
      outdent.registerChildCommand(commands.get("outdentList"), {
        priority: "lowest"
      });
    }
    this._setupModelPostFixing();
    this._setupConversion();
  }
  /**
  * Registers a downcast strategy.
  *
  * **Note**: Strategies must be registered in the `Plugin#init()` phase so that it can be applied
  * in the `ListEditing#afterInit()`.
  *
  * @param strategy The downcast strategy to register.
  */
  registerDowncastStrategy(strategy) {
    this._downcastStrategies.push(strategy);
  }
  /**
  * Returns list of model attribute names that should affect downcast conversion.
  */
  getListAttributeNames() {
    return [
      ...LIST_BASE_ATTRIBUTES,
      ...this._downcastStrategies.map((strategy) => strategy.attributeName)
    ];
  }
  /**
  * Attaches the listener to the {@link module:engine/view/document~Document#event:delete} event and handles backspace/delete
  * keys in and around document lists.
  */
  _setupDeleteIntegration() {
    const editor = this.editor;
    const mergeBackwardCommand = editor.commands.get("mergeListItemBackward");
    const mergeForwardCommand = editor.commands.get("mergeListItemForward");
    this.listenTo(editor.editing.view.document, "delete", (evt, data) => {
      const selection = editor.model.document.selection;
      if (getSelectedBlockObject(editor.model)) {
        return;
      }
      editor.model.change(() => {
        const firstPosition = selection.getFirstPosition();
        if (selection.isCollapsed && data.direction == "backward") {
          if (!firstPosition.isAtStart) {
            return;
          }
          const positionParent = firstPosition.parent;
          if (!isListItemBlock(positionParent)) {
            return;
          }
          const previousBlock = ListWalker.first(positionParent, {
            sameAttributes: "listType",
            sameIndent: true
          });
          if (!previousBlock && positionParent.getAttribute("listIndent") === 0) {
            if (!isLastBlockOfListItem(positionParent)) {
              editor.execute("splitListItemAfter");
            }
            editor.execute("outdentList");
          } else {
            if (!mergeBackwardCommand || !mergeBackwardCommand.isEnabled) {
              return;
            }
            mergeBackwardCommand.execute({
              shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, "backward")
            });
          }
          data.preventDefault();
          evt.stop();
        } else {
          if (selection.isCollapsed && !selection.getLastPosition().isAtEnd) {
            return;
          }
          if (!mergeForwardCommand || !mergeForwardCommand.isEnabled) {
            return;
          }
          mergeForwardCommand.execute({
            shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, "forward")
          });
          data.preventDefault();
          evt.stop();
        }
      });
    }, {
      context: "li"
    });
  }
  /**
  * Attaches a listener to the {@link module:engine/view/document~Document#event:enter} event and handles enter key press
  * in document lists.
  */
  _setupEnterIntegration() {
    const editor = this.editor;
    const model = editor.model;
    const commands = editor.commands;
    const enterCommand = commands.get("enter");
    this.listenTo(editor.editing.view.document, "enter", (evt, data) => {
      const doc = model.document;
      const positionParent = doc.selection.getFirstPosition().parent;
      if (doc.selection.isCollapsed && isListItemBlock(positionParent) && positionParent.isEmpty && !data.isSoft) {
        const isFirstBlock = isFirstBlockOfListItem(positionParent);
        const isLastBlock = isLastBlockOfListItem(positionParent);
        if (isFirstBlock && isLastBlock) {
          editor.execute("outdentList");
          data.preventDefault();
          evt.stop();
        } else if (isFirstBlock && !isLastBlock) {
          editor.execute("splitListItemAfter");
          data.preventDefault();
          evt.stop();
        } else if (isLastBlock) {
          editor.execute("splitListItemBefore");
          data.preventDefault();
          evt.stop();
        }
      }
    }, {
      context: "li"
    });
    this.listenTo(enterCommand, "afterExecute", () => {
      const splitCommand = commands.get("splitListItemBefore");
      splitCommand.refresh();
      if (!splitCommand.isEnabled) {
        return;
      }
      const doc = editor.model.document;
      const positionParent = doc.selection.getLastPosition().parent;
      const listItemBlocks = getAllListItemBlocks(positionParent);
      if (listItemBlocks.length === 2) {
        splitCommand.execute();
      }
    });
  }
  /**
  * Attaches a listener to the {@link module:engine/view/document~Document#event:tab} event and handles tab key and tab+shift keys
  * presses in document lists.
  */
  _setupTabIntegration() {
    const editor = this.editor;
    this.listenTo(editor.editing.view.document, "tab", (evt, data) => {
      const commandName = data.shiftKey ? "outdentList" : "indentList";
      const command = this.editor.commands.get(commandName);
      if (command.isEnabled) {
        editor.execute(commandName);
        data.stopPropagation();
        data.preventDefault();
        evt.stop();
      }
    }, {
      context: "li"
    });
  }
  /**
  * Registers the conversion helpers for the document-list feature.
  */
  _setupConversion() {
    const editor = this.editor;
    const model = editor.model;
    const attributeNames = this.getListAttributeNames();
    const multiBlock = editor.config.get("list.multiBlock");
    const elementName = multiBlock ? "paragraph" : "listItem";
    editor.conversion.for("upcast").elementToElement({
      view: "li",
      model: (viewElement, { writer }) => writer.createElement(elementName, {
        listType: ""
      })
    }).elementToElement({
      view: "p",
      model: (viewElement, { writer }) => {
        if (viewElement.parent && viewElement.parent.is("element", "li")) {
          return writer.createElement(elementName, {
            listType: ""
          });
        }
        return null;
      },
      converterPriority: "high"
    }).add((dispatcher) => {
      dispatcher.on("element:li", listItemUpcastConverter());
    });
    if (!multiBlock) {
      editor.conversion.for("downcast").elementToElement({
        model: "listItem",
        view: "p"
      });
    }
    editor.conversion.for("editingDowncast").elementToElement({
      model: elementName,
      view: bogusParagraphCreator(attributeNames),
      converterPriority: "high"
    }).add((dispatcher) => {
      dispatcher.on("attribute", listItemDowncastConverter(attributeNames, this._downcastStrategies, model));
      dispatcher.on("remove", listItemDowncastRemoveConverter(model.schema));
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: elementName,
      view: bogusParagraphCreator(attributeNames, {
        dataPipeline: true
      }),
      converterPriority: "high"
    }).add((dispatcher) => {
      dispatcher.on("attribute", listItemDowncastConverter(attributeNames, this._downcastStrategies, model, {
        dataPipeline: true
      }));
    });
    const modelToViewPositionMapper = createModelToViewPositionMapper(this._downcastStrategies, editor.editing.view);
    editor.editing.mapper.on("modelToViewPosition", modelToViewPositionMapper);
    editor.data.mapper.on("modelToViewPosition", modelToViewPositionMapper);
    this.listenTo(model.document, "change:data", reconvertItemsOnDataChange(model, editor.editing, attributeNames, this), {
      priority: "high"
    });
    this.on("checkAttributes:item", (evt, { viewElement, modelAttributes }) => {
      if (viewElement.id != modelAttributes.listItemId) {
        evt.return = true;
        evt.stop();
      }
    });
    this.on("checkAttributes:list", (evt, { viewElement, modelAttributes }) => {
      if (viewElement.name != getViewElementNameForListType(modelAttributes.listType) || viewElement.id != getViewElementIdForListType(modelAttributes.listType, modelAttributes.listIndent)) {
        evt.return = true;
        evt.stop();
      }
    });
  }
  /**
  * Registers model post-fixers.
  */
  _setupModelPostFixing() {
    const model = this.editor.model;
    const attributeNames = this.getListAttributeNames();
    model.document.registerPostFixer((writer) => modelChangePostFixer$1(model, writer, attributeNames, this));
    this.on("postFixer", (evt, { listNodes, writer }) => {
      evt.return = fixListIndents(listNodes, writer) || evt.return;
    }, {
      priority: "high"
    });
    this.on("postFixer", (evt, { listNodes, writer, seenIds }) => {
      evt.return = fixListItemIds(listNodes, seenIds, writer) || evt.return;
    }, {
      priority: "high"
    });
  }
  /**
  * Integrates the feature with the clipboard via {@link module:engine/model/model~Model#insertContent} and
  * {@link module:engine/model/model~Model#getSelectedContent}.
  */
  _setupClipboardIntegration() {
    const model = this.editor.model;
    const clipboardPipeline = this.editor.plugins.get("ClipboardPipeline");
    this.listenTo(model, "insertContent", createModelIndentPasteFixer(model), {
      priority: "high"
    });
    this.listenTo(clipboardPipeline, "outputTransformation", (evt, data) => {
      model.change((writer) => {
        const allContentChildren = Array.from(data.content.getChildren());
        const lastItem = allContentChildren[allContentChildren.length - 1];
        if (allContentChildren.length > 1 && lastItem.is("element") && lastItem.isEmpty) {
          const contentChildrenExceptLastItem = allContentChildren.slice(0, -1);
          if (contentChildrenExceptLastItem.every(isListItemBlock)) {
            writer.remove(lastItem);
          }
        }
        if (data.method == "copy" || data.method == "cut") {
          const allChildren = Array.from(data.content.getChildren());
          const isSingleListItemSelected = isSingleListItem(allChildren);
          if (isSingleListItemSelected) {
            removeListAttributes(allChildren, writer);
          }
        }
      });
    });
  }
  /**
  * Informs editor accessibility features about keystrokes brought by the plugin.
  */
  _setupAccessibilityIntegration() {
    const editor = this.editor;
    const t = editor.t;
    editor.accessibility.addKeystrokeInfoGroup({
      id: "list",
      label: t("Keystrokes that can be used in a list"),
      keystrokes: [
        {
          label: t("Increase list item indent"),
          keystroke: "Tab"
        },
        {
          label: t("Decrease list item indent"),
          keystroke: "Shift+Tab"
        }
      ]
    });
  }
};
function modelChangePostFixer$1(model, writer, attributeNames, listEditing) {
  const changes = model.document.differ.getChanges();
  const itemToListHead = /* @__PURE__ */ new Map();
  const multiBlock = listEditing.editor.config.get("list.multiBlock");
  let applied = false;
  for (const entry of changes) {
    if (entry.type == "insert" && entry.name != "$text") {
      const item = entry.position.nodeAfter;
      if (!model.schema.checkAttribute(item, "listItemId")) {
        for (const attributeName of Array.from(item.getAttributeKeys())) {
          if (attributeNames.includes(attributeName)) {
            writer.removeAttribute(attributeName, item);
            applied = true;
          }
        }
      }
      findAndAddListHeadToMap(entry.position, itemToListHead);
      if (!entry.attributes.has("listItemId")) {
        findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);
      }
      for (const { item: innerItem, previousPosition } of model.createRangeIn(item)) {
        if (isListItemBlock(innerItem)) {
          findAndAddListHeadToMap(previousPosition, itemToListHead);
        }
      }
    } else if (entry.type == "remove") {
      findAndAddListHeadToMap(entry.position, itemToListHead);
    } else if (entry.type == "attribute" && attributeNames.includes(entry.attributeKey)) {
      findAndAddListHeadToMap(entry.range.start, itemToListHead);
      if (entry.attributeNewValue === null) {
        findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);
      }
    }
    if (!multiBlock && entry.type == "attribute" && LIST_BASE_ATTRIBUTES.includes(entry.attributeKey)) {
      const element = entry.range.start.nodeAfter;
      if (entry.attributeNewValue === null && element && element.is("element", "listItem")) {
        writer.rename(element, "paragraph");
        applied = true;
      } else if (entry.attributeOldValue === null && element && element.is("element") && element.name != "listItem") {
        writer.rename(element, "listItem");
        applied = true;
      }
    }
  }
  const seenIds = /* @__PURE__ */ new Set();
  for (const listHead of itemToListHead.values()) {
    applied = listEditing.fire("postFixer", {
      listNodes: new ListBlocksIterable(listHead),
      listHead,
      writer,
      seenIds
    }) || applied;
  }
  return applied;
}
function createModelIndentPasteFixer(model) {
  return (evt, [content, selectable]) => {
    const items = content.is("documentFragment") ? Array.from(content.getChildren()) : [
      content
    ];
    if (!items.length) {
      return;
    }
    const selection = selectable ? model.createSelection(selectable) : model.document.selection;
    const position = selection.getFirstPosition();
    let refItem;
    if (isListItemBlock(position.parent)) {
      refItem = position.parent;
    } else if (isListItemBlock(position.nodeBefore)) {
      refItem = position.nodeBefore;
    } else {
      return;
    }
    model.change((writer) => {
      const refType = refItem.getAttribute("listType");
      const refIndent = refItem.getAttribute("listIndent");
      const firstElementIndent = items[0].getAttribute("listIndent") || 0;
      const indentDiff = Math.max(refIndent - firstElementIndent, 0);
      for (const item of items) {
        const isListItem = isListItemBlock(item);
        if (refItem.is("element", "listItem") && item.is("element", "paragraph")) {
          writer.rename(item, "listItem");
        }
        writer.setAttributes({
          listIndent: (isListItem ? item.getAttribute("listIndent") : 0) + indentDiff,
          listItemId: isListItem ? item.getAttribute("listItemId") : ListItemUid.next(),
          listType: refType
        }, item);
      }
    });
  };
}
function shouldMergeOnBlocksContentLevel(model, direction) {
  const selection = model.document.selection;
  if (!selection.isCollapsed) {
    return !getSelectedBlockObject(model);
  }
  if (direction === "forward") {
    return true;
  }
  const firstPosition = selection.getFirstPosition();
  const positionParent = firstPosition.parent;
  const previousSibling = positionParent.previousSibling;
  if (model.schema.isObject(previousSibling)) {
    return false;
  }
  if (previousSibling.isEmpty) {
    return true;
  }
  return isSingleListItem([
    positionParent,
    previousSibling
  ]);
}
function createUIComponents(editor, commandName, label, icon) {
  editor.ui.componentFactory.add(commandName, () => {
    const buttonView = _createButton(ButtonView, editor, commandName, label, icon);
    buttonView.set({
      tooltip: true,
      isToggleable: true
    });
    return buttonView;
  });
  editor.ui.componentFactory.add(`menuBar:${commandName}`, () => {
    const buttonView = _createButton(MenuBarMenuListItemButtonView, editor, commandName, label, icon);
    buttonView.set({
      role: "menuitemcheckbox",
      isToggleable: true
    });
    return buttonView;
  });
}
function _createButton(ButtonClass, editor, commandName, label, icon) {
  const command = editor.commands.get(commandName);
  const view = new ButtonClass(editor.locale);
  view.set({
    label,
    icon
  });
  view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
  view.on("execute", () => {
    editor.execute(commandName);
    editor.editing.view.focus();
  });
  return view;
}
var ListUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const t = this.editor.t;
    if (!this.editor.ui.componentFactory.has("numberedList")) {
      createUIComponents(this.editor, "numberedList", t("Numbered List"), icons.numberedList);
    }
    if (!this.editor.ui.componentFactory.has("bulletedList")) {
      createUIComponents(this.editor, "bulletedList", t("Bulleted List"), icons.bulletedList);
    }
  }
};
var List = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ListEditing,
      ListUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "List";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var ListStartCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const value = this._getValue();
    this.value = value;
    this.isEnabled = value != null;
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options.startIndex The list start index.
  */
  execute({ startIndex = 1 } = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    let blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => isListItemBlock(block2) && isNumberedListType(block2.getAttribute("listType")));
    blocks = expandListBlocksToCompleteList(blocks);
    model.change((writer) => {
      for (const block2 of blocks) {
        writer.setAttribute("listStart", startIndex >= 0 ? startIndex : 1, block2);
      }
    });
  }
  /**
  * Checks the command's {@link #value}.
  *
  * @returns The current value.
  */
  _getValue() {
    const model = this.editor.model;
    const document2 = model.document;
    const block2 = first(document2.selection.getSelectedBlocks());
    if (block2 && isListItemBlock(block2) && isNumberedListType(block2.getAttribute("listType"))) {
      return block2.getAttribute("listStart");
    }
    return null;
  }
};
var LIST_STYLE_TO_LIST_TYPE = {};
var LIST_STYLE_TO_TYPE_ATTRIBUTE = {};
var TYPE_ATTRIBUTE_TO_LIST_STYLE = {};
var LIST_STYLE_TYPES = [
  {
    listStyle: "disc",
    typeAttribute: "disc",
    listType: "bulleted"
  },
  {
    listStyle: "circle",
    typeAttribute: "circle",
    listType: "bulleted"
  },
  {
    listStyle: "square",
    typeAttribute: "square",
    listType: "bulleted"
  },
  {
    listStyle: "decimal",
    typeAttribute: "1",
    listType: "numbered"
  },
  {
    listStyle: "decimal-leading-zero",
    typeAttribute: null,
    listType: "numbered"
  },
  {
    listStyle: "lower-roman",
    typeAttribute: "i",
    listType: "numbered"
  },
  {
    listStyle: "upper-roman",
    typeAttribute: "I",
    listType: "numbered"
  },
  {
    listStyle: "lower-alpha",
    typeAttribute: "a",
    listType: "numbered"
  },
  {
    listStyle: "upper-alpha",
    typeAttribute: "A",
    listType: "numbered"
  },
  {
    listStyle: "lower-latin",
    typeAttribute: "a",
    listType: "numbered"
  },
  {
    listStyle: "upper-latin",
    typeAttribute: "A",
    listType: "numbered"
  }
];
for (const { listStyle, typeAttribute, listType } of LIST_STYLE_TYPES) {
  LIST_STYLE_TO_LIST_TYPE[listStyle] = listType;
  LIST_STYLE_TO_TYPE_ATTRIBUTE[listStyle] = typeAttribute;
  if (typeAttribute) {
    TYPE_ATTRIBUTE_TO_LIST_STYLE[typeAttribute] = listStyle;
  }
}
function getAllSupportedStyleTypes() {
  return LIST_STYLE_TYPES.map((x2) => x2.listStyle);
}
function getListTypeFromListStyleType$1(listStyleType) {
  return LIST_STYLE_TO_LIST_TYPE[listStyleType] || null;
}
function getListStyleTypeFromTypeAttribute(value) {
  return TYPE_ATTRIBUTE_TO_LIST_STYLE[value] || null;
}
function getTypeAttributeFromListStyleType(value) {
  return LIST_STYLE_TO_TYPE_ATTRIBUTE[value] || null;
}
var ListStyleCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param defaultType The list type that will be used by default if the value was not specified during
  * the command execution.
  * @param supportedTypes The list of supported style types by this command.
  */
  constructor(editor, defaultType, supportedTypes) {
    super(editor);
    /**
    * The default type of the list style.
    */
    __publicField(this, "defaultType");
    /**
    * The list of supported style types by this command.
    */
    __publicField(this, "_supportedTypes");
    this.defaultType = defaultType;
    this._supportedTypes = supportedTypes;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options.type The type of the list style, e.g. `'disc'` or `'square'`. If `null` is specified, the default
  * style will be applied.
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    model.change((writer) => {
      this._tryToConvertItemsToList(options2);
      let blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => block2.hasAttribute("listType"));
      if (!blocks.length) {
        return;
      }
      blocks = expandListBlocksToCompleteList(blocks);
      for (const block2 of blocks) {
        writer.setAttribute("listStyle", options2.type || this.defaultType, block2);
      }
    });
  }
  /**
  * Checks if the given style type is supported by this plugin.
  */
  isStyleTypeSupported(value) {
    if (!this._supportedTypes) {
      return true;
    }
    return this._supportedTypes.includes(value);
  }
  /**
  * Checks the command's {@link #value}.
  *
  * @returns The current value.
  */
  _getValue() {
    const listItem = first(this.editor.model.document.selection.getSelectedBlocks());
    if (isListItemBlock(listItem)) {
      return listItem.getAttribute("listStyle");
    }
    return null;
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    const editor = this.editor;
    const numberedList = editor.commands.get("numberedList");
    const bulletedList = editor.commands.get("bulletedList");
    return numberedList.isEnabled || bulletedList.isEnabled;
  }
  /**
   * Check if the provided list style is valid. Also change the selection to a list if it's not set yet.
   *
   * @param options.type The type of the list style. If `null` is specified, the function does nothing.
  */
  _tryToConvertItemsToList(options2) {
    if (!options2.type) {
      return;
    }
    const listType = getListTypeFromListStyleType$1(options2.type);
    if (!listType) {
      return;
    }
    const editor = this.editor;
    const commandName = `${listType}List`;
    const command = editor.commands.get(commandName);
    if (!command.value) {
      editor.execute(commandName);
    }
  }
};
var ListReversedCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const value = this._getValue();
    this.value = value;
    this.isEnabled = value != null;
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options.reversed Whether the list should be reversed.
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    let blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => isListItemBlock(block2) && block2.getAttribute("listType") == "numbered");
    blocks = expandListBlocksToCompleteList(blocks);
    model.change((writer) => {
      for (const block2 of blocks) {
        writer.setAttribute("listReversed", !!options2.reversed, block2);
      }
    });
  }
  /**
  * Checks the command's {@link #value}.
  */
  _getValue() {
    const model = this.editor.model;
    const document2 = model.document;
    const block2 = first(document2.selection.getSelectedBlocks());
    if (isListItemBlock(block2) && block2.getAttribute("listType") == "numbered") {
      return block2.getAttribute("listReversed");
    }
    return null;
  }
};
function listPropertiesUpcastConverter(strategy) {
  return (evt, data, conversionApi) => {
    const { writer, schema, consumable } = conversionApi;
    if (consumable.test(data.viewItem, strategy.viewConsumables) === false) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    let applied = false;
    for (const item of data.modelRange.getItems({
      shallow: true
    })) {
      if (!schema.checkAttribute(item, strategy.attributeName)) {
        continue;
      }
      if (!strategy.appliesToListItem(item)) {
        continue;
      }
      if (item.hasAttribute(strategy.attributeName)) {
        continue;
      }
      writer.setAttribute(strategy.attributeName, strategy.getAttributeOnUpcast(data.viewItem), item);
      applied = true;
    }
    if (applied) {
      consumable.consume(data.viewItem, strategy.viewConsumables);
    }
  };
}
var ListPropertiesUtils = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListPropertiesUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Gets all the style types supported by given list type.
  */
  getAllSupportedStyleTypes() {
    return getAllSupportedStyleTypes();
  }
  /**
  * Checks whether the given list-style-type is supported by numbered or bulleted list.
  */
  getListTypeFromListStyleType(listStyleType) {
    return getListTypeFromListStyleType$1(listStyleType);
  }
  /**
  * Converts `type` attribute of `<ul>` or `<ol>` elements to `list-style-type` equivalent.
  */
  getListStyleTypeFromTypeAttribute(value) {
    return getListStyleTypeFromTypeAttribute(value);
  }
  /**
  * Converts `list-style-type` style to `type` attribute of `<ul>` or `<ol>` elements.
  */
  getTypeAttributeFromListStyleType(value) {
    return getTypeAttributeFromListStyleType(value);
  }
};
function getNormalizedConfig(config) {
  const { startIndex, reversed, styles } = config;
  return {
    styles: getNormalizedStylesConfig(styles),
    startIndex: startIndex || false,
    reversed: reversed || false
  };
}
function getNormalizedStylesConfig(styles) {
  const normalizedConfig = {
    listTypes: [
      "bulleted",
      "numbered"
    ],
    useAttribute: false
  };
  if (styles === true) {
    return normalizedConfig;
  }
  if (!styles) {
    normalizedConfig.listTypes = [];
  } else if (Array.isArray(styles) || typeof styles == "string") {
    normalizedConfig.listTypes = toArray(styles);
  } else {
    normalizedConfig.listTypes = styles.listTypes ? toArray(styles.listTypes) : normalizedConfig.listTypes;
    normalizedConfig.useAttribute = !!styles.useAttribute;
  }
  return normalizedConfig;
}
var DEFAULT_LIST_TYPE$1 = "default";
var ListPropertiesEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ListEditing,
      ListPropertiesUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListPropertiesEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("list.properties", {
      styles: true,
      startIndex: false,
      reversed: false
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const listEditing = editor.plugins.get(ListEditing);
    const enabledProperties = editor.config.get("list.properties");
    const strategies = createAttributeStrategies$1(enabledProperties);
    for (const strategy of strategies) {
      strategy.addCommand(editor);
      model.schema.extend("$listItem", {
        allowAttributes: strategy.attributeName
      });
      listEditing.registerDowncastStrategy({
        scope: "list",
        attributeName: strategy.attributeName,
        setAttributeOnDowncast(writer, attributeValue, viewElement) {
          strategy.setAttributeOnDowncast(writer, attributeValue, viewElement);
        }
      });
    }
    editor.conversion.for("upcast").add((dispatcher) => {
      for (const strategy of strategies) {
        dispatcher.on("element:ol", listPropertiesUpcastConverter(strategy));
        dispatcher.on("element:ul", listPropertiesUpcastConverter(strategy));
      }
    });
    listEditing.on("checkAttributes:list", (evt, { viewElement, modelAttributes }) => {
      for (const strategy of strategies) {
        if (strategy.getAttributeOnUpcast(viewElement) != modelAttributes[strategy.attributeName]) {
          evt.return = true;
          evt.stop();
        }
      }
    });
    this.listenTo(editor.commands.get("indentList"), "afterExecute", (evt, changedBlocks) => {
      model.change((writer) => {
        for (const node of changedBlocks) {
          for (const strategy of strategies) {
            if (strategy.appliesToListItem(node)) {
              writer.setAttribute(strategy.attributeName, strategy.defaultValue, node);
            }
          }
        }
      });
    });
    listEditing.on("postFixer", (evt, { listNodes, writer }) => {
      for (const { node } of listNodes) {
        for (const strategy of strategies) {
          if (strategy.hasValidAttribute(node)) {
            continue;
          }
          if (strategy.appliesToListItem(node)) {
            writer.setAttribute(strategy.attributeName, strategy.defaultValue, node);
          } else {
            writer.removeAttribute(strategy.attributeName, node);
          }
          evt.return = true;
        }
      }
    });
    listEditing.on("postFixer", (evt, { listNodes, writer }) => {
      for (const { node, previousNodeInList } of listNodes) {
        if (!previousNodeInList) {
          continue;
        }
        if (previousNodeInList.getAttribute("listType") != node.getAttribute("listType")) {
          continue;
        }
        for (const strategy of strategies) {
          const { attributeName } = strategy;
          if (!strategy.appliesToListItem(node)) {
            continue;
          }
          const value = previousNodeInList.getAttribute(attributeName);
          if (node.getAttribute(attributeName) != value) {
            writer.setAttribute(attributeName, value, node);
            evt.return = true;
          }
        }
      }
    });
  }
};
function createAttributeStrategies$1(enabledProperties) {
  const strategies = [];
  const normalizedConfig = getNormalizedConfig(enabledProperties);
  if (enabledProperties.styles) {
    const useAttribute = normalizedConfig.styles.useAttribute;
    strategies.push({
      attributeName: "listStyle",
      defaultValue: DEFAULT_LIST_TYPE$1,
      viewConsumables: {
        styles: "list-style-type"
      },
      addCommand(editor) {
        let supportedTypes = getAllSupportedStyleTypes();
        if (useAttribute) {
          supportedTypes = supportedTypes.filter((styleType) => !!getTypeAttributeFromListStyleType(styleType));
        }
        editor.commands.add("listStyle", new ListStyleCommand(editor, DEFAULT_LIST_TYPE$1, supportedTypes));
      },
      appliesToListItem(item) {
        return item.getAttribute("listType") == "numbered" || item.getAttribute("listType") == "bulleted";
      },
      hasValidAttribute(item) {
        if (!this.appliesToListItem(item)) {
          return !item.hasAttribute("listStyle");
        }
        if (!item.hasAttribute("listStyle")) {
          return false;
        }
        const value = item.getAttribute("listStyle");
        if (value == DEFAULT_LIST_TYPE$1) {
          return true;
        }
        return getListTypeFromListStyleType$1(value) == item.getAttribute("listType");
      },
      setAttributeOnDowncast(writer, listStyle, element) {
        if (listStyle && listStyle !== DEFAULT_LIST_TYPE$1) {
          if (useAttribute) {
            const value = getTypeAttributeFromListStyleType(listStyle);
            if (value) {
              writer.setAttribute("type", value, element);
              return;
            }
          } else {
            writer.setStyle("list-style-type", listStyle, element);
            return;
          }
        }
        writer.removeStyle("list-style-type", element);
        writer.removeAttribute("type", element);
      },
      getAttributeOnUpcast(listParent) {
        const style = listParent.getStyle("list-style-type");
        if (style) {
          return style;
        }
        const attribute = listParent.getAttribute("type");
        if (attribute) {
          return getListStyleTypeFromTypeAttribute(attribute);
        }
        return DEFAULT_LIST_TYPE$1;
      }
    });
  }
  if (enabledProperties.reversed) {
    strategies.push({
      attributeName: "listReversed",
      defaultValue: false,
      viewConsumables: {
        attributes: "reversed"
      },
      addCommand(editor) {
        editor.commands.add("listReversed", new ListReversedCommand(editor));
      },
      appliesToListItem(item) {
        return item.getAttribute("listType") == "numbered";
      },
      hasValidAttribute(item) {
        return this.appliesToListItem(item) == item.hasAttribute("listReversed");
      },
      setAttributeOnDowncast(writer, listReversed, element) {
        if (listReversed) {
          writer.setAttribute("reversed", "reversed", element);
        } else {
          writer.removeAttribute("reversed", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        return listParent.hasAttribute("reversed");
      }
    });
  }
  if (enabledProperties.startIndex) {
    strategies.push({
      attributeName: "listStart",
      defaultValue: 1,
      viewConsumables: {
        attributes: "start"
      },
      addCommand(editor) {
        editor.commands.add("listStart", new ListStartCommand(editor));
      },
      appliesToListItem(item) {
        return isNumberedListType(item.getAttribute("listType"));
      },
      hasValidAttribute(item) {
        return this.appliesToListItem(item) == item.hasAttribute("listStart");
      },
      setAttributeOnDowncast(writer, listStart, element) {
        if (listStart == 0 || listStart > 1) {
          writer.setAttribute("start", listStart, element);
        } else {
          writer.removeAttribute("start", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        const startAttributeValue = listParent.getAttribute("start");
        return startAttributeValue >= 0 ? startAttributeValue : 1;
      }
    });
  }
  return strategies;
}
var ListPropertiesView = class extends View2 {
  /**
  * Creates an instance of the list properties view.
  *
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param options Options of the view.
  * @param options.enabledProperties An object containing the configuration of enabled list property names.
  * Allows conditional rendering the sub-components of the properties view.
  * @param options.styleButtonViews A list of style buttons to be rendered
  * inside the styles grid. The grid will not be rendered when `enabledProperties` does not include the `'styles'` key.
  * @param options.styleGridAriaLabel An assistive technologies label set on the grid of styles (if the grid is rendered).
  */
  constructor(locale, { enabledProperties, styleButtonViews, styleGridAriaLabel }) {
    super(locale);
    /**
    * A collection of the child views.
    */
    __publicField(this, "children");
    /**
    * A view that renders the grid of list styles.
    */
    __publicField(this, "stylesView", null);
    /**
    * A collapsible view that hosts additional list property fields ({@link #startIndexFieldView} and
    * {@link #reversedSwitchButtonView}) to visually separate them from the {@link #stylesView grid of styles}.
    *
    * **Note**: Only present when:
    * * the view represents **numbered** list properties,
    * * and the {@link #stylesView} is rendered,
    * * and either {@link #startIndexFieldView} or {@link #reversedSwitchButtonView} is rendered.
    *
    * @readonly
    */
    __publicField(this, "additionalPropertiesCollapsibleView", null);
    /**
    * A labeled number field allowing the user to set the start index of the list.
    *
    * **Note**: Only present when the view represents **numbered** list properties.
    *
    * @readonly
    */
    __publicField(this, "startIndexFieldView", null);
    /**
    * A switch button allowing the user to make the edited list reversed.
    *
    * **Note**: Only present when the view represents **numbered** list properties.
    *
    * @readonly
    */
    __publicField(this, "reversedSwitchButtonView", null);
    /**
    * Tracks information about the DOM focus in the view.
    */
    __publicField(this, "focusTracker", new FocusTracker());
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes", new KeystrokeHandler());
    /**
    * A collection of views that can be focused in the properties view.
    */
    __publicField(this, "focusables", new ViewCollection());
    /**
    * Helps cycling over {@link #focusables} in the view.
    */
    __publicField(this, "focusCycler");
    const elementCssClasses = [
      "ck",
      "ck-list-properties"
    ];
    this.children = this.createCollection();
    this.focusCycler = new FocusCycler({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate #children backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate #children forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    });
    if (styleButtonViews && styleButtonViews.length) {
      this.stylesView = this._createStylesView(styleButtonViews, styleGridAriaLabel);
      this.children.add(this.stylesView);
    } else {
      elementCssClasses.push("ck-list-properties_without-styles");
    }
    if (enabledProperties.startIndex || enabledProperties.reversed) {
      this._addNumberedListPropertyViews(enabledProperties);
      elementCssClasses.push("ck-list-properties_with-numbered-properties");
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: elementCssClasses
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    if (this.stylesView) {
      this.focusables.add(this.stylesView);
      this.focusTracker.add(this.stylesView.element);
      if (this.startIndexFieldView || this.reversedSwitchButtonView) {
        this.focusables.add(this.children.last.buttonView);
        this.focusTracker.add(this.children.last.buttonView.element);
      }
      for (const item of this.stylesView.children) {
        this.stylesView.focusTracker.add(item.element);
      }
      addKeyboardHandlingForGrid({
        keystrokeHandler: this.stylesView.keystrokes,
        focusTracker: this.stylesView.focusTracker,
        gridItems: this.stylesView.children,
        // Note: The styles view has a different number of columns depending on whether the other properties
        // are enabled in the dropdown or not (https://github.com/ckeditor/ckeditor5/issues/12340)
        numberOfColumns: () => global.window.getComputedStyle(this.stylesView.element).getPropertyValue("grid-template-columns").split(" ").length,
        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
      });
    }
    if (this.startIndexFieldView) {
      this.focusables.add(this.startIndexFieldView);
      this.focusTracker.add(this.startIndexFieldView.element);
      const stopPropagation = (data) => data.stopPropagation();
      this.keystrokes.set("arrowright", stopPropagation);
      this.keystrokes.set("arrowleft", stopPropagation);
      this.keystrokes.set("arrowup", stopPropagation);
      this.keystrokes.set("arrowdown", stopPropagation);
    }
    if (this.reversedSwitchButtonView) {
      this.focusables.add(this.reversedSwitchButtonView);
      this.focusTracker.add(this.reversedSwitchButtonView.element);
    }
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  focus() {
    this.focusCycler.focusFirst();
  }
  /**
  * @inheritDoc
  */
  focusLast() {
    this.focusCycler.focusLast();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Creates the list styles grid.
  *
  * @param styleButtons Buttons to be placed in the grid.
  * @param styleGridAriaLabel The assistive technology label of the grid.
  */
  _createStylesView(styleButtons, styleGridAriaLabel) {
    const stylesView = new View2(this.locale);
    stylesView.children = stylesView.createCollection();
    stylesView.children.addMany(styleButtons);
    stylesView.setTemplate({
      tag: "div",
      attributes: {
        "aria-label": styleGridAriaLabel,
        class: [
          "ck",
          "ck-list-styles-list"
        ]
      },
      children: stylesView.children
    });
    stylesView.children.delegate("execute").to(this);
    stylesView.focus = function() {
      this.children.first.focus();
    };
    stylesView.focusTracker = new FocusTracker();
    stylesView.keystrokes = new KeystrokeHandler();
    stylesView.render();
    stylesView.keystrokes.listenTo(stylesView.element);
    return stylesView;
  }
  /**
  * Renders {@link #startIndexFieldView} and/or {@link #reversedSwitchButtonView} depending on the configuration of the properties view.
  *
  * @param enabledProperties An object containing the configuration of enabled list property names
  * (see {@link #constructor}).
  */
  _addNumberedListPropertyViews(enabledProperties) {
    const t = this.locale.t;
    const numberedPropertyViews = [];
    if (enabledProperties.startIndex) {
      this.startIndexFieldView = this._createStartIndexField();
      numberedPropertyViews.push(this.startIndexFieldView);
    }
    if (enabledProperties.reversed) {
      this.reversedSwitchButtonView = this._createReversedSwitchButton();
      numberedPropertyViews.push(this.reversedSwitchButtonView);
    }
    if (this.stylesView) {
      this.additionalPropertiesCollapsibleView = new CollapsibleView(this.locale, numberedPropertyViews);
      this.additionalPropertiesCollapsibleView.set({
        label: t("List properties"),
        isCollapsed: true
      });
      this.additionalPropertiesCollapsibleView.buttonView.bind("isEnabled").toMany(numberedPropertyViews, "isEnabled", (...areEnabled) => areEnabled.some((isEnabled) => isEnabled));
      this.additionalPropertiesCollapsibleView.buttonView.on("change:isEnabled", (evt, data, isEnabled) => {
        if (!isEnabled) {
          this.additionalPropertiesCollapsibleView.isCollapsed = true;
        }
      });
      this.children.add(this.additionalPropertiesCollapsibleView);
    } else {
      this.children.addMany(numberedPropertyViews);
    }
  }
  /**
  * Creates the list start index labeled field.
  */
  _createStartIndexField() {
    const t = this.locale.t;
    const startIndexFieldView = new LabeledFieldView(this.locale, createLabeledInputNumber);
    startIndexFieldView.set({
      label: t("Start at"),
      class: "ck-numbered-list-properties__start-index"
    });
    startIndexFieldView.fieldView.set({
      min: 0,
      step: 1,
      value: 1,
      inputMode: "numeric"
    });
    startIndexFieldView.fieldView.on("input", () => {
      const inputElement = startIndexFieldView.fieldView.element;
      const startIndex = inputElement.valueAsNumber;
      if (Number.isNaN(startIndex)) {
        startIndexFieldView.errorText = t("Invalid start index value.");
        return;
      }
      if (!inputElement.checkValidity()) {
        startIndexFieldView.errorText = t("Start index must be greater than 0.");
      } else {
        this.fire("listStart", {
          startIndex
        });
      }
    });
    return startIndexFieldView;
  }
  /**
  * Creates the reversed list switch button.
  */
  _createReversedSwitchButton() {
    const t = this.locale.t;
    const reversedButtonView = new SwitchButtonView(this.locale);
    reversedButtonView.set({
      withText: true,
      label: t("Reversed order"),
      class: "ck-numbered-list-properties__reversed-order"
    });
    reversedButtonView.delegate("execute").to(this, "listReversed");
    return reversedButtonView;
  }
};
var listStyleDiscIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>';
var listStyleCircleIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>';
var listStyleSquareIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>';
var listStyleDecimalIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>';
var listStyleDecimalWithLeadingZeroIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>';
var listStyleLowerRomanIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>';
var listStyleUpperRomanIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>';
var listStyleLowerLatinIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>';
var listStyleUpperLatinIcon = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>';
var ListPropertiesUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListPropertiesUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const propertiesConfig = editor.config.get("list.properties");
    const normalizedConfig = getNormalizedConfig(propertiesConfig);
    const stylesListTypes = normalizedConfig.styles.listTypes;
    if (stylesListTypes.includes("bulleted")) {
      const styleDefinitions = [
        {
          label: t("Toggle the disc list style"),
          tooltip: t("Disc"),
          type: "disc",
          icon: listStyleDiscIcon
        },
        {
          label: t("Toggle the circle list style"),
          tooltip: t("Circle"),
          type: "circle",
          icon: listStyleCircleIcon
        },
        {
          label: t("Toggle the square list style"),
          tooltip: t("Square"),
          type: "square",
          icon: listStyleSquareIcon
        }
      ];
      const buttonLabel = t("Bulleted List");
      const styleGridAriaLabel = t("Bulleted list styles toolbar");
      const commandName = "bulletedList";
      editor.ui.componentFactory.add(commandName, getDropdownViewCreator({
        editor,
        normalizedConfig,
        parentCommandName: commandName,
        buttonLabel,
        buttonIcon: icons.bulletedList,
        styleGridAriaLabel,
        styleDefinitions
      }));
      editor.ui.componentFactory.add(`menuBar:${commandName}`, getMenuBarStylesMenuCreator({
        editor,
        normalizedConfig,
        parentCommandName: commandName,
        buttonLabel,
        styleGridAriaLabel,
        styleDefinitions
      }));
    }
    if (stylesListTypes.includes("numbered") || propertiesConfig.startIndex || propertiesConfig.reversed) {
      const styleDefinitions = [
        {
          label: t("Toggle the decimal list style"),
          tooltip: t("Decimal"),
          type: "decimal",
          icon: listStyleDecimalIcon
        },
        {
          label: t("Toggle the decimal with leading zero list style"),
          tooltip: t("Decimal with leading zero"),
          type: "decimal-leading-zero",
          icon: listStyleDecimalWithLeadingZeroIcon
        },
        {
          label: t("Toggle the lowerroman list style"),
          tooltip: t("Lowerroman"),
          type: "lower-roman",
          icon: listStyleLowerRomanIcon
        },
        {
          label: t("Toggle the upperroman list style"),
          tooltip: t("Upper-roman"),
          type: "upper-roman",
          icon: listStyleUpperRomanIcon
        },
        {
          label: t("Toggle the lowerlatin list style"),
          tooltip: t("Lower-latin"),
          type: "lower-latin",
          icon: listStyleLowerLatinIcon
        },
        {
          label: t("Toggle the upperlatin list style"),
          tooltip: t("Upper-latin"),
          type: "upper-latin",
          icon: listStyleUpperLatinIcon
        }
      ];
      const buttonLabel = t("Numbered List");
      const styleGridAriaLabel = t("Numbered list styles toolbar");
      const commandName = "numberedList";
      editor.ui.componentFactory.add(commandName, getDropdownViewCreator({
        editor,
        normalizedConfig,
        parentCommandName: commandName,
        buttonLabel,
        buttonIcon: icons.numberedList,
        styleGridAriaLabel,
        styleDefinitions
      }));
      if (stylesListTypes.includes("numbered")) {
        editor.ui.componentFactory.add(`menuBar:${commandName}`, getMenuBarStylesMenuCreator({
          editor,
          normalizedConfig,
          parentCommandName: commandName,
          buttonLabel,
          styleGridAriaLabel,
          styleDefinitions
        }));
      }
    }
  }
};
function getDropdownViewCreator({ editor, normalizedConfig, parentCommandName, buttonLabel, buttonIcon, styleGridAriaLabel, styleDefinitions }) {
  const parentCommand = editor.commands.get(parentCommandName);
  return (locale) => {
    const dropdownView = createDropdown(locale, SplitButtonView);
    const mainButtonView = dropdownView.buttonView;
    dropdownView.bind("isEnabled").to(parentCommand);
    dropdownView.class = "ck-list-styles-dropdown";
    mainButtonView.on("execute", () => {
      editor.execute(parentCommandName);
      editor.editing.view.focus();
    });
    mainButtonView.set({
      label: buttonLabel,
      icon: buttonIcon,
      tooltip: true,
      isToggleable: true
    });
    mainButtonView.bind("isOn").to(parentCommand, "value", (value) => !!value);
    dropdownView.once("change:isOpen", () => {
      const listPropertiesView = createListPropertiesView({
        editor,
        normalizedConfig,
        dropdownView,
        parentCommandName,
        styleGridAriaLabel,
        styleDefinitions
      });
      dropdownView.panelView.children.add(listPropertiesView);
    });
    dropdownView.on("execute", () => {
      editor.editing.view.focus();
    });
    return dropdownView;
  };
}
function getStyleButtonCreator({ editor, listStyleCommand, parentCommandName }) {
  const locale = editor.locale;
  const parentCommand = editor.commands.get(parentCommandName);
  return ({ label, type, icon, tooltip }) => {
    const button = new ButtonView(locale);
    button.set({
      label,
      icon,
      tooltip
    });
    listStyleCommand.on("change:value", () => {
      button.isOn = listStyleCommand.value === type;
    });
    button.on("execute", () => {
      if (parentCommand.value) {
        if (listStyleCommand.value === type) {
          editor.execute(parentCommandName);
        } else if (listStyleCommand.value !== type) {
          editor.execute("listStyle", {
            type
          });
        }
      } else {
        editor.model.change(() => {
          editor.execute("listStyle", {
            type
          });
        });
      }
    });
    return button;
  };
}
function createListPropertiesView({ editor, normalizedConfig, dropdownView, parentCommandName, styleDefinitions, styleGridAriaLabel }) {
  const locale = editor.locale;
  const enabledProperties = {
    ...normalizedConfig,
    ...parentCommandName != "numberedList" ? {
      startIndex: false,
      reversed: false
    } : null
  };
  const listType = parentCommandName.replace("List", "");
  let styleButtonViews = null;
  if (normalizedConfig.styles.listTypes.includes(listType)) {
    const listStyleCommand = editor.commands.get("listStyle");
    const styleButtonCreator = getStyleButtonCreator({
      editor,
      parentCommandName,
      listStyleCommand
    });
    const isStyleTypeSupported = getStyleTypeSupportChecker(listStyleCommand);
    styleButtonViews = styleDefinitions.filter(isStyleTypeSupported).map(styleButtonCreator);
  }
  const listPropertiesView = new ListPropertiesView(locale, {
    styleGridAriaLabel,
    enabledProperties,
    styleButtonViews
  });
  if (normalizedConfig.styles.listTypes.includes(listType)) {
    focusChildOnDropdownOpen(dropdownView, () => {
      return listPropertiesView.stylesView.children.find((child) => child.isOn);
    });
  }
  if (enabledProperties.startIndex) {
    const listStartCommand = editor.commands.get("listStart");
    listPropertiesView.startIndexFieldView.bind("isEnabled").to(listStartCommand);
    listPropertiesView.startIndexFieldView.fieldView.bind("value").to(listStartCommand);
    listPropertiesView.on("listStart", (evt, data) => editor.execute("listStart", data));
  }
  if (enabledProperties.reversed) {
    const listReversedCommand = editor.commands.get("listReversed");
    listPropertiesView.reversedSwitchButtonView.bind("isEnabled").to(listReversedCommand);
    listPropertiesView.reversedSwitchButtonView.bind("isOn").to(listReversedCommand, "value", (value) => !!value);
    listPropertiesView.on("listReversed", () => {
      const isReversed = listReversedCommand.value;
      editor.execute("listReversed", {
        reversed: !isReversed
      });
    });
  }
  listPropertiesView.delegate("execute").to(dropdownView);
  return listPropertiesView;
}
function getMenuBarStylesMenuCreator({ editor, normalizedConfig, parentCommandName, buttonLabel, styleGridAriaLabel, styleDefinitions }) {
  return (locale) => {
    const menuView = new MenuBarMenuView(locale);
    const listCommand = editor.commands.get(parentCommandName);
    const listStyleCommand = editor.commands.get("listStyle");
    const isStyleTypeSupported = getStyleTypeSupportChecker(listStyleCommand);
    const styleButtonCreator = getStyleButtonCreator({
      editor,
      parentCommandName,
      listStyleCommand
    });
    const styleButtonViews = styleDefinitions.filter(isStyleTypeSupported).map(styleButtonCreator);
    const listPropertiesView = new ListPropertiesView(locale, {
      styleGridAriaLabel,
      enabledProperties: {
        ...normalizedConfig,
        // Disable list start index and reversed in the menu bar.
        startIndex: false,
        reversed: false
      },
      styleButtonViews
    });
    listPropertiesView.delegate("execute").to(menuView);
    menuView.buttonView.set({
      label: buttonLabel,
      icon: icons[parentCommandName]
    });
    menuView.panelView.children.add(listPropertiesView);
    menuView.bind("isEnabled").to(listCommand, "isEnabled");
    menuView.on("execute", () => {
      editor.editing.view.focus();
    });
    return menuView;
  };
}
function getStyleTypeSupportChecker(listStyleCommand) {
  if (typeof listStyleCommand.isStyleTypeSupported == "function") {
    return (styleDefinition) => listStyleCommand.isStyleTypeSupported(styleDefinition.type);
  } else {
    return () => true;
  }
}
var ListProperties = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ListPropertiesEditing,
      ListPropertiesUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListProperties";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var CheckTodoListCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    this.on("execute", () => {
      this.refresh();
    }, {
      priority: "highest"
    });
  }
  /**
  * Updates the command's {@link #value} and {@link #isEnabled} properties based on the current selection.
  */
  refresh() {
    const selectedElements = this._getSelectedItems();
    this.value = this._getValue(selectedElements);
    this.isEnabled = !!selectedElements.length;
  }
  /**
  * Executes the command.
  *
  * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply
  * the attribute. Otherwise, the command will remove the attribute. If not set, the command will look for its current
  * value to decide what it should do.
  */
  execute(options2 = {}) {
    this.editor.model.change((writer) => {
      const selectedElements = this._getSelectedItems();
      const value = options2.forceValue === void 0 ? !this._getValue(selectedElements) : options2.forceValue;
      for (const element of selectedElements) {
        if (value) {
          writer.setAttribute("todoListChecked", true, element);
        } else {
          writer.removeAttribute("todoListChecked", element);
        }
      }
    });
  }
  /**
  * Returns a value for the command.
  */
  _getValue(selectedElements) {
    return selectedElements.every((element) => element.getAttribute("todoListChecked"));
  }
  /**
  * Gets all to-do list items selected by the {@link module:engine/model/selection~Selection}.
  */
  _getSelectedItems() {
    const model = this.editor.model;
    const schema = model.schema;
    const selectionRange = model.document.selection.getFirstRange();
    const startElement = selectionRange.start.parent;
    const elements = [];
    if (schema.checkAttribute(startElement, "todoListChecked")) {
      elements.push(...getAllListItemBlocks(startElement));
    }
    for (const item of selectionRange.getItems({
      shallow: true
    })) {
      if (schema.checkAttribute(item, "todoListChecked") && !elements.includes(item)) {
        elements.push(...getAllListItemBlocks(item));
      }
    }
    return elements;
  }
};
var TodoCheckboxChangeObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    /**
    * @inheritDoc
    */
    __publicField(this, "domEventType", [
      "change"
    ]);
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    if (domEvent.target) {
      const viewTarget = this.view.domConverter.mapDomToView(domEvent.target);
      if (viewTarget && viewTarget.is("element", "input") && viewTarget.getAttribute("type") == "checkbox" && viewTarget.findAncestor({
        classes: "todo-list__label"
      })) {
        this.fire("todoCheckboxChange", domEvent);
      }
    }
  }
};
var ITEM_TOGGLE_KEYSTROKE$1 = parseKeystroke("Ctrl+Enter");
var TodoListEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TodoListEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ListEditing
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const editing = editor.editing;
    const listEditing = editor.plugins.get(ListEditing);
    const multiBlock = editor.config.get("list.multiBlock");
    const elementName = multiBlock ? "paragraph" : "listItem";
    editor.commands.add("todoList", new ListCommand(editor, "todo"));
    editor.commands.add("checkTodoList", new CheckTodoListCommand(editor));
    editing.view.addObserver(TodoCheckboxChangeObserver);
    model.schema.extend("$listItem", {
      allowAttributes: "todoListChecked"
    });
    model.schema.addAttributeCheck((context) => {
      const item = context.last;
      if (!item.getAttribute("listItemId") || item.getAttribute("listType") != "todo") {
        return false;
      }
    }, "todoListChecked");
    editor.conversion.for("upcast").add((dispatcher) => {
      dispatcher.on("element:input", todoItemInputConverter());
      dispatcher.on("element:li", todoListItemUpcastConverter(), {
        priority: "low"
      });
      dispatcher.on("element:label", elementUpcastConsumingConverter({
        name: "label",
        classes: "todo-list__label"
      }));
      dispatcher.on("element:label", elementUpcastConsumingConverter({
        name: "label",
        classes: [
          "todo-list__label",
          "todo-list__label_without-description"
        ]
      }));
      dispatcher.on("element:span", elementUpcastConsumingConverter({
        name: "span",
        classes: "todo-list__label__description"
      }));
      dispatcher.on("element:ul", attributeUpcastConsumingConverter({
        name: "ul",
        classes: "todo-list"
      }));
    });
    editor.conversion.for("downcast").elementToElement({
      model: elementName,
      view: (element, { writer }) => {
        if (isDescriptionBlock(element, listEditing.getListAttributeNames())) {
          return writer.createContainerElement("span", {
            class: "todo-list__label__description"
          });
        }
      },
      converterPriority: "highest"
    });
    listEditing.registerDowncastStrategy({
      scope: "list",
      attributeName: "listType",
      setAttributeOnDowncast(writer, value, element) {
        if (value == "todo") {
          writer.addClass("todo-list", element);
        } else {
          writer.removeClass("todo-list", element);
        }
      }
    });
    listEditing.registerDowncastStrategy({
      scope: "itemMarker",
      attributeName: "todoListChecked",
      createElement(writer, modelElement, { dataPipeline }) {
        if (modelElement.getAttribute("listType") != "todo") {
          return null;
        }
        const viewElement = writer.createUIElement("input", {
          type: "checkbox",
          ...modelElement.getAttribute("todoListChecked") ? {
            checked: "checked"
          } : null,
          ...dataPipeline ? {
            disabled: "disabled"
          } : {
            tabindex: "-1"
          }
        });
        if (dataPipeline) {
          return viewElement;
        }
        const wrapper = writer.createContainerElement("span", {
          contenteditable: "false"
        }, viewElement);
        wrapper.getFillerOffset = () => null;
        return wrapper;
      },
      canWrapElement(modelElement) {
        return isDescriptionBlock(modelElement, listEditing.getListAttributeNames());
      },
      createWrapperElement(writer, modelElement, { dataPipeline }) {
        const classes = [
          "todo-list__label"
        ];
        if (!isDescriptionBlock(modelElement, listEditing.getListAttributeNames())) {
          classes.push("todo-list__label_without-description");
        }
        return writer.createAttributeElement(dataPipeline ? "label" : "span", {
          class: classes.join(" ")
        });
      }
    });
    listEditing.on("checkElement", (evt, { modelElement, viewElement }) => {
      const isFirstTodoModelParagraphBlock = isDescriptionBlock(modelElement, listEditing.getListAttributeNames());
      const hasViewClass = viewElement.hasClass("todo-list__label__description");
      if (hasViewClass != isFirstTodoModelParagraphBlock) {
        evt.return = true;
        evt.stop();
      }
    });
    listEditing.on("checkElement", (evt, { modelElement, viewElement }) => {
      const isFirstTodoModelItemBlock = modelElement.getAttribute("listType") == "todo" && isFirstBlockOfListItem(modelElement);
      let hasViewItemMarker = false;
      const viewWalker = editor.editing.view.createPositionBefore(viewElement).getWalker({
        direction: "backward"
      });
      for (const { item } of viewWalker) {
        if (item.is("element") && editor.editing.mapper.toModelElement(item)) {
          break;
        }
        if (item.is("element", "input") && item.getAttribute("type") == "checkbox") {
          hasViewItemMarker = true;
        }
      }
      if (hasViewItemMarker != isFirstTodoModelItemBlock) {
        evt.return = true;
        evt.stop();
      }
    });
    listEditing.on("postFixer", (evt, { listNodes, writer }) => {
      for (const { node, previousNodeInList } of listNodes) {
        if (!previousNodeInList) {
          continue;
        }
        if (previousNodeInList.getAttribute("listItemId") != node.getAttribute("listItemId")) {
          continue;
        }
        const previousHasAttribute = previousNodeInList.hasAttribute("todoListChecked");
        const nodeHasAttribute = node.hasAttribute("todoListChecked");
        if (nodeHasAttribute && !previousHasAttribute) {
          writer.removeAttribute("todoListChecked", node);
          evt.return = true;
        } else if (!nodeHasAttribute && previousHasAttribute) {
          writer.setAttribute("todoListChecked", true, node);
          evt.return = true;
        }
      }
    });
    model.document.registerPostFixer((writer) => {
      const changes = model.document.differ.getChanges();
      let wasFixed = false;
      for (const change of changes) {
        if (change.type == "attribute" && change.attributeKey == "listType") {
          const element = change.range.start.nodeAfter;
          if (change.attributeOldValue == "todo" && element.hasAttribute("todoListChecked")) {
            writer.removeAttribute("todoListChecked", element);
            wasFixed = true;
          }
        } else if (change.type == "insert" && change.name != "$text") {
          for (const { item } of writer.createRangeOn(change.position.nodeAfter)) {
            if (item.is("element") && item.getAttribute("listType") != "todo" && item.hasAttribute("todoListChecked")) {
              writer.removeAttribute("todoListChecked", item);
              wasFixed = true;
            }
          }
        }
      }
      return wasFixed;
    });
    this.listenTo(editing.view.document, "keydown", (evt, data) => {
      if (getCode(data) === ITEM_TOGGLE_KEYSTROKE$1) {
        editor.execute("checkTodoList");
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.listenTo(editing.view.document, "todoCheckboxChange", (evt, data) => {
      const viewTarget = data.target;
      if (!viewTarget || !viewTarget.is("element", "input")) {
        return;
      }
      const viewPositionAfter = editing.view.createPositionAfter(viewTarget);
      const modelPositionAfter = editing.mapper.toModelPosition(viewPositionAfter);
      const modelElement = modelPositionAfter.parent;
      if (modelElement && isListItemBlock(modelElement) && modelElement.getAttribute("listType") == "todo") {
        this._handleCheckmarkChange(modelElement);
      }
    });
    this.listenTo(editing.view.document, "arrowKey", jumpOverCheckmarkOnSideArrowKeyPress$1(model, editor.locale), {
      context: "$text"
    });
    this.listenTo(editing.mapper, "viewToModelPosition", (evt, data) => {
      const viewParent = data.viewPosition.parent;
      const isStartOfListItem = viewParent.is("attributeElement", "li") && data.viewPosition.offset == 0;
      const isStartOfListLabel = isLabelElement(viewParent) && data.viewPosition.offset <= 1;
      const isInInputWrapper = viewParent.is("element", "span") && viewParent.getAttribute("contenteditable") == "false" && isLabelElement(viewParent.parent);
      if (!isStartOfListItem && !isStartOfListLabel && !isInInputWrapper) {
        return;
      }
      const nodeAfter = data.modelPosition.nodeAfter;
      if (nodeAfter && nodeAfter.getAttribute("listType") == "todo") {
        data.modelPosition = model.createPositionAt(nodeAfter, 0);
      }
    }, {
      priority: "low"
    });
    this._initAriaAnnouncements();
  }
  /**
  * Handles the checkbox element change, moves the selection to the corresponding model item to make it possible
  * to toggle the `todoListChecked` attribute using the command, and restores the selection position.
  *
  * Some say it's a hack :) Moving the selection only for executing the command on a certain node and restoring it after,
  * is not a clear solution. We need to design an API for using commands beyond the selection range.
  * See https://github.com/ckeditor/ckeditor5/issues/1954.
  */
  _handleCheckmarkChange(listItem) {
    const editor = this.editor;
    const model = editor.model;
    const previousSelectionRanges = Array.from(model.document.selection.getRanges());
    model.change((writer) => {
      writer.setSelection(listItem, "end");
      editor.execute("checkTodoList");
      writer.setSelection(previousSelectionRanges);
    });
  }
  /**
  * Observe when user enters or leaves todo list and set proper aria value in global live announcer.
  * This allows screen readers to indicate when the user has entered and left the specified todo list.
  *
  * @internal
  */
  _initAriaAnnouncements() {
    const { model, ui, t } = this.editor;
    let lastFocusedCodeBlock = null;
    if (!ui) {
      return;
    }
    model.document.selection.on("change:range", () => {
      const focusParent = model.document.selection.focus.parent;
      const lastElementIsTodoList = isTodoListItemElement(lastFocusedCodeBlock);
      const currentElementIsTodoList = isTodoListItemElement(focusParent);
      if (lastElementIsTodoList && !currentElementIsTodoList) {
        ui.ariaLiveAnnouncer.announce(t("Leaving a to-do list"));
      } else if (!lastElementIsTodoList && currentElementIsTodoList) {
        ui.ariaLiveAnnouncer.announce(t("Entering a to-do list"));
      }
      lastFocusedCodeBlock = focusParent;
    });
  }
};
function todoListItemUpcastConverter() {
  return (evt, data, conversionApi) => {
    const { writer, schema } = conversionApi;
    if (!data.modelRange) {
      return;
    }
    const groupedItems = Array.from(data.modelRange.getItems({
      shallow: true
    })).filter((item) => item.getAttribute("listType") === "todo" && schema.checkAttribute(item, "listItemId")).reduce((acc, item) => {
      const listItemId = item.getAttribute("listItemId");
      if (!acc.has(listItemId)) {
        acc.set(listItemId, getAllListItemBlocks(item));
      }
      return acc;
    }, /* @__PURE__ */ new Map());
    for (const [, items] of groupedItems.entries()) {
      if (items.some((item) => item.getAttribute("todoListChecked"))) {
        for (const item of items) {
          writer.setAttribute("todoListChecked", true, item);
        }
      }
    }
  };
}
function todoItemInputConverter() {
  return (evt, data, conversionApi) => {
    const modelCursor = data.modelCursor;
    const modelItem = modelCursor.parent;
    const viewItem = data.viewItem;
    if (!conversionApi.consumable.test(viewItem, {
      name: true
    })) {
      return;
    }
    if (viewItem.getAttribute("type") != "checkbox" || !modelCursor.isAtStart || !modelItem.hasAttribute("listType")) {
      return;
    }
    conversionApi.consumable.consume(viewItem, {
      name: true
    });
    const writer = conversionApi.writer;
    writer.setAttribute("listType", "todo", modelItem);
    if (data.viewItem.hasAttribute("checked")) {
      writer.setAttribute("todoListChecked", true, modelItem);
    }
    data.modelRange = writer.createRange(modelCursor);
  };
}
function elementUpcastConsumingConverter(matcherPattern) {
  const matcher = new Matcher(matcherPattern);
  return (evt, data, conversionApi) => {
    const matcherResult = matcher.match(data.viewItem);
    if (!matcherResult) {
      return;
    }
    if (!conversionApi.consumable.consume(data.viewItem, matcherResult.match)) {
      return;
    }
    Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
  };
}
function attributeUpcastConsumingConverter(matcherPattern) {
  const matcher = new Matcher(matcherPattern);
  return (evt, data, conversionApi) => {
    const matcherResult = matcher.match(data.viewItem);
    if (!matcherResult) {
      return;
    }
    const match = matcherResult.match;
    match.name = false;
    conversionApi.consumable.consume(data.viewItem, match);
  };
}
function isDescriptionBlock(modelElement, listAttributeNames) {
  return (modelElement.is("element", "paragraph") || modelElement.is("element", "listItem")) && modelElement.getAttribute("listType") == "todo" && isFirstBlockOfListItem(modelElement) && hasOnlyListAttributes(modelElement, listAttributeNames);
}
function hasOnlyListAttributes(modelElement, attributeNames) {
  for (const attributeKey2 of modelElement.getAttributeKeys()) {
    if (attributeKey2.startsWith("selection:")) {
      continue;
    }
    if (!attributeNames.includes(attributeKey2)) {
      return false;
    }
  }
  return true;
}
function jumpOverCheckmarkOnSideArrowKeyPress$1(model, locale) {
  return (eventInfo, domEventData) => {
    const direction = getLocalizedArrowKeyCodeDirection(domEventData.keyCode, locale.contentLanguageDirection);
    const schema = model.schema;
    const selection = model.document.selection;
    if (!selection.isCollapsed) {
      return;
    }
    const position = selection.getFirstPosition();
    const parent = position.parent;
    if (direction == "right" && position.isAtEnd) {
      const newRange = schema.getNearestSelectionRange(model.createPositionAfter(parent), "forward");
      if (!newRange) {
        return;
      }
      const newRangeParent = newRange.start.parent;
      if (newRangeParent && isListItemBlock(newRangeParent) && newRangeParent.getAttribute("listType") == "todo") {
        model.change((writer) => writer.setSelection(newRange));
        domEventData.preventDefault();
        domEventData.stopPropagation();
        eventInfo.stop();
      }
    } else if (direction == "left" && position.isAtStart && isListItemBlock(parent) && parent.getAttribute("listType") == "todo") {
      const newRange = schema.getNearestSelectionRange(model.createPositionBefore(parent), "backward");
      if (!newRange) {
        return;
      }
      model.change((writer) => writer.setSelection(newRange));
      domEventData.preventDefault();
      domEventData.stopPropagation();
      eventInfo.stop();
    }
  };
}
function isLabelElement(viewElement) {
  return !!viewElement && viewElement.is("attributeElement") && viewElement.hasClass("todo-list__label");
}
function isTodoListItemElement(element) {
  if (!element) {
    return false;
  }
  if (!element.is("element", "paragraph") && !element.is("element", "listItem")) {
    return false;
  }
  return element.getAttribute("listType") == "todo";
}
var TodoListUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TodoListUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const t = this.editor.t;
    createUIComponents(this.editor, "todoList", t("To-do List"), icons.todoList);
  }
};
var TodoList = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TodoListEditing,
      TodoListUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TodoList";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var LegacyListCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param type List type that will be handled by this command.
  */
  constructor(editor, type) {
    super(editor);
    /**
    * The type of the list created by the command.
    */
    __publicField(this, "type");
    this.type = type;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the list command.
  *
  * @fires execute
  * @param options Command options.
  * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
  * selected items and potentially the neighbor elements to the proper list items. If set to `false`, it will convert selected elements
  * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => checkCanBecomeListItem(block2, model.schema));
    const turnOff = options2.forceValue !== void 0 ? !options2.forceValue : this.value;
    model.change((writer) => {
      if (turnOff) {
        let next2 = blocks[blocks.length - 1].nextSibling;
        let currentIndent = Number.POSITIVE_INFINITY;
        let changes = [];
        while (next2 && next2.name == "listItem" && next2.getAttribute("listIndent") !== 0) {
          const indent = next2.getAttribute("listIndent");
          if (indent < currentIndent) {
            currentIndent = indent;
          }
          const newIndent = indent - currentIndent;
          changes.push({
            element: next2,
            listIndent: newIndent
          });
          next2 = next2.nextSibling;
        }
        changes = changes.reverse();
        for (const item of changes) {
          writer.setAttribute("listIndent", item.listIndent, item.element);
        }
      }
      if (!turnOff) {
        let lowestIndent = Number.POSITIVE_INFINITY;
        for (const item of blocks) {
          if (item.is("element", "listItem") && item.getAttribute("listIndent") < lowestIndent) {
            lowestIndent = item.getAttribute("listIndent");
          }
        }
        lowestIndent = lowestIndent === 0 ? 1 : lowestIndent;
        _fixType(blocks, true, lowestIndent);
        _fixType(blocks, false, lowestIndent);
      }
      for (const element of blocks.reverse()) {
        if (turnOff && element.name == "listItem") {
          writer.rename(element, "paragraph");
        } else if (!turnOff && element.name != "listItem") {
          writer.setAttributes({
            listType: this.type,
            listIndent: 0
          }, element);
          writer.rename(element, "listItem");
        } else if (!turnOff && element.name == "listItem" && element.getAttribute("listType") != this.type) {
          writer.setAttribute("listType", this.type, element);
        }
      }
      this.fire("_executeCleanup", blocks);
    });
  }
  /**
  * Checks the command's {@link #value}.
  *
  * @returns The current value.
  */
  _getValue() {
    const listItem = first(this.editor.model.document.selection.getSelectedBlocks());
    return !!listItem && listItem.is("element", "listItem") && listItem.getAttribute("listType") == this.type;
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    if (this.value) {
      return true;
    }
    const selection = this.editor.model.document.selection;
    const schema = this.editor.model.schema;
    const firstBlock = first(selection.getSelectedBlocks());
    if (!firstBlock) {
      return false;
    }
    return checkCanBecomeListItem(firstBlock, schema);
  }
};
function _fixType(blocks, isBackward, lowestIndent) {
  const startingItem = isBackward ? blocks[0] : blocks[blocks.length - 1];
  if (startingItem.is("element", "listItem")) {
    let item = startingItem[isBackward ? "previousSibling" : "nextSibling"];
    let currentIndent = startingItem.getAttribute("listIndent");
    while (item && item.is("element", "listItem") && item.getAttribute("listIndent") >= lowestIndent) {
      if (currentIndent > item.getAttribute("listIndent")) {
        currentIndent = item.getAttribute("listIndent");
      }
      if (item.getAttribute("listIndent") == currentIndent) {
        blocks[isBackward ? "unshift" : "push"](item);
      }
      item = item[isBackward ? "previousSibling" : "nextSibling"];
    }
  }
}
function checkCanBecomeListItem(block2, schema) {
  return schema.checkChild(block2.parent, "listItem") && !schema.isObject(block2);
}
var LegacyIndentCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param indentDirection The direction of indent. If it is equal to `backward`, the command will outdent a list item.
  */
  constructor(editor, indentDirection) {
    super(editor);
    /**
    * Determines by how much the command will change the list item's indent attribute.
    */
    __publicField(this, "_indentBy");
    this._indentBy = indentDirection == "forward" ? 1 : -1;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
  *
  * @fires execute
  */
  execute() {
    const model = this.editor.model;
    const doc = model.document;
    let itemsToChange = Array.from(doc.selection.getSelectedBlocks());
    model.change((writer) => {
      const lastItem = itemsToChange[itemsToChange.length - 1];
      let next2 = lastItem.nextSibling;
      while (next2 && next2.name == "listItem" && next2.getAttribute("listIndent") > lastItem.getAttribute("listIndent")) {
        itemsToChange.push(next2);
        next2 = next2.nextSibling;
      }
      if (this._indentBy < 0) {
        itemsToChange = itemsToChange.reverse();
      }
      for (const item of itemsToChange) {
        const indent = item.getAttribute("listIndent") + this._indentBy;
        if (indent < 0) {
          writer.rename(item, "paragraph");
        } else {
          writer.setAttribute("listIndent", indent, item);
        }
      }
      this.fire("_executeCleanup", itemsToChange);
    });
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    const listItem = first(this.editor.model.document.selection.getSelectedBlocks());
    if (!listItem || !listItem.is("element", "listItem")) {
      return false;
    }
    if (this._indentBy > 0) {
      const indent = listItem.getAttribute("listIndent");
      const type = listItem.getAttribute("listType");
      let prev = listItem.previousSibling;
      while (prev && prev.is("element", "listItem") && prev.getAttribute("listIndent") >= indent) {
        if (prev.getAttribute("listIndent") == indent) {
          return prev.getAttribute("listType") == type;
        }
        prev = prev.previousSibling;
      }
      return false;
    }
    return true;
  }
};
function createViewListItemElement(writer) {
  const viewItem = writer.createContainerElement("li");
  viewItem.getFillerOffset = getListItemFillerOffset;
  return viewItem;
}
function generateLiInUl(modelItem, conversionApi) {
  const mapper = conversionApi.mapper;
  const viewWriter = conversionApi.writer;
  const listType = modelItem.getAttribute("listType") == "numbered" ? "ol" : "ul";
  const viewItem = createViewListItemElement(viewWriter);
  const viewList = viewWriter.createContainerElement(listType, null);
  viewWriter.insert(viewWriter.createPositionAt(viewList, 0), viewItem);
  mapper.bindElements(modelItem, viewItem);
  return viewItem;
}
function injectViewList(modelItem, injectedItem, conversionApi, model) {
  const injectedList = injectedItem.parent;
  const mapper = conversionApi.mapper;
  const viewWriter = conversionApi.writer;
  let insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));
  const refItem = getSiblingListItem(modelItem.previousSibling, {
    sameIndent: true,
    smallerIndent: true,
    listIndent: modelItem.getAttribute("listIndent")
  });
  const prevItem = modelItem.previousSibling;
  if (refItem && refItem.getAttribute("listIndent") == modelItem.getAttribute("listIndent")) {
    const viewItem = mapper.toViewElement(refItem);
    insertPosition = viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
  } else {
    if (prevItem && prevItem.name == "listItem") {
      insertPosition = mapper.toViewPosition(model.createPositionAt(prevItem, "end"));
      const mappedViewAncestor = mapper.findMappedViewAncestor(insertPosition);
      const nestedList = findNestedList(mappedViewAncestor);
      if (nestedList) {
        insertPosition = viewWriter.createPositionBefore(nestedList);
      } else {
        insertPosition = viewWriter.createPositionAt(mappedViewAncestor, "end");
      }
    } else {
      insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));
    }
  }
  insertPosition = positionAfterUiElements(insertPosition);
  viewWriter.insert(insertPosition, injectedList);
  if (prevItem && prevItem.name == "listItem") {
    const prevView = mapper.toViewElement(prevItem);
    const walkerBoundaries = viewWriter.createRange(viewWriter.createPositionAt(prevView, 0), insertPosition);
    const walker = walkerBoundaries.getWalker({
      ignoreElementEnd: true
    });
    for (const value of walker) {
      if (value.item.is("element", "li")) {
        const breakPosition = viewWriter.breakContainer(viewWriter.createPositionBefore(value.item));
        const viewList = value.item.parent;
        const targetPosition = viewWriter.createPositionAt(injectedItem, "end");
        mergeViewLists(viewWriter, targetPosition.nodeBefore, targetPosition.nodeAfter);
        viewWriter.move(viewWriter.createRangeOn(viewList), targetPosition);
        walker._position = breakPosition;
      }
    }
  } else {
    const nextViewList = injectedList.nextSibling;
    if (nextViewList && (nextViewList.is("element", "ul") || nextViewList.is("element", "ol"))) {
      let lastSubChild = null;
      for (const child of nextViewList.getChildren()) {
        const modelChild = mapper.toModelElement(child);
        if (modelChild && modelChild.getAttribute("listIndent") > modelItem.getAttribute("listIndent")) {
          lastSubChild = child;
        } else {
          break;
        }
      }
      if (lastSubChild) {
        viewWriter.breakContainer(viewWriter.createPositionAfter(lastSubChild));
        viewWriter.move(viewWriter.createRangeOn(lastSubChild.parent), viewWriter.createPositionAt(injectedItem, "end"));
      }
    }
  }
  mergeViewLists(viewWriter, injectedList, injectedList.nextSibling);
  mergeViewLists(viewWriter, injectedList.previousSibling, injectedList);
}
function mergeViewLists(viewWriter, firstList, secondList) {
  if (!firstList || !secondList || firstList.name != "ul" && firstList.name != "ol") {
    return null;
  }
  if (firstList.name != secondList.name || firstList.getAttribute("class") !== secondList.getAttribute("class")) {
    return null;
  }
  return viewWriter.mergeContainers(viewWriter.createPositionAfter(firstList));
}
function positionAfterUiElements(viewPosition) {
  return viewPosition.getLastMatchingPosition((value) => value.item.is("uiElement"));
}
function getSiblingListItem(modelItem, options2) {
  const sameIndent = !!options2.sameIndent;
  const smallerIndent = !!options2.smallerIndent;
  const indent = options2.listIndent;
  let item = modelItem;
  while (item && item.name == "listItem") {
    const itemIndent = item.getAttribute("listIndent");
    if (sameIndent && indent == itemIndent || smallerIndent && indent > itemIndent) {
      return item;
    }
    if (options2.direction === "forward") {
      item = item.nextSibling;
    } else {
      item = item.previousSibling;
    }
  }
  return null;
}
function findNestedList(viewElement) {
  for (const node of viewElement.getChildren()) {
    if (node.name == "ul" || node.name == "ol") {
      return node;
    }
  }
  return null;
}
function getSiblingNodes(position, direction) {
  const items = [];
  const listItem = position.parent;
  const walkerOptions = {
    ignoreElementEnd: false,
    startPosition: position,
    shallow: true,
    direction
  };
  const limitIndent = listItem.getAttribute("listIndent");
  const nodes = [
    ...new TreeWalker(walkerOptions)
  ].filter((value) => value.item.is("element")).map((value) => value.item);
  for (const element of nodes) {
    if (!element.is("element", "listItem")) {
      break;
    }
    if (element.getAttribute("listIndent") < limitIndent) {
      break;
    }
    if (element.getAttribute("listIndent") > limitIndent) {
      continue;
    }
    if (element.getAttribute("listType") !== listItem.getAttribute("listType")) {
      break;
    }
    if (element.getAttribute("listStyle") !== listItem.getAttribute("listStyle")) {
      break;
    }
    if (element.getAttribute("listReversed") !== listItem.getAttribute("listReversed")) {
      break;
    }
    if (element.getAttribute("listStart") !== listItem.getAttribute("listStart")) {
      break;
    }
    if (direction === "backward") {
      items.unshift(element);
    } else {
      items.push(element);
    }
  }
  return items;
}
function getSelectedListItems(model) {
  const document2 = model.document;
  let listItems = [
    ...document2.selection.getSelectedBlocks()
  ].filter((element) => element.is("element", "listItem")).map((element) => {
    const position = model.change((writer) => writer.createPositionAt(element, 0));
    return [
      ...getSiblingNodes(position, "backward"),
      ...getSiblingNodes(position, "forward")
    ];
  }).flat();
  listItems = [
    ...new Set(listItems)
  ];
  return listItems;
}
var BULLETED_LIST_STYLE_TYPES = [
  "disc",
  "circle",
  "square"
];
var NUMBERED_LIST_STYLE_TYPES = [
  "decimal",
  "decimal-leading-zero",
  "lower-roman",
  "upper-roman",
  "lower-latin",
  "upper-latin"
];
function getListTypeFromListStyleType(listStyleType) {
  if (BULLETED_LIST_STYLE_TYPES.includes(listStyleType)) {
    return "bulleted";
  }
  if (NUMBERED_LIST_STYLE_TYPES.includes(listStyleType)) {
    return "numbered";
  }
  return null;
}
function getListItemFillerOffset() {
  const hasOnlyLists = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
  if (this.isEmpty || hasOnlyLists) {
    return 0;
  }
  return getFillerOffset$4.call(this);
}
var LegacyListUtils = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LegacyListUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * Checks whether the given list-style-type is supported by numbered or bulleted list.
  */
  getListTypeFromListStyleType(listStyleType) {
    return getListTypeFromListStyleType(listStyleType);
  }
  /**
  * Returns an array with all `listItem` elements in the model selection.
  *
  * It returns all the items even if only a part of the list is selected, including items that belong to nested lists.
  * If no list is selected, it returns an empty array.
  * The order of the elements is not specified.
  */
  getSelectedListItems(model) {
    return getSelectedListItems(model);
  }
  /**
  * Returns an array with all `listItem` elements that represent the same list.
  *
  * It means that values of `listIndent`, `listType`, `listStyle`, `listReversed` and `listStart` for all items are equal.
  *
  * Additionally, if the `position` is inside a list item, that list item will be returned as well.
  *
  * @param position Starting position.
  * @param direction Walking direction.
  */
  getSiblingNodes(position, direction) {
    return getSiblingNodes(position, direction);
  }
};
function modelViewInsertion$1(model) {
  return (evt, data, conversionApi) => {
    const consumable = conversionApi.consumable;
    if (!consumable.test(data.item, "insert") || !consumable.test(data.item, "attribute:listType") || !consumable.test(data.item, "attribute:listIndent")) {
      return;
    }
    consumable.consume(data.item, "insert");
    consumable.consume(data.item, "attribute:listType");
    consumable.consume(data.item, "attribute:listIndent");
    const modelItem = data.item;
    const viewItem = generateLiInUl(modelItem, conversionApi);
    injectViewList(modelItem, viewItem, conversionApi, model);
  };
}
function modelViewRemove(model) {
  return (evt, data, conversionApi) => {
    const viewPosition = conversionApi.mapper.toViewPosition(data.position);
    const viewStart = viewPosition.getLastMatchingPosition((value) => !value.item.is("element", "li"));
    const viewItem = viewStart.nodeAfter;
    const viewWriter = conversionApi.writer;
    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
    const viewList = viewItem.parent;
    const viewListPrev = viewList.previousSibling;
    const removeRange = viewWriter.createRangeOn(viewList);
    const removed = viewWriter.remove(removeRange);
    if (viewListPrev && viewListPrev.nextSibling) {
      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);
    }
    const modelItem = conversionApi.mapper.toModelElement(viewItem);
    hoistNestedLists(modelItem.getAttribute("listIndent") + 1, data.position, removeRange.start, viewItem, conversionApi, model);
    for (const child of viewWriter.createRangeIn(removed).getItems()) {
      conversionApi.mapper.unbindViewElement(child);
    }
    evt.stop();
  };
}
var modelViewChangeType$1 = (evt, data, conversionApi) => {
  if (!conversionApi.consumable.test(data.item, evt.name)) {
    return;
  }
  const viewItem = conversionApi.mapper.toViewElement(data.item);
  const viewWriter = conversionApi.writer;
  viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
  viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
  const viewList = viewItem.parent;
  const listName = data.attributeNewValue == "numbered" ? "ol" : "ul";
  viewWriter.rename(listName, viewList);
};
var modelViewMergeAfterChangeType = (evt, data, conversionApi) => {
  conversionApi.consumable.consume(data.item, evt.name);
  const viewItem = conversionApi.mapper.toViewElement(data.item);
  const viewList = viewItem.parent;
  const viewWriter = conversionApi.writer;
  mergeViewLists(viewWriter, viewList, viewList.nextSibling);
  mergeViewLists(viewWriter, viewList.previousSibling, viewList);
};
function modelViewChangeIndent(model) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, "attribute:listIndent")) {
      return;
    }
    const viewItem = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
    const viewList = viewItem.parent;
    const viewListPrev = viewList.previousSibling;
    const removeRange = viewWriter.createRangeOn(viewList);
    viewWriter.remove(removeRange);
    if (viewListPrev && viewListPrev.nextSibling) {
      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);
    }
    hoistNestedLists(data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model);
    injectViewList(data.item, viewItem, conversionApi, model);
    for (const child of data.item.getChildren()) {
      conversionApi.consumable.consume(child, "insert");
    }
  };
}
var modelViewSplitOnInsert = (evt, data, conversionApi) => {
  if (!conversionApi.consumable.test(data.item, evt.name)) {
    return;
  }
  if (data.item.name != "listItem") {
    let viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    const viewWriter = conversionApi.writer;
    const lists = [];
    while (viewPosition.parent.name == "ul" || viewPosition.parent.name == "ol") {
      viewPosition = viewWriter.breakContainer(viewPosition);
      if (viewPosition.parent.name != "li") {
        break;
      }
      const removeStart = viewPosition;
      const removeEnd = viewWriter.createPositionAt(viewPosition.parent, "end");
      if (!removeStart.isEqual(removeEnd)) {
        const removed = viewWriter.remove(viewWriter.createRange(removeStart, removeEnd));
        lists.push(removed);
      }
      viewPosition = viewWriter.createPositionAfter(viewPosition.parent);
    }
    if (lists.length > 0) {
      for (let i = 0; i < lists.length; i++) {
        const previousList = viewPosition.nodeBefore;
        const insertedRange = viewWriter.insert(viewPosition, lists[i]);
        viewPosition = insertedRange.end;
        if (i > 0) {
          const mergePos = mergeViewLists(viewWriter, previousList, previousList.nextSibling);
          if (mergePos && mergePos.parent == previousList) {
            viewPosition.offset--;
          }
        }
      }
      mergeViewLists(viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter);
    }
  }
};
var modelViewMergeAfter = (evt, data, conversionApi) => {
  const viewPosition = conversionApi.mapper.toViewPosition(data.position);
  const viewItemPrev = viewPosition.nodeBefore;
  const viewItemNext = viewPosition.nodeAfter;
  mergeViewLists(conversionApi.writer, viewItemPrev, viewItemNext);
};
var viewModelConverter = (evt, data, conversionApi) => {
  if (conversionApi.consumable.consume(data.viewItem, {
    name: true
  })) {
    const writer = conversionApi.writer;
    const listItem = writer.createElement("listItem");
    const indent = getIndent(data.viewItem);
    writer.setAttribute("listIndent", indent, listItem);
    const type = data.viewItem.parent && data.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
    writer.setAttribute("listType", type, listItem);
    if (!conversionApi.safeInsert(listItem, data.modelCursor)) {
      return;
    }
    const nextPosition = viewToModelListItemChildrenConverter(listItem, data.viewItem.getChildren(), conversionApi);
    data.modelRange = writer.createRange(data.modelCursor, nextPosition);
    conversionApi.updateConversionResult(listItem, data);
  }
};
var cleanList = (evt, data, conversionApi) => {
  if (conversionApi.consumable.test(data.viewItem, {
    name: true
  })) {
    const children = Array.from(data.viewItem.getChildren());
    for (const child of children) {
      const isWrongElement = !(child.is("element", "li") || isList(child));
      if (isWrongElement) {
        child._remove();
      }
    }
  }
};
var cleanListItem = (evt, data, conversionApi) => {
  if (conversionApi.consumable.test(data.viewItem, {
    name: true
  })) {
    if (data.viewItem.childCount === 0) {
      return;
    }
    const children = [
      ...data.viewItem.getChildren()
    ];
    let foundList = false;
    for (const child of children) {
      if (foundList && !isList(child)) {
        child._remove();
      }
      if (isList(child)) {
        foundList = true;
      }
    }
  }
};
function modelToViewPosition(view) {
  return (evt, data) => {
    if (data.isPhantom) {
      return;
    }
    const modelItem = data.modelPosition.nodeBefore;
    if (modelItem && modelItem.is("element", "listItem")) {
      const viewItem = data.mapper.toViewElement(modelItem);
      const topmostViewList = viewItem.getAncestors().find(isList);
      const walker = view.createPositionAt(viewItem, 0).getWalker();
      for (const value of walker) {
        if (value.type == "elementStart" && value.item.is("element", "li")) {
          data.viewPosition = value.previousPosition;
          break;
        } else if (value.type == "elementEnd" && value.item == topmostViewList) {
          data.viewPosition = value.nextPosition;
          break;
        }
      }
    }
  };
}
function viewToModelPosition(model) {
  return (evt, data) => {
    const viewPos = data.viewPosition;
    const viewParent = viewPos.parent;
    const mapper = data.mapper;
    if (viewParent.name == "ul" || viewParent.name == "ol") {
      if (!viewPos.isAtEnd) {
        const modelNode = mapper.toModelElement(viewPos.nodeAfter);
        data.modelPosition = model.createPositionBefore(modelNode);
      } else {
        const modelNode = mapper.toModelElement(viewPos.nodeBefore);
        const modelLength = mapper.getModelLength(viewPos.nodeBefore);
        data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);
      }
      evt.stop();
    } else if (viewParent.name == "li" && viewPos.nodeBefore && (viewPos.nodeBefore.name == "ul" || viewPos.nodeBefore.name == "ol")) {
      const modelNode = mapper.toModelElement(viewParent);
      let modelLength = 1;
      let viewList = viewPos.nodeBefore;
      while (viewList && isList(viewList)) {
        modelLength += mapper.getModelLength(viewList);
        viewList = viewList.previousSibling;
      }
      data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);
      evt.stop();
    }
  };
}
function modelChangePostFixer(model, writer) {
  const changes = model.document.differ.getChanges();
  const itemToListHead = /* @__PURE__ */ new Map();
  let applied = false;
  for (const entry of changes) {
    if (entry.type == "insert" && entry.name == "listItem") {
      _addListToFix(entry.position);
    } else if (entry.type == "insert" && entry.name != "listItem") {
      if (entry.name != "$text") {
        const item = entry.position.nodeAfter;
        if (item.hasAttribute("listIndent")) {
          writer.removeAttribute("listIndent", item);
          applied = true;
        }
        if (item.hasAttribute("listType")) {
          writer.removeAttribute("listType", item);
          applied = true;
        }
        if (item.hasAttribute("listStyle")) {
          writer.removeAttribute("listStyle", item);
          applied = true;
        }
        if (item.hasAttribute("listReversed")) {
          writer.removeAttribute("listReversed", item);
          applied = true;
        }
        if (item.hasAttribute("listStart")) {
          writer.removeAttribute("listStart", item);
          applied = true;
        }
        for (const innerItem of Array.from(model.createRangeIn(item)).filter((e) => e.item.is("element", "listItem"))) {
          _addListToFix(innerItem.previousPosition);
        }
      }
      const posAfter = entry.position.getShiftedBy(entry.length);
      _addListToFix(posAfter);
    } else if (entry.type == "remove" && entry.name == "listItem") {
      _addListToFix(entry.position);
    } else if (entry.type == "attribute" && entry.attributeKey == "listIndent") {
      _addListToFix(entry.range.start);
    } else if (entry.type == "attribute" && entry.attributeKey == "listType") {
      _addListToFix(entry.range.start);
    }
  }
  for (const listHead of itemToListHead.values()) {
    _fixListIndents(listHead);
    _fixListTypes(listHead);
  }
  return applied;
  function _addListToFix(position) {
    const previousNode = position.nodeBefore;
    if (!previousNode || !previousNode.is("element", "listItem")) {
      const item = position.nodeAfter;
      if (item && item.is("element", "listItem")) {
        itemToListHead.set(item, item);
      }
    } else {
      let listHead = previousNode;
      if (itemToListHead.has(listHead)) {
        return;
      }
      for (let previousSibling = listHead.previousSibling; previousSibling && previousSibling.is("element", "listItem"); previousSibling = listHead.previousSibling) {
        listHead = previousSibling;
        if (itemToListHead.has(listHead)) {
          return;
        }
      }
      itemToListHead.set(previousNode, listHead);
    }
  }
  function _fixListIndents(item) {
    let maxIndent = 0;
    let fixBy = null;
    while (item && item.is("element", "listItem")) {
      const itemIndent = item.getAttribute("listIndent");
      if (itemIndent > maxIndent) {
        let newIndent;
        if (fixBy === null) {
          fixBy = itemIndent - maxIndent;
          newIndent = maxIndent;
        } else {
          if (fixBy > itemIndent) {
            fixBy = itemIndent;
          }
          newIndent = itemIndent - fixBy;
        }
        writer.setAttribute("listIndent", newIndent, item);
        applied = true;
      } else {
        fixBy = null;
        maxIndent = item.getAttribute("listIndent") + 1;
      }
      item = item.nextSibling;
    }
  }
  function _fixListTypes(item) {
    let typesStack = [];
    let prev = null;
    while (item && item.is("element", "listItem")) {
      const itemIndent = item.getAttribute("listIndent");
      if (prev && prev.getAttribute("listIndent") > itemIndent) {
        typesStack = typesStack.slice(0, itemIndent + 1);
      }
      if (itemIndent != 0) {
        if (typesStack[itemIndent]) {
          const type = typesStack[itemIndent];
          if (item.getAttribute("listType") != type) {
            writer.setAttribute("listType", type, item);
            applied = true;
          }
        } else {
          typesStack[itemIndent] = item.getAttribute("listType");
        }
      }
      prev = item;
      item = item.nextSibling;
    }
  }
}
var modelIndentPasteFixer = function(evt, [content, selectable]) {
  const model = this;
  let item = content.is("documentFragment") ? content.getChild(0) : content;
  let selection;
  if (!selectable) {
    selection = model.document.selection;
  } else {
    selection = model.createSelection(selectable);
  }
  if (item && item.is("element", "listItem")) {
    const pos = selection.getFirstPosition();
    let refItem = null;
    if (pos.parent.is("element", "listItem")) {
      refItem = pos.parent;
    } else if (pos.nodeBefore && pos.nodeBefore.is("element", "listItem")) {
      refItem = pos.nodeBefore;
    }
    if (refItem) {
      const indentChange = refItem.getAttribute("listIndent");
      if (indentChange > 0) {
        while (item && item.is("element", "listItem")) {
          item._setAttribute("listIndent", item.getAttribute("listIndent") + indentChange);
          item = item.nextSibling;
        }
      }
    }
  }
};
function viewToModelListItemChildrenConverter(listItemModel, viewChildren, conversionApi) {
  const { writer, schema } = conversionApi;
  let nextPosition = writer.createPositionAfter(listItemModel);
  for (const child of viewChildren) {
    if (child.name == "ul" || child.name == "ol") {
      nextPosition = conversionApi.convertItem(child, nextPosition).modelCursor;
    } else {
      const result = conversionApi.convertItem(child, writer.createPositionAt(listItemModel, "end"));
      const convertedChild = result.modelRange.start.nodeAfter;
      const wasSplit = convertedChild && convertedChild.is("element") && !schema.checkChild(listItemModel, convertedChild.name);
      if (wasSplit) {
        if (result.modelCursor.parent.is("element", "listItem")) {
          listItemModel = result.modelCursor.parent;
        } else {
          listItemModel = findNextListItem(result.modelCursor);
        }
        nextPosition = writer.createPositionAfter(listItemModel);
      }
    }
  }
  return nextPosition;
}
function findNextListItem(startPosition) {
  const treeWalker = new TreeWalker({
    startPosition
  });
  let value;
  do {
    value = treeWalker.next();
  } while (!value.value.item.is("element", "listItem"));
  return value.value.item;
}
function hoistNestedLists(nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model) {
  const prevModelItem = getSiblingListItem(modelRemoveStartPosition.nodeBefore, {
    sameIndent: true,
    smallerIndent: true,
    listIndent: nextIndent
  });
  const mapper = conversionApi.mapper;
  const viewWriter = conversionApi.writer;
  const prevIndent = prevModelItem ? prevModelItem.getAttribute("listIndent") : null;
  let insertPosition;
  if (!prevModelItem) {
    insertPosition = viewRemoveStartPosition;
  } else if (prevIndent == nextIndent) {
    const prevViewList = mapper.toViewElement(prevModelItem).parent;
    insertPosition = viewWriter.createPositionAfter(prevViewList);
  } else {
    const modelPosition = model.createPositionAt(prevModelItem, "end");
    insertPosition = mapper.toViewPosition(modelPosition);
  }
  insertPosition = positionAfterUiElements(insertPosition);
  for (const child of [
    ...viewRemovedItem.getChildren()
  ]) {
    if (isList(child)) {
      insertPosition = viewWriter.move(viewWriter.createRangeOn(child), insertPosition).end;
      mergeViewLists(viewWriter, child, child.nextSibling);
      mergeViewLists(viewWriter, child.previousSibling, child);
    }
  }
}
function isList(viewElement) {
  return viewElement.is("element", "ol") || viewElement.is("element", "ul");
}
function getIndent(listItem) {
  let indent = 0;
  let parent = listItem.parent;
  while (parent) {
    if (parent.is("element", "li")) {
      indent++;
    } else {
      const previousSibling = parent.previousSibling;
      if (previousSibling && previousSibling.is("element", "li")) {
        indent++;
      }
    }
    parent = parent.parent;
  }
  return indent;
}
var LegacyListEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LegacyListEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Enter,
      Delete,
      LegacyListUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.schema.register("listItem", {
      inheritAllFrom: "$block",
      allowAttributes: [
        "listType",
        "listIndent"
      ]
    });
    const data = editor.data;
    const editing = editor.editing;
    editor.model.document.registerPostFixer((writer) => modelChangePostFixer(editor.model, writer));
    editing.mapper.registerViewToModelLength("li", getViewListItemLength);
    data.mapper.registerViewToModelLength("li", getViewListItemLength);
    editing.mapper.on("modelToViewPosition", modelToViewPosition(editing.view));
    editing.mapper.on("viewToModelPosition", viewToModelPosition(editor.model));
    data.mapper.on("modelToViewPosition", modelToViewPosition(editing.view));
    editor.conversion.for("editingDowncast").add((dispatcher) => {
      dispatcher.on("insert", modelViewSplitOnInsert, {
        priority: "high"
      });
      dispatcher.on("insert:listItem", modelViewInsertion$1(editor.model));
      dispatcher.on("attribute:listType:listItem", modelViewChangeType$1, {
        priority: "high"
      });
      dispatcher.on("attribute:listType:listItem", modelViewMergeAfterChangeType, {
        priority: "low"
      });
      dispatcher.on("attribute:listIndent:listItem", modelViewChangeIndent(editor.model));
      dispatcher.on("remove:listItem", modelViewRemove(editor.model));
      dispatcher.on("remove", modelViewMergeAfter, {
        priority: "low"
      });
    });
    editor.conversion.for("dataDowncast").add((dispatcher) => {
      dispatcher.on("insert", modelViewSplitOnInsert, {
        priority: "high"
      });
      dispatcher.on("insert:listItem", modelViewInsertion$1(editor.model));
    });
    editor.conversion.for("upcast").add((dispatcher) => {
      dispatcher.on("element:ul", cleanList, {
        priority: "high"
      });
      dispatcher.on("element:ol", cleanList, {
        priority: "high"
      });
      dispatcher.on("element:li", cleanListItem, {
        priority: "high"
      });
      dispatcher.on("element:li", viewModelConverter);
    });
    editor.model.on("insertContent", modelIndentPasteFixer, {
      priority: "high"
    });
    editor.commands.add("numberedList", new LegacyListCommand(editor, "numbered"));
    editor.commands.add("bulletedList", new LegacyListCommand(editor, "bulleted"));
    editor.commands.add("indentList", new LegacyIndentCommand(editor, "forward"));
    editor.commands.add("outdentList", new LegacyIndentCommand(editor, "backward"));
    const viewDocument = editing.view.document;
    this.listenTo(viewDocument, "enter", (evt, data2) => {
      const doc = this.editor.model.document;
      const positionParent = doc.selection.getLastPosition().parent;
      if (doc.selection.isCollapsed && positionParent.name == "listItem" && positionParent.isEmpty) {
        this.editor.execute("outdentList");
        data2.preventDefault();
        evt.stop();
      }
    }, {
      context: "li"
    });
    this.listenTo(viewDocument, "delete", (evt, data2) => {
      if (data2.direction !== "backward") {
        return;
      }
      const selection = this.editor.model.document.selection;
      if (!selection.isCollapsed) {
        return;
      }
      const firstPosition = selection.getFirstPosition();
      if (!firstPosition.isAtStart) {
        return;
      }
      const positionParent = firstPosition.parent;
      if (positionParent.name !== "listItem") {
        return;
      }
      const previousIsAListItem = positionParent.previousSibling && positionParent.previousSibling.name === "listItem";
      if (previousIsAListItem) {
        return;
      }
      this.editor.execute("outdentList");
      data2.preventDefault();
      evt.stop();
    }, {
      context: "li"
    });
    this.listenTo(editor.editing.view.document, "tab", (evt, data2) => {
      const commandName = data2.shiftKey ? "outdentList" : "indentList";
      const command = this.editor.commands.get(commandName);
      if (command.isEnabled) {
        editor.execute(commandName);
        data2.stopPropagation();
        data2.preventDefault();
        evt.stop();
      }
    }, {
      context: "li"
    });
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const commands = this.editor.commands;
    const indent = commands.get("indent");
    const outdent = commands.get("outdent");
    if (indent) {
      indent.registerChildCommand(commands.get("indentList"));
    }
    if (outdent) {
      outdent.registerChildCommand(commands.get("outdentList"));
    }
  }
};
function getViewListItemLength(element) {
  let length = 1;
  for (const child of element.getChildren()) {
    if (child.name == "ul" || child.name == "ol") {
      for (const item of child.getChildren()) {
        length += getViewListItemLength(item);
      }
    }
  }
  return length;
}
var LegacyList = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      LegacyListEditing,
      ListUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LegacyList";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var LegacyListStyleCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param defaultType The list type that will be used by default if the value was not specified during
  * the command execution.
  */
  constructor(editor, defaultType) {
    super(editor);
    /**
    * The default type of the list style.
    */
    __publicField(this, "defaultType");
    this.defaultType = defaultType;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options.type The type of the list style, e.g. `'disc'` or `'square'`. If `null` is specified, the default
  * style will be applied.
  */
  execute(options2 = {}) {
    this._tryToConvertItemsToList(options2);
    const model = this.editor.model;
    const listItems = getSelectedListItems(model);
    if (!listItems.length) {
      return;
    }
    model.change((writer) => {
      for (const item of listItems) {
        writer.setAttribute("listStyle", options2.type || this.defaultType, item);
      }
    });
  }
  /**
  * Checks the command's {@link #value}.
  *
  * @returns The current value.
  */
  _getValue() {
    const listItem = this.editor.model.document.selection.getFirstPosition().parent;
    if (listItem && listItem.is("element", "listItem")) {
      return listItem.getAttribute("listStyle");
    }
    return null;
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    const editor = this.editor;
    const numberedList = editor.commands.get("numberedList");
    const bulletedList = editor.commands.get("bulletedList");
    return numberedList.isEnabled || bulletedList.isEnabled;
  }
  /**
   * Checks if the provided list style is valid. Also changes the selection to a list if it's not set yet.
   *
   * @param The type of the list style. If `null` is specified, the function does nothing.
  */
  _tryToConvertItemsToList(options2) {
    if (!options2.type) {
      return;
    }
    const listType = getListTypeFromListStyleType(options2.type);
    if (!listType) {
      return;
    }
    const editor = this.editor;
    const commandName = `${listType}List`;
    const command = editor.commands.get(commandName);
    if (!command.value) {
      editor.execute(commandName);
    }
  }
};
var LegacyListReversedCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const value = this._getValue();
    this.value = value;
    this.isEnabled = value != null;
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options.reversed Whether the list should be reversed.
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const listItems = getSelectedListItems(model).filter((item) => item.getAttribute("listType") == "numbered");
    model.change((writer) => {
      for (const item of listItems) {
        writer.setAttribute("listReversed", !!options2.reversed, item);
      }
    });
  }
  /**
  * Checks the command's {@link #value}.
  *
  * @returns The current value.
  */
  _getValue() {
    const listItem = this.editor.model.document.selection.getFirstPosition().parent;
    if (listItem && listItem.is("element", "listItem") && listItem.getAttribute("listType") == "numbered") {
      return listItem.getAttribute("listReversed");
    }
    return null;
  }
};
var LegacyListStartCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const value = this._getValue();
    this.value = value;
    this.isEnabled = value != null;
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options.startIndex The list start index.
  */
  execute({ startIndex = 1 } = {}) {
    const model = this.editor.model;
    const listItems = getSelectedListItems(model).filter((item) => item.getAttribute("listType") == "numbered");
    model.change((writer) => {
      for (const item of listItems) {
        writer.setAttribute("listStart", startIndex >= 0 ? startIndex : 1, item);
      }
    });
  }
  /**
  * Checks the command's {@link #value}.
  *
  * @returns The current value.
  */
  _getValue() {
    const listItem = this.editor.model.document.selection.getFirstPosition().parent;
    if (listItem && listItem.is("element", "listItem") && listItem.getAttribute("listType") == "numbered") {
      return listItem.getAttribute("listStart");
    }
    return null;
  }
};
var DEFAULT_LIST_TYPE = "default";
var LegacyListPropertiesEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      LegacyListEditing
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LegacyListPropertiesEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.config.define("list", {
      properties: {
        styles: true,
        startIndex: false,
        reversed: false
      }
    });
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const enabledProperties = editor.config.get("list.properties");
    const strategies = createAttributeStrategies(enabledProperties);
    model.schema.extend("listItem", {
      allowAttributes: strategies.map((s) => s.attributeName)
    });
    for (const strategy of strategies) {
      strategy.addCommand(editor);
    }
    this.listenTo(editor.commands.get("indentList"), "_executeCleanup", fixListAfterIndentListCommand(editor, strategies));
    this.listenTo(editor.commands.get("outdentList"), "_executeCleanup", fixListAfterOutdentListCommand(editor, strategies));
    this.listenTo(editor.commands.get("bulletedList"), "_executeCleanup", restoreDefaultListStyle(editor));
    this.listenTo(editor.commands.get("numberedList"), "_executeCleanup", restoreDefaultListStyle(editor));
    model.document.registerPostFixer(fixListAttributesOnListItemElements(editor, strategies));
    editor.conversion.for("upcast").add(upcastListItemAttributes(strategies));
    editor.conversion.for("downcast").add(downcastListItemAttributes(strategies));
    this._mergeListAttributesWhileMergingLists(strategies);
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    if (editor.commands.get("todoList")) {
      editor.model.document.registerPostFixer(removeListItemAttributesFromTodoList(editor));
    }
  }
  /**
  * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether two lists will be merged into a single
  * one after deleting the content.
  *
  * The purpose of this action is to adjust the `listStyle`, `listReversed` and `listStart` values
  * for the list that was merged.
  *
  * Consider the following model's content:
  *
  * ```xml
  * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
  * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
  * <paragraph>[A paragraph.]</paragraph>
  * <listItem listIndent="0" listType="bulleted" listStyle="circle">UL List item 1</listItem>
  * <listItem listIndent="0" listType="bulleted" listStyle="circle">UL List item 2</listItem>
  * ```
  *
  * After removing the paragraph element, the second list will be merged into the first one.
  * We want to inherit the `listStyle` attribute for the second list from the first one.
  *
  * ```xml
  * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
  * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
  * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
  * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
  * ```
  *
  * See https://github.com/ckeditor/ckeditor5/issues/7879.
  *
  * @param attributeStrategies Strategies for the enabled attributes.
  */
  _mergeListAttributesWhileMergingLists(attributeStrategies) {
    const editor = this.editor;
    const model = editor.model;
    let firstMostOuterItem;
    this.listenTo(model, "deleteContent", (evt, [selection]) => {
      const firstPosition = selection.getFirstPosition();
      const lastPosition = selection.getLastPosition();
      if (firstPosition.parent === lastPosition.parent) {
        return;
      }
      if (!firstPosition.parent.is("element", "listItem")) {
        return;
      }
      const nextSibling = lastPosition.parent.nextSibling;
      if (!nextSibling || !nextSibling.is("element", "listItem")) {
        return;
      }
      const mostOuterItemList = getSiblingListItem(firstPosition.parent, {
        sameIndent: true,
        listIndent: nextSibling.getAttribute("listIndent")
      });
      if (!mostOuterItemList) {
        return;
      }
      if (mostOuterItemList.getAttribute("listType") === nextSibling.getAttribute("listType")) {
        firstMostOuterItem = mostOuterItemList;
      }
    }, {
      priority: "high"
    });
    this.listenTo(model, "deleteContent", () => {
      if (!firstMostOuterItem) {
        return;
      }
      model.change((writer) => {
        const secondListMostOuterItem = getSiblingListItem(firstMostOuterItem.nextSibling, {
          sameIndent: true,
          listIndent: firstMostOuterItem.getAttribute("listIndent"),
          direction: "forward"
        });
        if (!secondListMostOuterItem) {
          firstMostOuterItem = null;
          return;
        }
        const items = [
          secondListMostOuterItem,
          ...getSiblingNodes(writer.createPositionAt(secondListMostOuterItem, 0), "forward")
        ];
        for (const listItem of items) {
          for (const strategy of attributeStrategies) {
            if (strategy.appliesToListItem(listItem)) {
              const attributeName = strategy.attributeName;
              const value = firstMostOuterItem.getAttribute(attributeName);
              writer.setAttribute(attributeName, value, listItem);
            }
          }
        }
      });
      firstMostOuterItem = null;
    }, {
      priority: "low"
    });
  }
};
function createAttributeStrategies(enabledProperties) {
  const strategies = [];
  if (enabledProperties.styles) {
    strategies.push({
      attributeName: "listStyle",
      defaultValue: DEFAULT_LIST_TYPE,
      addCommand(editor) {
        editor.commands.add("listStyle", new LegacyListStyleCommand(editor, DEFAULT_LIST_TYPE));
      },
      appliesToListItem() {
        return true;
      },
      setAttributeOnDowncast(writer, listStyle, element) {
        if (listStyle && listStyle !== DEFAULT_LIST_TYPE) {
          writer.setStyle("list-style-type", listStyle, element);
        } else {
          writer.removeStyle("list-style-type", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        return listParent.getStyle("list-style-type") || DEFAULT_LIST_TYPE;
      }
    });
  }
  if (enabledProperties.reversed) {
    strategies.push({
      attributeName: "listReversed",
      defaultValue: false,
      addCommand(editor) {
        editor.commands.add("listReversed", new LegacyListReversedCommand(editor));
      },
      appliesToListItem(item) {
        return item.getAttribute("listType") == "numbered";
      },
      setAttributeOnDowncast(writer, listReversed, element) {
        if (listReversed) {
          writer.setAttribute("reversed", "reversed", element);
        } else {
          writer.removeAttribute("reversed", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        return listParent.hasAttribute("reversed");
      }
    });
  }
  if (enabledProperties.startIndex) {
    strategies.push({
      attributeName: "listStart",
      defaultValue: 1,
      addCommand(editor) {
        editor.commands.add("listStart", new LegacyListStartCommand(editor));
      },
      appliesToListItem(item) {
        return item.getAttribute("listType") == "numbered";
      },
      setAttributeOnDowncast(writer, listStart, element) {
        if (listStart == 0 || listStart > 1) {
          writer.setAttribute("start", listStart, element);
        } else {
          writer.removeAttribute("start", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        const startAttributeValue = listParent.getAttribute("start");
        return startAttributeValue >= 0 ? startAttributeValue : 1;
      }
    });
  }
  return strategies;
}
function upcastListItemAttributes(attributeStrategies) {
  return (dispatcher) => {
    dispatcher.on("element:li", (evt, data, conversionApi) => {
      if (!data.modelRange) {
        return;
      }
      const listParent = data.viewItem.parent;
      const listItem = data.modelRange.start.nodeAfter || data.modelRange.end.nodeBefore;
      for (const strategy of attributeStrategies) {
        if (strategy.appliesToListItem(listItem)) {
          const listStyle = strategy.getAttributeOnUpcast(listParent);
          conversionApi.writer.setAttribute(strategy.attributeName, listStyle, listItem);
        }
      }
    }, {
      priority: "low"
    });
  };
}
function downcastListItemAttributes(attributeStrategies) {
  return (dispatcher) => {
    for (const strategy of attributeStrategies) {
      dispatcher.on(`attribute:${strategy.attributeName}:listItem`, (evt, data, conversionApi) => {
        const viewWriter = conversionApi.writer;
        const currentElement = data.item;
        const previousElement = getSiblingListItem(currentElement.previousSibling, {
          sameIndent: true,
          listIndent: currentElement.getAttribute("listIndent"),
          direction: "backward"
        });
        const viewItem = conversionApi.mapper.toViewElement(currentElement);
        if (!areRepresentingSameList(currentElement, previousElement)) {
          viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
        }
        strategy.setAttributeOnDowncast(viewWriter, data.attributeNewValue, viewItem.parent);
      }, {
        priority: "low"
      });
    }
  };
  function areRepresentingSameList(listItem1, listItem2) {
    return listItem2 && listItem1.getAttribute("listType") === listItem2.getAttribute("listType") && listItem1.getAttribute("listIndent") === listItem2.getAttribute("listIndent") && listItem1.getAttribute("listStyle") === listItem2.getAttribute("listStyle") && listItem1.getAttribute("listReversed") === listItem2.getAttribute("listReversed") && listItem1.getAttribute("listStart") === listItem2.getAttribute("listStart");
  }
}
function fixListAfterIndentListCommand(editor, attributeStrategies) {
  return (evt, changedItems) => {
    const root2 = changedItems[0];
    const rootIndent = root2.getAttribute("listIndent");
    const itemsToUpdate = changedItems.filter((item) => item.getAttribute("listIndent") === rootIndent);
    let previousSibling = null;
    if (root2.previousSibling.getAttribute("listIndent") + 1 !== rootIndent) {
      previousSibling = getSiblingListItem(root2.previousSibling, {
        sameIndent: true,
        direction: "backward",
        listIndent: rootIndent
      });
    }
    editor.model.change((writer) => {
      for (const item of itemsToUpdate) {
        for (const strategy of attributeStrategies) {
          if (strategy.appliesToListItem(item)) {
            const valueToSet = previousSibling == null ? strategy.defaultValue : previousSibling.getAttribute(strategy.attributeName);
            writer.setAttribute(strategy.attributeName, valueToSet, item);
          }
        }
      }
    });
  };
}
function fixListAfterOutdentListCommand(editor, attributeStrategies) {
  return (evt, changedItems) => {
    changedItems = changedItems.reverse().filter((item) => item.is("element", "listItem"));
    if (!changedItems.length) {
      return;
    }
    const indent = changedItems[0].getAttribute("listIndent");
    const listType = changedItems[0].getAttribute("listType");
    let listItem = changedItems[0].previousSibling;
    if (listItem.is("element", "listItem")) {
      while (listItem.getAttribute("listIndent") !== indent) {
        listItem = listItem.previousSibling;
      }
    } else {
      listItem = null;
    }
    if (!listItem) {
      listItem = changedItems[changedItems.length - 1].nextSibling;
    }
    if (!listItem || !listItem.is("element", "listItem")) {
      return;
    }
    if (listItem.getAttribute("listType") !== listType) {
      return;
    }
    editor.model.change((writer) => {
      const itemsToUpdate = changedItems.filter((item) => item.getAttribute("listIndent") === indent);
      for (const item of itemsToUpdate) {
        for (const strategy of attributeStrategies) {
          if (strategy.appliesToListItem(item)) {
            const attributeName = strategy.attributeName;
            const valueToSet = listItem.getAttribute(attributeName);
            writer.setAttribute(attributeName, valueToSet, item);
          }
        }
      }
    });
  };
}
function fixListAttributesOnListItemElements(editor, attributeStrategies) {
  return (writer) => {
    let wasFixed = false;
    const insertedListItems = getChangedListItems(editor.model.document.differ.getChanges()).filter((item) => {
      return item.getAttribute("listType") !== "todo";
    });
    if (!insertedListItems.length) {
      return wasFixed;
    }
    let existingListItem = insertedListItems[insertedListItems.length - 1].nextSibling;
    if (!existingListItem || !existingListItem.is("element", "listItem")) {
      existingListItem = insertedListItems[0].previousSibling;
      if (existingListItem) {
        const indent = insertedListItems[0].getAttribute("listIndent");
        while (existingListItem.is("element", "listItem") && existingListItem.getAttribute("listIndent") !== indent) {
          existingListItem = existingListItem.previousSibling;
          if (!existingListItem) {
            break;
          }
        }
      }
    }
    for (const strategy of attributeStrategies) {
      const attributeName = strategy.attributeName;
      for (const item of insertedListItems) {
        if (!strategy.appliesToListItem(item)) {
          writer.removeAttribute(attributeName, item);
          continue;
        }
        if (!item.hasAttribute(attributeName)) {
          if (shouldInheritListType(existingListItem, item, strategy)) {
            writer.setAttribute(attributeName, existingListItem.getAttribute(attributeName), item);
          } else {
            writer.setAttribute(attributeName, strategy.defaultValue, item);
          }
          wasFixed = true;
        } else {
          const previousSibling = item.previousSibling;
          if (shouldInheritListTypeFromPreviousItem(previousSibling, item, strategy.attributeName)) {
            writer.setAttribute(attributeName, previousSibling.getAttribute(attributeName), item);
            wasFixed = true;
          }
        }
      }
    }
    return wasFixed;
  };
}
function shouldInheritListType(baseItem, itemToChange, attributeStrategy) {
  if (!baseItem) {
    return false;
  }
  const baseListAttribute = baseItem.getAttribute(attributeStrategy.attributeName);
  if (!baseListAttribute) {
    return false;
  }
  if (baseListAttribute == attributeStrategy.defaultValue) {
    return false;
  }
  if (baseItem.getAttribute("listType") !== itemToChange.getAttribute("listType")) {
    return false;
  }
  return true;
}
function shouldInheritListTypeFromPreviousItem(previousItem, itemToChange, attributeName) {
  if (!previousItem || !previousItem.is("element", "listItem")) {
    return false;
  }
  if (itemToChange.getAttribute("listType") !== previousItem.getAttribute("listType")) {
    return false;
  }
  const previousItemIndent = previousItem.getAttribute("listIndent");
  if (previousItemIndent < 1 || previousItemIndent !== itemToChange.getAttribute("listIndent")) {
    return false;
  }
  const previousItemListAttribute = previousItem.getAttribute(attributeName);
  if (!previousItemListAttribute || previousItemListAttribute === itemToChange.getAttribute(attributeName)) {
    return false;
  }
  return true;
}
function removeListItemAttributesFromTodoList(editor) {
  return (writer) => {
    const todoListItems = getChangedListItems(editor.model.document.differ.getChanges()).filter((item) => {
      return item.getAttribute("listType") === "todo" && (item.hasAttribute("listStyle") || item.hasAttribute("listReversed") || item.hasAttribute("listStart"));
    });
    if (!todoListItems.length) {
      return false;
    }
    for (const item of todoListItems) {
      writer.removeAttribute("listStyle", item);
      writer.removeAttribute("listReversed", item);
      writer.removeAttribute("listStart", item);
    }
    return true;
  };
}
function restoreDefaultListStyle(editor) {
  return (evt, changedItems) => {
    changedItems = changedItems.filter((item) => item.is("element", "listItem"));
    editor.model.change((writer) => {
      for (const item of changedItems) {
        writer.removeAttribute("listStyle", item);
      }
    });
  };
}
function getChangedListItems(changes) {
  const items = [];
  for (const change of changes) {
    const item = getItemFromChange(change);
    if (item && item.is("element", "listItem")) {
      items.push(item);
    }
  }
  return items;
}
function getItemFromChange(change) {
  if (change.type === "attribute") {
    return change.range.start.nodeAfter;
  }
  if (change.type === "insert") {
    return change.position.nodeAfter;
  }
  return null;
}
var LegacyListProperties = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      LegacyListPropertiesEditing,
      ListPropertiesUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LegacyListProperties";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var attributeKey = "todoListChecked";
var LegacyCheckTodoListCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * A list of to-do list items selected by the {@link module:engine/model/selection~Selection}.
    *
    * @internal
    */
    __publicField(this, "_selectedElements");
    this._selectedElements = [];
    this.on("execute", () => {
      this.refresh();
    }, {
      priority: "highest"
    });
  }
  /**
  * Updates the command's {@link #value} and {@link #isEnabled} properties based on the current selection.
  */
  refresh() {
    this._selectedElements = this._getSelectedItems();
    this.value = this._selectedElements.every((element) => !!element.getAttribute(attributeKey));
    this.isEnabled = !!this._selectedElements.length;
  }
  /**
  * Gets all to-do list items selected by the {@link module:engine/model/selection~Selection}.
  */
  _getSelectedItems() {
    const model = this.editor.model;
    const schema = model.schema;
    const selectionRange = model.document.selection.getFirstRange();
    const startElement = selectionRange.start.parent;
    const elements = [];
    if (schema.checkAttribute(startElement, attributeKey)) {
      elements.push(startElement);
    }
    for (const item of selectionRange.getItems()) {
      if (schema.checkAttribute(item, attributeKey) && !elements.includes(item)) {
        elements.push(item);
      }
    }
    return elements;
  }
  /**
  * Executes the command.
  *
  * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply
  * the attribute. Otherwise, the command will remove the attribute. If not set, the command will look for its current
  * value to decide what it should do.
  */
  execute(options2 = {}) {
    this.editor.model.change((writer) => {
      for (const element of this._selectedElements) {
        const value = options2.forceValue === void 0 ? !this.value : options2.forceValue;
        if (value) {
          writer.setAttribute(attributeKey, true, element);
        } else {
          writer.removeAttribute(attributeKey, element);
        }
      }
    });
  }
};
function modelViewInsertion(model, onCheckboxChecked) {
  return (evt, data, conversionApi) => {
    const consumable = conversionApi.consumable;
    if (!consumable.test(data.item, "insert") || !consumable.test(data.item, "attribute:listType") || !consumable.test(data.item, "attribute:listIndent")) {
      return;
    }
    if (data.item.getAttribute("listType") != "todo") {
      return;
    }
    const modelItem = data.item;
    consumable.consume(modelItem, "insert");
    consumable.consume(modelItem, "attribute:listType");
    consumable.consume(modelItem, "attribute:listIndent");
    consumable.consume(modelItem, "attribute:todoListChecked");
    const viewWriter = conversionApi.writer;
    const viewItem = generateLiInUl(modelItem, conversionApi);
    const isChecked = !!modelItem.getAttribute("todoListChecked");
    const checkmarkElement = createCheckmarkElement(modelItem, viewWriter, isChecked, onCheckboxChecked);
    const span = viewWriter.createContainerElement("span", {
      class: "todo-list__label__description"
    });
    viewWriter.addClass("todo-list", viewItem.parent);
    viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), checkmarkElement);
    viewWriter.insert(viewWriter.createPositionAfter(checkmarkElement), span);
    injectViewList(modelItem, viewItem, conversionApi, model);
  };
}
function dataModelViewInsertion(model) {
  return (evt, data, conversionApi) => {
    const consumable = conversionApi.consumable;
    if (!consumable.test(data.item, "insert") || !consumable.test(data.item, "attribute:listType") || !consumable.test(data.item, "attribute:listIndent")) {
      return;
    }
    if (data.item.getAttribute("listType") != "todo") {
      return;
    }
    const modelItem = data.item;
    consumable.consume(modelItem, "insert");
    consumable.consume(modelItem, "attribute:listType");
    consumable.consume(modelItem, "attribute:listIndent");
    consumable.consume(modelItem, "attribute:todoListChecked");
    const viewWriter = conversionApi.writer;
    const viewItem = generateLiInUl(modelItem, conversionApi);
    viewWriter.addClass("todo-list", viewItem.parent);
    const label = viewWriter.createContainerElement("label", {
      class: "todo-list__label"
    });
    const checkbox = viewWriter.createEmptyElement("input", {
      type: "checkbox",
      disabled: "disabled"
    });
    const span = viewWriter.createContainerElement("span", {
      class: "todo-list__label__description"
    });
    if (modelItem.getAttribute("todoListChecked")) {
      viewWriter.setAttribute("checked", "checked", checkbox);
    }
    viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), label);
    viewWriter.insert(viewWriter.createPositionAt(label, 0), checkbox);
    viewWriter.insert(viewWriter.createPositionAfter(checkbox), span);
    injectViewList(modelItem, viewItem, conversionApi, model);
  };
}
var dataViewModelCheckmarkInsertion = (evt, data, conversionApi) => {
  const modelCursor = data.modelCursor;
  const modelItem = modelCursor.parent;
  const viewItem = data.viewItem;
  if (viewItem.getAttribute("type") != "checkbox" || modelItem.name != "listItem" || !modelCursor.isAtStart) {
    return;
  }
  if (!conversionApi.consumable.consume(viewItem, {
    name: true
  })) {
    return;
  }
  const writer = conversionApi.writer;
  writer.setAttribute("listType", "todo", modelItem);
  if (data.viewItem.hasAttribute("checked")) {
    writer.setAttribute("todoListChecked", true, modelItem);
  }
  data.modelRange = writer.createRange(modelCursor);
};
function modelViewChangeType(onCheckedChange, view) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewItem = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    const labelElement = findLabel(viewItem, view);
    if (data.attributeNewValue == "todo") {
      const isChecked = !!data.item.getAttribute("todoListChecked");
      const checkmarkElement = createCheckmarkElement(data.item, viewWriter, isChecked, onCheckedChange);
      const span = viewWriter.createContainerElement("span", {
        class: "todo-list__label__description"
      });
      const itemRange = viewWriter.createRangeIn(viewItem);
      const nestedList = findNestedList(viewItem);
      const descriptionStart = positionAfterUiElements(itemRange.start);
      const descriptionEnd = nestedList ? viewWriter.createPositionBefore(nestedList) : itemRange.end;
      const descriptionRange = viewWriter.createRange(descriptionStart, descriptionEnd);
      viewWriter.addClass("todo-list", viewItem.parent);
      viewWriter.move(descriptionRange, viewWriter.createPositionAt(span, 0));
      viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), checkmarkElement);
      viewWriter.insert(viewWriter.createPositionAfter(checkmarkElement), span);
    } else if (data.attributeOldValue == "todo") {
      const descriptionSpan = findDescription(viewItem, view);
      viewWriter.removeClass("todo-list", viewItem.parent);
      viewWriter.remove(labelElement);
      viewWriter.move(viewWriter.createRangeIn(descriptionSpan), viewWriter.createPositionBefore(descriptionSpan));
      viewWriter.remove(descriptionSpan);
    }
  };
}
function modelViewChangeChecked(onCheckedChange) {
  return (evt, data, conversionApi) => {
    if (data.item.getAttribute("listType") != "todo") {
      return;
    }
    if (!conversionApi.consumable.consume(data.item, "attribute:todoListChecked")) {
      return;
    }
    const { mapper, writer: viewWriter } = conversionApi;
    const isChecked = !!data.item.getAttribute("todoListChecked");
    const viewItem = mapper.toViewElement(data.item);
    const oldCheckmarkElement = viewItem.getChild(0);
    const newCheckmarkElement = createCheckmarkElement(data.item, viewWriter, isChecked, onCheckedChange);
    viewWriter.insert(viewWriter.createPositionAfter(oldCheckmarkElement), newCheckmarkElement);
    viewWriter.remove(oldCheckmarkElement);
  };
}
function mapModelToViewPosition(view) {
  return (evt, data) => {
    const modelPosition = data.modelPosition;
    const parent = modelPosition.parent;
    if (!parent.is("element", "listItem") || parent.getAttribute("listType") != "todo") {
      return;
    }
    const viewLi = data.mapper.toViewElement(parent);
    const descSpan = findDescription(viewLi, view);
    if (descSpan) {
      data.viewPosition = data.mapper.findPositionIn(descSpan, modelPosition.offset);
    }
  };
}
function createCheckmarkElement(modelItem, viewWriter, isChecked, onChange) {
  const uiElement = viewWriter.createUIElement("label", {
    class: "todo-list__label",
    contenteditable: false
  }, function(domDocument) {
    const checkbox = createElement(document, "input", {
      type: "checkbox",
      tabindex: "-1"
    });
    if (isChecked) {
      checkbox.setAttribute("checked", "checked");
    }
    checkbox.addEventListener("change", () => onChange(modelItem));
    const domElement = this.toDomElement(domDocument);
    domElement.appendChild(checkbox);
    return domElement;
  });
  return uiElement;
}
function findLabel(viewItem, view) {
  const range = view.createRangeIn(viewItem);
  for (const value of range) {
    if (value.item.is("uiElement", "label")) {
      return value.item;
    }
  }
}
function findDescription(viewItem, view) {
  const range = view.createRangeIn(viewItem);
  for (const value of range) {
    if (value.item.is("containerElement", "span") && value.item.hasClass("todo-list__label__description")) {
      return value.item;
    }
  }
}
var ITEM_TOGGLE_KEYSTROKE = parseKeystroke("Ctrl+Enter");
var LegacyTodoListEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LegacyTodoListEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      LegacyListEditing
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const { editing, data, model } = editor;
    model.schema.extend("listItem", {
      allowAttributes: [
        "todoListChecked"
      ]
    });
    model.schema.addAttributeCheck((context, attributeName) => {
      const item = context.last;
      if (attributeName == "todoListChecked" && item.name == "listItem" && item.getAttribute("listType") != "todo") {
        return false;
      }
    });
    editor.commands.add("todoList", new LegacyListCommand(editor, "todo"));
    const checkTodoListCommand = new LegacyCheckTodoListCommand(editor);
    editor.commands.add("checkTodoList", checkTodoListCommand);
    editor.commands.add("todoListCheck", checkTodoListCommand);
    data.downcastDispatcher.on("insert:listItem", dataModelViewInsertion(model), {
      priority: "high"
    });
    data.upcastDispatcher.on("element:input", dataViewModelCheckmarkInsertion, {
      priority: "high"
    });
    editing.downcastDispatcher.on("insert:listItem", modelViewInsertion(model, (listItem) => this._handleCheckmarkChange(listItem)), {
      priority: "high"
    });
    editing.downcastDispatcher.on("attribute:listType:listItem", modelViewChangeType((listItem) => this._handleCheckmarkChange(listItem), editing.view));
    editing.downcastDispatcher.on("attribute:todoListChecked:listItem", modelViewChangeChecked((listItem) => this._handleCheckmarkChange(listItem)));
    editing.mapper.on("modelToViewPosition", mapModelToViewPosition(editing.view));
    data.mapper.on("modelToViewPosition", mapModelToViewPosition(editing.view));
    this.listenTo(editing.view.document, "arrowKey", jumpOverCheckmarkOnSideArrowKeyPress(model, editor.locale), {
      context: "li"
    });
    this.listenTo(editing.view.document, "keydown", (evt, data2) => {
      if (getCode(data2) === ITEM_TOGGLE_KEYSTROKE) {
        editor.execute("checkTodoList");
        evt.stop();
      }
    }, {
      priority: "high"
    });
    const listItemsToFix = /* @__PURE__ */ new Set();
    this.listenTo(model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (operation.type == "rename" && operation.oldName == "listItem") {
        const item = operation.position.nodeAfter;
        if (item.hasAttribute("todoListChecked")) {
          listItemsToFix.add(item);
        }
      } else if (operation.type == "changeAttribute" && operation.key == "listType" && operation.oldValue === "todo") {
        for (const item of operation.range.getItems()) {
          if (item.hasAttribute("todoListChecked") && item.getAttribute("listType") !== "todo") {
            listItemsToFix.add(item);
          }
        }
      }
    });
    model.document.registerPostFixer((writer) => {
      let hasChanged = false;
      for (const listItem of listItemsToFix) {
        writer.removeAttribute("todoListChecked", listItem);
        hasChanged = true;
      }
      listItemsToFix.clear();
      return hasChanged;
    });
    this._initAriaAnnouncements();
  }
  /**
  * Handles the checkbox element change, moves the selection to the corresponding model item to make it possible
  * to toggle the `todoListChecked` attribute using the command, and restores the selection position.
  *
  * Some say it's a hack :) Moving the selection only for executing the command on a certain node and restoring it after,
  * is not a clear solution. We need to design an API for using commands beyond the selection range.
  * See https://github.com/ckeditor/ckeditor5/issues/1954.
  */
  _handleCheckmarkChange(listItem) {
    const editor = this.editor;
    const model = editor.model;
    const previousSelectionRanges = Array.from(model.document.selection.getRanges());
    model.change((writer) => {
      writer.setSelection(listItem, "end");
      editor.execute("checkTodoList");
      writer.setSelection(previousSelectionRanges);
    });
  }
  /**
  * Observe when user enters or leaves todo list and set proper aria value in global live announcer.
  * This allows screen readers to indicate when the user has entered and left the specified todo list.
  *
  * @internal
  */
  _initAriaAnnouncements() {
    const { model, ui, t } = this.editor;
    let lastFocusedCodeBlock = null;
    if (!ui) {
      return;
    }
    model.document.selection.on("change:range", () => {
      const focusParent = model.document.selection.focus.parent;
      const lastElementIsTodoList = isLegacyTodoListItemElement(lastFocusedCodeBlock);
      const currentElementIsTodoList = isLegacyTodoListItemElement(focusParent);
      if (lastElementIsTodoList && !currentElementIsTodoList) {
        ui.ariaLiveAnnouncer.announce(t("Leaving a to-do list"));
      } else if (!lastElementIsTodoList && currentElementIsTodoList) {
        ui.ariaLiveAnnouncer.announce(t("Entering a to-do list"));
      }
      lastFocusedCodeBlock = focusParent;
    });
  }
};
function jumpOverCheckmarkOnSideArrowKeyPress(model, locale) {
  return (eventInfo, domEventData) => {
    const direction = getLocalizedArrowKeyCodeDirection(domEventData.keyCode, locale.contentLanguageDirection);
    if (direction != "left") {
      return;
    }
    const schema = model.schema;
    const selection = model.document.selection;
    if (!selection.isCollapsed) {
      return;
    }
    const position = selection.getFirstPosition();
    const parent = position.parent;
    if (parent.name === "listItem" && parent.getAttribute("listType") == "todo" && position.isAtStart) {
      const newRange = schema.getNearestSelectionRange(model.createPositionBefore(parent), "backward");
      if (newRange) {
        model.change((writer) => writer.setSelection(newRange));
      }
      domEventData.preventDefault();
      domEventData.stopPropagation();
      eventInfo.stop();
    }
  };
}
function isLegacyTodoListItemElement(element) {
  return !!element && element.is("element", "listItem") && element.getAttribute("listType") === "todo";
}
var LegacyTodoList = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      LegacyTodoListEditing,
      TodoListUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LegacyTodoList";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var AdjacentListsSupport = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "AdjacentListsSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    model.schema.register("listSeparator", {
      allowWhere: "$block",
      isBlock: true
    });
    editor.conversion.for("upcast").add((dispatcher) => {
      dispatcher.on("element:ol", listSeparatorUpcastConverter());
      dispatcher.on("element:ul", listSeparatorUpcastConverter());
    }).elementToElement({
      model: "listSeparator",
      view: "ck-list-separator"
    });
    editor.conversion.for("editingDowncast").elementToElement({
      model: "listSeparator",
      view: {
        name: "div",
        classes: [
          "ck-list-separator",
          "ck-hidden"
        ]
      }
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "listSeparator",
      view: (modelElement, conversionApi) => {
        const viewElement = conversionApi.writer.createContainerElement("ck-list-separator");
        conversionApi.writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
        viewElement.getFillerOffset = () => null;
        return viewElement;
      }
    });
  }
};
function listSeparatorUpcastConverter() {
  return (evt, data, conversionApi) => {
    const element = data.viewItem;
    const nextSibling = element.nextSibling;
    if (!nextSibling) {
      return;
    }
    if (element.name !== nextSibling.name) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    const writer = conversionApi.writer;
    const modelElement = writer.createElement("listSeparator");
    if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
      return;
    }
    const parts = conversionApi.getSplitParts(modelElement);
    data.modelRange = writer.createRange(data.modelRange.start, writer.createPositionAfter(parts[parts.length - 1]));
    conversionApi.updateConversionResult(modelElement, data);
  };
}
var DocumentList = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      List
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "DocumentList";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  constructor(editor) {
    super(editor);
    logWarning("plugin-obsolete-documentlist", {
      pluginName: "DocumentList"
    });
  }
};
var DocumentListProperties = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ListProperties
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "DocumentListProperties";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  constructor(editor) {
    super(editor);
    logWarning("plugin-obsolete-documentlistproperties", {
      pluginName: "DocumentListProperties"
    });
  }
};
var TodoDocumentList = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TodoList
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TodoDocumentList";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  constructor(editor) {
    super(editor);
    logWarning("plugin-obsolete-tododocumentlist", {
      pluginName: "TodoDocumentList"
    });
  }
};

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = /[&<>"']/g;
var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon") return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
var noopTest = { exec: function noopTest2() {
} };
function merge(obj) {
  let i = 1, target, key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count2) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\") escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count2) {
    cells.splice(count2);
  } else {
    while (cells.length < count2) cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.substr(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count2) {
  if (count2 < 1) {
    return "";
  }
  let result = "";
  while (count2 > 1) {
    if (count2 & 1) {
      result += pattern;
    }
    count2 >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text, [])
    };
    lexer2.state.inLink = false;
    return token;
  } else {
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape(text)
    };
  }
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim() : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *> ?/gm, "");
      return {
        type: "blockquote",
        raw: cap[0],
        tokens: this.lexer.blockTokens(text, []),
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?: [^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0];
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            line = rawLine;
            if (this.options.pedantic) {
              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (nextBulletRegex.test(line)) {
              break;
            }
            if (line.search(/[^ ]/) >= indent || !line.trim()) {
              itemContents += "\n" + line.slice(indent);
            } else if (!blankLine) {
              itemContents += "\n" + line;
            } else {
              break;
            }
            if (!blankLine && !line.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        const spacers = list.items[i].tokens.filter((t) => t.type === "space");
        const hasMultipleLineBreaks = spacers.every((t) => {
          const chars = t.raw.split("");
          let lineBreaks = 0;
          for (const char of chars) {
            if (char === "\n") {
              lineBreaks += 1;
            }
            if (lineBreaks > 1) {
              return true;
            }
          }
          return false;
        });
        if (!list.loose && spacers.length && hasMultipleLineBreaks) {
          list.loose = true;
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        token.type = "paragraph";
        token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.tokens = [];
        this.lexer.inline(token.text, token.tokens);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      return {
        type: "def",
        tag,
        raw: cap[0],
        href: cap[2],
        title: cap[3]
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j2, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l = item.header.length;
        for (j2 = 0; j2 < l; j2++) {
          item.header[j2].tokens = [];
          this.lexer.inlineTokens(item.header[j2].text, item.header[j2].tokens);
        }
        l = item.rows.length;
        for (j2 = 0; j2 < l; j2++) {
          row = item.rows[j2];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = [];
            this.lexer.inlineTokens(row[k].text, row[k].tokens);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const token = {
        type: "paragraph",
        raw: cap[0],
        text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      const token = {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link || !link.href) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match) return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim) continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0) continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = src.slice(1, lLength + match.index + rLength);
          return {
            type: "em",
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: text2,
            tokens: this.lexer.inlineTokens(text2, [])
          };
        }
        const text = src.slice(2, lLength + match.index + rLength - 1);
        return {
          type: "strong",
          raw: src.slice(0, lLength + match.index + rLength + 1),
          text,
          tokens: this.lexer.inlineTokens(text, [])
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2], [])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + text;
        } else {
          href = text;
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = merge({}, block);
block.gfm = merge({}, block.normal, {
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
});
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = merge({}, block.normal, {
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
});
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //        () Skip orphan delim inside strong    (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /\\\*|\\_/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = merge({}, inline);
inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
});
inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
function smartypants(text) {
  return text.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
var Lexer = class _Lexer {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules3 = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules3.block = block.pedantic;
      rules3.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules3.block = block.gfm;
      if (this.options.breaks) {
        rules3.inline = inline.breaks;
      } else {
        rules3.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules3;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new _Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new _Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
    this.blockTokens(src, this.tokens);
    let next2;
    while (next2 = this.inlineQueue.shift()) {
      this.inlineTokens(next2.src, next2.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/^ +$/gm, "");
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens) {
    this.inlineQueue.push({ src, tokens });
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var Renderer2 = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return "<blockquote>\n" + quote + "</blockquote>\n";
  }
  html(html) {
    return html;
  }
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
    }
    return "<h" + level + ">" + text + "</h" + level + ">\n";
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text) {
    return "<li>" + text + "</li>\n";
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  paragraph(text) {
    return "<p>" + text + "</p>\n";
  }
  table(header, body) {
    if (body) body = "<tbody>" + body + "</tbody>";
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return "<tr>\n" + content + "</tr>\n";
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
    return tag + content + "</" + type + ">\n";
  }
  // span level renderer
  strong(text) {
    return "<strong>" + text + "</strong>";
  }
  em(text) {
    return "<em>" + text + "</em>";
  }
  codespan(text) {
    return "<code>" + text + "</code>";
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(text) {
    return "<del>" + text + "</del>";
  }
  link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + escape(href) + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<img src="' + href + '" alt="' + text + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var TextRenderer = class {
  // no need for block level renderers
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var Slugger = class {
  constructor() {
    this.seen = {};
  }
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} options
   * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
   */
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var Parser = class _Parser {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer2();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new _Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new _Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "", i, j2, k, l2, l3, row, cell2, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header = "";
          cell2 = "";
          l2 = token.header.length;
          for (j2 = 0; j2 < l2; j2++) {
            cell2 += this.renderer.tablecell(
              this.parseInline(token.header[j2].tokens),
              { header: true, align: token.align[j2] }
            );
          }
          header += this.renderer.tablerow(cell2);
          body = "";
          l2 = token.rows.length;
          for (j2 = 0; j2 < l2; j2++) {
            row = token.rows[j2];
            cell2 = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell2 += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                { header: false, align: token.align[k] }
              );
            }
            body += this.renderer.tablerow(cell2);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j2 = 0; j2 < l2; j2++) {
            item = token.items[j2];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i, token, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
function marked(src, opt, callback) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  if (typeof opt === "function") {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    const highlight = opt.highlight;
    let tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    const done = function(err) {
      let out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done();
    }
    delete opt.highlight;
    if (!tokens.length) return done();
    let pending = 0;
    marked.walkTokens(tokens, function(token) {
      if (token.type === "code") {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done();
    }
    return;
  }
  try {
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parse(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
}
marked.options = marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const opts = merge({}, ...args);
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  let hasExtensions;
  args.forEach((pack) => {
    if (pack.extensions) {
      hasExtensions = true;
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer2();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.walkTokens) {
      const walkTokens2 = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        pack.walkTokens.call(this, token);
        if (walkTokens2) {
          walkTokens2.call(this, token);
        }
      };
    }
    if (hasExtensions) {
      opts.extensions = extensions;
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  for (const token of tokens) {
    callback.call(marked, token);
    switch (token.type) {
      case "table": {
        for (const cell2 of token.header) {
          marked.walkTokens(cell2.tokens, callback);
        }
        for (const row of token.rows) {
          for (const cell2 of row) {
            marked.walkTokens(cell2.tokens, callback);
          }
        }
        break;
      }
      case "list": {
        marked.walkTokens(token.items, callback);
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            marked.walkTokens(token[childTokens], callback);
          });
        } else if (token.tokens) {
          marked.walkTokens(token.tokens, callback);
        }
      }
    }
  }
};
marked.parseInline = function(src, opt) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked.parseInline(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  try {
    const tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parseInline(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
};
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer2;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = Parser.parse;
var lexer = Lexer.lex;

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key)) destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count2) {
  return Array(count2 + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n") indexEnd--;
  return string.substring(0, indexEnd);
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options2) {
    return options2.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options2) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options2.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = content.replace(/^\n+|\n+$/g, "");
    content = content.replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options2) {
    content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
    var prefix = options2.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + ".  ";
    }
    return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options2) {
    return options2.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options2) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options2) {
    return options2.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options2) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code = node.firstChild.textContent;
    var fenceChar = options2.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options2) {
    return "\n\n" + options2.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options2) {
    return options2.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    if (href) href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options2) {
    return options2.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options2) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options2.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference = "[" + id + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options2) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options2) {
    if (!content.trim()) return "";
    return options2.emDelimiter + content + options2.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options2) {
    if (!content.trim()) return "";
    return options2.strongDelimiter + content + options2.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content) return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + "`";
    return delimiter + extraSpace + content + extraSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options2) {
  this.options = options2;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options2.blankReplacement
  };
  this.keepReplacement = options2.keepReplacement;
  this.defaultRule = {
    replacement: options2.defaultReplacement
  };
  this.array = [];
  for (var key in options2.rules) this.array.push(options2.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank) return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options)) return rule;
    if (rule = findRule(this._keep, node, this.options)) return rule;
    if (rule = findRule(this._remove, node, this.options)) return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);
  }
};
function findRule(rules3, node, options2) {
  for (var i = 0; i < rules3.length; i++) {
    var rule = rules3[i];
    if (filterValue(rule, node, options2)) return rule;
  }
  return void 0;
}
function filterValue(rule, node, options2) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase()) return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options2)) return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options2) {
  var element = options2.element;
  var isBlock2 = options2.isBlock;
  var isVoid2 = options2.isVoid;
  var isPre = options2.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element)) return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node = remove2(node);
        continue;
      }
      node.data = text;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove2(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove2(prevText);
    }
  }
}
function remove2(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser2 = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser2().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser2 = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser2.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser2.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser2;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (root.ActiveXObject) useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options2) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options2.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node(node, options2) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options2);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options2) {
  if (node.isBlock || options2.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options2)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options2)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options2) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options2.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options2) {
  if (!(this instanceof TurndownService)) return new TurndownService(options2);
  var defaults2 = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults2, options2);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "") return "";
    var output = process.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape2) {
      return accumulator.replace(escape2[0], escape2[1]);
    }, string);
  }
};
function process(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node(node, self.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing) content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_browser_es_default = TurndownService;

// node_modules/turndown-plugin-gfm/lib/turndown-plugin-gfm.es.js
var highlightRegExp = /highlight-(?:text|source)-([a-z0-9]+)/;
function highlightedCodeBlock(turndownService) {
  turndownService.addRule("highlightedCodeBlock", {
    filter: function(node) {
      var firstChild = node.firstChild;
      return node.nodeName === "DIV" && highlightRegExp.test(node.className) && firstChild && firstChild.nodeName === "PRE";
    },
    replacement: function(content, node, options2) {
      var className = node.className || "";
      var language = (className.match(highlightRegExp) || [null, ""])[1];
      return "\n\n" + options2.fence + language + "\n" + node.firstChild.textContent + "\n" + options2.fence + "\n\n";
    }
  });
}
function strikethrough(turndownService) {
  turndownService.addRule("strikethrough", {
    filter: ["del", "s", "strike"],
    replacement: function(content) {
      return "~" + content + "~";
    }
  });
}
var indexOf2 = Array.prototype.indexOf;
var every = Array.prototype.every;
var rules2 = {};
rules2.tableCell = {
  filter: ["th", "td"],
  replacement: function(content, node) {
    return cell(content, node);
  }
};
rules2.tableRow = {
  filter: "tr",
  replacement: function(content, node) {
    var borderCells = "";
    var alignMap = { left: ":--", right: "--:", center: ":-:" };
    if (isHeadingRow(node)) {
      for (var i = 0; i < node.childNodes.length; i++) {
        var border = "---";
        var align = (node.childNodes[i].getAttribute("align") || "").toLowerCase();
        if (align) border = alignMap[align] || border;
        borderCells += cell(border, node.childNodes[i]);
      }
    }
    return "\n" + content + (borderCells ? "\n" + borderCells : "");
  }
};
rules2.table = {
  // Only convert tables with a heading row.
  // Tables with no heading row are kept using `keep` (see below).
  filter: function(node) {
    return node.nodeName === "TABLE" && isHeadingRow(node.rows[0]);
  },
  replacement: function(content) {
    content = content.replace("\n\n", "\n");
    return "\n\n" + content + "\n\n";
  }
};
rules2.tableSection = {
  filter: ["thead", "tbody", "tfoot"],
  replacement: function(content) {
    return content;
  }
};
function isHeadingRow(tr) {
  var parentNode = tr.parentNode;
  return parentNode.nodeName === "THEAD" || parentNode.firstChild === tr && (parentNode.nodeName === "TABLE" || isFirstTbody(parentNode)) && every.call(tr.childNodes, function(n) {
    return n.nodeName === "TH";
  });
}
function isFirstTbody(element) {
  var previousSibling = element.previousSibling;
  return element.nodeName === "TBODY" && (!previousSibling || previousSibling.nodeName === "THEAD" && /^\s*$/i.test(previousSibling.textContent));
}
function cell(content, node) {
  var index = indexOf2.call(node.parentNode.childNodes, node);
  var prefix = " ";
  if (index === 0) prefix = "| ";
  return prefix + content + " |";
}
function tables(turndownService) {
  turndownService.keep(function(node) {
    return node.nodeName === "TABLE" && !isHeadingRow(node.rows[0]);
  });
  for (var key in rules2) turndownService.addRule(key, rules2[key]);
}
function taskListItems(turndownService) {
  turndownService.addRule("taskListItems", {
    filter: function(node) {
      return node.type === "checkbox" && node.parentNode.nodeName === "LI";
    },
    replacement: function(content, node) {
      return (node.checked ? "[x]" : "[ ]") + " ";
    }
  });
}
function gfm(turndownService) {
  turndownService.use([
    highlightedCodeBlock,
    strikethrough,
    tables,
    taskListItems
  ]);
}

// node_modules/@ckeditor/ckeditor5-markdown-gfm/dist/index.js
var MarkdownToHtml = class {
  constructor() {
    __publicField(this, "_parser");
    __publicField(this, "_options", {
      gfm: true,
      breaks: true,
      tables: true,
      xhtml: true,
      headerIds: false
    });
    marked.use({
      tokenizer: {
        // Disable the autolink rule in the lexer.
        autolink: () => null,
        url: () => null
      },
      renderer: {
        checkbox(...args) {
          return Object.getPrototypeOf(this).checkbox.call(this, ...args).trimRight();
        },
        code(...args) {
          return Object.getPrototypeOf(this).code.call(this, ...args).replace("\n</code>", "</code>");
        }
      }
    });
    this._parser = marked;
  }
  parse(markdown) {
    return this._parser.parse(markdown, this._options);
  }
};
var autolinkRegex = new RegExp(
  // Prefix.
  /\b(?:(?:https?|ftp):\/\/|www\.)/.source + // Domain name.
  /(?![-_])(?:[-_a-z0-9\u00a1-\uffff]{1,63}\.)+(?:[a-z\u00a1-\uffff]{2,63})/.source + // The rest.
  /(?:[^\s<>]*)/.source,
  "gi"
);
var UpdatedTurndown = class extends turndown_browser_es_default {
  escape(string) {
    const originalEscape = super.escape;
    function escape2(string2) {
      string2 = originalEscape(string2);
      string2 = string2.replace(/</g, "\\<");
      return string2;
    }
    let escaped = "";
    let lastLinkEnd = 0;
    for (const match of this._matchAutolink(string)) {
      const index = match.index;
      if (index > lastLinkEnd) {
        escaped += escape2(string.substring(lastLinkEnd, index));
      }
      const matchedURL = match[0];
      escaped += matchedURL;
      lastLinkEnd = index + matchedURL.length;
    }
    if (lastLinkEnd < string.length) {
      escaped += escape2(string.substring(lastLinkEnd, string.length));
    }
    return escaped;
  }
  /**
  * Trimming end of link.
  * https://github.github.com/gfm/#autolinks-extension-
  */
  *_matchAutolink(string) {
    for (const match of string.matchAll(autolinkRegex)) {
      const matched = match[0];
      const length = this._autolinkFindEnd(matched);
      yield Object.assign([
        matched.substring(0, length)
      ], {
        index: match.index
      });
    }
  }
  /**
  * Returns the new length of the link (after it would trim trailing characters).
  */
  _autolinkFindEnd(string) {
    let length = string.length;
    while (length > 0) {
      const char = string[length - 1];
      if (`?!.,:*_~'"`.includes(char)) {
        length--;
      } else if (char == ")") {
        let openBrackets = 0;
        for (let i = 0; i < length; i++) {
          if (string[i] == "(") {
            openBrackets++;
          } else if (string[i] == ")") {
            openBrackets--;
          }
        }
        if (openBrackets < 0) {
          length--;
        } else {
          break;
        }
      } else {
        break;
      }
    }
    return length;
  }
};
var HtmlToMarkdown = class {
  constructor() {
    __publicField(this, "_parser");
    this._parser = this._createParser();
  }
  parse(html) {
    return this._parser.turndown(html);
  }
  keep(elements) {
    this._parser.keep(elements);
  }
  _createParser() {
    const parser2 = new UpdatedTurndown({
      codeBlockStyle: "fenced",
      hr: "---",
      headingStyle: "atx"
    });
    parser2.use([
      gfm,
      this._todoList
    ]);
    return parser2;
  }
  // This is a copy of the original taskListItems rule from turndown-plugin-gfm, with minor changes.
  _todoList(turndown) {
    turndown.addRule("taskListItems", {
      filter(node) {
        return node.type === "checkbox" && // Changes here as CKEditor outputs a deeper structure.
        (node.parentNode.nodeName === "LI" || node.parentNode.parentNode.nodeName === "LI");
      },
      replacement(content, node) {
        return (node.checked ? "[x]" : "[ ]") + " ";
      }
    });
  }
};
var GFMDataProcessor = class {
  /**
  * Creates a new instance of the Markdown data processor class.
  */
  constructor(document2) {
    /**
    * HTML data processor used to process HTML produced by the Markdown-to-HTML converter and the other way.
    */
    __publicField(this, "_htmlDP");
    /**
    * Helper for converting Markdown to HTML.
    */
    __publicField(this, "_markdown2html");
    /**
    * Helper for converting HTML to Markdown.
    */
    __publicField(this, "_html2markdown");
    this._htmlDP = new HtmlDataProcessor(document2);
    this._markdown2html = new MarkdownToHtml();
    this._html2markdown = new HtmlToMarkdown();
  }
  /**
  * Keeps the specified element in the output as HTML. This is useful if the editor contains
  * features producing HTML that is not a part of the Markdown standard.
  *
  * By default, all HTML tags are removed.
  *
  * @param element The element name to be kept.
  */
  keepHtml(element) {
    this._html2markdown.keep([
      element
    ]);
  }
  /**
  * Converts the provided Markdown string to a view tree.
  *
  * @param data A Markdown string.
  * @returns The converted view element.
  */
  toView(data) {
    const html = this._markdown2html.parse(data);
    return this._htmlDP.toView(html);
  }
  /**
  * Converts the provided {@link module:engine/view/documentfragment~DocumentFragment} to data format &ndash; in this
  * case to a Markdown string.
  *
  * @returns Markdown string.
  */
  toData(viewFragment) {
    const html = this._htmlDP.toData(viewFragment);
    return this._html2markdown.parse(html);
  }
  /**
  * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
  * and not processed during the conversion from Markdown to view elements.
  *
  * The raw data can be later accessed by a
  * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
  *
  * @param pattern The pattern matching all view elements whose content should
  * be treated as raw data.
  */
  registerRawContentMatcher(pattern) {
    this._htmlDP.registerRawContentMatcher(pattern);
  }
  /**
  * This method does not have any effect on the data processor result. It exists for compatibility with the
  * {@link module:engine/dataprocessor/dataprocessor~DataProcessor `DataProcessor` interface}.
  */
  useFillerType() {
  }
};
var Markdown = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    editor.data.processor = new GFMDataProcessor(editor.data.viewDocument);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Markdown";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var ALLOWED_MARKDOWN_FIRST_LEVEL_TAGS = [
  "SPAN",
  "BR",
  "PRE",
  "CODE"
];
var PasteFromMarkdownExperimental = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * @internal
    */
    __publicField(this, "_gfmDataProcessor");
    this._gfmDataProcessor = new GFMDataProcessor(editor.data.viewDocument);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PasteFromMarkdownExperimental";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ClipboardPipeline
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    let shiftPressed = false;
    this.listenTo(viewDocument, "keydown", (evt, data) => {
      shiftPressed = data.shiftKey;
    });
    this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
      if (shiftPressed) {
        return;
      }
      const dataAsTextHtml = data.dataTransfer.getData("text/html");
      if (!dataAsTextHtml) {
        const dataAsTextPlain = data.dataTransfer.getData("text/plain");
        data.content = this._gfmDataProcessor.toView(dataAsTextPlain);
        return;
      }
      const markdownFromHtml = this._parseMarkdownFromHtml(dataAsTextHtml);
      if (markdownFromHtml) {
        data.content = this._gfmDataProcessor.toView(markdownFromHtml);
      }
    });
  }
  /**
  * Determines if the code copied from a website in the `text/html` type can be parsed as Markdown.
  * It removes any OS-specific HTML tags, for example, <meta> on macOS and <!--StartFragment--> on Windows.
  * Then removes a single wrapper HTML tag or wrappers for sibling tags, and if there are no more tags left,
  * returns the remaining text. Returns null if there are any remaining HTML tags detected.
  *
  * @param htmlString Clipboard content in the `text/html` type format.
  */
  _parseMarkdownFromHtml(htmlString) {
    const withoutOsSpecificTags = this._removeOsSpecificTags(htmlString);
    if (!this._containsOnlyAllowedFirstLevelTags(withoutOsSpecificTags)) {
      return null;
    }
    const withoutWrapperTag = this._removeFirstLevelWrapperTagsAndBrs(withoutOsSpecificTags);
    if (this._containsAnyRemainingHtmlTags(withoutWrapperTag)) {
      return null;
    }
    return this._replaceHtmlReservedEntitiesWithCharacters(withoutWrapperTag);
  }
  /**
  * Removes OS-specific tags.
  *
  * @param htmlString Clipboard content in the `text/html` type format.
  */
  _removeOsSpecificTags(htmlString) {
    const withoutMetaTag = htmlString.replace(/^<meta\b[^>]*>/, "").trim();
    const withoutHtmlTag = withoutMetaTag.replace(/^<html>/, "").replace(/<\/html>$/, "").trim();
    const withoutBodyTag = withoutHtmlTag.replace(/^<body>/, "").replace(/<\/body>$/, "").trim();
    return withoutBodyTag.replace(/^<!--StartFragment-->/, "").replace(/<!--EndFragment-->$/, "").trim();
  }
  /**
  * If the input HTML string contains any first-level formatting tags
  * like <b>, <strong>, or <i>, we should not treat it as Markdown.
  *
  * @param htmlString Clipboard content.
  */
  _containsOnlyAllowedFirstLevelTags(htmlString) {
    const parser2 = new DOMParser();
    const { body: tempElement } = parser2.parseFromString(htmlString, "text/html");
    const tagNames = Array.from(tempElement.children).map((el) => el.tagName);
    return tagNames.every((el) => ALLOWED_MARKDOWN_FIRST_LEVEL_TAGS.includes(el));
  }
  /**
  * Removes multiple HTML wrapper tags from a list of sibling HTML tags.
  *
  * @param htmlString Clipboard content without any OS-specific tags.
  */
  _removeFirstLevelWrapperTagsAndBrs(htmlString) {
    const parser2 = new DOMParser();
    const { body: tempElement } = parser2.parseFromString(htmlString, "text/html");
    const brElements = tempElement.querySelectorAll("br");
    for (const br of brElements) {
      br.replaceWith("\n");
    }
    const outerElements = tempElement.querySelectorAll(":scope > *");
    for (const element of outerElements) {
      const elementClone = element.cloneNode(true);
      element.replaceWith(...elementClone.childNodes);
    }
    return tempElement.innerHTML;
  }
  /**
  * Determines if a string contains any HTML tags.
  */
  _containsAnyRemainingHtmlTags(str) {
    return str.includes("<");
  }
  /**
  * Replaces the reserved HTML entities with the actual characters.
  *
  * @param htmlString Clipboard content without any tags.
  */
  _replaceHtmlReservedEntitiesWithCharacters(htmlString) {
    return htmlString.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&nbsp;/g, " ");
  }
};

// node_modules/@ckeditor/ckeditor5-media-embed/dist/index.js
function modelToViewUrlAttributeConverter(registry, options2) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const url = data.attributeNewValue;
    const viewWriter = conversionApi.writer;
    const figure = conversionApi.mapper.toViewElement(data.item);
    const mediaContentElement = [
      ...figure.getChildren()
    ].find((child) => child.getCustomProperty("media-content"));
    viewWriter.remove(mediaContentElement);
    const mediaViewElement = registry.getMediaViewElement(viewWriter, url, options2);
    viewWriter.insert(viewWriter.createPositionAt(figure, 0), mediaViewElement);
  };
  return (dispatcher) => {
    dispatcher.on("attribute:url:media", converter);
  };
}
function toMediaWidget(viewElement, writer, label) {
  writer.setCustomProperty("media", true, viewElement);
  return toWidget(viewElement, writer, {
    label
  });
}
function getSelectedMediaViewWidget(selection) {
  const viewElement = selection.getSelectedElement();
  if (viewElement && isMediaWidget(viewElement)) {
    return viewElement;
  }
  return null;
}
function isMediaWidget(viewElement) {
  return !!viewElement.getCustomProperty("media") && isWidget(viewElement);
}
function createMediaFigureElement(writer, registry, url, options2) {
  return writer.createContainerElement("figure", {
    class: "media"
  }, [
    registry.getMediaViewElement(writer, url, options2),
    writer.createSlot()
  ]);
}
function getSelectedMediaModelWidget(selection) {
  const selectedElement = selection.getSelectedElement();
  if (selectedElement && selectedElement.is("element", "media")) {
    return selectedElement;
  }
  return null;
}
function insertMedia(model, url, selectable, findOptimalPosition) {
  model.change((writer) => {
    const mediaElement = writer.createElement("media", {
      url
    });
    model.insertObject(mediaElement, selectable, null, {
      setSelection: "on",
      findOptimalPosition: findOptimalPosition ? "auto" : void 0
    });
  });
}
var MediaEmbedCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedMedia = getSelectedMediaModelWidget(selection);
    this.value = selectedMedia ? selectedMedia.getAttribute("url") : void 0;
    this.isEnabled = isMediaSelected(selection) || isAllowedInParent(selection, model);
  }
  /**
  * Executes the command, which either:
  *
  * * updates the URL of the selected media,
  * * inserts the new media into the editor and puts the selection around it.
  *
  * @fires execute
  * @param url The URL of the media.
  */
  execute(url) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedMedia = getSelectedMediaModelWidget(selection);
    if (selectedMedia) {
      model.change((writer) => {
        writer.setAttribute("url", url, selectedMedia);
      });
    } else {
      insertMedia(model, url, selection, true);
    }
  }
};
function isAllowedInParent(selection, model) {
  const insertionRange = findOptimalInsertionRange(selection, model);
  let parent = insertionRange.start.parent;
  if (parent.isEmpty && !model.schema.isLimit(parent)) {
    parent = parent.parent;
  }
  return model.schema.checkChild(parent, "media");
}
function isMediaSelected(selection) {
  const element = selection.getSelectedElement();
  return !!element && element.name === "media";
}
var mediaPlaceholderIcon = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>';
var mediaPlaceholderIconViewBox = "0 0 64 42";
var MediaRegistry = class {
  /**
  * Creates an instance of the {@link module:media-embed/mediaregistry~MediaRegistry} class.
  *
  * @param locale The localization services instance.
  * @param config The configuration of the media embed feature.
  */
  constructor(locale, config) {
    /**
    * The {@link module:utils/locale~Locale} instance.
    */
    __publicField(this, "locale");
    /**
    * The media provider definitions available for the registry. Usually corresponding with the
    * {@link module:media-embed/mediaembedconfig~MediaEmbedConfig media configuration}.
    */
    __publicField(this, "providerDefinitions");
    const providers = config.providers;
    const extraProviders = config.extraProviders || [];
    const removedProviders = new Set(config.removeProviders);
    const providerDefinitions = providers.concat(extraProviders).filter((provider) => {
      const name = provider.name;
      if (!name) {
        logWarning("media-embed-no-provider-name", {
          provider
        });
        return false;
      }
      return !removedProviders.has(name);
    });
    this.locale = locale;
    this.providerDefinitions = providerDefinitions;
  }
  /**
  * Checks whether the passed URL is representing a certain media type allowed in the editor.
  *
  * @param url The URL to be checked
  */
  hasMedia(url) {
    return !!this._getMedia(url);
  }
  /**
  * For the given media URL string and options, it returns the {@link module:engine/view/element~Element view element}
  * representing that media.
  *
  * **Note:** If no URL is specified, an empty view element is returned.
  *
  * @param writer The view writer used to produce a view element.
  * @param url The URL to be translated into a view element.
  */
  getMediaViewElement(writer, url, options2) {
    return this._getMedia(url).getViewElement(writer, options2);
  }
  /**
  * Returns a `Media` instance for the given URL.
  *
  * @param url The URL of the media.
  * @returns The `Media` instance or `null` when there is none.
  */
  _getMedia(url) {
    if (!url) {
      return new Media(this.locale);
    }
    url = url.trim();
    for (const definition of this.providerDefinitions) {
      const previewRenderer = definition.html;
      const pattern = toArray(definition.url);
      for (const subPattern of pattern) {
        const match = this._getUrlMatches(url, subPattern);
        if (match) {
          return new Media(this.locale, url, match, previewRenderer);
        }
      }
    }
    return null;
  }
  /**
  * Tries to match `url` to `pattern`.
  *
  * @param url The URL of the media.
  * @param pattern The pattern that should accept the media URL.
  */
  _getUrlMatches(url, pattern) {
    let match = url.match(pattern);
    if (match) {
      return match;
    }
    let rawUrl = url.replace(/^https?:\/\//, "");
    match = rawUrl.match(pattern);
    if (match) {
      return match;
    }
    rawUrl = rawUrl.replace(/^www\./, "");
    match = rawUrl.match(pattern);
    if (match) {
      return match;
    }
    return null;
  }
};
var Media = class {
  constructor(locale, url, match, previewRenderer) {
    /**
    * The URL this Media instance represents.
    */
    __publicField(this, "url");
    /**
    * Shorthand for {@link module:utils/locale~Locale#t}.
    *
    * @see module:utils/locale~Locale#t
    */
    __publicField(this, "_locale");
    /**
    * The output of the `RegExp.match` which validated the {@link #url} of this media.
    */
    __publicField(this, "_match");
    /**
    * The function returning the HTML string preview of this media.
    */
    __publicField(this, "_previewRenderer");
    this.url = this._getValidUrl(url);
    this._locale = locale;
    this._match = match;
    this._previewRenderer = previewRenderer;
  }
  /**
  * Returns the view element representation of the media.
  *
  * @param writer The view writer used to produce a view element.
  */
  getViewElement(writer, options2) {
    const attributes = {};
    let viewElement;
    if (options2.renderForEditingView || options2.renderMediaPreview && this.url && this._previewRenderer) {
      if (this.url) {
        attributes["data-oembed-url"] = this.url;
      }
      if (options2.renderForEditingView) {
        attributes.class = "ck-media__wrapper";
      }
      const mediaHtml = this._getPreviewHtml(options2);
      viewElement = writer.createRawElement("div", attributes, (domElement, domConverter) => {
        domConverter.setContentOf(domElement, mediaHtml);
      });
    } else {
      if (this.url) {
        attributes.url = this.url;
      }
      viewElement = writer.createEmptyElement(options2.elementName, attributes);
    }
    writer.setCustomProperty("media-content", true, viewElement);
    return viewElement;
  }
  /**
  * Returns the HTML string of the media content preview.
  */
  _getPreviewHtml(options2) {
    if (this._previewRenderer) {
      return this._previewRenderer(this._match);
    } else {
      if (this.url && options2.renderForEditingView) {
        return this._getPlaceholderHtml();
      }
      return "";
    }
  }
  /**
  * Returns the placeholder HTML when the media has no content preview.
  */
  _getPlaceholderHtml() {
    const icon = new IconView();
    const t = this._locale.t;
    icon.content = mediaPlaceholderIcon;
    icon.viewBox = mediaPlaceholderIconViewBox;
    const placeholder = new Template({
      tag: "div",
      attributes: {
        class: "ck ck-reset_all ck-media__placeholder"
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: "ck-media__placeholder__icon"
          },
          children: [
            icon
          ]
        },
        {
          tag: "a",
          attributes: {
            class: "ck-media__placeholder__url",
            target: "_blank",
            rel: "noopener noreferrer",
            href: this.url,
            "data-cke-tooltip-text": t("Open media in new tab")
          },
          children: [
            {
              tag: "span",
              attributes: {
                class: "ck-media__placeholder__url__text"
              },
              children: [
                this.url
              ]
            }
          ]
        }
      ]
    }).render();
    return placeholder.outerHTML;
  }
  /**
  * Returns the full URL to the specified media.
  *
  * @param url The URL of the media.
  */
  _getValidUrl(url) {
    if (!url) {
      return null;
    }
    if (url.match(/^https?/)) {
      return url;
    }
    return "https://" + url;
  }
};
var MediaEmbedEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The media registry managing the media providers in the editor.
    */
    __publicField(this, "registry");
    editor.config.define("mediaEmbed", {
      elementName: "oembed",
      providers: [
        {
          name: "dailymotion",
          url: [
            /^dailymotion\.com\/video\/(\w+)/,
            /^dai.ly\/(\w+)/
          ],
          html: (match) => {
            const id = match[1];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${id}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`;
          }
        },
        {
          name: "spotify",
          url: [
            /^open\.spotify\.com\/(artist\/\w+)/,
            /^open\.spotify\.com\/(album\/\w+)/,
            /^open\.spotify\.com\/(track\/\w+)/
          ],
          html: (match) => {
            const id = match[1];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${id}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`;
          }
        },
        {
          name: "youtube",
          url: [
            /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/,
            /^(?:m\.)?youtube\.com\/shorts\/([\w-]+)(?:\?t=(\d+))?/,
            /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/,
            /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/,
            /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/
          ],
          html: (match) => {
            const id = match[1];
            const time = match[2];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${id}${time ? `?start=${time}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`;
          }
        },
        {
          name: "vimeo",
          url: [
            /^vimeo\.com\/(\d+)/,
            /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
            /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
            /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
            /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
            /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
            /^player\.vimeo\.com\/video\/(\d+)/
          ],
          html: (match) => {
            const id = match[1];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${id}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`;
          }
        },
        {
          name: "instagram",
          url: [
            /^instagram\.com\/p\/(\w+)/,
            /^instagram\.com\/reel\/(\w+)/
          ]
        },
        {
          name: "twitter",
          url: [
            /^twitter\.com/,
            /^x\.com/
          ]
        },
        {
          name: "googleMaps",
          url: [
            /^google\.com\/maps/,
            /^goo\.gl\/maps/,
            /^maps\.google\.com/,
            /^maps\.app\.goo\.gl/
          ]
        },
        {
          name: "flickr",
          url: /^flickr\.com/
        },
        {
          name: "facebook",
          url: /^facebook\.com/
        }
      ]
    });
    this.registry = new MediaRegistry(editor.locale, editor.config.get("mediaEmbed"));
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "MediaEmbedEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const t = editor.t;
    const conversion = editor.conversion;
    const renderMediaPreview = editor.config.get("mediaEmbed.previewsInData");
    const elementName = editor.config.get("mediaEmbed.elementName");
    const registry = this.registry;
    editor.commands.add("mediaEmbed", new MediaEmbedCommand(editor));
    schema.register("media", {
      inheritAllFrom: "$blockObject",
      allowAttributes: [
        "url"
      ]
    });
    conversion.for("dataDowncast").elementToStructure({
      model: "media",
      view: (modelElement, { writer }) => {
        const url = modelElement.getAttribute("url");
        return createMediaFigureElement(writer, registry, url, {
          elementName,
          renderMediaPreview: !!url && renderMediaPreview
        });
      }
    });
    conversion.for("dataDowncast").add(modelToViewUrlAttributeConverter(registry, {
      elementName,
      renderMediaPreview
    }));
    conversion.for("editingDowncast").elementToStructure({
      model: "media",
      view: (modelElement, { writer }) => {
        const url = modelElement.getAttribute("url");
        const figure = createMediaFigureElement(writer, registry, url, {
          elementName,
          renderForEditingView: true
        });
        return toMediaWidget(figure, writer, t("media widget"));
      }
    });
    conversion.for("editingDowncast").add(modelToViewUrlAttributeConverter(registry, {
      elementName,
      renderForEditingView: true
    }));
    conversion.for("upcast").elementToElement({
      view: (element) => [
        "oembed",
        elementName
      ].includes(element.name) && element.getAttribute("url") ? {
        name: true
      } : null,
      model: (viewMedia, { writer }) => {
        const url = viewMedia.getAttribute("url");
        if (registry.hasMedia(url)) {
          return writer.createElement("media", {
            url
          });
        }
        return null;
      }
    }).elementToElement({
      view: {
        name: "div",
        attributes: {
          "data-oembed-url": true
        }
      },
      model: (viewMedia, { writer }) => {
        const url = viewMedia.getAttribute("data-oembed-url");
        if (registry.hasMedia(url)) {
          return writer.createElement("media", {
            url
          });
        }
        return null;
      }
    }).add((dispatcher) => {
      const converter = (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.viewItem, {
          name: true,
          classes: "media"
        })) {
          return;
        }
        const { modelRange, modelCursor } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
        data.modelRange = modelRange;
        data.modelCursor = modelCursor;
        const modelElement = first(modelRange.getItems());
        if (!modelElement) {
          conversionApi.consumable.revert(data.viewItem, {
            name: true,
            classes: "media"
          });
        }
      };
      dispatcher.on("element:figure", converter);
    });
  }
};
var URL_REGEXP = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
var AutoMediaEmbed = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The pastetoembed `setTimeout` ID. Stored as a property to allow
    * cleaning of the timeout.
    */
    __publicField(this, "_timeoutId");
    /**
    * The position where the `<media>` element will be inserted after the timeout,
    * determined each time the new content is pasted into the document.
    */
    __publicField(this, "_positionToInsert");
    this._timeoutId = null;
    this._positionToInsert = null;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Clipboard,
      Delete,
      Undo
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "AutoMediaEmbed";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const modelDocument = editor.model.document;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    this.listenTo(clipboardPipeline, "inputTransformation", () => {
      const firstRange = modelDocument.selection.getFirstRange();
      const leftLivePosition = LivePosition.fromPosition(firstRange.start);
      leftLivePosition.stickiness = "toPrevious";
      const rightLivePosition = LivePosition.fromPosition(firstRange.end);
      rightLivePosition.stickiness = "toNext";
      modelDocument.once("change:data", () => {
        this._embedMediaBetweenPositions(leftLivePosition, rightLivePosition);
        leftLivePosition.detach();
        rightLivePosition.detach();
      }, {
        priority: "high"
      });
    });
    const undoCommand = editor.commands.get("undo");
    undoCommand.on("execute", () => {
      if (this._timeoutId) {
        global.window.clearTimeout(this._timeoutId);
        this._positionToInsert.detach();
        this._timeoutId = null;
        this._positionToInsert = null;
      }
    }, {
      priority: "high"
    });
  }
  /**
  * Analyzes the part of the document between provided positions in search for a URL representing media.
  * When the URL is found, it is automatically converted into media.
  *
  * @param leftPosition Left position of the selection.
  * @param rightPosition Right position of the selection.
  */
  _embedMediaBetweenPositions(leftPosition, rightPosition) {
    const editor = this.editor;
    const mediaRegistry = editor.plugins.get(MediaEmbedEditing).registry;
    const urlRange = new LiveRange(leftPosition, rightPosition);
    const walker = urlRange.getWalker({
      ignoreElementEnd: true
    });
    let url = "";
    for (const node of walker) {
      if (node.item.is("$textProxy")) {
        url += node.item.data;
      }
    }
    url = url.trim();
    if (!url.match(URL_REGEXP)) {
      urlRange.detach();
      return;
    }
    if (!mediaRegistry.hasMedia(url)) {
      urlRange.detach();
      return;
    }
    const mediaEmbedCommand = editor.commands.get("mediaEmbed");
    if (!mediaEmbedCommand.isEnabled) {
      urlRange.detach();
      return;
    }
    this._positionToInsert = LivePosition.fromPosition(leftPosition);
    this._timeoutId = global.window.setTimeout(() => {
      editor.model.change((writer) => {
        this._timeoutId = null;
        writer.remove(urlRange);
        urlRange.detach();
        let insertionPosition = null;
        if (this._positionToInsert.root.rootName !== "$graveyard") {
          insertionPosition = this._positionToInsert;
        }
        insertMedia(editor.model, url, insertionPosition, false);
        this._positionToInsert.detach();
        this._positionToInsert = null;
      });
      editor.plugins.get(Delete).requestUndoOnBackspace();
    }, 100);
  }
};
var MediaFormView = class extends View2 {
  /**
  * @param validators Form validators used by {@link #isValid}.
  * @param locale The localization services instance.
  */
  constructor(validators, locale) {
    super(locale);
    /**
    * Tracks information about the DOM focus in the form.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * The URL input view.
    */
    __publicField(this, "urlInputView");
    /**
    * An array of form validators used by {@link #isValid}.
    */
    __publicField(this, "_validators");
    /**
    * The default info text for the {@link #urlInputView}.
    */
    __publicField(this, "_urlInputViewInfoDefault");
    /**
    * The info text with an additional tip for the {@link #urlInputView},
    * displayed when the input has some value.
    */
    __publicField(this, "_urlInputViewInfoTip");
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.set("mediaURLInputValue", "");
    this.urlInputView = this._createUrlInput();
    this._validators = validators;
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-media-form",
          "ck-responsive-form"
        ],
        tabindex: "-1"
      },
      children: [
        this.urlInputView
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    this.focusTracker.add(this.urlInputView.element);
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the {@link #urlInputView}.
  */
  focus() {
    this.urlInputView.focus();
  }
  /**
  * The native DOM `value` of the {@link #urlInputView} element.
  *
  * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
  * which works one way only and may not represent the actual state of the component in the DOM.
  */
  get url() {
    return this.urlInputView.fieldView.element.value.trim();
  }
  set url(url) {
    this.urlInputView.fieldView.value = url.trim();
  }
  /**
  * Validates the form and returns `false` when some fields are invalid.
  */
  isValid() {
    this.resetFormStatus();
    for (const validator of this._validators) {
      const errorText = validator(this);
      if (errorText) {
        this.urlInputView.errorText = errorText;
        return false;
      }
    }
    return true;
  }
  /**
  * Cleans up the supplementary error and information text of the {@link #urlInputView}
  * bringing them back to the state when the form has been displayed for the first time.
  *
  * See {@link #isValid}.
  */
  resetFormStatus() {
    this.urlInputView.errorText = null;
    this.urlInputView.infoText = this._urlInputViewInfoDefault;
  }
  /**
  * Creates a labeled input view.
  *
  * @returns Labeled input view instance.
  */
  _createUrlInput() {
    const t = this.locale.t;
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    const inputField = labeledInput.fieldView;
    this._urlInputViewInfoDefault = t("Paste the media URL in the input.");
    this._urlInputViewInfoTip = t("Tip: Paste the URL into the content to embed faster.");
    labeledInput.label = t("Media URL");
    labeledInput.infoText = this._urlInputViewInfoDefault;
    inputField.inputMode = "url";
    inputField.on("input", () => {
      labeledInput.infoText = inputField.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault;
      this.mediaURLInputValue = inputField.element.value.trim();
    });
    return labeledInput;
  }
};
var mediaIcon = '<svg viewBox="0 0 22 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.587 1.5c-.612 0-.601-.029-.601.551v14.84c0 .59-.01.559.591.559h18.846c.602 0 .591.03.591-.56V2.052c0-.58.01-.55-.591-.55H1.587Zm.701.971h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-14.24 1h13.008v12H4.467l.029-12Zm-2.208 1h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003l-.029 1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h.974v1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Z"/><path d="M8.374 6.648a.399.399 0 0 1 .395-.4.402.402 0 0 1 .2.049l5.148 2.824a.4.4 0 0 1 0 .7l-5.148 2.824a.403.403 0 0 1-.595-.35V6.648Z"/></svg>';
var MediaEmbedUI = class extends Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "_formView");
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      MediaEmbedEditing,
      Dialog
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "MediaEmbedUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("mediaEmbed", () => {
      const t = this.editor.locale.t;
      const button = this._createDialogButton(ButtonView);
      button.tooltip = true;
      button.label = t("Insert media");
      return button;
    });
    editor.ui.componentFactory.add("menuBar:mediaEmbed", () => {
      const t = this.editor.locale.t;
      const button = this._createDialogButton(MenuBarMenuListItemButtonView);
      button.label = t("Media");
      return button;
    });
  }
  /**
  * Creates a button for menu bar that will show media embed dialog.
  */
  _createDialogButton(ButtonClass) {
    const editor = this.editor;
    const buttonView = new ButtonClass(editor.locale);
    const command = editor.commands.get("mediaEmbed");
    const dialogPlugin = this.editor.plugins.get("Dialog");
    buttonView.icon = mediaIcon;
    buttonView.bind("isEnabled").to(command, "isEnabled");
    buttonView.on("execute", () => {
      if (dialogPlugin.id === "mediaEmbed") {
        dialogPlugin.hide();
      } else {
        this._showDialog();
      }
    });
    return buttonView;
  }
  _showDialog() {
    const editor = this.editor;
    const dialog = editor.plugins.get("Dialog");
    const command = editor.commands.get("mediaEmbed");
    const t = editor.locale.t;
    if (!this._formView) {
      const registry = editor.plugins.get(MediaEmbedEditing).registry;
      this._formView = new (CssTransitionDisablerMixin(MediaFormView))(getFormValidators3(editor.t, registry), editor.locale);
      this._formView.on("submit", () => this._handleSubmitForm());
    }
    dialog.show({
      id: "mediaEmbed",
      title: t("Insert media"),
      content: this._formView,
      isModal: true,
      onShow: () => {
        this._formView.url = command.value || "";
        this._formView.resetFormStatus();
        this._formView.urlInputView.fieldView.select();
      },
      actionButtons: [
        {
          label: t("Cancel"),
          withText: true,
          onExecute: () => dialog.hide()
        },
        {
          label: t("Accept"),
          class: "ck-button-action",
          withText: true,
          onExecute: () => this._handleSubmitForm()
        }
      ]
    });
  }
  _handleSubmitForm() {
    const editor = this.editor;
    const dialog = editor.plugins.get("Dialog");
    if (this._formView.isValid()) {
      editor.execute("mediaEmbed", this._formView.url);
      dialog.hide();
      editor.editing.view.focus();
    }
  }
};
function getFormValidators3(t, registry) {
  return [
    (form) => {
      if (!form.url.length) {
        return t("The URL must not be empty.");
      }
    },
    (form) => {
      if (!registry.hasMedia(form.url)) {
        return t("This media URL is not supported.");
      }
    }
  ];
}
var MediaEmbed = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      MediaEmbedEditing,
      MediaEmbedUI,
      AutoMediaEmbed,
      Widget
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "MediaEmbed";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var MediaEmbedToolbar = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      WidgetToolbarRepository
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "MediaEmbedToolbar";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const t = editor.t;
    const widgetToolbarRepository = editor.plugins.get(WidgetToolbarRepository);
    widgetToolbarRepository.register("mediaEmbed", {
      ariaLabel: t("Media toolbar"),
      items: editor.config.get("mediaEmbed.toolbar") || [],
      getRelatedElement: getSelectedMediaViewWidget
    });
  }
};

// node_modules/@ckeditor/ckeditor5-mention/dist/index.js
var BRACKET_PAIRS = {
  "(": ")",
  "[": "]",
  "{": "}"
};
var MentionCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    this._isEnabledBasedOnSelection = false;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, "mention");
  }
  /**
  * Executes the command.
  *
  * @param options Options for the executed command.
  * @param options.mention The mention object to insert. When a string is passed, it will be used to create a plain
  * object with the name attribute that equals the passed string.
  * @param options.marker The marker character (e.g. `'@'`).
  * @param options.text The text of the inserted mention. Defaults to the full mention string composed from `marker` and
  * `mention` string or `mention.id` if an object is passed.
  * @param options.range The range to replace.
  * Note that the replaced range might be shorter than the inserted text with the mention attribute.
  * @fires execute
  */
  execute(options2) {
    const model = this.editor.model;
    const document2 = model.document;
    const selection = document2.selection;
    const mentionData = typeof options2.mention == "string" ? {
      id: options2.mention
    } : options2.mention;
    const mentionID = mentionData.id;
    const range = options2.range || selection.getFirstRange();
    if (!model.canEditAt(range)) {
      return;
    }
    const mentionText = options2.text || mentionID;
    const mention = _addMentionAttributes({
      _text: mentionText,
      id: mentionID
    }, mentionData);
    if (options2.marker.length != 1) {
      throw new CKEditorError("mentioncommand-incorrect-marker", this);
    }
    if (mentionID.charAt(0) != options2.marker) {
      throw new CKEditorError("mentioncommand-incorrect-id", this);
    }
    model.change((writer) => {
      const currentAttributes = toMap(selection.getAttributes());
      const attributesWithMention = new Map(currentAttributes.entries());
      attributesWithMention.set("mention", mention);
      const insertionRange = model.insertContent(writer.createText(mentionText, attributesWithMention), range);
      const nodeBefore = insertionRange.start.nodeBefore;
      const nodeAfter = insertionRange.end.nodeAfter;
      const isFollowedByWhiteSpace = nodeAfter && nodeAfter.is("$text") && nodeAfter.data.startsWith(" ");
      let isInsertedInBrackets = false;
      if (nodeBefore && nodeAfter && nodeBefore.is("$text") && nodeAfter.is("$text")) {
        const precedingCharacter = nodeBefore.data.slice(-1);
        const isPrecededByOpeningBracket = precedingCharacter in BRACKET_PAIRS;
        const isFollowedByBracketClosure = isPrecededByOpeningBracket && nodeAfter.data.startsWith(BRACKET_PAIRS[precedingCharacter]);
        isInsertedInBrackets = isPrecededByOpeningBracket && isFollowedByBracketClosure;
      }
      if (!isInsertedInBrackets && !isFollowedByWhiteSpace) {
        model.insertContent(writer.createText(" ", currentAttributes), range.start.getShiftedBy(mentionText.length));
      }
    });
  }
};
var MentionEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "MentionEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const doc = model.document;
    model.schema.extend("$text", {
      allowAttributes: "mention"
    });
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "span",
        key: "data-mention",
        classes: "mention"
      },
      model: {
        key: "mention",
        value: (viewElement) => _toMentionAttribute(viewElement)
      }
    });
    editor.conversion.for("downcast").attributeToElement({
      model: "mention",
      view: createViewMentionElement
    });
    editor.conversion.for("downcast").add(preventPartialMentionDowncast);
    doc.registerPostFixer((writer) => removePartialMentionPostFixer(writer, doc, model.schema));
    doc.registerPostFixer((writer) => extendAttributeOnMentionPostFixer(writer, doc));
    doc.registerPostFixer((writer) => selectionMentionAttributePostFixer(writer, doc));
    editor.commands.add("mention", new MentionCommand(editor));
  }
};
function _addMentionAttributes(baseMentionData, data) {
  return Object.assign({
    uid: uid()
  }, baseMentionData, data || {});
}
function _toMentionAttribute(viewElementOrMention, data) {
  const dataMention = viewElementOrMention.getAttribute("data-mention");
  const textNode = viewElementOrMention.getChild(0);
  if (!textNode) {
    return;
  }
  const baseMentionData = {
    id: dataMention,
    _text: textNode.data
  };
  return _addMentionAttributes(baseMentionData, data);
}
function preventPartialMentionDowncast(dispatcher) {
  dispatcher.on("attribute:mention", (evt, data, conversionApi) => {
    const mention = data.attributeNewValue;
    if (!data.item.is("$textProxy") || !mention) {
      return;
    }
    const start = data.range.start;
    const textNode = start.textNode || start.nodeAfter;
    if (textNode.data != mention._text) {
      conversionApi.consumable.consume(data.item, evt.name);
    }
  }, {
    priority: "highest"
  });
}
function createViewMentionElement(mention, { writer }) {
  if (!mention) {
    return;
  }
  const attributes = {
    class: "mention",
    "data-mention": mention.id
  };
  const options2 = {
    id: mention.uid,
    priority: 20
  };
  return writer.createAttributeElement("span", attributes, options2);
}
function selectionMentionAttributePostFixer(writer, doc) {
  const selection = doc.selection;
  const focus = selection.focus;
  if (selection.isCollapsed && selection.hasAttribute("mention") && shouldNotTypeWithMentionAt(focus)) {
    writer.removeSelectionAttribute("mention");
    return true;
  }
  return false;
}
function shouldNotTypeWithMentionAt(position) {
  const isAtStart = position.isAtStart;
  const isAfterAMention = position.nodeBefore && position.nodeBefore.is("$text");
  return isAfterAMention || isAtStart;
}
function removePartialMentionPostFixer(writer, doc, schema) {
  const changes = doc.differ.getChanges();
  let wasChanged = false;
  for (const change of changes) {
    if (change.type == "attribute") {
      continue;
    }
    const position = change.position;
    if (change.name == "$text") {
      const nodeAfterInsertedTextNode = position.textNode && position.textNode.nextSibling;
      wasChanged = checkAndFix(position.textNode, writer) || wasChanged;
      wasChanged = checkAndFix(nodeAfterInsertedTextNode, writer) || wasChanged;
      wasChanged = checkAndFix(position.nodeBefore, writer) || wasChanged;
      wasChanged = checkAndFix(position.nodeAfter, writer) || wasChanged;
    }
    if (change.name != "$text" && change.type == "insert") {
      const insertedNode = position.nodeAfter;
      for (const item of writer.createRangeIn(insertedNode).getItems()) {
        wasChanged = checkAndFix(item, writer) || wasChanged;
      }
    }
    if (change.type == "insert" && schema.isInline(change.name)) {
      const nodeAfterInserted = position.nodeAfter && position.nodeAfter.nextSibling;
      wasChanged = checkAndFix(position.nodeBefore, writer) || wasChanged;
      wasChanged = checkAndFix(nodeAfterInserted, writer) || wasChanged;
    }
  }
  return wasChanged;
}
function extendAttributeOnMentionPostFixer(writer, doc) {
  const changes = doc.differ.getChanges();
  let wasChanged = false;
  for (const change of changes) {
    if (change.type === "attribute" && change.attributeKey != "mention") {
      const nodeBefore = change.range.start.nodeBefore;
      const nodeAfter = change.range.end.nodeAfter;
      for (const node of [
        nodeBefore,
        nodeAfter
      ]) {
        if (isBrokenMentionNode(node) && node.getAttribute(change.attributeKey) != change.attributeNewValue) {
          writer.setAttribute(change.attributeKey, change.attributeNewValue, node);
          wasChanged = true;
        }
      }
    }
  }
  return wasChanged;
}
function isBrokenMentionNode(node) {
  if (!node || !(node.is("$text") || node.is("$textProxy")) || !node.hasAttribute("mention")) {
    return false;
  }
  const text = node.data;
  const mention = node.getAttribute("mention");
  const expectedText = mention._text;
  return text != expectedText;
}
function checkAndFix(textNode, writer) {
  if (isBrokenMentionNode(textNode)) {
    writer.removeAttribute("mention", textNode);
    return true;
  }
  return false;
}
var MentionsView = class extends ListView {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    __publicField(this, "selected");
    __publicField(this, "position");
    this.extendTemplate({
      attributes: {
        class: [
          "ck-mentions"
        ],
        tabindex: "-1"
      }
    });
  }
  /**
  * {@link #select Selects} the first item.
  */
  selectFirst() {
    this.select(0);
  }
  /**
  * Selects next item to the currently {@link #select selected}.
  *
  * If the last item is already selected, it will select the first item.
  */
  selectNext() {
    const item = this.selected;
    const index = this.items.getIndex(item);
    this.select(index + 1);
  }
  /**
  * Selects previous item to the currently {@link #select selected}.
  *
  * If the first item is already selected, it will select the last item.
  */
  selectPrevious() {
    const item = this.selected;
    const index = this.items.getIndex(item);
    this.select(index - 1);
  }
  /**
  * Marks item at a given index as selected.
  *
  * Handles selection cycling when passed index is out of bounds:
  * - if the index is lower than 0, it will select the last item,
  * - if the index is higher than the last item index, it will select the first item.
  *
  * @param index Index of an item to be marked as selected.
  */
  select(index) {
    let indexToGet = 0;
    if (index > 0 && index < this.items.length) {
      indexToGet = index;
    } else if (index < 0) {
      indexToGet = this.items.length - 1;
    }
    const item = this.items.get(indexToGet);
    if (this.selected === item) {
      return;
    }
    if (this.selected) {
      this.selected.removeHighlight();
    }
    item.highlight();
    this.selected = item;
    if (!this._isItemVisibleInScrolledArea(item)) {
      this.element.scrollTop = item.element.offsetTop;
    }
  }
  /**
  * Triggers the `execute` event on the {@link #select selected} item.
  */
  executeSelected() {
    this.selected.fire("execute");
  }
  /**
  * Checks if an item is visible in the scrollable area.
  *
  * The item is considered visible when:
  * - its top boundary is inside the scrollable rect
  * - its bottom boundary is inside the scrollable rect (the whole item must be visible)
  */
  _isItemVisibleInScrolledArea(item) {
    return new Rect(this.element).contains(new Rect(item.element));
  }
};
var DomWrapperView = class extends View2 {
  /**
  * Creates an instance of {@link module:mention/ui/domwrapperview~DomWrapperView} class.
  *
  * Also see {@link #render}.
  */
  constructor(locale, domElement) {
    super(locale);
    /**
    * The DOM element for which wrapper was created.
    */
    __publicField(this, "domElement");
    this.template = void 0;
    this.domElement = domElement;
    this.domElement.classList.add("ck-button");
    this.set("isOn", false);
    this.on("change:isOn", (evt, name, isOn) => {
      if (isOn) {
        this.domElement.classList.add("ck-on");
        this.domElement.classList.remove("ck-off");
      } else {
        this.domElement.classList.add("ck-off");
        this.domElement.classList.remove("ck-on");
      }
    });
    this.listenTo(this.domElement, "click", () => {
      this.fire("execute");
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.element = this.domElement;
  }
  /**
  * Focuses the DOM element.
  */
  focus() {
    this.domElement.focus();
  }
};
var MentionListItemView = class extends ListItemView {
  constructor() {
    super(...arguments);
    __publicField(this, "item");
    __publicField(this, "marker");
  }
  highlight() {
    const child = this.children.first;
    child.isOn = true;
  }
  removeHighlight() {
    const child = this.children.first;
    child.isOn = false;
  }
};
var VERTICAL_SPACING = 3;
var defaultHandledKeyCodes = [
  keyCodes.arrowup,
  keyCodes.arrowdown,
  keyCodes.esc
];
var defaultCommitKeyCodes = [
  keyCodes.enter,
  keyCodes.tab
];
var MentionUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The mention view.
    */
    __publicField(this, "_mentionsView");
    /**
    * Stores mention feeds configurations.
    */
    __publicField(this, "_mentionsConfigurations");
    /**
    * The contextual balloon plugin instance.
    */
    __publicField(this, "_balloon");
    __publicField(this, "_items", new Collection());
    __publicField(this, "_lastRequested");
    /**
    * Debounced feed requester. It uses `lodash#debounce` method to delay function call.
    */
    __publicField(this, "_requestFeedDebounced");
    this._mentionsView = this._createMentionView();
    this._mentionsConfigurations = /* @__PURE__ */ new Map();
    this._requestFeedDebounced = debounce_default(this._requestFeed, 100);
    editor.config.define("mention", {
      feeds: []
    });
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "MentionUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ContextualBalloon
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const commitKeys = editor.config.get("mention.commitKeys") || defaultCommitKeyCodes;
    const handledKeyCodes = defaultHandledKeyCodes.concat(commitKeys);
    this._balloon = editor.plugins.get(ContextualBalloon);
    editor.editing.view.document.on("keydown", (evt, data) => {
      if (isHandledKey(data.keyCode) && this._isUIVisible) {
        data.preventDefault();
        evt.stop();
        if (data.keyCode == keyCodes.arrowdown) {
          this._mentionsView.selectNext();
        }
        if (data.keyCode == keyCodes.arrowup) {
          this._mentionsView.selectPrevious();
        }
        if (commitKeys.includes(data.keyCode)) {
          this._mentionsView.executeSelected();
        }
        if (data.keyCode == keyCodes.esc) {
          this._hideUIAndRemoveMarker();
        }
      }
    }, {
      priority: "highest"
    });
    clickOutsideHandler({
      emitter: this._mentionsView,
      activator: () => this._isUIVisible,
      contextElements: () => [
        this._balloon.view.element
      ],
      callback: () => this._hideUIAndRemoveMarker()
    });
    const feeds = editor.config.get("mention.feeds");
    for (const mentionDescription of feeds) {
      const { feed, marker, dropdownLimit } = mentionDescription;
      if (!isValidMentionMarker(marker)) {
        throw new CKEditorError("mentionconfig-incorrect-marker", null, {
          marker
        });
      }
      const feedCallback = typeof feed == "function" ? feed.bind(this.editor) : createFeedCallback(feed);
      const itemRenderer = mentionDescription.itemRenderer;
      const definition = {
        marker,
        feedCallback,
        itemRenderer,
        dropdownLimit
      };
      this._mentionsConfigurations.set(marker, definition);
    }
    this._setupTextWatcher(feeds);
    this.listenTo(editor, "change:isReadOnly", () => {
      this._hideUIAndRemoveMarker();
    });
    this.on("requestFeed:response", (evt, data) => this._handleFeedResponse(data));
    this.on("requestFeed:error", () => this._hideUIAndRemoveMarker());
    function isHandledKey(keyCode) {
      return handledKeyCodes.includes(keyCode);
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._mentionsView.destroy();
  }
  /**
  * Returns true when {@link #_mentionsView} is in the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon} and it is
  * currently visible.
  */
  get _isUIVisible() {
    return this._balloon.visibleView === this._mentionsView;
  }
  /**
  * Creates the {@link #_mentionsView}.
  */
  _createMentionView() {
    const locale = this.editor.locale;
    const mentionsView = new MentionsView(locale);
    mentionsView.items.bindTo(this._items).using((data) => {
      const { item, marker } = data;
      const { dropdownLimit: markerDropdownLimit } = this._mentionsConfigurations.get(marker);
      const dropdownLimit = markerDropdownLimit || this.editor.config.get("mention.dropdownLimit") || 10;
      if (mentionsView.items.length >= dropdownLimit) {
        return null;
      }
      const listItemView = new MentionListItemView(locale);
      const view = this._renderItem(item, marker);
      view.delegate("execute").to(listItemView);
      listItemView.children.add(view);
      listItemView.item = item;
      listItemView.marker = marker;
      listItemView.on("execute", () => {
        mentionsView.fire("execute", {
          item,
          marker
        });
      });
      return listItemView;
    });
    mentionsView.on("execute", (evt, data) => {
      const editor = this.editor;
      const model = editor.model;
      const item = data.item;
      const marker = data.marker;
      const mentionMarker = editor.model.markers.get("mention");
      const end = model.createPositionAt(model.document.selection.focus);
      const start = model.createPositionAt(mentionMarker.getStart());
      const range = model.createRange(start, end);
      this._hideUIAndRemoveMarker();
      editor.execute("mention", {
        mention: item,
        text: item.text,
        marker,
        range
      });
      editor.editing.view.focus();
    });
    return mentionsView;
  }
  /**
  * Returns item renderer for the marker.
  */
  _getItemRenderer(marker) {
    const { itemRenderer } = this._mentionsConfigurations.get(marker);
    return itemRenderer;
  }
  /**
  * Requests a feed from a configured callbacks.
  */
  _requestFeed(marker, feedText) {
    this._lastRequested = feedText;
    const { feedCallback } = this._mentionsConfigurations.get(marker);
    const feedResponse = feedCallback(feedText);
    const isAsynchronous = feedResponse instanceof Promise;
    if (!isAsynchronous) {
      this.fire("requestFeed:response", {
        feed: feedResponse,
        marker,
        feedText
      });
      return;
    }
    feedResponse.then((response) => {
      if (this._lastRequested == feedText) {
        this.fire("requestFeed:response", {
          feed: response,
          marker,
          feedText
        });
      } else {
        this.fire("requestFeed:discarded", {
          feed: response,
          marker,
          feedText
        });
      }
    }).catch((error) => {
      this.fire("requestFeed:error", {
        error
      });
      logWarning("mention-feed-callback-error", {
        marker
      });
    });
  }
  /**
  * Registers a text watcher for the marker.
  */
  _setupTextWatcher(feeds) {
    const editor = this.editor;
    const feedsWithPattern = feeds.map((feed) => ({
      ...feed,
      pattern: createRegExp(feed.marker, feed.minimumCharacters || 0)
    }));
    const watcher = new TextWatcher(editor.model, createTestCallback(feedsWithPattern));
    watcher.on("matched", (evt, data) => {
      const markerDefinition = getLastValidMarkerInText(feedsWithPattern, data.text);
      const selection = editor.model.document.selection;
      const focus = selection.focus;
      const markerPosition = editor.model.createPositionAt(focus.parent, markerDefinition.position);
      if (isPositionInExistingMention(focus) || isMarkerInExistingMention(markerPosition)) {
        this._hideUIAndRemoveMarker();
        return;
      }
      const feedText = requestFeedText(markerDefinition, data.text);
      const matchedTextLength = markerDefinition.marker.length + feedText.length;
      const start = focus.getShiftedBy(-matchedTextLength);
      const end = focus.getShiftedBy(-feedText.length);
      const markerRange = editor.model.createRange(start, end);
      if (checkIfStillInCompletionMode(editor)) {
        const mentionMarker = editor.model.markers.get("mention");
        editor.model.change((writer) => {
          writer.updateMarker(mentionMarker, {
            range: markerRange
          });
        });
      } else {
        editor.model.change((writer) => {
          writer.addMarker("mention", {
            range: markerRange,
            usingOperation: false,
            affectsData: false
          });
        });
      }
      this._requestFeedDebounced(markerDefinition.marker, feedText);
    });
    watcher.on("unmatched", () => {
      this._hideUIAndRemoveMarker();
    });
    const mentionCommand = editor.commands.get("mention");
    watcher.bind("isEnabled").to(mentionCommand);
    return watcher;
  }
  /**
  * Handles the feed response event data.
  */
  _handleFeedResponse(data) {
    const { feed, marker } = data;
    if (!checkIfStillInCompletionMode(this.editor)) {
      return;
    }
    this._items.clear();
    for (const feedItem of feed) {
      const item = typeof feedItem != "object" ? {
        id: feedItem,
        text: feedItem
      } : feedItem;
      this._items.add({
        item,
        marker
      });
    }
    const mentionMarker = this.editor.model.markers.get("mention");
    if (this._items.length) {
      this._showOrUpdateUI(mentionMarker);
    } else {
      this._hideUIAndRemoveMarker();
    }
  }
  /**
  * Shows the mentions balloon. If the panel is already visible, it will reposition it.
  */
  _showOrUpdateUI(markerMarker) {
    if (this._isUIVisible) {
      this._balloon.updatePosition(this._getBalloonPanelPositionData(markerMarker, this._mentionsView.position));
    } else {
      this._balloon.add({
        view: this._mentionsView,
        position: this._getBalloonPanelPositionData(markerMarker, this._mentionsView.position),
        singleViewMode: true
      });
    }
    this._mentionsView.position = this._balloon.view.position;
    this._mentionsView.selectFirst();
  }
  /**
  * Hides the mentions balloon and removes the 'mention' marker from the markers collection.
  */
  _hideUIAndRemoveMarker() {
    if (this._balloon.hasView(this._mentionsView)) {
      this._balloon.remove(this._mentionsView);
    }
    if (checkIfStillInCompletionMode(this.editor)) {
      this.editor.model.change((writer) => writer.removeMarker("mention"));
    }
    this._mentionsView.position = void 0;
  }
  /**
  * Renders a single item in the autocomplete list.
  */
  _renderItem(item, marker) {
    const editor = this.editor;
    let view;
    let label = item.id;
    const renderer = this._getItemRenderer(marker);
    if (renderer) {
      const renderResult = renderer(item);
      if (typeof renderResult != "string") {
        view = new DomWrapperView(editor.locale, renderResult);
      } else {
        label = renderResult;
      }
    }
    if (!view) {
      const buttonView = new ButtonView(editor.locale);
      buttonView.label = label;
      buttonView.withText = true;
      view = buttonView;
    }
    return view;
  }
  /**
  * Creates a position options object used to position the balloon panel.
  *
  * @param mentionMarker
  * @param preferredPosition The name of the last matched position name.
  */
  _getBalloonPanelPositionData(mentionMarker, preferredPosition) {
    const editor = this.editor;
    const editing = editor.editing;
    const domConverter = editing.view.domConverter;
    const mapper = editing.mapper;
    const uiLanguageDirection = editor.locale.uiLanguageDirection;
    return {
      target: () => {
        let modelRange = mentionMarker.getRange();
        if (modelRange.start.root.rootName == "$graveyard") {
          modelRange = editor.model.document.selection.getFirstRange();
        }
        const viewRange = mapper.toViewRange(modelRange);
        const rangeRects = Rect.getDomRangeRects(domConverter.viewRangeToDom(viewRange));
        return rangeRects.pop();
      },
      limiter: () => {
        const view = this.editor.editing.view;
        const viewDocument = view.document;
        const editableElement = viewDocument.selection.editableElement;
        if (editableElement) {
          return view.domConverter.mapViewToDom(editableElement.root);
        }
        return null;
      },
      positions: getBalloonPanelPositions(preferredPosition, uiLanguageDirection)
    };
  }
};
function getBalloonPanelPositions(preferredPosition, uiLanguageDirection) {
  const positions = {
    // Positions the panel to the southeast of the caret rectangle.
    "caret_se": (targetRect) => {
      return {
        top: targetRect.bottom + VERTICAL_SPACING,
        left: targetRect.right,
        name: "caret_se",
        config: {
          withArrow: false
        }
      };
    },
    // Positions the panel to the northeast of the caret rectangle.
    "caret_ne": (targetRect, balloonRect) => {
      return {
        top: targetRect.top - balloonRect.height - VERTICAL_SPACING,
        left: targetRect.right,
        name: "caret_ne",
        config: {
          withArrow: false
        }
      };
    },
    // Positions the panel to the southwest of the caret rectangle.
    "caret_sw": (targetRect, balloonRect) => {
      return {
        top: targetRect.bottom + VERTICAL_SPACING,
        left: targetRect.right - balloonRect.width,
        name: "caret_sw",
        config: {
          withArrow: false
        }
      };
    },
    // Positions the panel to the northwest of the caret rect.
    "caret_nw": (targetRect, balloonRect) => {
      return {
        top: targetRect.top - balloonRect.height - VERTICAL_SPACING,
        left: targetRect.right - balloonRect.width,
        name: "caret_nw",
        config: {
          withArrow: false
        }
      };
    }
  };
  if (Object.prototype.hasOwnProperty.call(positions, preferredPosition)) {
    return [
      positions[preferredPosition]
    ];
  }
  return uiLanguageDirection !== "rtl" ? [
    positions.caret_se,
    positions.caret_sw,
    positions.caret_ne,
    positions.caret_nw
  ] : [
    positions.caret_sw,
    positions.caret_se,
    positions.caret_nw,
    positions.caret_ne
  ];
}
function getLastValidMarkerInText(feedsWithPattern, text) {
  let lastValidMarker;
  for (const feed of feedsWithPattern) {
    const currentMarkerLastIndex = text.lastIndexOf(feed.marker);
    if (currentMarkerLastIndex > 0 && !text.substring(currentMarkerLastIndex - 1).match(feed.pattern)) {
      continue;
    }
    if (!lastValidMarker || currentMarkerLastIndex >= lastValidMarker.position) {
      lastValidMarker = {
        marker: feed.marker,
        position: currentMarkerLastIndex,
        minimumCharacters: feed.minimumCharacters,
        pattern: feed.pattern
      };
    }
  }
  return lastValidMarker;
}
function createRegExp(marker, minimumCharacters) {
  const numberOfCharacters = minimumCharacters == 0 ? "*" : `{${minimumCharacters},}`;
  const openAfterCharacters = env.features.isRegExpUnicodePropertySupported ? `\\p{Ps}\\p{Pi}"'` : `\\(\\[{"'`;
  const mentionCharacters = ".";
  marker = marker.replace(/[.*+?^${}()\-|[\]\\]/g, "\\$&");
  const pattern = `(?:^|[ ${openAfterCharacters}])([${marker}])(${mentionCharacters}${numberOfCharacters})$`;
  return new RegExp(pattern, "u");
}
function createTestCallback(feedsWithPattern) {
  const textMatcher = (text) => {
    const markerDefinition = getLastValidMarkerInText(feedsWithPattern, text);
    if (!markerDefinition) {
      return false;
    }
    let splitStringFrom = 0;
    if (markerDefinition.position !== 0) {
      splitStringFrom = markerDefinition.position - 1;
    }
    const textToTest = text.substring(splitStringFrom);
    return markerDefinition.pattern.test(textToTest);
  };
  return textMatcher;
}
function requestFeedText(markerDefinition, text) {
  let splitStringFrom = 0;
  if (markerDefinition.position !== 0) {
    splitStringFrom = markerDefinition.position - 1;
  }
  const regExp = createRegExp(markerDefinition.marker, 0);
  const textToMatch = text.substring(splitStringFrom);
  const match = textToMatch.match(regExp);
  return match[2];
}
function createFeedCallback(feedItems) {
  return (feedText) => {
    const filteredItems = feedItems.filter((item) => {
      const itemId = typeof item == "string" ? item : String(item.id);
      return itemId.toLowerCase().includes(feedText.toLowerCase());
    });
    return filteredItems;
  };
}
function isPositionInExistingMention(position) {
  const hasMention = position.textNode && position.textNode.hasAttribute("mention");
  const nodeBefore = position.nodeBefore;
  return hasMention || nodeBefore && nodeBefore.is("$text") && nodeBefore.hasAttribute("mention");
}
function isMarkerInExistingMention(markerPosition) {
  const nodeAfter = markerPosition.nodeAfter;
  return nodeAfter && nodeAfter.is("$text") && nodeAfter.hasAttribute("mention");
}
function isValidMentionMarker(marker) {
  return marker && marker.length == 1;
}
function checkIfStillInCompletionMode(editor) {
  return editor.model.markers.has("mention");
}
var Mention = class extends Plugin {
  toMentionAttribute(viewElement, data) {
    return _toMentionAttribute(viewElement, data);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Mention";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      MentionEditing,
      MentionUI
    ];
  }
};

// node_modules/@ckeditor/ckeditor5-minimap/dist/index.js
var toPx$1 = toUnit("px");
var MinimapIframeView = class extends IframeView {
  /**
  * Creates an instance of the internal minimap iframe.
  */
  constructor(locale, options2) {
    super(locale);
    /**
    * Cached view constructor options for re-use in other methods.
    */
    __publicField(this, "_options");
    const bind = this.bindTemplate;
    this.set("top", 0);
    this.set("height", 0);
    this._options = options2;
    this.extendTemplate({
      attributes: {
        tabindex: -1,
        "aria-hidden": "true",
        class: [
          "ck-minimap__iframe"
        ],
        style: {
          top: bind.to("top", (top) => toPx$1(top)),
          height: bind.to("height", (height) => toPx$1(height))
        }
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    return super.render().then(() => {
      this._prepareDocument();
    });
  }
  /**
  * Sets the new height of the iframe.
  */
  setHeight(newHeight) {
    this.height = newHeight;
  }
  /**
  * Sets the top offset of the iframe to move it around vertically.
  */
  setTopOffset(newOffset) {
    this.top = newOffset;
  }
  /**
  * Sets the internal structure of the `<iframe>` readying it to display the
  * minimap element.
  */
  _prepareDocument() {
    const iframeDocument = this.element.contentWindow.document;
    const domRootClone = iframeDocument.adoptNode(this._options.domRootClone);
    const boxStyles = this._options.useSimplePreview ? `
			.ck.ck-editor__editable_inline img {
				filter: contrast( 0 );
			}

			p, li, a, figcaption, span {
				background: hsl(0, 0%, 80%) !important;
				color: hsl(0, 0%, 80%) !important;
			}

			h1, h2, h3, h4 {
				background: hsl(0, 0%, 60%) !important;
				color: hsl(0, 0%, 60%) !important;
			}
		` : "";
    const pageStyles = this._options.pageStyles.map((definition) => {
      if (typeof definition === "string") {
        return `<style>${definition}</style>`;
      } else {
        return `<link rel="stylesheet" type="text/css" href="${definition.href}">`;
      }
    }).join("\n");
    const html = `<!DOCTYPE html><html lang="en">
			<head>
				<meta charset="utf-8">
				<meta name="viewport" content="width=device-width, initial-scale=1">
				${pageStyles}
				<style>
					html, body {
						margin: 0 !important;
						padding: 0 !important;
					}

					html {
						overflow: hidden;
					}

					body {
						transform: scale( ${this._options.scaleRatio} );
						transform-origin: 0 0;
						overflow: visible;
					}

					.ck.ck-editor__editable_inline {
						margin: 0 !important;
						border-color: transparent !important;
						outline-color: transparent !important;
						box-shadow: none !important;
					}

					.ck.ck-content {
						background: white;
					}

					${boxStyles}
				</style>
			</head>
			<body class="${this._options.extraClasses || ""}"></body>
		</html>`;
    iframeDocument.open();
    iframeDocument.write(html);
    iframeDocument.close();
    iframeDocument.body.appendChild(domRootClone);
  }
};
var toPx2 = toUnit("px");
var MinimapPositionTrackerView = class extends View2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("height", 0);
    this.set("top", 0);
    this.set("scrollProgress", 0);
    this.set("_isDragging", false);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-minimap__position-tracker",
          bind.if("_isDragging", "ck-minimap__position-tracker_dragging")
        ],
        style: {
          top: bind.to("top", (top) => toPx2(top)),
          height: bind.to("height", (height) => toPx2(height))
        },
        "data-progress": bind.to("scrollProgress")
      },
      on: {
        mousedown: bind.to(() => {
          this._isDragging = true;
        })
      }
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.listenTo(global.document, "mousemove", (evt, data) => {
      if (!this._isDragging) {
        return;
      }
      this.fire("drag", data.movementY);
    }, {
      useCapture: true
    });
    this.listenTo(global.document, "mouseup", () => {
      this._isDragging = false;
    }, {
      useCapture: true
    });
  }
  /**
  * Sets the new height of the tracker to visualize the subset of the content visible to the user.
  */
  setHeight(newHeight) {
    this.height = newHeight;
  }
  /**
  * Sets the top offset of the tracker to move it around vertically.
  */
  setTopOffset(newOffset) {
    this.top = newOffset;
  }
  /**
  * Sets the scroll progress (in %) to inform the user using a label when the tracker is being dragged.
  */
  setScrollProgress(newProgress) {
    this.scrollProgress = newProgress;
  }
};
var MinimapView = class extends View2 {
  /**
  * Creates an instance of the minimap view.
  */
  constructor({ locale, scaleRatio, pageStyles, extraClasses, useSimplePreview, domRootClone }) {
    super(locale);
    /**
    * An instance of the tracker view displayed over the minimap.
    */
    __publicField(this, "_positionTrackerView");
    /**
    * The scale ratio of the minimap relative to the original editing DOM root with the content.
    */
    __publicField(this, "_scaleRatio");
    /**
    * An instance of the iframe view that hosts the minimap.
    */
    __publicField(this, "_minimapIframeView");
    const bind = this.bindTemplate;
    this._positionTrackerView = new MinimapPositionTrackerView(locale);
    this._positionTrackerView.delegate("drag").to(this);
    this._scaleRatio = scaleRatio;
    this._minimapIframeView = new MinimapIframeView(locale, {
      useSimplePreview,
      pageStyles,
      extraClasses,
      scaleRatio,
      domRootClone
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-minimap"
        ]
      },
      children: [
        this._positionTrackerView
      ],
      on: {
        click: bind.to(this._handleMinimapClick.bind(this)),
        wheel: bind.to(this._handleMinimapMouseWheel.bind(this))
      }
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._minimapIframeView.destroy();
    super.destroy();
  }
  /**
  * Returns the DOM {@link module:utils/dom/rect~Rect} height of the minimap.
  */
  get height() {
    return new Rect(this.element).height;
  }
  /**
  * Returns the number of available space (pixels) the position tracker (visible subset of the content) can use to scroll vertically.
  */
  get scrollHeight() {
    return Math.max(0, Math.min(this.height, this._minimapIframeView.height) - this._positionTrackerView.height);
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this._minimapIframeView.render();
    this.element.appendChild(this._minimapIframeView.element);
  }
  /**
  * Sets the new height of the minimap (in px) to respond to the changes in the original editing DOM root.
  *
  * **Note**:The provided value should be the `offsetHeight` of the original editing DOM root.
  */
  setContentHeight(newHeight) {
    this._minimapIframeView.setHeight(newHeight * this._scaleRatio);
  }
  /**
  * Sets the minimap scroll progress.
  *
  * The minimap scroll progress is linked to the original editing DOM root and its scrollable container (ancestor).
  * Changing the progress will alter the vertical position of the minimap (and its position tracker) and give the user an accurate
  * overview of the visible document.
  *
  * **Note**: The value should be between 0 and 1. 0 when the DOM root has not been scrolled, 1 when the
  * scrolling has reached the end.
  */
  setScrollProgress(newScrollProgress) {
    const iframeView = this._minimapIframeView;
    const positionTrackerView = this._positionTrackerView;
    if (iframeView.height < this.height) {
      iframeView.setTopOffset(0);
      positionTrackerView.setTopOffset((iframeView.height - positionTrackerView.height) * newScrollProgress);
    } else {
      const totalOffset = iframeView.height - this.height;
      iframeView.setTopOffset(-totalOffset * newScrollProgress);
      positionTrackerView.setTopOffset((this.height - positionTrackerView.height) * newScrollProgress);
    }
    positionTrackerView.setScrollProgress(Math.round(newScrollProgress * 100));
  }
  /**
  * Sets the new height of the tracker (in px) to visualize the subset of the content visible to the user.
  */
  setPositionTrackerHeight(trackerHeight) {
    this._positionTrackerView.setHeight(trackerHeight * this._scaleRatio);
  }
  /**
  * @param data DOM event data
  */
  _handleMinimapClick(data) {
    const positionTrackerView = this._positionTrackerView;
    if (data.target === positionTrackerView.element) {
      return;
    }
    const trackerViewRect = new Rect(positionTrackerView.element);
    const diff2 = data.clientY - trackerViewRect.top - trackerViewRect.height / 2;
    const percentage = diff2 / this._minimapIframeView.height;
    this.fire("click", percentage);
  }
  /**
  * @param data DOM event data
  */
  _handleMinimapMouseWheel(data) {
    this.fire("drag", data.deltaY * this._scaleRatio);
  }
};
function cloneEditingViewDomRoot(editor, rootName) {
  const viewDocument = editor.editing.view.document;
  const viewRoot = viewDocument.getRoot(rootName);
  const domConverter = new DomConverter(viewDocument);
  const renderer = new Renderer(domConverter, viewDocument.selection);
  const domRootClone = editor.editing.view.getDomRoot().cloneNode();
  domConverter.bindElements(domRootClone, viewRoot);
  renderer.markToSync("children", viewRoot);
  renderer.markToSync("attributes", viewRoot);
  viewRoot.on("change:children", (evt, node) => renderer.markToSync("children", node));
  viewRoot.on("change:attributes", (evt, node) => renderer.markToSync("attributes", node));
  viewRoot.on("change:text", (evt, node) => renderer.markToSync("text", node));
  renderer.render();
  editor.editing.view.on("render", () => renderer.render());
  editor.on("destroy", () => {
    domConverter.unbindDomElement(domRootClone);
  });
  return domRootClone;
}
function getPageStyles() {
  return Array.from(global.document.styleSheets).map((styleSheet) => {
    if (styleSheet.href && !styleSheet.href.startsWith(global.window.location.origin)) {
      return {
        href: styleSheet.href
      };
    }
    return Array.from(styleSheet.cssRules).filter((rule) => !(rule instanceof CSSMediaRule)).map((rule) => rule.cssText).join(" \n");
  });
}
function getDomElementRect(domElement) {
  return new Rect(domElement === global.document.body ? global.window : domElement);
}
function getClientHeight(domElement) {
  return domElement === global.document.body ? global.window.innerHeight : domElement.clientHeight;
}
function getScrollable(domElement) {
  return domElement === global.document.body ? global.window : domElement;
}
var Minimap = class extends Plugin {
  constructor() {
    super(...arguments);
    /**
    * The reference to the view of the minimap.
    */
    __publicField(this, "_minimapView");
    /**
    * The DOM element closest to the editable element of the editor as returned
    * by {@link module:ui/editorui/editorui~EditorUI#getEditableElement}.
    */
    __publicField(this, "_scrollableRootAncestor");
    /**
    * The DOM element closest to the editable element of the editor as returned
    * by {@link module:ui/editorui/editorui~EditorUI#getEditableElement}.
    */
    __publicField(this, "_editingRootElement");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Minimap";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    this._minimapView = null;
    this._scrollableRootAncestor = null;
    this.listenTo(editor.ui, "ready", this._onUiReady.bind(this));
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this._minimapView.destroy();
    this._minimapView.element.remove();
  }
  /**
  * Initializes the minimap view element and starts the layout synchronization
  * on the editing view `render` event.
  */
  _onUiReady() {
    const editor = this.editor;
    const editingRootElement = this._editingRootElement = editor.ui.getEditableElement();
    this._scrollableRootAncestor = findClosestScrollableAncestor(editingRootElement);
    if (!editingRootElement.ownerDocument.body.contains(editingRootElement)) {
      editor.ui.once("update", this._onUiReady.bind(this));
      return;
    }
    this._initializeMinimapView();
    this.listenTo(editor.editing.view, "render", () => {
      if (editor.state !== "ready") {
        return;
      }
      this._syncMinimapToEditingRootScrollPosition();
    });
    this._syncMinimapToEditingRootScrollPosition();
  }
  /**
  * Initializes the minimap view and attaches listeners that make it responsive to the environment (document)
  * but also allow the minimap to control the document (scroll position).
  */
  _initializeMinimapView() {
    const editor = this.editor;
    const locale = editor.locale;
    const useSimplePreview = editor.config.get("minimap.useSimplePreview");
    const minimapContainerElement = editor.config.get("minimap.container");
    const scrollableRootAncestor = this._scrollableRootAncestor;
    const editingRootElementWidth = getDomElementRect(this._editingRootElement).width;
    const minimapContainerWidth = getDomElementRect(minimapContainerElement).width;
    const minimapScaleRatio = minimapContainerWidth / editingRootElementWidth;
    const minimapView = this._minimapView = new MinimapView({
      locale,
      scaleRatio: minimapScaleRatio,
      pageStyles: getPageStyles(),
      extraClasses: editor.config.get("minimap.extraClasses"),
      useSimplePreview,
      domRootClone: cloneEditingViewDomRoot(editor)
    });
    minimapView.render();
    minimapView.listenTo(global.document, "scroll", (evt, data) => {
      if (scrollableRootAncestor === global.document.body) {
        if (data.target !== global.document) {
          return;
        }
      } else if (data.target !== scrollableRootAncestor) {
        return;
      }
      this._syncMinimapToEditingRootScrollPosition();
    }, {
      useCapture: true,
      usePassive: true
    });
    minimapView.listenTo(global.window, "resize", () => {
      this._syncMinimapToEditingRootScrollPosition();
    });
    minimapView.on("drag", (evt, movementY) => {
      let movementYPercentage;
      if (minimapView.scrollHeight === 0) {
        movementYPercentage = 0;
      } else {
        movementYPercentage = movementY / minimapView.scrollHeight;
      }
      const absoluteScrollProgress = movementYPercentage * (scrollableRootAncestor.scrollHeight - getClientHeight(scrollableRootAncestor));
      const scrollable = getScrollable(scrollableRootAncestor);
      scrollable.scrollBy(0, Math.round(absoluteScrollProgress));
    });
    minimapView.on("click", (evt, percentage) => {
      const absoluteScrollProgress = percentage * scrollableRootAncestor.scrollHeight;
      const scrollable = getScrollable(scrollableRootAncestor);
      scrollable.scrollBy(0, Math.round(absoluteScrollProgress));
    });
    minimapContainerElement.appendChild(minimapView.element);
  }
  /**
  * @private
  */
  _syncMinimapToEditingRootScrollPosition() {
    const editingRootElement = this._editingRootElement;
    const minimapView = this._minimapView;
    minimapView.setContentHeight(editingRootElement.offsetHeight);
    const editingRootRect = getDomElementRect(editingRootElement);
    const scrollableRootAncestorRect = getDomElementRect(this._scrollableRootAncestor);
    let scrollProgress;
    if (scrollableRootAncestorRect.contains(editingRootRect)) {
      scrollProgress = 0;
    } else {
      if (editingRootRect.top > scrollableRootAncestorRect.top) {
        scrollProgress = 0;
      } else {
        scrollProgress = (editingRootRect.top - scrollableRootAncestorRect.top) / (scrollableRootAncestorRect.height - editingRootRect.height);
        scrollProgress = Math.max(0, Math.min(scrollProgress, 1));
      }
    }
    minimapView.setPositionTrackerHeight(scrollableRootAncestorRect.getIntersection(editingRootRect).height);
    minimapView.setScrollProgress(scrollProgress);
  }
};

// node_modules/@ckeditor/ckeditor5-page-break/dist/index.js
var PageBreakCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    this.isEnabled = isPageBreakAllowedInParent(selection, schema, model);
  }
  /**
  * Executes the command.
  *
  * @fires execute
  */
  execute() {
    const model = this.editor.model;
    model.change((writer) => {
      const pageBreakElement = writer.createElement("pageBreak");
      model.insertObject(pageBreakElement, null, null, {
        setSelection: "after"
      });
    });
  }
};
function isPageBreakAllowedInParent(selection, schema, model) {
  const parent = getInsertPageBreakParent(selection, model);
  return schema.checkChild(parent, "pageBreak");
}
function getInsertPageBreakParent(selection, model) {
  const insertionRange = findOptimalInsertionRange(selection, model);
  const parent = insertionRange.start.parent;
  if (parent.isEmpty && !parent.is("element", "$root")) {
    return parent.parent;
  }
  return parent;
}
var PageBreakEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PageBreakEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const t = editor.t;
    const conversion = editor.conversion;
    schema.register("pageBreak", {
      inheritAllFrom: "$blockObject"
    });
    conversion.for("dataDowncast").elementToStructure({
      model: "pageBreak",
      view: (modelElement, { writer }) => {
        const divElement = writer.createContainerElement(
          "div",
          {
            class: "page-break",
            // If user has no `.ck-content` styles, it should always break a page during print.
            style: "page-break-after: always"
          },
          // For a rationale of using span inside a div see:
          // https://github.com/ckeditor/ckeditor5-page-break/pull/1#discussion_r328934062.
          writer.createContainerElement("span", {
            style: "display: none"
          })
        );
        return divElement;
      }
    });
    conversion.for("editingDowncast").elementToStructure({
      model: "pageBreak",
      view: (modelElement, { writer }) => {
        const label = t("Page break");
        const viewWrapper = writer.createContainerElement("div");
        const viewLabelElement = writer.createRawElement("span", {
          class: "page-break__label"
        }, function(domElement) {
          domElement.innerText = t("Page break");
        });
        writer.addClass("page-break", viewWrapper);
        writer.insert(writer.createPositionAt(viewWrapper, 0), viewLabelElement);
        return toPageBreakWidget(viewWrapper, writer, label);
      }
    });
    conversion.for("upcast").elementToElement({
      view: (element) => {
        const hasPageBreakBefore = element.getStyle("page-break-before") == "always";
        const hasPageBreakAfter = element.getStyle("page-break-after") == "always";
        if (!hasPageBreakBefore && !hasPageBreakAfter) {
          return null;
        }
        if (element.childCount == 1) {
          const viewSpan = element.getChild(0);
          if (!viewSpan.is("element", "span") || viewSpan.getStyle("display") != "none") {
            return null;
          }
        } else if (element.childCount > 1) {
          return null;
        }
        return {
          name: true
        };
      },
      model: "pageBreak",
      // This conversion must be checked before <br> conversion because some editors use
      // <br style="page-break-before:always"> as a page break marker.
      converterPriority: "high"
    });
    editor.commands.add("pageBreak", new PageBreakCommand(editor));
  }
};
function toPageBreakWidget(viewElement, writer, label) {
  writer.setCustomProperty("pageBreak", true, viewElement);
  return toWidget(viewElement, writer, {
    label
  });
}
var pageBreakIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.598.687h1.5v5h-1.5zm14.5 0h1.5v5h-1.5z"/><path d="M19.598 4.187v1.5h-16v-1.5zm-16 14.569h1.5v-5h-1.5zm14.5 0h1.5v-5h-1.5z"/><path d="M19.598 15.256v-1.5h-16v1.5zM5.081 9h6v2h-6zm8 0h6v2h-6zm-9.483 1L0 12.5v-5z"/></svg>';
var PageBreakUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PageBreakUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("pageBreak", () => {
      const view = this._createButton(ButtonView);
      view.set({
        tooltip: true
      });
      return view;
    });
    editor.ui.componentFactory.add("menuBar:pageBreak", () => this._createButton(MenuBarMenuListItemButtonView));
  }
  /**
  * Creates a button for page break command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get("pageBreak");
    const view = new ButtonClass(editor.locale);
    const t = locale.t;
    view.set({
      label: t("Page break"),
      icon: pageBreakIcon
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute("pageBreak");
      editor.editing.view.focus();
    });
    return view;
  }
};
var PageBreak = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      PageBreakEditing,
      PageBreakUI,
      Widget
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PageBreak";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-remove-format/dist/index.js
var removeFormatIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>';
var REMOVE_FORMAT = "removeFormat";
var RemoveFormatUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "RemoveFormatUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add(REMOVE_FORMAT, () => {
      const view = this._createButton(ButtonView);
      view.set({
        tooltip: true
      });
      return view;
    });
    editor.ui.componentFactory.add(`menuBar:${REMOVE_FORMAT}`, () => this._createButton(MenuBarMenuListItemButtonView));
  }
  /**
  * Creates a button for remove format command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get(REMOVE_FORMAT);
    const view = new ButtonClass(editor.locale);
    const t = locale.t;
    view.set({
      label: t("Remove Format"),
      icon: removeFormatIcon
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute(REMOVE_FORMAT);
      editor.editing.view.focus();
    });
    return view;
  }
};
var RemoveFormatCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    this.isEnabled = !!first(this._getFormattingItems(model.document.selection, model.schema));
  }
  /**
  * @inheritDoc
  */
  execute() {
    const model = this.editor.model;
    const schema = model.schema;
    model.change((writer) => {
      for (const item of this._getFormattingItems(model.document.selection, schema)) {
        if (item.is("selection")) {
          for (const attributeName of this._getFormattingAttributes(item, schema)) {
            writer.removeSelectionAttribute(attributeName);
          }
        } else {
          const itemRange = writer.createRangeOn(item);
          for (const attributeName of this._getFormattingAttributes(item, schema)) {
            writer.removeAttribute(attributeName, itemRange);
          }
        }
      }
    });
  }
  /**
  * Returns an iterable of items in a selection (including the selection itself) that have formatting model
  * attributes to be removed by the feature.
  *
  * @param schema The schema describing the item.
  */
  *_getFormattingItems(selection, schema) {
    const itemHasRemovableFormatting = (item) => {
      return !!first(this._getFormattingAttributes(item, schema));
    };
    for (const curRange of selection.getRanges()) {
      for (const item of curRange.getItems()) {
        if (!schema.isBlock(item) && itemHasRemovableFormatting(item)) {
          yield item;
        }
      }
    }
    for (const block2 of selection.getSelectedBlocks()) {
      if (itemHasRemovableFormatting(block2)) {
        yield block2;
      }
    }
    if (itemHasRemovableFormatting(selection)) {
      yield selection;
    }
  }
  /**
  * Returns an iterable of formatting attributes of a given model item.
  *
  * **Note:** Formatting items have the `isFormatting` property set to `true`.
  *
  * @param schema The schema describing the item.
  * @returns The names of formatting attributes found in a given item.
  */
  *_getFormattingAttributes(item, schema) {
    for (const [attributeName] of item.getAttributes()) {
      const attributeProperties = schema.getAttributeProperties(attributeName);
      if (attributeProperties && attributeProperties.isFormatting) {
        yield attributeName;
      }
    }
  }
};
var RemoveFormatEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "RemoveFormatEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.commands.add("removeFormat", new RemoveFormatCommand(editor));
  }
};
var RemoveFormat = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      RemoveFormatEditing,
      RemoveFormatUI
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "RemoveFormat";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-restricted-editing/dist/index.js
var RestrictedEditingModeNavigationCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor The editor instance.
  * @param direction The direction that the command works.
  */
  constructor(editor, direction) {
    super(editor);
    /**
    * The direction of the command.
    */
    __publicField(this, "_direction");
    this.affectsData = false;
    this._direction = direction;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
  * Executes the command.
  *
  * @fires execute
  */
  execute() {
    const position = getNearestExceptionRange(this.editor.model, this._direction);
    if (!position) {
      return;
    }
    this.editor.model.change((writer) => {
      writer.setSelection(position);
    });
  }
  /**
  * Checks whether the command can be enabled in the current context.
  *
  * @returns Whether the command should be enabled.
  */
  _checkEnabled() {
    return !!getNearestExceptionRange(this.editor.model, this._direction);
  }
};
function getNearestExceptionRange(model, direction) {
  const selection = model.document.selection;
  const selectionPosition = selection.getFirstPosition();
  const markerRanges = [];
  for (const marker of model.markers.getMarkersGroup("restrictedEditingException")) {
    const markerRange = marker.getRange();
    const isMarkerRangeTouching = selectionPosition.isTouching(markerRange.start) && selectionPosition.hasSameParentAs(markerRange.start) || selectionPosition.isTouching(markerRange.end) && selectionPosition.hasSameParentAs(markerRange.end);
    if (markerRange.containsPosition(selectionPosition) || isMarkerRangeTouching) {
      continue;
    }
    if (direction === "forward" && markerRange.start.isAfter(selectionPosition)) {
      markerRanges.push(markerRange);
    } else if (direction === "backward" && markerRange.end.isBefore(selectionPosition)) {
      markerRanges.push(markerRange);
    }
  }
  if (!markerRanges.length) {
    return;
  }
  return markerRanges.sort((rangeA, rangeB) => {
    if (direction === "forward") {
      return rangeA.start.isAfter(rangeB.start) ? 1 : -1;
    } else {
      return rangeA.start.isBefore(rangeB.start) ? 1 : -1;
    }
  }).shift();
}
function getMarkerAtPosition(editor, position) {
  for (const marker of editor.model.markers) {
    const markerRange = marker.getRange();
    if (isPositionInRangeBoundaries(markerRange, position)) {
      if (marker.name.startsWith("restrictedEditingException:")) {
        return marker;
      }
    }
  }
}
function isPositionInRangeBoundaries(range, position) {
  return range.containsPosition(position) || range.end.isEqual(position) || range.start.isEqual(position);
}
function isSelectionInMarker(selection, marker) {
  if (!marker) {
    return false;
  }
  const markerRange = marker.getRange();
  if (selection.isCollapsed) {
    return isPositionInRangeBoundaries(markerRange, selection.focus);
  }
  return markerRange.containsRange(selection.getFirstRange(), true);
}
var HIGHLIGHT_CLASS4 = "restricted-editing-exception_selected";
function setupExceptionHighlighting(editor) {
  const view = editor.editing.view;
  const model = editor.model;
  const highlightedMarkers = /* @__PURE__ */ new Set();
  view.document.registerPostFixer((writer) => {
    const modelSelection = model.document.selection;
    const marker = getMarkerAtPosition(editor, modelSelection.anchor);
    if (!marker) {
      return false;
    }
    for (const viewElement of editor.editing.mapper.markerNameToElements(marker.name)) {
      writer.addClass(HIGHLIGHT_CLASS4, viewElement);
      highlightedMarkers.add(viewElement);
    }
    return false;
  });
  editor.conversion.for("editingDowncast").add((dispatcher) => {
    dispatcher.on("insert", removeHighlight, {
      priority: "highest"
    });
    dispatcher.on("remove", removeHighlight, {
      priority: "highest"
    });
    dispatcher.on("attribute", removeHighlight, {
      priority: "highest"
    });
    dispatcher.on("cleanSelection", removeHighlight);
    function removeHighlight() {
      view.change((writer) => {
        for (const item of highlightedMarkers.values()) {
          writer.removeClass(HIGHLIGHT_CLASS4, item);
          highlightedMarkers.delete(item);
        }
      });
    }
  });
}
function resurrectCollapsedMarkerPostFixer(editor) {
  return (writer) => {
    let changeApplied = false;
    for (const { name, data } of editor.model.document.differ.getChangedMarkers()) {
      if (name.startsWith("restrictedEditingException") && data.newRange && data.newRange.root.rootName == "$graveyard") {
        writer.updateMarker(name, {
          range: writer.createRange(writer.createPositionAt(data.oldRange.start))
        });
        changeApplied = true;
      }
    }
    return changeApplied;
  };
}
function extendMarkerOnTypingPostFixer(editor) {
  return (writer) => {
    let changeApplied = false;
    const schema = editor.model.schema;
    for (const change of editor.model.document.differ.getChanges()) {
      if (change.type == "insert" && schema.checkChild("$block", change.name)) {
        changeApplied = _tryExtendMarkerStart(editor, change.position, change.length, writer) || changeApplied;
        changeApplied = _tryExtendMarkedEnd(editor, change.position, change.length, writer) || changeApplied;
      }
    }
    return changeApplied;
  };
}
function upcastHighlightToMarker(config) {
  return (dispatcher) => dispatcher.on("element:span", (evt, data, conversionApi) => {
    const { writer } = conversionApi;
    const matcher = new Matcher(config.view);
    const matcherResult = matcher.match(data.viewItem);
    if (!matcherResult) {
      return;
    }
    const match = matcherResult.match;
    match.name = true;
    const { modelRange: convertedChildrenRange } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
    conversionApi.consumable.consume(data.viewItem, match);
    const markerName = config.model();
    const fakeMarkerStart = writer.createElement("$marker", {
      "data-name": markerName
    });
    const fakeMarkerEnd = writer.createElement("$marker", {
      "data-name": markerName
    });
    writer.insert(fakeMarkerEnd, convertedChildrenRange.end);
    writer.insert(fakeMarkerStart, convertedChildrenRange.start);
    data.modelRange = writer.createRange(writer.createPositionBefore(fakeMarkerStart), writer.createPositionAfter(fakeMarkerEnd));
    data.modelCursor = data.modelRange.end;
  });
}
function _tryExtendMarkerStart(editor, position, length, writer) {
  const markerAtStart = getMarkerAtPosition(editor, position.getShiftedBy(length));
  if (markerAtStart && markerAtStart.getStart().isEqual(position.getShiftedBy(length))) {
    writer.updateMarker(markerAtStart, {
      range: writer.createRange(markerAtStart.getStart().getShiftedBy(-length), markerAtStart.getEnd())
    });
    return true;
  }
  return false;
}
function _tryExtendMarkedEnd(editor, position, length, writer) {
  const markerAtEnd = getMarkerAtPosition(editor, position);
  if (markerAtEnd && markerAtEnd.getEnd().isEqual(position)) {
    writer.updateMarker(markerAtEnd, {
      range: writer.createRange(markerAtEnd.getStart(), markerAtEnd.getEnd().getShiftedBy(length))
    });
    return true;
  }
  return false;
}
var COMMAND_FORCE_DISABLE_ID2 = "RestrictedEditingMode";
var RestrictedEditingModeEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * Command names that are enabled outside the non-restricted regions.
    */
    __publicField(this, "_alwaysEnabled");
    /**
    * Commands allowed in non-restricted areas.
    *
    * Commands always enabled combine typing feature commands: `'input'`, `'insertText'`, `'delete'`, and `'deleteForward'` with
    * commands defined in the feature configuration.
    */
    __publicField(this, "_allowedInException");
    editor.config.define("restrictedEditing", {
      allowedCommands: [
        "bold",
        "italic",
        "link",
        "unlink"
      ],
      allowedAttributes: [
        "bold",
        "italic",
        "linkHref"
      ]
    });
    this._alwaysEnabled = /* @__PURE__ */ new Set([
      "undo",
      "redo"
    ]);
    this._allowedInException = /* @__PURE__ */ new Set([
      "input",
      "insertText",
      "delete",
      "deleteForward"
    ]);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "RestrictedEditingModeEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const allowedCommands = editor.config.get("restrictedEditing.allowedCommands");
    allowedCommands.forEach((commandName) => this._allowedInException.add(commandName));
    this._setupConversion();
    this._setupCommandsToggling();
    this._setupRestrictions();
    editor.commands.add("goToPreviousRestrictedEditingException", new RestrictedEditingModeNavigationCommand(editor, "backward"));
    editor.commands.add("goToNextRestrictedEditingException", new RestrictedEditingModeNavigationCommand(editor, "forward"));
    this.listenTo(editingView.document, "tab", (evt, data) => {
      const commandName = !data.shiftKey ? "goToNextRestrictedEditingException" : "goToPreviousRestrictedEditingException";
      const command = editor.commands.get(commandName);
      if (command.isEnabled) {
        editor.execute(commandName);
        data.preventDefault();
        data.stopPropagation();
      }
      evt.stop();
    }, {
      context: "$capture"
    });
    editor.keystrokes.set("Ctrl+A", getSelectAllHandler(editor));
    editingView.change((writer) => {
      for (const root2 of editingView.document.roots) {
        writer.addClass("ck-restricted-editing_mode_restricted", root2);
      }
    });
  }
  /**
  * Makes the given command always enabled in the restricted editing mode (regardless
  * of selection location).
  *
  * To enable some commands in non-restricted areas of the content use
  * {@link module:restricted-editing/restrictededitingconfig~RestrictedEditingConfig#allowedCommands} configuration option.
  *
  * @param commandName Name of the command to enable.
  */
  enableCommand(commandName) {
    const command = this.editor.commands.get(commandName);
    command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID2);
    this._alwaysEnabled.add(commandName);
  }
  /**
  * Sets up the restricted mode editing conversion:
  *
  * * ucpast & downcast converters,
  * * marker highlighting in the edting area,
  * * marker post-fixers.
  */
  _setupConversion() {
    const editor = this.editor;
    const model = editor.model;
    const doc = model.document;
    let markerNumber = 0;
    editor.conversion.for("upcast").add(upcastHighlightToMarker({
      view: {
        name: "span",
        classes: "restricted-editing-exception"
      },
      model: () => {
        markerNumber++;
        return `restrictedEditingException:${markerNumber}`;
      }
    }));
    editor.conversion.for("downcast").add((dispatcher) => {
      dispatcher.on("addMarker:restrictedEditingException", (evt, data, conversionApi) => {
        if (!data.item) {
          return;
        }
        if (data.item.is("selection") || !conversionApi.schema.isInline(data.item)) {
          return;
        }
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const viewElement = viewWriter.createAttributeElement("span", {
          class: "restricted-editing-exception"
        }, {
          id: data.markerName,
          priority: -10
        });
        const viewRange = conversionApi.mapper.toViewRange(data.range);
        const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);
        for (const element of rangeAfterWrap.getItems()) {
          if (element.is("attributeElement") && element.isSimilar(viewElement)) {
            conversionApi.mapper.bindElementToMarker(element, data.markerName);
            break;
          }
        }
      });
    });
    editor.conversion.for("downcast").markerToHighlight({
      model: "restrictedEditingException",
      // Use callback to return new object every time new marker instance is created - otherwise it will be seen as the same marker.
      view: () => {
        return {
          name: "span",
          classes: "restricted-editing-exception",
          priority: -10
        };
      }
    });
    editor.conversion.for("editingDowncast").markerToElement({
      model: "restrictedEditingException",
      view: (markerData, { writer }) => {
        return writer.createUIElement("span", {
          class: "restricted-editing-exception restricted-editing-exception_collapsed"
        });
      }
    });
    editor.conversion.for("dataDowncast").markerToElement({
      model: "restrictedEditingException",
      view: (markerData, { writer }) => {
        return writer.createEmptyElement("span", {
          class: "restricted-editing-exception"
        });
      }
    });
    doc.registerPostFixer(extendMarkerOnTypingPostFixer(editor));
    doc.registerPostFixer(resurrectCollapsedMarkerPostFixer(editor));
    doc.registerPostFixer(ensureNewMarkerIsFlatPostFixer(editor));
    setupExceptionHighlighting(editor);
  }
  /**
  * Setups additional editing restrictions beyond command toggling:
  *
  * * delete content range trimming
  * * disabling input command outside exception marker
  * * restricting clipboard holder to text only
  * * restricting text attributes in content
  */
  _setupRestrictions() {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const viewDoc = editor.editing.view.document;
    const clipboard = editor.plugins.get("ClipboardPipeline");
    this.listenTo(model, "deleteContent", restrictDeleteContent(editor), {
      priority: "high"
    });
    const insertTextCommand = editor.commands.get("insertText");
    if (insertTextCommand) {
      this.listenTo(insertTextCommand, "execute", disallowInputExecForWrongRange(editor), {
        priority: "high"
      });
    }
    this.listenTo(clipboard, "contentInsertion", (evt) => {
      if (!isRangeInsideSingleMarker(editor, selection.getFirstRange())) {
        evt.stop();
      }
    });
    this.listenTo(viewDoc, "clipboardOutput", (evt, data) => {
      if (data.method == "cut" && !isRangeInsideSingleMarker(editor, selection.getFirstRange())) {
        evt.stop();
      }
    }, {
      priority: "high"
    });
    const allowedAttributes = editor.config.get("restrictedEditing.allowedAttributes");
    model.schema.addAttributeCheck(onlyAllowAttributesFromList(allowedAttributes));
    model.schema.addChildCheck(allowTextOnlyInClipboardHolder());
  }
  /**
  * Sets up the command toggling which enables or disables commands based on the user selection.
  */
  _setupCommandsToggling() {
    const editor = this.editor;
    const model = editor.model;
    const doc = model.document;
    this._disableCommands();
    this.listenTo(doc.selection, "change", this._checkCommands.bind(this));
    this.listenTo(doc, "change:data", this._checkCommands.bind(this));
  }
  /**
  * Checks if commands should be enabled or disabled based on the current selection.
  */
  _checkCommands() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    if (selection.rangeCount > 1) {
      this._disableCommands();
      return;
    }
    const marker = getMarkerAtPosition(editor, selection.focus);
    this._disableCommands();
    if (isSelectionInMarker(selection, marker)) {
      this._enableCommands(marker);
    }
  }
  /**
  * Enables commands in non-restricted regions.
  */
  _enableCommands(marker) {
    const editor = this.editor;
    for (const [commandName, command] of editor.commands) {
      if (!command.affectsData || this._alwaysEnabled.has(commandName)) {
        continue;
      }
      if (!this._allowedInException.has(commandName)) {
        continue;
      }
      if (isDeleteCommandOnMarkerBoundaries(commandName, editor.model.document.selection, marker.getRange())) {
        continue;
      }
      command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID2);
    }
  }
  /**
  * Disables commands outside non-restricted regions.
  */
  _disableCommands() {
    const editor = this.editor;
    for (const [commandName, command] of editor.commands) {
      if (!command.affectsData || this._alwaysEnabled.has(commandName)) {
        continue;
      }
      command.forceDisabled(COMMAND_FORCE_DISABLE_ID2);
    }
  }
};
function getSelectAllHandler(editor) {
  return (_, cancel) => {
    const model = editor.model;
    const selection = editor.model.document.selection;
    const marker = getMarkerAtPosition(editor, selection.focus);
    if (!marker) {
      return;
    }
    const selectionRange = selection.getFirstRange();
    const markerRange = marker.getRange();
    if (markerRange.containsRange(selectionRange, true) || selection.isCollapsed) {
      cancel();
      model.change((writer) => {
        writer.setSelection(marker.getRange());
      });
    }
  };
}
function isDeleteCommandOnMarkerBoundaries(commandName, selection, markerRange) {
  if (commandName == "delete" && markerRange.start.isEqual(selection.focus)) {
    return true;
  }
  if (commandName == "deleteForward" && selection.isCollapsed && markerRange.end.isEqual(selection.focus)) {
    return true;
  }
  return false;
}
function restrictDeleteContent(editor) {
  return (evt, args) => {
    const [selection] = args;
    const marker = getMarkerAtPosition(editor, selection.focus) || getMarkerAtPosition(editor, selection.anchor);
    if (!marker) {
      evt.stop();
      return;
    }
    if (selection.isCollapsed) {
      return;
    }
    const allowedToDelete = marker.getRange().getIntersection(selection.getFirstRange());
    if (selection.is("documentSelection")) {
      editor.model.change((writer) => {
        writer.setSelection(allowedToDelete);
      });
    } else {
      selection.setTo(allowedToDelete);
    }
  };
}
function disallowInputExecForWrongRange(editor) {
  return (evt, args) => {
    const [options2] = args;
    const { range } = options2;
    if (!range) {
      return;
    }
    if (!isRangeInsideSingleMarker(editor, range)) {
      evt.stop();
    }
  };
}
function isRangeInsideSingleMarker(editor, range) {
  const markerAtStart = getMarkerAtPosition(editor, range.start);
  const markerAtEnd = getMarkerAtPosition(editor, range.end);
  return markerAtStart && markerAtEnd && markerAtEnd === markerAtStart;
}
function ensureNewMarkerIsFlatPostFixer(editor) {
  return (writer) => {
    let changeApplied = false;
    const changedMarkers = editor.model.document.differ.getChangedMarkers();
    for (const { data, name } of changedMarkers) {
      if (!name.startsWith("restrictedEditingException")) {
        continue;
      }
      const newRange = data.newRange;
      if (!data.oldRange && !newRange.isFlat) {
        const start = newRange.start;
        const end = newRange.end;
        const startIsHigherInTree = start.path.length > end.path.length;
        const fixedStart = startIsHigherInTree ? newRange.start : writer.createPositionAt(end.parent, 0);
        const fixedEnd = startIsHigherInTree ? writer.createPositionAt(start.parent, "end") : newRange.end;
        writer.updateMarker(name, {
          range: writer.createRange(fixedStart, fixedEnd)
        });
        changeApplied = true;
      }
    }
    return changeApplied;
  };
}
function onlyAllowAttributesFromList(allowedAttributes) {
  return (context, attributeName) => {
    if (context.startsWith("$clipboardHolder")) {
      return allowedAttributes.includes(attributeName);
    }
  };
}
function allowTextOnlyInClipboardHolder() {
  return (context, childDefinition) => {
    if (context.startsWith("$clipboardHolder")) {
      return childDefinition.name === "$text";
    }
  };
}
var lockIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.5 6.5a3.5 3.5 0 0 1 3.495 3.308L19 10v2a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-2l.005-.192A3.5 3.5 0 0 1 15.5 6.5zm0 7.5a.5.5 0 0 0-.492.41L15 14.5v2a.5.5 0 0 0 .992.09L16 16.5v-2a.5.5 0 0 0-.5-.5zm0-6a2 2 0 0 0-2 2v2h4v-2a2 2 0 0 0-2-2zm-9.25 8a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm0-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm3-5a.75.75 0 0 1 0 1.5H.75a.75.75 0 0 1 0-1.5h8.5zm6-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 0 1 0-1.5h14.5z"/></svg>';
var RestrictedEditingModeUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "RestrictedEditingModeUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("restrictedEditing", (locale) => {
      const dropdownView = createDropdown(locale);
      const listItems = new Collection();
      this._getButtonDefinitions().forEach(({ commandName, label, keystroke }) => {
        listItems.add(this._getButtonDefinition(commandName, label, keystroke));
      });
      addListToDropdown(dropdownView, listItems, {
        role: "menu"
      });
      dropdownView.buttonView.set({
        label: t("Navigate editable regions"),
        icon: lockIcon,
        tooltip: true,
        isEnabled: true,
        isOn: false
      });
      this.listenTo(dropdownView, "execute", (evt) => {
        const { _commandName } = evt.source;
        editor.execute(_commandName);
        editor.editing.view.focus();
      });
      return dropdownView;
    });
    editor.ui.componentFactory.add("menuBar:restrictedEditing", (locale) => {
      const menuView = new MenuBarMenuView(locale);
      const listView = new MenuBarMenuListView(locale);
      listView.set({
        ariaLabel: t("Navigate editable regions"),
        role: "menu"
      });
      menuView.buttonView.set({
        label: t("Navigate editable regions"),
        icon: lockIcon
      });
      menuView.panelView.children.add(listView);
      this._getButtonDefinitions().forEach(({ commandName, label, keystroke }) => {
        const listItemView = new MenuBarMenuListItemView(locale, menuView);
        const buttonView = this._createMenuBarButton(label, commandName, keystroke);
        buttonView.delegate("execute").to(menuView);
        listItemView.children.add(buttonView);
        listView.items.add(listItemView);
      });
      return menuView;
    });
  }
  /**
  * Creates a button for restricted editing command to use in menu bar.
  */
  _createMenuBarButton(label, commandName, keystroke) {
    const editor = this.editor;
    const command = editor.commands.get(commandName);
    const view = new MenuBarMenuListItemButtonView(editor.locale);
    view.set({
      label,
      keystroke,
      isEnabled: true,
      isOn: false
    });
    view.bind("isEnabled").to(command);
    this.listenTo(view, "execute", () => {
      editor.execute(commandName);
      editor.editing.view.focus();
    });
    return view;
  }
  /**
  * Returns a definition of the navigation button to be used in the dropdown.
  *
  * @param commandName The name of the command that the button represents.
  * @param label The translated label of the button.
  * @param keystroke The button keystroke.
  */
  _getButtonDefinition(commandName, label, keystroke) {
    const editor = this.editor;
    const command = editor.commands.get(commandName);
    const definition = {
      type: "button",
      model: new Model2({
        label,
        withText: true,
        keystroke,
        withKeystroke: true,
        role: "menuitem",
        _commandName: commandName
      })
    };
    definition.model.bind("isEnabled").to(command, "isEnabled");
    return definition;
  }
  /**
  * Returns definitions for UI buttons.
  *
  * @internal
  */
  _getButtonDefinitions() {
    const t = this.editor.locale.t;
    return [
      {
        commandName: "goToPreviousRestrictedEditingException",
        label: t("Previous editable region"),
        keystroke: "Shift+Tab"
      },
      {
        commandName: "goToNextRestrictedEditingException",
        label: t("Next editable region"),
        keystroke: "Tab"
      }
    ];
  }
};
var RestrictedEditingMode = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "RestrictedEditingMode";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      RestrictedEditingModeEditing,
      RestrictedEditingModeUI
    ];
  }
};
var RestrictedEditingExceptionCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.value = !!doc.selection.getAttribute("restrictedEditingException");
    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, "restrictedEditingException");
  }
  /**
  * @inheritDoc
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    const selection = document2.selection;
    const valueToSet = options2.forceValue === void 0 ? !this.value : options2.forceValue;
    model.change((writer) => {
      const ranges = model.schema.getValidRanges(selection.getRanges(), "restrictedEditingException");
      if (selection.isCollapsed) {
        if (valueToSet) {
          writer.setSelectionAttribute("restrictedEditingException", valueToSet);
        } else {
          const isSameException = (value) => {
            return value.item.getAttribute("restrictedEditingException") === this.value;
          };
          const focus = selection.focus;
          const exceptionStart = focus.getLastMatchingPosition(isSameException, {
            direction: "backward"
          });
          const exceptionEnd = focus.getLastMatchingPosition(isSameException);
          writer.removeSelectionAttribute("restrictedEditingException");
          if (!(focus.isEqual(exceptionStart) || focus.isEqual(exceptionEnd))) {
            writer.removeAttribute("restrictedEditingException", writer.createRange(exceptionStart, exceptionEnd));
          }
        }
      } else {
        for (const range of ranges) {
          if (valueToSet) {
            writer.setAttribute("restrictedEditingException", valueToSet, range);
          } else {
            writer.removeAttribute("restrictedEditingException", range);
          }
        }
      }
    });
  }
};
var StandardEditingModeEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StandardEditingModeEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", {
      allowAttributes: [
        "restrictedEditingException"
      ]
    });
    editor.conversion.for("upcast").elementToAttribute({
      model: "restrictedEditingException",
      view: {
        name: "span",
        classes: "restricted-editing-exception"
      }
    });
    editor.conversion.for("downcast").attributeToElement({
      model: "restrictedEditingException",
      view: (modelAttributeValue, { writer }) => {
        if (modelAttributeValue) {
          return writer.createAttributeElement("span", {
            class: "restricted-editing-exception"
          }, {
            priority: -10
          });
        }
      }
    });
    editor.commands.add("restrictedEditingException", new RestrictedEditingExceptionCommand(editor));
    editor.editing.view.change((writer) => {
      for (const root2 of editor.editing.view.document.roots) {
        writer.addClass("ck-restricted-editing_mode_standard", root2);
      }
    });
  }
};
var unlockIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.25 16a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm0-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm3-5a.75.75 0 0 1 0 1.5H.75a.75.75 0 0 1 0-1.5h8.5zm6-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 0 1 0-1.5h14.5zm.25 5.5a3.5 3.5 0 0 1 3.143 1.959.75.75 0 0 1-1.36.636A2 2 0 0 0 13.5 10v2H19a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-2l.005-.192A3.5 3.5 0 0 1 15.5 6.5zm0 7.5a.5.5 0 0 0-.492.41L15 14.5v2a.5.5 0 0 0 .992.09L16 16.5v-2a.5.5 0 0 0-.5-.5z"/></svg>';
var StandardEditingModeUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StandardEditingModeUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("restrictedEditingException", () => {
      const button = this._createButton(ButtonView);
      button.set({
        tooltip: true,
        isToggleable: true
      });
      return button;
    });
    editor.ui.componentFactory.add("menuBar:restrictedEditingException", () => {
      return this._createButton(MenuBarMenuListItemButtonView);
    });
  }
  /**
  * Creates a button for restricted editing exception command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = this.editor.commands.get("restrictedEditingException");
    const view = new ButtonClass(locale);
    const t = locale.t;
    view.icon = unlockIcon;
    view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
    view.bind("label").to(command, "value", (value) => {
      return value ? t("Disable editing") : t("Enable editing");
    });
    this.listenTo(view, "execute", () => {
      editor.execute("restrictedEditingException");
      editor.editing.view.focus();
    });
    return view;
  }
};
var StandardEditingMode = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StandardEditingMode";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  static get requires() {
    return [
      StandardEditingModeEditing,
      StandardEditingModeUI
    ];
  }
};

// node_modules/@ckeditor/ckeditor5-show-blocks/dist/index.js
var ShowBlocksCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    this.affectsData = false;
    this.value = false;
  }
  /**
  * Toggles the visibility of content blocks.
  */
  execute() {
    const CLASS_NAME = "ck-show-blocks";
    const view = this.editor.editing.view;
    view.change((writer) => {
      for (const root2 of view.document.roots) {
        if (!root2.hasClass(CLASS_NAME)) {
          writer.addClass(CLASS_NAME, root2);
          this.value = true;
        } else {
          writer.removeClass(CLASS_NAME, root2);
          this.value = false;
        }
      }
    });
  }
};
var ShowBlocksEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ShowBlocksEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const { editor } = this;
    editor.commands.add("showBlocks", new ShowBlocksCommand(editor));
  }
};
var showBlocksIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m6.395 9.196 2.545-.007V6.498a.598.598 0 0 1 .598-.598h.299a.598.598 0 0 1 .598.598v6.877a.598.598 0 0 1-.598.598h-.299a.598.598 0 0 1-.598-.598v-2.691l-2.545.007v2.691a.598.598 0 0 1-.598.598h-.299a.598.598 0 0 1-.598-.598V6.505a.598.598 0 0 1 .598-.598h.299a.598.598 0 0 1 .598.598v2.691Z"/><path d="M15.094 13.417V6.462a.562.562 0 0 0-.562-.562h-.782a1 1 0 0 0-.39.08l-1.017.43a.562.562 0 0 0-.343.517v.197c0 .4.406.67.775.519l.819-.337v6.111c0 .31.251.562.561.562h.377c.31 0 .562-.251.562-.562Z"/><path d="M0 15.417v1.5h1.5v-1.5H0Z"/><path d="M18.5 15.417v1.5H20v-1.5h-1.5Z"/><path d="M18.5 12.333v1.5H20v-1.5h-1.5Z"/><path d="M18.5 9.25v1.5H20v-1.5h-1.5Z"/><path d="M18.5 6.167v1.5H20v-1.5h-1.5Z"/><path d="M0 18.5v.5a1 1 0 0 0 1 1h.5v-1.5H0Z"/><path d="M3.083 18.5V20h1.5v-1.5h-1.5Z"/><path d="M6.167 18.5V20h1.5v-1.5h-1.5Z"/><path d="M9.25 18.5V20h1.5v-1.5h-1.5Z"/><path d="M12.333 18.5V20h1.5v-1.5h-1.5Z"/><path d="M15.417 18.5V20h1.5v-1.5h-1.5Z"/><path d="M18.5 18.5V20h.5a1 1 0 0 0 1-1v-.5h-1.5Z"/><path clip-rule="evenodd" d="M0 1a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v3.583h-1.5V1.5h-17v12.333H0V1Z"/></svg>';
var ShowBlocksUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ShowBlocksUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("showBlocks", () => {
      const buttonView = this._createButton(ButtonView);
      buttonView.set({
        tooltip: true,
        icon: showBlocksIcon
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:showBlocks", () => {
      return this._createButton(MenuBarMenuListItemButtonView);
    });
  }
  /**
  * Creates a button for show blocks command to use either in toolbar or in menu bar.
  */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get("showBlocks");
    const view = new ButtonClass(locale);
    const t = locale.t;
    view.set({
      label: t("Show blocks"),
      isToggleable: true,
      role: "menuitemcheckbox"
    });
    view.bind("isEnabled").to(command);
    view.bind("isOn").to(command, "value", command, "isEnabled", (value, isEnabled) => value && isEnabled);
    this.listenTo(view, "execute", () => {
      editor.execute("showBlocks");
      editor.editing.view.focus();
    });
    return view;
  }
};
var ShowBlocks = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ShowBlocks";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ShowBlocksEditing,
      ShowBlocksUI
    ];
  }
};

// node_modules/@ckeditor/ckeditor5-source-editing/dist/index.js
function formatHtml(input) {
  const elementsToFormat = [
    {
      name: "address",
      isVoid: false
    },
    {
      name: "article",
      isVoid: false
    },
    {
      name: "aside",
      isVoid: false
    },
    {
      name: "blockquote",
      isVoid: false
    },
    {
      name: "details",
      isVoid: false
    },
    {
      name: "dialog",
      isVoid: false
    },
    {
      name: "dd",
      isVoid: false
    },
    {
      name: "div",
      isVoid: false
    },
    {
      name: "dl",
      isVoid: false
    },
    {
      name: "dt",
      isVoid: false
    },
    {
      name: "fieldset",
      isVoid: false
    },
    {
      name: "figcaption",
      isVoid: false
    },
    {
      name: "figure",
      isVoid: false
    },
    {
      name: "footer",
      isVoid: false
    },
    {
      name: "form",
      isVoid: false
    },
    {
      name: "h1",
      isVoid: false
    },
    {
      name: "h2",
      isVoid: false
    },
    {
      name: "h3",
      isVoid: false
    },
    {
      name: "h4",
      isVoid: false
    },
    {
      name: "h5",
      isVoid: false
    },
    {
      name: "h6",
      isVoid: false
    },
    {
      name: "header",
      isVoid: false
    },
    {
      name: "hgroup",
      isVoid: false
    },
    {
      name: "hr",
      isVoid: true
    },
    {
      name: "li",
      isVoid: false
    },
    {
      name: "main",
      isVoid: false
    },
    {
      name: "nav",
      isVoid: false
    },
    {
      name: "ol",
      isVoid: false
    },
    {
      name: "p",
      isVoid: false
    },
    {
      name: "section",
      isVoid: false
    },
    {
      name: "table",
      isVoid: false
    },
    {
      name: "tbody",
      isVoid: false
    },
    {
      name: "td",
      isVoid: false
    },
    {
      name: "th",
      isVoid: false
    },
    {
      name: "thead",
      isVoid: false
    },
    {
      name: "tr",
      isVoid: false
    },
    {
      name: "ul",
      isVoid: false
    }
  ];
  const elementNamesToFormat = elementsToFormat.map((element) => element.name).join("|");
  const lines = input.replace(new RegExp(`</?(${elementNamesToFormat})( .*?)?>`, "g"), "\n$&\n").replace(/<br[^>]*>/g, "$&\n").split("\n");
  let indentCount = 0;
  let isPreformattedLine = false;
  return lines.filter((line) => line.length).map((line) => {
    isPreformattedLine = isPreformattedBlockLine(line, isPreformattedLine);
    if (isNonVoidOpeningTag(line, elementsToFormat)) {
      return indentLine(line, indentCount++);
    }
    if (isClosingTag(line, elementsToFormat)) {
      return indentLine(line, --indentCount);
    }
    if (isPreformattedLine === "middle" || isPreformattedLine === "last") {
      return line;
    }
    return indentLine(line, indentCount);
  }).join("\n");
}
function isNonVoidOpeningTag(line, elementsToFormat) {
  return elementsToFormat.some((element) => {
    if (element.isVoid) {
      return false;
    }
    if (!new RegExp(`<${element.name}( .*?)?>`).test(line)) {
      return false;
    }
    return true;
  });
}
function isClosingTag(line, elementsToFormat) {
  return elementsToFormat.some((element) => {
    return new RegExp(`</${element.name}>`).test(line);
  });
}
function indentLine(line, indentCount, indentChar = "    ") {
  return `${indentChar.repeat(Math.max(0, indentCount))}${line}`;
}
function isPreformattedBlockLine(line, isPreviousLinePreFormatted) {
  if (new RegExp("<pre( .*?)?>").test(line)) {
    return "first";
  } else if (new RegExp("</pre>").test(line)) {
    return "last";
  } else if (isPreviousLinePreFormatted === "first" || isPreviousLinePreFormatted === "middle") {
    return "middle";
  } else {
    return false;
  }
}
var sourceEditingIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>';
var COMMAND_FORCE_DISABLE_ID3 = "SourceEditingMode";
var SourceEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The element replacer instance used to replace the editing roots with the wrapper elements containing the document source.
    */
    __publicField(this, "_elementReplacer");
    /**
    * Maps all root names to wrapper elements containing the document source.
    */
    __publicField(this, "_replacedRoots");
    /**
    * Maps all root names to their document data.
    */
    __publicField(this, "_dataFromRoots");
    this.set("isSourceEditingMode", false);
    this._elementReplacer = new ElementReplacer();
    this._replacedRoots = /* @__PURE__ */ new Map();
    this._dataFromRoots = /* @__PURE__ */ new Map();
    editor.config.define("sourceEditing.allowCollaborationFeatures", false);
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SourceEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      PendingActions
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    this._checkCompatibility();
    const editor = this.editor;
    const t = editor.locale.t;
    editor.ui.componentFactory.add("sourceEditing", () => {
      const buttonView = this._createButton(ButtonView);
      buttonView.set({
        label: t("Source"),
        icon: sourceEditingIcon,
        tooltip: true,
        class: "ck-source-editing-button"
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:sourceEditing", () => {
      const buttonView = this._createButton(MenuBarMenuListItemButtonView);
      buttonView.set({
        label: t("Show source"),
        role: "menuitemcheckbox"
      });
      return buttonView;
    });
    if (this._isAllowedToHandleSourceEditingMode()) {
      this.on("change:isSourceEditingMode", (evt, name, isSourceEditingMode) => {
        if (isSourceEditingMode) {
          this._hideVisibleDialog();
          this._showSourceEditing();
          this._disableCommands();
        } else {
          this._hideSourceEditing();
          this._enableCommands();
        }
      });
      this.on("change:isEnabled", (evt, name, isEnabled) => this._handleReadOnlyMode(!isEnabled));
      this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => this._handleReadOnlyMode(isReadOnly));
    }
    editor.data.on("get", () => {
      if (this.isSourceEditingMode) {
        this.updateEditorData();
      }
    }, {
      priority: "high"
    });
  }
  /**
  * Updates the source data in all hidden editing roots.
  */
  updateEditorData() {
    const editor = this.editor;
    const data = {};
    for (const [rootName, domSourceEditingElementWrapper] of this._replacedRoots) {
      const oldData = this._dataFromRoots.get(rootName);
      const newData = domSourceEditingElementWrapper.dataset.value;
      if (oldData !== newData) {
        data[rootName] = newData;
        this._dataFromRoots.set(rootName, newData);
      }
    }
    if (Object.keys(data).length) {
      editor.data.set(data, {
        batchType: {
          isUndoable: true
        },
        suppressErrorInCollaboration: true
      });
    }
  }
  _checkCompatibility() {
    const editor = this.editor;
    const allowCollaboration = editor.config.get("sourceEditing.allowCollaborationFeatures");
    if (!allowCollaboration && editor.plugins.has("RealTimeCollaborativeEditing")) {
      throw new CKEditorError("source-editing-incompatible-with-real-time-collaboration", null);
    }
    const collaborationPluginNamesToWarn = [
      "CommentsEditing",
      "TrackChangesEditing",
      "RevisionHistory"
    ];
    if (!allowCollaboration && collaborationPluginNamesToWarn.some((pluginName) => editor.plugins.has(pluginName))) {
      console.warn("You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features.");
    }
    if (editor.plugins.has("RestrictedEditingModeEditing")) {
      console.warn("You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature.");
    }
  }
  /**
  * Creates source editing wrappers that replace each editing root. Each wrapper contains the document source from the corresponding
  * root.
  *
  * The wrapper element contains a textarea and it solves the problem, that the textarea element cannot auto expand its height based on
  * the content it contains. The solution is to make the textarea more like a plain div element, which expands in height as much as it
  * needs to, in order to display the whole document source without scrolling. The wrapper element is a parent for the textarea and for
  * the pseudo-element `::after`, that replicates the look, content, and position of the textarea. The pseudo-element replica is hidden,
  * but it is styled to be an identical visual copy of the textarea with the same content. Then, the wrapper is a grid container and both
  * of its children (the textarea and the `::after` pseudo-element) are positioned within a CSS grid to occupy the same grid cell. The
  * content in the pseudo-element `::after` is set in CSS and it stretches the grid to the appropriate size based on the textarea value.
  * Since both children occupy the same grid cell, both have always the same height.
  */
  _showSourceEditing() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const model = editor.model;
    model.change((writer) => {
      writer.setSelection(null);
      writer.removeSelectionAttribute(model.document.selection.getAttributeKeys());
    });
    for (const [rootName, domRootElement] of editingView.domRoots) {
      const data = formatSource(editor.data.get({
        rootName
      }));
      const domSourceEditingElementTextarea = createElement(domRootElement.ownerDocument, "textarea", {
        rows: "1",
        "aria-label": "Source code editing area"
      });
      const domSourceEditingElementWrapper = createElement(domRootElement.ownerDocument, "div", {
        class: "ck-source-editing-area",
        "data-value": data
      }, [
        domSourceEditingElementTextarea
      ]);
      domSourceEditingElementTextarea.value = data;
      domSourceEditingElementTextarea.setSelectionRange(0, 0);
      domSourceEditingElementTextarea.addEventListener("input", () => {
        domSourceEditingElementWrapper.dataset.value = domSourceEditingElementTextarea.value;
        editor.ui.update();
      });
      editingView.change((writer) => {
        const viewRoot = editingView.document.getRoot(rootName);
        writer.addClass("ck-hidden", viewRoot);
      });
      editor.ui.setEditableElement("sourceEditing:" + rootName, domSourceEditingElementTextarea);
      this._replacedRoots.set(rootName, domSourceEditingElementWrapper);
      this._elementReplacer.replace(domRootElement, domSourceEditingElementWrapper);
      this._dataFromRoots.set(rootName, data);
    }
    this._focusSourceEditing();
  }
  /**
  * Restores all hidden editing roots and sets the source data in them.
  */
  _hideSourceEditing() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    this.updateEditorData();
    editingView.change((writer) => {
      for (const [rootName] of this._replacedRoots) {
        writer.removeClass("ck-hidden", editingView.document.getRoot(rootName));
      }
    });
    this._elementReplacer.restore();
    this._replacedRoots.clear();
    this._dataFromRoots.clear();
    editingView.focus();
  }
  /**
  * Focuses the textarea containing document source from the first editing root.
  */
  _focusSourceEditing() {
    const editor = this.editor;
    const [domSourceEditingElementWrapper] = this._replacedRoots.values();
    const textarea = domSourceEditingElementWrapper.querySelector("textarea");
    editor.editing.view.document.isFocused = false;
    textarea.focus();
  }
  /**
  * Disables all commands.
  */
  _disableCommands() {
    const editor = this.editor;
    for (const command of editor.commands.commands()) {
      command.forceDisabled(COMMAND_FORCE_DISABLE_ID3);
    }
    if (editor.plugins.has("CommentsArchiveUI")) {
      editor.plugins.get("CommentsArchiveUI").forceDisabled(COMMAND_FORCE_DISABLE_ID3);
    }
  }
  /**
  * Clears forced disable for all commands, that was previously set through {@link #_disableCommands}.
  */
  _enableCommands() {
    const editor = this.editor;
    for (const command of editor.commands.commands()) {
      command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID3);
    }
    if (editor.plugins.has("CommentsArchiveUI")) {
      editor.plugins.get("CommentsArchiveUI").clearForceDisabled(COMMAND_FORCE_DISABLE_ID3);
    }
  }
  /**
  * Adds or removes the `readonly` attribute from the textarea from all roots, if document source mode is active.
  *
  * @param isReadOnly Indicates whether all textarea elements should be read-only.
  */
  _handleReadOnlyMode(isReadOnly) {
    if (!this.isSourceEditingMode) {
      return;
    }
    for (const [, domSourceEditingElementWrapper] of this._replacedRoots) {
      domSourceEditingElementWrapper.querySelector("textarea").readOnly = isReadOnly;
    }
  }
  /**
  * Checks, if the plugin is allowed to handle the source editing mode by itself. Currently, the source editing mode is supported only
  * for the {@link module:editor-classic/classiceditor~ClassicEditor classic editor}.
  */
  _isAllowedToHandleSourceEditingMode() {
    const editor = this.editor;
    const editable = editor.ui.view.editable;
    return editable && !editable.hasExternalElement;
  }
  /**
  * If any {@link module:ui/dialog/dialogview~DialogView editor dialog} is currently visible, hide it.
  */
  _hideVisibleDialog() {
    if (this.editor.plugins.has("Dialog")) {
      const dialogPlugin = this.editor.plugins.get("Dialog");
      if (dialogPlugin.isOpen) {
        dialogPlugin.hide();
      }
    }
  }
  _createButton(ButtonClass) {
    const editor = this.editor;
    const buttonView = new ButtonClass(editor.locale);
    buttonView.set({
      withText: true,
      isToggleable: true
    });
    buttonView.bind("isOn").to(this, "isSourceEditingMode");
    buttonView.bind("isEnabled").to(this, "isEnabled", editor, "isReadOnly", editor.plugins.get(PendingActions), "hasAny", (isEnabled, isEditorReadOnly, hasAnyPendingActions) => {
      if (!isEnabled) {
        return false;
      }
      if (isEditorReadOnly) {
        return false;
      }
      if (hasAnyPendingActions) {
        return false;
      }
      return true;
    });
    this.listenTo(buttonView, "execute", () => {
      this.isSourceEditingMode = !this.isSourceEditingMode;
    });
    return buttonView;
  }
};
function formatSource(input) {
  if (!isHtml(input)) {
    return input;
  }
  return formatHtml(input);
}
function isHtml(input) {
  return input.startsWith("<");
}

// node_modules/@ckeditor/ckeditor5-special-characters/dist/index.js
var CharacterGridView = class extends View2 {
  /**
  * Creates an instance of a character grid containing tiles representing special characters.
  *
  * @param locale The localization services instance.
  */
  constructor(locale) {
    super(locale);
    /**
    * A collection of the child tile views. Each tile represents a particular character.
    */
    __publicField(this, "tiles");
    /**
    * Tracks information about the DOM focus in the grid.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    this.tiles = this.createCollection();
    this.setTemplate({
      tag: "div",
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-character-grid__tiles"
            ]
          },
          children: this.tiles
        }
      ],
      attributes: {
        class: [
          "ck",
          "ck-character-grid"
        ]
      }
    });
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    addKeyboardHandlingForGrid({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.tiles,
      numberOfColumns: () => global.window.getComputedStyle(this.element.firstChild).getPropertyValue("grid-template-columns").split(" ").length,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
  }
  /**
  * Creates a new tile for the grid.
  *
  * @param character A human-readable character displayed as the label (e.g. "").
  * @param name The name of the character (e.g. "greek small letter epsilon").
  */
  createTile(character, name) {
    const tile = new ButtonView(this.locale);
    tile.set({
      label: character,
      withText: true,
      class: "ck-character-grid__tile"
    });
    tile.extendTemplate({
      attributes: {
        title: name
      },
      on: {
        mouseover: tile.bindTemplate.to("mouseover"),
        focus: tile.bindTemplate.to("focus")
      }
    });
    tile.on("mouseover", () => {
      this.fire("tileHover", {
        name,
        character
      });
    });
    tile.on("focus", () => {
      this.fire("tileFocus", {
        name,
        character
      });
    });
    tile.on("execute", () => {
      this.fire("execute", {
        name,
        character
      });
    });
    return tile;
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    for (const item of this.tiles) {
      this.focusTracker.add(item.element);
    }
    this.tiles.on("change", (eventInfo, { added, removed }) => {
      if (added.length > 0) {
        for (const item of added) {
          this.focusTracker.add(item.element);
        }
      }
      if (removed.length > 0) {
        for (const item of removed) {
          this.focusTracker.remove(item.element);
        }
      }
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the first focusable in {@link ~CharacterGridView#tiles}.
  */
  focus() {
    this.tiles.first.focus();
  }
};
var CharacterInfoView = class extends View2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("character", null);
    this.set("name", null);
    this.bind("code").to(this, "character", characterToUnicodeString);
    this.setTemplate({
      tag: "div",
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck-character-info__name"
            ]
          },
          children: [
            {
              // Note: ZWSP to prevent vertical collapsing.
              text: bind.to("name", (name) => name ? name : "")
            }
          ]
        },
        {
          tag: "span",
          attributes: {
            class: [
              "ck-character-info__code"
            ]
          },
          children: [
            {
              text: bind.to("code")
            }
          ]
        }
      ],
      attributes: {
        class: [
          "ck",
          "ck-character-info"
        ]
      }
    });
  }
};
function characterToUnicodeString(character) {
  if (character === null) {
    return "";
  }
  const hexCode = character.codePointAt(0).toString(16);
  return "U+" + ("0000" + hexCode).slice(-4);
}
var SpecialCharactersView = class extends View2 {
  /**
  * Creates an instance of the `SpecialCharactersView`.
  */
  constructor(locale, categoriesView, gridView, infoView) {
    super(locale);
    /**
    * A collection of the focusable children of the view.
    */
    __publicField(this, "items");
    /**
    * Tracks information about the DOM focus in the view.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * Helps cycling over focusable {@link #items} in the view.
    */
    __publicField(this, "_focusCycler");
    /**
    * An instance of the `SpecialCharactersCategoriesView`.
    */
    __publicField(this, "categoriesView");
    /**
    * An instance of the `CharacterGridView`.
    */
    __publicField(this, "gridView");
    /**
    * An instance of the `CharacterInfoView`.
    */
    __publicField(this, "infoView");
    this.categoriesView = categoriesView;
    this.gridView = gridView;
    this.infoView = infoView;
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusCycler = new FocusCycler({
      focusables: this.items,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: "shift + tab",
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "div",
      children: [
        this.categoriesView,
        this.gridView,
        this.infoView
      ],
      attributes: {
        // Avoid focus loss when the user clicks the area of the grid that is not a button.
        // https://github.com/ckeditor/ckeditor5/pull/12319#issuecomment-1231779819
        tabindex: "-1"
      }
    });
    this.items.add(this.categoriesView);
    this.items.add(this.gridView);
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this.focusTracker.add(this.categoriesView.element);
    this.focusTracker.add(this.gridView.element);
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the first focusable in {@link #items}.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
};
var specialCharactersIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>';
var SpecialCharactersCategoriesView = class extends View2 {
  /**
  * Creates an instance of the {@link module:special-characters/ui/specialcharacterscategoriesview~SpecialCharactersCategoriesView}
  * class.
  *
  * @param locale The localization services instance.
  * @param groupNames The names of the character groups.
  */
  constructor(locale, groupNames) {
    super(locale);
    __publicField(this, "_groupNames");
    __publicField(this, "_dropdownView");
    this.set("currentGroupName", Array.from(groupNames.entries())[0][0]);
    this._groupNames = groupNames;
    this._dropdownView = new LabeledFieldView(locale, createLabeledDropdown);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-character-categories"
        ]
      },
      children: [
        this._dropdownView
      ]
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this._setupDropdown();
  }
  /**
  * @inheritDoc
  */
  focus() {
    this._dropdownView.focus();
  }
  /**
  * Creates dropdown item list, sets up bindings and fills properties.
  */
  _setupDropdown() {
    const items = new Collection();
    for (const [name, label] of this._groupNames) {
      const item = {
        type: "button",
        model: new Model2({
          name,
          label,
          role: "menuitemradio",
          withText: true
        })
      };
      item.model.bind("isOn").to(this, "currentGroupName", (value) => {
        return value === name;
      });
      items.add(item);
    }
    const t = this.locale.t;
    const accessibleLabel = t("Category");
    this._dropdownView.set({
      label: accessibleLabel,
      isEmpty: false
    });
    this._dropdownView.fieldView.panelPosition = this.locale.uiLanguageDirection === "rtl" ? "se" : "sw";
    this._dropdownView.fieldView.buttonView.set({
      withText: true,
      tooltip: accessibleLabel,
      ariaLabel: accessibleLabel,
      ariaLabelledBy: void 0,
      isOn: false
    });
    this._dropdownView.fieldView.buttonView.bind("label").to(this, "currentGroupName", (value) => this._groupNames.get(value));
    this._dropdownView.fieldView.on("execute", ({ source }) => {
      this.currentGroupName = source.name;
    });
    addListToDropdown(this._dropdownView.fieldView, items, {
      ariaLabel: accessibleLabel,
      role: "menu"
    });
  }
};
var ALL_SPECIAL_CHARACTERS_GROUP = "All";
var SpecialCharacters = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * Registered characters. A pair of a character name and its symbol.
    */
    __publicField(this, "_characters");
    /**
    * Registered groups. Each group contains a displayed label and a collection with symbol names.
    */
    __publicField(this, "_groups");
    /**
    * A label describing the "All" special characters category.
    */
    __publicField(this, "_allSpecialCharactersGroupLabel");
    const t = editor.t;
    this._characters = /* @__PURE__ */ new Map();
    this._groups = /* @__PURE__ */ new Map();
    this._allSpecialCharactersGroupLabel = t("All");
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Typing,
      Dialog
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SpecialCharacters";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("specialCharacters", () => {
      const button = this._createDialogButton(ButtonView);
      button.set({
        tooltip: true
      });
      return button;
    });
    editor.ui.componentFactory.add("menuBar:specialCharacters", () => {
      return this._createDialogButton(MenuBarMenuListItemButtonView);
    });
  }
  /**
  * Adds a collection of special characters to the specified group. The title of a special character must be unique.
  *
  * **Note:** The "All" category name is reserved by the plugin and cannot be used as a new name for a special
  * characters category.
  */
  addItems(groupName, items, options2 = {
    label: groupName
  }) {
    if (groupName === ALL_SPECIAL_CHARACTERS_GROUP) {
      throw new CKEditorError("special-character-invalid-group-name", null);
    }
    const group = this._getGroup(groupName, options2.label);
    for (const item of items) {
      group.items.add(item.title);
      this._characters.set(item.title, item.character);
    }
  }
  /**
  * Returns special character groups in an order determined based on configuration and registration sequence.
  */
  getGroups() {
    const groups = Array.from(this._groups.keys());
    const order = this.editor.config.get("specialCharacters.order") || [];
    const invalidGroup = order.find((item) => !groups.includes(item));
    if (invalidGroup) {
      throw new CKEditorError("special-character-invalid-order-group-name", null, {
        invalidGroup
      });
    }
    return /* @__PURE__ */ new Set([
      ...order,
      ...groups
    ]);
  }
  /**
  * Returns a collection of special characters symbol names (titles).
  */
  getCharactersForGroup(groupName) {
    if (groupName === ALL_SPECIAL_CHARACTERS_GROUP) {
      return new Set(this._characters.keys());
    }
    const group = this._groups.get(groupName);
    if (group) {
      return group.items;
    }
  }
  /**
  * Returns the symbol of a special character for the specified name. If the special character could not be found, `undefined`
  * is returned.
  *
  * @param title The title of a special character.
  */
  getCharacter(title) {
    return this._characters.get(title);
  }
  /**
  * Returns a group of special characters. If the group with the specified name does not exist, it will be created.
  *
  * @param groupName The name of the group to create.
  * @param label The label describing the new group.
  */
  _getGroup(groupName, label) {
    if (!this._groups.has(groupName)) {
      this._groups.set(groupName, {
        items: /* @__PURE__ */ new Set(),
        label
      });
    }
    return this._groups.get(groupName);
  }
  /**
  * Updates the symbol grid depending on the currently selected character group.
  */
  _updateGrid(currentGroupName, gridView) {
    gridView.tiles.clear();
    const characterTitles = this.getCharactersForGroup(currentGroupName);
    for (const title of characterTitles) {
      const character = this.getCharacter(title);
      gridView.tiles.add(gridView.createTile(character, title));
    }
  }
  /**
  * Initializes the dropdown, used for lazy loading.
  *
  * @returns An object with `categoriesView`, `gridView` and `infoView` properties, containing UI parts.
  */
  _createDropdownPanelContent(locale) {
    const groupEntries = Array.from(this.getGroups()).map((name) => [
      name,
      this._groups.get(name).label
    ]);
    const specialCharsGroups = new Map([
      // Add a special group that shows all available special characters.
      [
        ALL_SPECIAL_CHARACTERS_GROUP,
        this._allSpecialCharactersGroupLabel
      ],
      ...groupEntries
    ]);
    const categoriesView = new SpecialCharactersCategoriesView(locale, specialCharsGroups);
    const gridView = new CharacterGridView(locale);
    const infoView = new CharacterInfoView(locale);
    gridView.on("tileHover", (evt, data) => {
      infoView.set(data);
    });
    gridView.on("tileFocus", (evt, data) => {
      infoView.set(data);
    });
    categoriesView.on("change:currentGroupName", (evt, propertyName, newValue) => {
      this._updateGrid(newValue, gridView);
    });
    this._updateGrid(categoriesView.currentGroupName, gridView);
    return {
      categoriesView,
      gridView,
      infoView
    };
  }
  /**
  * Creates a button for toolbar and menu bar that will show special characters dialog.
  */
  _createDialogButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const buttonView = new ButtonClass(editor.locale);
    const command = editor.commands.get("insertText");
    const t = locale.t;
    const dialogPlugin = this.editor.plugins.get("Dialog");
    buttonView.set({
      label: t("Special characters"),
      icon: specialCharactersIcon,
      isToggleable: true
    });
    buttonView.bind("isOn").to(dialogPlugin, "id", (id) => id === "specialCharacters");
    buttonView.bind("isEnabled").to(command, "isEnabled");
    buttonView.on("execute", () => {
      if (dialogPlugin.id === "specialCharacters") {
        dialogPlugin.hide();
        return;
      }
      this._showDialog();
    });
    return buttonView;
  }
  _showDialog() {
    const editor = this.editor;
    const dialog = editor.plugins.get("Dialog");
    const locale = editor.locale;
    const t = locale.t;
    const { categoriesView, gridView, infoView } = this._createDropdownPanelContent(locale);
    const content = new SpecialCharactersView(locale, categoriesView, gridView, infoView);
    gridView.on("execute", (evt, data) => {
      editor.execute("insertText", {
        text: data.character
      });
    });
    dialog.show({
      id: "specialCharacters",
      title: t("Special characters"),
      className: "ck-special-characters",
      content,
      position: DialogViewPosition.EDITOR_TOP_SIDE
    });
  }
};
var SpecialCharactersArrows = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SpecialCharactersArrows";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const plugin = editor.plugins.get("SpecialCharacters");
    plugin.addItems("Arrows", [
      {
        title: t("leftwards simple arrow"),
        character: ""
      },
      {
        title: t("rightwards simple arrow"),
        character: ""
      },
      {
        title: t("upwards simple arrow"),
        character: ""
      },
      {
        title: t("downwards simple arrow"),
        character: ""
      },
      {
        title: t("leftwards double arrow"),
        character: ""
      },
      {
        title: t("rightwards double arrow"),
        character: ""
      },
      {
        title: t("upwards double arrow"),
        character: ""
      },
      {
        title: t("downwards double arrow"),
        character: ""
      },
      {
        title: t("leftwards dashed arrow"),
        character: ""
      },
      {
        title: t("rightwards dashed arrow"),
        character: ""
      },
      {
        title: t("upwards dashed arrow"),
        character: ""
      },
      {
        title: t("downwards dashed arrow"),
        character: ""
      },
      {
        title: t("leftwards arrow to bar"),
        character: ""
      },
      {
        title: t("rightwards arrow to bar"),
        character: ""
      },
      {
        title: t("upwards arrow to bar"),
        character: ""
      },
      {
        title: t("downwards arrow to bar"),
        character: ""
      },
      {
        title: t("up down arrow with base"),
        character: ""
      },
      {
        title: t("back with leftwards arrow above"),
        character: ""
      },
      {
        title: t("end with leftwards arrow above"),
        character: ""
      },
      {
        title: t("on with exclamation mark with left right arrow above"),
        character: ""
      },
      {
        title: t("soon with rightwards arrow above"),
        character: ""
      },
      {
        title: t("top with upwards arrow above"),
        character: ""
      }
    ], {
      label: t("Arrows")
    });
  }
};
var SpecialCharactersText = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SpecialCharactersText";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const plugin = editor.plugins.get("SpecialCharacters");
    plugin.addItems("Text", [
      {
        character: "",
        title: t("Single left-pointing angle quotation mark")
      },
      {
        character: "",
        title: t("Single right-pointing angle quotation mark")
      },
      {
        character: "",
        title: t("Left-pointing double angle quotation mark")
      },
      {
        character: "",
        title: t("Right-pointing double angle quotation mark")
      },
      {
        character: "",
        title: t("Left single quotation mark")
      },
      {
        character: "",
        title: t("Right single quotation mark")
      },
      {
        character: "",
        title: t("Left double quotation mark")
      },
      {
        character: "",
        title: t("Right double quotation mark")
      },
      {
        character: "",
        title: t("Single low-9 quotation mark")
      },
      {
        character: "",
        title: t("Double low-9 quotation mark")
      },
      {
        character: "",
        title: t("Inverted exclamation mark")
      },
      {
        character: "",
        title: t("Inverted question mark")
      },
      {
        character: "",
        title: t("Two dot leader")
      },
      {
        character: "",
        title: t("Horizontal ellipsis")
      },
      {
        character: "",
        title: t("Double dagger")
      },
      {
        character: "",
        title: t("Per mille sign")
      },
      {
        character: "",
        title: t("Per ten thousand sign")
      },
      {
        character: "",
        title: t("Double exclamation mark")
      },
      {
        character: "",
        title: t("Question exclamation mark")
      },
      {
        character: "",
        title: t("Exclamation question mark")
      },
      {
        character: "",
        title: t("Double question mark")
      },
      {
        character: "",
        title: t("Copyright sign")
      },
      {
        character: "",
        title: t("Registered sign")
      },
      {
        character: "",
        title: t("Trade mark sign")
      },
      {
        character: "",
        title: t("Section sign")
      },
      {
        character: "",
        title: t("Paragraph sign")
      },
      {
        character: "",
        title: t("Reversed paragraph sign")
      }
    ], {
      label: t("Text")
    });
  }
};
var SpecialCharactersMathematical = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SpecialCharactersMathematical";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const plugin = editor.plugins.get("SpecialCharacters");
    plugin.addItems("Mathematical", [
      {
        character: "<",
        title: t("Less-than sign")
      },
      {
        character: ">",
        title: t("Greater-than sign")
      },
      {
        character: "",
        title: t("Less-than or equal to")
      },
      {
        character: "",
        title: t("Greater-than or equal to")
      },
      {
        character: "",
        title: t("En dash")
      },
      {
        character: "",
        title: t("Em dash")
      },
      {
        character: "",
        title: t("Macron")
      },
      {
        character: "",
        title: t("Overline")
      },
      {
        character: "",
        title: t("Degree sign")
      },
      {
        character: "",
        title: t("Minus sign")
      },
      {
        character: "",
        title: t("Plus-minus sign")
      },
      {
        character: "",
        title: t("Division sign")
      },
      {
        character: "",
        title: t("Fraction slash")
      },
      {
        character: "",
        title: t("Multiplication sign")
      },
      {
        character: "",
        title: t("Latin small letter f with hook")
      },
      {
        character: "",
        title: t("Integral")
      },
      {
        character: "",
        title: t("N-ary summation")
      },
      {
        character: "",
        title: t("Infinity")
      },
      {
        character: "",
        title: t("Square root")
      },
      {
        character: "",
        title: t("Tilde operator")
      },
      {
        character: "",
        title: t("Approximately equal to")
      },
      {
        character: "",
        title: t("Almost equal to")
      },
      {
        character: "",
        title: t("Not equal to")
      },
      {
        character: "",
        title: t("Identical to")
      },
      {
        character: "",
        title: t("Element of")
      },
      {
        character: "",
        title: t("Not an element of")
      },
      {
        character: "",
        title: t("Contains as member")
      },
      {
        character: "",
        title: t("N-ary product")
      },
      {
        character: "",
        title: t("Logical and")
      },
      {
        character: "",
        title: t("Logical or")
      },
      {
        character: "",
        title: t("Not sign")
      },
      {
        character: "",
        title: t("Intersection")
      },
      {
        character: "",
        title: t("Union")
      },
      {
        character: "",
        title: t("Partial differential")
      },
      {
        character: "",
        title: t("For all")
      },
      {
        character: "",
        title: t("There exists")
      },
      {
        character: "",
        title: t("Empty set")
      },
      {
        character: "",
        title: t("Nabla")
      },
      {
        character: "",
        title: t("Asterisk operator")
      },
      {
        character: "",
        title: t("Proportional to")
      },
      {
        character: "",
        title: t("Angle")
      },
      {
        character: "",
        title: t("Vulgar fraction one quarter")
      },
      {
        character: "",
        title: t("Vulgar fraction one half")
      },
      {
        character: "",
        title: t("Vulgar fraction three quarters")
      }
    ], {
      label: t("Mathematical")
    });
  }
};
var SpecialCharactersLatin = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SpecialCharactersLatin";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const plugin = editor.plugins.get("SpecialCharacters");
    plugin.addItems("Latin", [
      {
        character: "",
        title: t("Latin capital letter a with macron")
      },
      {
        character: "",
        title: t("Latin small letter a with macron")
      },
      {
        character: "",
        title: t("Latin capital letter a with breve")
      },
      {
        character: "",
        title: t("Latin small letter a with breve")
      },
      {
        character: "",
        title: t("Latin capital letter a with ogonek")
      },
      {
        character: "",
        title: t("Latin small letter a with ogonek")
      },
      {
        character: "",
        title: t("Latin capital letter c with acute")
      },
      {
        character: "",
        title: t("Latin small letter c with acute")
      },
      {
        character: "",
        title: t("Latin capital letter c with circumflex")
      },
      {
        character: "",
        title: t("Latin small letter c with circumflex")
      },
      {
        character: "",
        title: t("Latin capital letter c with dot above")
      },
      {
        character: "",
        title: t("Latin small letter c with dot above")
      },
      {
        character: "",
        title: t("Latin capital letter c with caron")
      },
      {
        character: "",
        title: t("Latin small letter c with caron")
      },
      {
        character: "",
        title: t("Latin capital letter d with caron")
      },
      {
        character: "",
        title: t("Latin small letter d with caron")
      },
      {
        character: "",
        title: t("Latin capital letter d with stroke")
      },
      {
        character: "",
        title: t("Latin small letter d with stroke")
      },
      {
        character: "",
        title: t("Latin capital letter e with macron")
      },
      {
        character: "",
        title: t("Latin small letter e with macron")
      },
      {
        character: "",
        title: t("Latin capital letter e with breve")
      },
      {
        character: "",
        title: t("Latin small letter e with breve")
      },
      {
        character: "",
        title: t("Latin capital letter e with dot above")
      },
      {
        character: "",
        title: t("Latin small letter e with dot above")
      },
      {
        character: "",
        title: t("Latin capital letter e with ogonek")
      },
      {
        character: "",
        title: t("Latin small letter e with ogonek")
      },
      {
        character: "",
        title: t("Latin capital letter e with caron")
      },
      {
        character: "",
        title: t("Latin small letter e with caron")
      },
      {
        character: "",
        title: t("Latin capital letter g with circumflex")
      },
      {
        character: "",
        title: t("Latin small letter g with circumflex")
      },
      {
        character: "",
        title: t("Latin capital letter g with breve")
      },
      {
        character: "",
        title: t("Latin small letter g with breve")
      },
      {
        character: "",
        title: t("Latin capital letter g with dot above")
      },
      {
        character: "",
        title: t("Latin small letter g with dot above")
      },
      {
        character: "",
        title: t("Latin capital letter g with cedilla")
      },
      {
        character: "",
        title: t("Latin small letter g with cedilla")
      },
      {
        character: "",
        title: t("Latin capital letter h with circumflex")
      },
      {
        character: "",
        title: t("Latin small letter h with circumflex")
      },
      {
        character: "",
        title: t("Latin capital letter h with stroke")
      },
      {
        character: "",
        title: t("Latin small letter h with stroke")
      },
      {
        character: "",
        title: t("Latin capital letter i with tilde")
      },
      {
        character: "",
        title: t("Latin small letter i with tilde")
      },
      {
        character: "",
        title: t("Latin capital letter i with macron")
      },
      {
        character: "",
        title: t("Latin small letter i with macron")
      },
      {
        character: "",
        title: t("Latin capital letter i with breve")
      },
      {
        character: "",
        title: t("Latin small letter i with breve")
      },
      {
        character: "",
        title: t("Latin capital letter i with ogonek")
      },
      {
        character: "",
        title: t("Latin small letter i with ogonek")
      },
      {
        character: "",
        title: t("Latin capital letter i with dot above")
      },
      {
        character: "",
        title: t("Latin small letter dotless i")
      },
      {
        character: "",
        title: t("Latin capital ligature ij")
      },
      {
        character: "",
        title: t("Latin small ligature ij")
      },
      {
        character: "",
        title: t("Latin capital letter j with circumflex")
      },
      {
        character: "",
        title: t("Latin small letter j with circumflex")
      },
      {
        character: "",
        title: t("Latin capital letter k with cedilla")
      },
      {
        character: "",
        title: t("Latin small letter k with cedilla")
      },
      {
        character: "",
        title: t("Latin small letter kra")
      },
      {
        character: "",
        title: t("Latin capital letter l with acute")
      },
      {
        character: "",
        title: t("Latin small letter l with acute")
      },
      {
        character: "",
        title: t("Latin capital letter l with cedilla")
      },
      {
        character: "",
        title: t("Latin small letter l with cedilla")
      },
      {
        character: "",
        title: t("Latin capital letter l with caron")
      },
      {
        character: "",
        title: t("Latin small letter l with caron")
      },
      {
        character: "",
        title: t("Latin capital letter l with middle dot")
      },
      {
        character: "",
        title: t("Latin small letter l with middle dot")
      },
      {
        character: "",
        title: t("Latin capital letter l with stroke")
      },
      {
        character: "",
        title: t("Latin small letter l with stroke")
      },
      {
        character: "",
        title: t("Latin capital letter n with acute")
      },
      {
        character: "",
        title: t("Latin small letter n with acute")
      },
      {
        character: "",
        title: t("Latin capital letter n with cedilla")
      },
      {
        character: "",
        title: t("Latin small letter n with cedilla")
      },
      {
        character: "",
        title: t("Latin capital letter n with caron")
      },
      {
        character: "",
        title: t("Latin small letter n with caron")
      },
      {
        character: "",
        title: t("Latin small letter n preceded by apostrophe")
      },
      {
        character: "",
        title: t("Latin capital letter eng")
      },
      {
        character: "",
        title: t("Latin small letter eng")
      },
      {
        character: "",
        title: t("Latin capital letter o with macron")
      },
      {
        character: "",
        title: t("Latin small letter o with macron")
      },
      {
        character: "",
        title: t("Latin capital letter o with breve")
      },
      {
        character: "",
        title: t("Latin small letter o with breve")
      },
      {
        character: "",
        title: t("Latin capital letter o with double acute")
      },
      {
        character: "",
        title: t("Latin small letter o with double acute")
      },
      {
        character: "",
        title: t("Latin capital ligature oe")
      },
      {
        character: "",
        title: t("Latin small ligature oe")
      },
      {
        character: "",
        title: t("Latin capital letter r with acute")
      },
      {
        character: "",
        title: t("Latin small letter r with acute")
      },
      {
        character: "",
        title: t("Latin capital letter r with cedilla")
      },
      {
        character: "",
        title: t("Latin small letter r with cedilla")
      },
      {
        character: "",
        title: t("Latin capital letter r with caron")
      },
      {
        character: "",
        title: t("Latin small letter r with caron")
      },
      {
        character: "",
        title: t("Latin capital letter s with acute")
      },
      {
        character: "",
        title: t("Latin small letter s with acute")
      },
      {
        character: "",
        title: t("Latin capital letter s with circumflex")
      },
      {
        character: "",
        title: t("Latin small letter s with circumflex")
      },
      {
        character: "",
        title: t("Latin capital letter s with cedilla")
      },
      {
        character: "",
        title: t("Latin small letter s with cedilla")
      },
      {
        character: "",
        title: t("Latin capital letter s with caron")
      },
      {
        character: "",
        title: t("Latin small letter s with caron")
      },
      {
        character: "",
        title: t("Latin capital letter t with cedilla")
      },
      {
        character: "",
        title: t("Latin small letter t with cedilla")
      },
      {
        character: "",
        title: t("Latin capital letter t with caron")
      },
      {
        character: "",
        title: t("Latin small letter t with caron")
      },
      {
        character: "",
        title: t("Latin capital letter t with stroke")
      },
      {
        character: "",
        title: t("Latin small letter t with stroke")
      },
      {
        character: "",
        title: t("Latin capital letter u with tilde")
      },
      {
        character: "",
        title: t("Latin small letter u with tilde")
      },
      {
        character: "",
        title: t("Latin capital letter u with macron")
      },
      {
        character: "",
        title: t("Latin small letter u with macron")
      },
      {
        character: "",
        title: t("Latin capital letter u with breve")
      },
      {
        character: "",
        title: t("Latin small letter u with breve")
      },
      {
        character: "",
        title: t("Latin capital letter u with ring above")
      },
      {
        character: "",
        title: t("Latin small letter u with ring above")
      },
      {
        character: "",
        title: t("Latin capital letter u with double acute")
      },
      {
        character: "",
        title: t("Latin small letter u with double acute")
      },
      {
        character: "",
        title: t("Latin capital letter u with ogonek")
      },
      {
        character: "",
        title: t("Latin small letter u with ogonek")
      },
      {
        character: "",
        title: t("Latin capital letter w with circumflex")
      },
      {
        character: "",
        title: t("Latin small letter w with circumflex")
      },
      {
        character: "",
        title: t("Latin capital letter y with circumflex")
      },
      {
        character: "",
        title: t("Latin small letter y with circumflex")
      },
      {
        character: "",
        title: t("Latin capital letter y with diaeresis")
      },
      {
        character: "",
        title: t("Latin capital letter z with acute")
      },
      {
        character: "",
        title: t("Latin small letter z with acute")
      },
      {
        character: "",
        title: t("Latin capital letter z with dot above")
      },
      {
        character: "",
        title: t("Latin small letter z with dot above")
      },
      {
        character: "",
        title: t("Latin capital letter z with caron")
      },
      {
        character: "",
        title: t("Latin small letter z with caron")
      },
      {
        character: "",
        title: t("Latin small letter long s")
      }
    ], {
      label: t("Latin")
    });
  }
};
var SpecialCharactersCurrency = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SpecialCharactersCurrency";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const plugin = editor.plugins.get("SpecialCharacters");
    plugin.addItems("Currency", [
      {
        character: "$",
        title: t("Dollar sign")
      },
      {
        character: "",
        title: t("Euro sign")
      },
      {
        character: "",
        title: t("Yen sign")
      },
      {
        character: "",
        title: t("Pound sign")
      },
      {
        character: "",
        title: t("Cent sign")
      },
      {
        character: "",
        title: t("Euro-currency sign")
      },
      {
        character: "",
        title: t("Colon sign")
      },
      {
        character: "",
        title: t("Cruzeiro sign")
      },
      {
        character: "",
        title: t("French franc sign")
      },
      {
        character: "",
        title: t("Lira sign")
      },
      {
        character: "",
        title: t("Currency sign")
      },
      {
        character: "",
        title: t("Bitcoin sign")
      },
      {
        character: "",
        title: t("Mill sign")
      },
      {
        character: "",
        title: t("Naira sign")
      },
      {
        character: "",
        title: t("Peseta sign")
      },
      {
        character: "",
        title: t("Rupee sign")
      },
      {
        character: "",
        title: t("Won sign")
      },
      {
        character: "",
        title: t("New sheqel sign")
      },
      {
        character: "",
        title: t("Dong sign")
      },
      {
        character: "",
        title: t("Kip sign")
      },
      {
        character: "",
        title: t("Tugrik sign")
      },
      {
        character: "",
        title: t("Drachma sign")
      },
      {
        character: "",
        title: t("German penny sign")
      },
      {
        character: "",
        title: t("Peso sign")
      },
      {
        character: "",
        title: t("Guarani sign")
      },
      {
        character: "",
        title: t("Austral sign")
      },
      {
        character: "",
        title: t("Hryvnia sign")
      },
      {
        character: "",
        title: t("Cedi sign")
      },
      {
        character: "",
        title: t("Livre tournois sign")
      },
      {
        character: "",
        title: t("Spesmilo sign")
      },
      {
        character: "",
        title: t("Tenge sign")
      },
      {
        character: "",
        title: t("Indian rupee sign")
      },
      {
        character: "",
        title: t("Turkish lira sign")
      },
      {
        character: "",
        title: t("Nordic mark sign")
      },
      {
        character: "",
        title: t("Manat sign")
      },
      {
        character: "",
        title: t("Ruble sign")
      }
    ], {
      label: t("Currency")
    });
  }
};
var SpecialCharactersEssentials = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "SpecialCharactersEssentials";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      SpecialCharactersCurrency,
      SpecialCharactersText,
      SpecialCharactersMathematical,
      SpecialCharactersArrows,
      SpecialCharactersLatin
    ];
  }
};

// node_modules/@ckeditor/ckeditor5-style/dist/index.js
var StyleGridButtonView = class extends ButtonView {
  /**
  * Creates an instance of the {@link module:style/ui/stylegridbuttonview~StyleGridButtonView} class.
  *
  * @param locale The localization services instance.
  * @param styleDefinition Definition of the style.
  */
  constructor(locale, styleDefinition) {
    super(locale);
    /**
    * Definition of the style the button will apply when executed.
    */
    __publicField(this, "styleDefinition");
    /**
    * The view rendering the preview of the style.
    */
    __publicField(this, "previewView");
    this.styleDefinition = styleDefinition;
    this.previewView = this._createPreview();
    this.set({
      label: styleDefinition.name,
      class: "ck-style-grid__button",
      withText: true
    });
    this.extendTemplate({
      attributes: {
        role: "option"
      }
    });
    this.children.add(this.previewView, 0);
  }
  /**
  * Creates the view representing the preview of the style.
  */
  _createPreview() {
    const previewView = new View2(this.locale);
    previewView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset_all-excluded",
          "ck-style-grid__button__preview",
          "ck-content"
        ],
        // The preview "AaBbCcDdEeFfGgHhIiJj" should not be read by screen readers because it is purely presentational.
        "aria-hidden": "true"
      },
      children: [
        this.styleDefinition.previewTemplate
      ]
    });
    return previewView;
  }
};
var StyleGridView = class extends View2 {
  /**
  * Creates an instance of the {@link module:style/ui/stylegridview~StyleGridView} class.
  *
  * @param locale The localization services instance.
  * @param styleDefinitions Definitions of the styles.
  */
  constructor(locale, styleDefinitions) {
    super(locale);
    /**
    * Tracks information about the DOM focus in the view.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * A collection of style {@link module:style/ui/stylegridbuttonview~StyleGridButtonView buttons}.
    */
    __publicField(this, "children");
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.set("activeStyles", []);
    this.set("enabledStyles", []);
    this.children = this.createCollection();
    this.children.delegate("execute").to(this);
    for (const definition of styleDefinitions) {
      const gridTileView = new StyleGridButtonView(locale, definition);
      this.children.add(gridTileView);
    }
    this.on("change:activeStyles", () => {
      for (const child of this.children) {
        child.isOn = this.activeStyles.includes(child.styleDefinition.name);
      }
    });
    this.on("change:enabledStyles", () => {
      for (const child of this.children) {
        child.isEnabled = this.enabledStyles.includes(child.styleDefinition.name);
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-style-grid"
        ],
        role: "listbox"
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    for (const child of this.children) {
      this.focusTracker.add(child.element);
    }
    addKeyboardHandlingForGrid({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.children,
      numberOfColumns: 3,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * Focuses the first style button in the grid.
  */
  focus() {
    this.children.first.focus();
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
};
var StyleGroupView = class extends View2 {
  /**
  * Creates an instance of the {@link module:style/ui/stylegroupview~StyleGroupView} class.
  *
  * @param locale The localization services instance.
  * @param label The localized label of the group.
  * @param styleDefinitions Definitions of the styles in the group.
  */
  constructor(locale, label, styleDefinitions) {
    super(locale);
    /**
    * The styles grid of the group.
    */
    __publicField(this, "gridView");
    /**
    * The label of the group.
    */
    __publicField(this, "labelView");
    this.labelView = new LabelView(locale);
    this.labelView.text = label;
    this.gridView = new StyleGridView(locale, styleDefinitions);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-style-panel__style-group"
        ],
        role: "group",
        "aria-labelledby": this.labelView.id
      },
      children: [
        this.labelView,
        this.gridView
      ]
    });
  }
};
var StylePanelView = class extends View2 {
  /**
  * Creates an instance of the {@link module:style/ui/stylegroupview~StyleGroupView} class.
  *
  * @param locale The localization services instance.
  * @param styleDefinitions Normalized definitions of the styles.
  */
  constructor(locale, styleDefinitions) {
    super(locale);
    /**
    * Tracks information about DOM focus in the panel.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * A collection of panel children.
    */
    __publicField(this, "children");
    /**
    * A view representing block styles group.
    */
    __publicField(this, "blockStylesGroupView");
    /**
    * A view representing inline styles group
    */
    __publicField(this, "inlineStylesGroupView");
    /**
    * A collection of views that can be focused in the panel.
    */
    __publicField(this, "_focusables");
    /**
    * Helps cycling over {@link #_focusables} in the panel.
    */
    __publicField(this, "_focusCycler");
    const t = locale.t;
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.children = this.createCollection();
    this.blockStylesGroupView = new StyleGroupView(locale, t("Block styles"), styleDefinitions.block);
    this.inlineStylesGroupView = new StyleGroupView(locale, t("Text styles"), styleDefinitions.inline);
    this.set("activeStyles", []);
    this.set("enabledStyles", []);
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate style groups backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: [
          "shift + tab"
        ],
        // Navigate style groups forward using the <kbd>Tab</kbd> key.
        focusNext: [
          "tab"
        ]
      }
    });
    if (styleDefinitions.block.length) {
      this.children.add(this.blockStylesGroupView);
    }
    if (styleDefinitions.inline.length) {
      this.children.add(this.inlineStylesGroupView);
    }
    this.blockStylesGroupView.gridView.delegate("execute").to(this);
    this.inlineStylesGroupView.gridView.delegate("execute").to(this);
    this.blockStylesGroupView.gridView.bind("activeStyles", "enabledStyles").to(this, "activeStyles", "enabledStyles");
    this.inlineStylesGroupView.gridView.bind("activeStyles", "enabledStyles").to(this, "activeStyles", "enabledStyles");
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-style-panel"
        ]
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    this._focusables.add(this.blockStylesGroupView.gridView);
    this._focusables.add(this.inlineStylesGroupView.gridView);
    this.focusTracker.add(this.blockStylesGroupView.gridView.element);
    this.focusTracker.add(this.inlineStylesGroupView.gridView.element);
    this.keystrokes.listenTo(this.element);
  }
  /**
  * Focuses the first focusable element in the panel.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Focuses the last focusable element in the panel.
  */
  focusLast() {
    this._focusCycler.focusLast();
  }
};
var NON_PREVIEWABLE_ELEMENT_NAMES = [
  "caption",
  "colgroup",
  "dd",
  "dt",
  "figcaption",
  "legend",
  "li",
  "optgroup",
  "option",
  "rp",
  "rt",
  "summary",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "tr"
];
var StyleUtils = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    __publicField(this, "_htmlSupport");
    this.decorate("isStyleEnabledForBlock");
    this.decorate("isStyleActiveForBlock");
    this.decorate("getAffectedBlocks");
    this.decorate("isStyleEnabledForInlineSelection");
    this.decorate("isStyleActiveForInlineSelection");
    this.decorate("getAffectedInlineSelectable");
    this.decorate("getStylePreview");
    this.decorate("configureGHSDataFilter");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StyleUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
  }
  /**
  * Normalizes {@link module:style/styleconfig~StyleConfig#definitions} in the configuration of the styles feature.
  * The structure of normalized styles looks as follows:
  *
  * ```ts
  * {
  * 	block: [
  * 		<module:style/style~StyleDefinition>,
  * 		<module:style/style~StyleDefinition>,
  * 		...
  * 	],
  * 	inline: [
  * 		<module:style/style~StyleDefinition>,
  * 		<module:style/style~StyleDefinition>,
  * 		...
  * 	]
  * }
  * ```
  *
  * @returns An object with normalized style definitions grouped into `block` and `inline` categories (arrays).
  */
  normalizeConfig(dataSchema, styleDefinitions = []) {
    const normalizedDefinitions = {
      block: [],
      inline: []
    };
    for (const definition of styleDefinitions) {
      const modelElements = [];
      const ghsAttributes = [];
      for (const ghsDefinition of dataSchema.getDefinitionsForView(definition.element)) {
        const appliesToBlock = "appliesToBlock" in ghsDefinition ? ghsDefinition.appliesToBlock : false;
        if (ghsDefinition.isBlock || appliesToBlock) {
          if (typeof appliesToBlock == "string") {
            modelElements.push(appliesToBlock);
          } else if (ghsDefinition.isBlock) {
            const ghsBlockDefinition = ghsDefinition;
            modelElements.push(ghsDefinition.model);
            if (ghsBlockDefinition.paragraphLikeModel) {
              modelElements.push(ghsBlockDefinition.paragraphLikeModel);
            }
          }
        } else {
          ghsAttributes.push(ghsDefinition.model);
        }
      }
      const previewTemplate = this.getStylePreview(definition, [
        {
          text: "AaBbCcDdEeFfGgHhIiJj"
        }
      ]);
      if (modelElements.length) {
        normalizedDefinitions.block.push({
          ...definition,
          previewTemplate,
          modelElements,
          isBlock: true
        });
      } else {
        normalizedDefinitions.inline.push({
          ...definition,
          previewTemplate,
          ghsAttributes
        });
      }
    }
    return normalizedDefinitions;
  }
  /**
  * Verifies if the given style is applicable to the provided block element.
  *
  * @internal
  */
  isStyleEnabledForBlock(definition, block2) {
    const model = this.editor.model;
    const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
    if (!model.schema.checkAttribute(block2, attributeName)) {
      return false;
    }
    return definition.modelElements.includes(block2.name);
  }
  /**
  * Returns true if the given style is applied to the specified block element.
  *
  * @internal
  */
  isStyleActiveForBlock(definition, block2) {
    const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
    const ghsAttributeValue = block2.getAttribute(attributeName);
    return this.hasAllClasses(ghsAttributeValue, definition.classes);
  }
  /**
  * Returns an array of block elements that style should be applied to.
  *
  * @internal
  */
  getAffectedBlocks(definition, block2) {
    if (definition.modelElements.includes(block2.name)) {
      return [
        block2
      ];
    }
    return null;
  }
  /**
  * Verifies if the given style is applicable to the provided document selection.
  *
  * @internal
  */
  isStyleEnabledForInlineSelection(definition, selection) {
    const model = this.editor.model;
    for (const ghsAttributeName of definition.ghsAttributes) {
      if (model.schema.checkAttributeInSelection(selection, ghsAttributeName)) {
        return true;
      }
    }
    return false;
  }
  /**
  * Returns true if the given style is applied to the specified document selection.
  *
  * @internal
  */
  isStyleActiveForInlineSelection(definition, selection) {
    for (const ghsAttributeName of definition.ghsAttributes) {
      const ghsAttributeValue = this._getValueFromFirstAllowedNode(selection, ghsAttributeName);
      if (this.hasAllClasses(ghsAttributeValue, definition.classes)) {
        return true;
      }
    }
    return false;
  }
  /**
  * Returns a selectable that given style should be applied to.
  *
  * @internal
  */
  getAffectedInlineSelectable(definition, selection) {
    return selection;
  }
  /**
  * Returns the `TemplateDefinition` used by styles dropdown to render style preview.
  *
  * @internal
  */
  getStylePreview(definition, children) {
    const { element, classes } = definition;
    return {
      tag: isPreviewable(element) ? element : "div",
      attributes: {
        class: classes
      },
      children
    };
  }
  /**
  * Verifies if all classes are present in the given GHS attribute.
  *
  * @internal
  */
  hasAllClasses(ghsAttributeValue, classes) {
    return isObject_default(ghsAttributeValue) && hasClassesProperty(ghsAttributeValue) && classes.every((className) => ghsAttributeValue.classes.includes(className));
  }
  /**
  * This is where the styles feature configures the GHS feature. This method translates normalized
  * {@link module:style/styleconfig~StyleDefinition style definitions} to
  * {@link module:engine/view/matcher~MatcherObjectPattern matcher patterns} and feeds them to the GHS
  * {@link module:html-support/datafilter~DataFilter} plugin.
  *
  * @internal
  */
  configureGHSDataFilter({ block: block2, inline: inline2 }) {
    const ghsDataFilter = this.editor.plugins.get("DataFilter");
    ghsDataFilter.loadAllowedConfig(block2.map(normalizedStyleDefinitionToMatcherPattern));
    ghsDataFilter.loadAllowedConfig(inline2.map(normalizedStyleDefinitionToMatcherPattern));
  }
  /**
  * Checks the attribute value of the first node in the selection that allows the attribute.
  * For the collapsed selection, returns the selection attribute.
  *
  * @param selection The document selection.
  * @param attributeName Name of the GHS attribute.
  * @returns The attribute value.
  */
  _getValueFromFirstAllowedNode(selection, attributeName) {
    const model = this.editor.model;
    const schema = model.schema;
    if (selection.isCollapsed) {
      return selection.getAttribute(attributeName);
    }
    for (const range of selection.getRanges()) {
      for (const item of range.getItems()) {
        if (schema.checkAttribute(item, attributeName)) {
          return item.getAttribute(attributeName);
        }
      }
    }
    return null;
  }
};
function hasClassesProperty(obj) {
  return Boolean(obj.classes) && Array.isArray(obj.classes);
}
function isPreviewable(elementName) {
  return !NON_PREVIEWABLE_ELEMENT_NAMES.includes(elementName);
}
function normalizedStyleDefinitionToMatcherPattern({ element, classes }) {
  return {
    name: element,
    classes
  };
}
var StyleUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StyleUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      StyleUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const dataSchema = editor.plugins.get("DataSchema");
    const styleUtils = editor.plugins.get("StyleUtils");
    const styleDefinitions = editor.config.get("style.definitions");
    const normalizedStyleDefinitions = styleUtils.normalizeConfig(dataSchema, styleDefinitions);
    editor.ui.componentFactory.add("style", (locale) => {
      const t = locale.t;
      const dropdown = createDropdown(locale);
      const styleCommand = editor.commands.get("style");
      dropdown.once("change:isOpen", () => {
        const panelView = new StylePanelView(locale, normalizedStyleDefinitions);
        dropdown.panelView.children.add(panelView);
        panelView.delegate("execute").to(dropdown);
        panelView.bind("activeStyles").to(styleCommand, "value");
        panelView.bind("enabledStyles").to(styleCommand, "enabledStyles");
      });
      dropdown.bind("isEnabled").to(styleCommand);
      dropdown.buttonView.withText = true;
      dropdown.buttonView.bind("label").to(styleCommand, "value", (value) => {
        if (value.length > 1) {
          return t("Multiple styles");
        } else if (value.length === 1) {
          return value[0];
        } else {
          return t("Styles");
        }
      });
      dropdown.bind("class").to(styleCommand, "value", (value) => {
        const classes = [
          "ck-style-dropdown"
        ];
        if (value.length > 1) {
          classes.push("ck-style-dropdown_multiple-active");
        }
        return classes.join(" ");
      });
      dropdown.on("execute", (evt) => {
        editor.execute("style", {
          styleName: evt.source.styleDefinition.name
        });
        editor.editing.view.focus();
      });
      return dropdown;
    });
  }
};
var StyleCommand = class extends Command {
  /**
  * Creates an instance of the command.
  *
  * @param editor Editor on which this command will be used.
  * @param styleDefinitions Normalized definitions of the styles.
  */
  constructor(editor, styleDefinitions) {
    super(editor);
    /**
    * Normalized definitions of the styles.
    */
    __publicField(this, "_styleDefinitions");
    /**
    * The StyleUtils plugin.
    */
    __publicField(this, "_styleUtils");
    this.set("value", []);
    this.set("enabledStyles", []);
    this._styleDefinitions = styleDefinitions;
    this._styleUtils = this.editor.plugins.get(StyleUtils);
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const value = /* @__PURE__ */ new Set();
    const enabledStyles = /* @__PURE__ */ new Set();
    for (const definition of this._styleDefinitions.inline) {
      if (this._styleUtils.isStyleEnabledForInlineSelection(definition, selection)) {
        enabledStyles.add(definition.name);
      }
      if (this._styleUtils.isStyleActiveForInlineSelection(definition, selection)) {
        value.add(definition.name);
      }
    }
    const firstBlock = first(selection.getSelectedBlocks()) || selection.getFirstPosition().parent;
    if (firstBlock) {
      const ancestorBlocks = firstBlock.getAncestors({
        includeSelf: true,
        parentFirst: true
      });
      for (const block2 of ancestorBlocks) {
        if (block2.is("rootElement")) {
          break;
        }
        for (const definition of this._styleDefinitions.block) {
          if (!this._styleUtils.isStyleEnabledForBlock(definition, block2)) {
            continue;
          }
          enabledStyles.add(definition.name);
          if (this._styleUtils.isStyleActiveForBlock(definition, block2)) {
            value.add(definition.name);
          }
        }
        if (model.schema.isObject(block2)) {
          break;
        }
      }
    }
    this.enabledStyles = Array.from(enabledStyles).sort();
    this.isEnabled = this.enabledStyles.length > 0;
    this.value = this.isEnabled ? Array.from(value).sort() : [];
  }
  /**
  * Executes the command &ndash; applies the style classes to the selection or removes it from the selection.
  *
  * If the command value already contains the requested style, it will remove the style classes. Otherwise, it will set it.
  *
  * The execution result differs, depending on the {@link module:engine/model/document~Document#selection} and the
  * style type (inline or block):
  *
  * * When applying inline styles:
  *   * If the selection is on a range, the command applies the style classes to all nodes in that range.
  *   * If the selection is collapsed in a non-empty node, the command applies the style classes to the
  * {@link module:engine/model/document~Document#selection}.
  *
  * * When applying block styles:
  *   * If the selection is on a range, the command applies the style classes to the nearest block parent element.
  *
  * @fires execute
  * @param options Command options.
  * @param options.styleName Style name matching the one defined in the
  * {@link module:style/styleconfig~StyleConfig#definitions configuration}.
  * @param options.forceValue Whether the command should add given style (`true`) or remove it (`false`) from the selection.
  * If not set (default), the command will toggle the style basing on the first selected node. Note, that this will not force
  * setting a style on an element that cannot receive given style.
  */
  execute({ styleName, forceValue }) {
    if (!this.enabledStyles.includes(styleName)) {
      logWarning("style-command-executed-with-incorrect-style-name");
      return;
    }
    const model = this.editor.model;
    const selection = model.document.selection;
    const htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
    const allDefinitions = [
      ...this._styleDefinitions.inline,
      ...this._styleDefinitions.block
    ];
    const activeDefinitions = allDefinitions.filter(({ name }) => this.value.includes(name));
    const definition = allDefinitions.find(({ name }) => name == styleName);
    const shouldAddStyle = forceValue === void 0 ? !this.value.includes(definition.name) : forceValue;
    model.change(() => {
      let selectables;
      if (isBlockStyleDefinition(definition)) {
        selectables = this._findAffectedBlocks(getBlocksFromSelection(selection), definition);
      } else {
        selectables = [
          this._styleUtils.getAffectedInlineSelectable(definition, selection)
        ];
      }
      for (const selectable of selectables) {
        if (shouldAddStyle) {
          htmlSupport.addModelHtmlClass(definition.element, definition.classes, selectable);
        } else {
          htmlSupport.removeModelHtmlClass(definition.element, getDefinitionExclusiveClasses(activeDefinitions, definition), selectable);
        }
      }
    });
  }
  /**
  * Returns a set of elements that should be affected by the block-style change.
  */
  _findAffectedBlocks(selectedBlocks, definition) {
    const blocks = /* @__PURE__ */ new Set();
    for (const selectedBlock of selectedBlocks) {
      const ancestorBlocks = selectedBlock.getAncestors({
        includeSelf: true,
        parentFirst: true
      });
      for (const block2 of ancestorBlocks) {
        if (block2.is("rootElement")) {
          break;
        }
        const affectedBlocks = this._styleUtils.getAffectedBlocks(definition, block2);
        if (affectedBlocks) {
          for (const affectedBlock of affectedBlocks) {
            blocks.add(affectedBlock);
          }
          break;
        }
      }
    }
    return blocks;
  }
};
function getDefinitionExclusiveClasses(activeDefinitions, definition) {
  return activeDefinitions.reduce((classes, currentDefinition) => {
    if (currentDefinition.name === definition.name) {
      return classes;
    }
    return classes.filter((className) => !currentDefinition.classes.includes(className));
  }, definition.classes);
}
function isBlockStyleDefinition(definition) {
  return "isBlock" in definition;
}
function getBlocksFromSelection(selection) {
  const blocks = Array.from(selection.getSelectedBlocks());
  if (blocks.length) {
    return blocks;
  }
  return [
    selection.getFirstPosition().parent
  ];
}
var ListStyleSupport = class extends Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "_listUtils");
    __publicField(this, "_styleUtils");
    __publicField(this, "_htmlSupport");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "ListStyleSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      StyleUtils,
      "GeneralHtmlSupport"
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("ListEditing")) {
      return;
    }
    this._styleUtils = editor.plugins.get(StyleUtils);
    this._listUtils = this.editor.plugins.get("ListUtils");
    this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
    this.listenTo(this._styleUtils, "isStyleEnabledForBlock", (evt, [definition, block2]) => {
      if (this._isStyleEnabledForBlock(definition, block2)) {
        evt.return = true;
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.listenTo(this._styleUtils, "isStyleActiveForBlock", (evt, [definition, block2]) => {
      if (this._isStyleActiveForBlock(definition, block2)) {
        evt.return = true;
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.listenTo(this._styleUtils, "getAffectedBlocks", (evt, [definition, block2]) => {
      const blocks = this._getAffectedBlocks(definition, block2);
      if (blocks) {
        evt.return = blocks;
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.listenTo(this._styleUtils, "getStylePreview", (evt, [definition, children]) => {
      const templateDefinition = this._getStylePreview(definition, children);
      if (templateDefinition) {
        evt.return = templateDefinition;
        evt.stop();
      }
    }, {
      priority: "high"
    });
  }
  /**
  * Verifies if the given style is applicable to the provided block element.
  */
  _isStyleEnabledForBlock(definition, block2) {
    const model = this.editor.model;
    if (![
      "ol",
      "ul",
      "li"
    ].includes(definition.element)) {
      return false;
    }
    if (!this._listUtils.isListItemBlock(block2)) {
      return false;
    }
    const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
    if (definition.element == "ol" || definition.element == "ul") {
      if (!model.schema.checkAttribute(block2, attributeName)) {
        return false;
      }
      const isNumbered = this._listUtils.isNumberedListType(block2.getAttribute("listType"));
      const viewElementName = isNumbered ? "ol" : "ul";
      return definition.element == viewElementName;
    } else {
      return model.schema.checkAttribute(block2, attributeName);
    }
  }
  /**
  * Returns true if the given style is applied to the specified block element.
  */
  _isStyleActiveForBlock(definition, block2) {
    const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
    const ghsAttributeValue = block2.getAttribute(attributeName);
    return this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes);
  }
  /**
  * Returns an array of block elements that style should be applied to.
  */
  _getAffectedBlocks(definition, block2) {
    if (!this._isStyleEnabledForBlock(definition, block2)) {
      return null;
    }
    if (definition.element == "li") {
      return this._listUtils.expandListBlocksToCompleteItems(block2, {
        withNested: false
      });
    } else {
      return this._listUtils.expandListBlocksToCompleteList(block2);
    }
  }
  /**
  * Returns a view template definition for the style preview.
  */
  _getStylePreview(definition, children) {
    const { element, classes } = definition;
    if (element == "ol" || element == "ul") {
      return {
        tag: element,
        attributes: {
          class: classes
        },
        children: [
          {
            tag: "li",
            children
          }
        ]
      };
    } else if (element == "li") {
      return {
        tag: "ol",
        children: [
          {
            tag: element,
            attributes: {
              class: classes
            },
            children
          }
        ]
      };
    }
    return null;
  }
};
var TableStyleSupport = class extends Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "_tableUtils");
    __publicField(this, "_styleUtils");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableStyleSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      StyleUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("TableEditing")) {
      return;
    }
    this._styleUtils = editor.plugins.get(StyleUtils);
    this._tableUtils = this.editor.plugins.get("TableUtils");
    this.listenTo(this._styleUtils, "isStyleEnabledForBlock", (evt, [definition, block2]) => {
      if (this._isApplicable(definition, block2)) {
        evt.return = this._isStyleEnabledForBlock(definition, block2);
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.listenTo(this._styleUtils, "getAffectedBlocks", (evt, [definition, block2]) => {
      if (this._isApplicable(definition, block2)) {
        evt.return = this._getAffectedBlocks(definition, block2);
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.listenTo(this._styleUtils, "configureGHSDataFilter", (evt, [{ block: block2 }]) => {
      const ghsDataFilter = this.editor.plugins.get("DataFilter");
      ghsDataFilter.loadAllowedConfig(block2.filter((definition) => definition.element == "figcaption").map((definition) => ({
        name: "caption",
        classes: definition.classes
      })));
    });
  }
  /**
  * Checks if this plugin's custom logic should be applied for defintion-block pair.
  *
  * @param definition Style definition that is being considered.
  * @param block Block element to check if should be styled.
  * @returns True if the defintion-block pair meet the plugin criteria, false otherwise.
  */
  _isApplicable(definition, block2) {
    if ([
      "td",
      "th"
    ].includes(definition.element)) {
      return block2.name == "tableCell";
    }
    if ([
      "thead",
      "tbody"
    ].includes(definition.element)) {
      return block2.name == "table";
    }
    return false;
  }
  /**
  * Checks if the style definition should be applied to selected block.
  *
  * @param definition Style definition that is being considered.
  * @param block Block element to check if should be styled.
  * @returns True if the block should be style with the style description, false otherwise.
  */
  _isStyleEnabledForBlock(definition, block2) {
    if ([
      "td",
      "th"
    ].includes(definition.element)) {
      const location = this._tableUtils.getCellLocation(block2);
      const tableRow = block2.parent;
      const table = tableRow.parent;
      const headingRows = table.getAttribute("headingRows") || 0;
      const headingColumns = table.getAttribute("headingColumns") || 0;
      const isHeadingCell = location.row < headingRows || location.column < headingColumns;
      if (definition.element == "th") {
        return isHeadingCell;
      } else {
        return !isHeadingCell;
      }
    }
    if ([
      "thead",
      "tbody"
    ].includes(definition.element)) {
      const headingRows = block2.getAttribute("headingRows") || 0;
      if (definition.element == "thead") {
        return headingRows > 0;
      } else {
        return headingRows < this._tableUtils.getRows(block2);
      }
    }
    return false;
  }
  /**
  * Gets all blocks that the style should be applied to.
  *
  * @param definition Style definition that is being considered.
  * @param block A block element from selection.
  * @returns An array with the block that was passed as an argument if meets the criteria, null otherwise.
  */
  _getAffectedBlocks(definition, block2) {
    if (!this._isStyleEnabledForBlock(definition, block2)) {
      return null;
    }
    return [
      block2
    ];
  }
};
var LinkStyleSupport = class extends Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "_styleUtils");
    __publicField(this, "_htmlSupport");
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "LinkStyleSupport";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      StyleUtils,
      "GeneralHtmlSupport"
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    if (!editor.plugins.has("LinkEditing")) {
      return;
    }
    this._styleUtils = editor.plugins.get(StyleUtils);
    this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
    this.listenTo(this._styleUtils, "isStyleEnabledForInlineSelection", (evt, [definition, selection]) => {
      if (definition.element == "a") {
        evt.return = this._isStyleEnabled(definition, selection);
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.listenTo(this._styleUtils, "isStyleActiveForInlineSelection", (evt, [definition, selection]) => {
      if (definition.element == "a") {
        evt.return = this._isStyleActive(definition, selection);
        evt.stop();
      }
    }, {
      priority: "high"
    });
    this.listenTo(this._styleUtils, "getAffectedInlineSelectable", (evt, [definition, selection]) => {
      if (definition.element != "a") {
        return;
      }
      const selectable = this._getAffectedSelectable(definition, selection);
      if (selectable) {
        evt.return = selectable;
        evt.stop();
      }
    }, {
      priority: "high"
    });
  }
  /**
  * Verifies if the given style is applicable to the provided document selection.
  */
  _isStyleEnabled(definition, selection) {
    const model = this.editor.model;
    if (selection.isCollapsed) {
      return selection.hasAttribute("linkHref");
    }
    for (const range of selection.getRanges()) {
      for (const item of range.getItems()) {
        if ((item.is("$textProxy") || model.schema.isInline(item)) && item.hasAttribute("linkHref")) {
          return true;
        }
      }
    }
    return false;
  }
  /**
  * Returns true if the given style is applied to the specified document selection.
  */
  _isStyleActive(definition, selection) {
    const model = this.editor.model;
    const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
    if (selection.isCollapsed) {
      if (selection.hasAttribute("linkHref")) {
        const ghsAttributeValue = selection.getAttribute(attributeName);
        if (this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes)) {
          return true;
        }
      }
      return false;
    }
    for (const range of selection.getRanges()) {
      for (const item of range.getItems()) {
        if ((item.is("$textProxy") || model.schema.isInline(item)) && item.hasAttribute("linkHref")) {
          const ghsAttributeValue = item.getAttribute(attributeName);
          return this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes);
        }
      }
    }
    return false;
  }
  /**
  * Returns a selectable that given style should be applied to.
  */
  _getAffectedSelectable(definition, selection) {
    const model = this.editor.model;
    if (selection.isCollapsed) {
      const linkHref = selection.getAttribute("linkHref");
      return findAttributeRange(selection.getFirstPosition(), "linkHref", linkHref, model);
    }
    const ranges = [];
    for (const range of selection.getRanges()) {
      const expandedRange = model.createRange(expandAttributePosition(range.start, "linkHref", true, model), expandAttributePosition(range.end, "linkHref", false, model));
      for (const item of expandedRange.getItems()) {
        if ((item.is("$textProxy") || model.schema.isInline(item)) && item.hasAttribute("linkHref")) {
          ranges.push(this.editor.model.createRangeOn(item));
        }
      }
    }
    return normalizeRanges(ranges);
  }
};
function expandAttributePosition(position, attributeName, lookBack, model) {
  const referenceNode = position.textNode || (lookBack ? position.nodeAfter : position.nodeBefore);
  if (!referenceNode || !referenceNode.hasAttribute(attributeName)) {
    return position;
  }
  const attributeValue = referenceNode.getAttribute(attributeName);
  return findAttributeRangeBound(position, attributeName, attributeValue, lookBack, model);
}
function normalizeRanges(ranges) {
  for (let i = 1; i < ranges.length; i++) {
    const joinedRange = ranges[i - 1].getJoined(ranges[i]);
    if (joinedRange) {
      ranges.splice(--i, 2, joinedRange);
    }
  }
  return ranges;
}
var StyleEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "StyleEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      "GeneralHtmlSupport",
      StyleUtils,
      ListStyleSupport,
      TableStyleSupport,
      LinkStyleSupport
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const dataSchema = editor.plugins.get("DataSchema");
    const styleUtils = editor.plugins.get("StyleUtils");
    const styleDefinitions = editor.config.get("style.definitions");
    const normalizedStyleDefinitions = styleUtils.normalizeConfig(dataSchema, styleDefinitions);
    editor.commands.add("style", new StyleCommand(editor, normalizedStyleDefinitions));
    styleUtils.configureGHSDataFilter(normalizedStyleDefinitions);
  }
};
var Style = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Style";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      StyleEditing,
      StyleUI
    ];
  }
};

// node_modules/@ckeditor/ckeditor5-table/dist/index.js
function upcastStyleToAttribute(conversion, options2) {
  const { modelAttribute, styleName, viewElement, defaultValue, reduceBoxSides = false, shouldUpcast = () => true } = options2;
  conversion.for("upcast").attributeToAttribute({
    view: {
      name: viewElement,
      styles: {
        [styleName]: /[\s\S]+/
      }
    },
    model: {
      key: modelAttribute,
      value: (viewElement2) => {
        if (!shouldUpcast(viewElement2)) {
          return;
        }
        const normalized = viewElement2.getNormalizedStyle(styleName);
        const value = reduceBoxSides ? reduceBoxSidesValue(normalized) : normalized;
        if (defaultValue !== value) {
          return value;
        }
      }
    }
  });
}
function upcastBorderStyles(conversion, viewElementName, modelAttributes, defaultBorder) {
  conversion.for("upcast").add((dispatcher) => dispatcher.on("element:" + viewElementName, (evt, data, conversionApi) => {
    if (!data.modelRange) {
      return;
    }
    const stylesToConsume = [
      "border-top-width",
      "border-top-color",
      "border-top-style",
      "border-bottom-width",
      "border-bottom-color",
      "border-bottom-style",
      "border-right-width",
      "border-right-color",
      "border-right-style",
      "border-left-width",
      "border-left-color",
      "border-left-style"
    ].filter((styleName) => data.viewItem.hasStyle(styleName));
    if (!stylesToConsume.length) {
      return;
    }
    const matcherPattern = {
      styles: stylesToConsume
    };
    if (!conversionApi.consumable.test(data.viewItem, matcherPattern)) {
      return;
    }
    const modelElement = [
      ...data.modelRange.getItems({
        shallow: true
      })
    ].pop();
    conversionApi.consumable.consume(data.viewItem, matcherPattern);
    const normalizedBorder = {
      style: data.viewItem.getNormalizedStyle("border-style"),
      color: data.viewItem.getNormalizedStyle("border-color"),
      width: data.viewItem.getNormalizedStyle("border-width")
    };
    const reducedBorder = {
      style: reduceBoxSidesValue(normalizedBorder.style),
      color: reduceBoxSidesValue(normalizedBorder.color),
      width: reduceBoxSidesValue(normalizedBorder.width)
    };
    if (reducedBorder.style !== defaultBorder.style) {
      conversionApi.writer.setAttribute(modelAttributes.style, reducedBorder.style, modelElement);
    }
    if (reducedBorder.color !== defaultBorder.color) {
      conversionApi.writer.setAttribute(modelAttributes.color, reducedBorder.color, modelElement);
    }
    if (reducedBorder.width !== defaultBorder.width) {
      conversionApi.writer.setAttribute(modelAttributes.width, reducedBorder.width, modelElement);
    }
  }));
}
function downcastAttributeToStyle(conversion, options2) {
  const { modelElement, modelAttribute, styleName } = options2;
  conversion.for("downcast").attributeToAttribute({
    model: {
      name: modelElement,
      key: modelAttribute
    },
    view: (modelAttributeValue) => ({
      key: "style",
      value: {
        [styleName]: modelAttributeValue
      }
    })
  });
}
function downcastTableAttribute(conversion, options2) {
  const { modelAttribute, styleName } = options2;
  conversion.for("downcast").add((dispatcher) => dispatcher.on(`attribute:${modelAttribute}:table`, (evt, data, conversionApi) => {
    const { item, attributeNewValue } = data;
    const { mapper, writer } = conversionApi;
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const table = [
      ...mapper.toViewElement(item).getChildren()
    ].find((child) => child.is("element", "table"));
    if (attributeNewValue) {
      writer.setStyle(styleName, attributeNewValue, table);
    } else {
      writer.removeStyle(styleName, table);
    }
  }));
}
function reduceBoxSidesValue(style) {
  if (!style) {
    return;
  }
  const sides = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  const allSidesDefined = sides.every((side) => style[side]);
  if (!allSidesDefined) {
    return style;
  }
  const topSideStyle = style.top;
  const allSidesEqual = sides.every((side) => style[side] === topSideStyle);
  if (!allSidesEqual) {
    return style;
  }
  return topSideStyle;
}
function updateNumericAttribute(key, value, item, writer, defaultValue = 1) {
  if (value !== void 0 && value !== null && defaultValue !== void 0 && defaultValue !== null && value > defaultValue) {
    writer.setAttribute(key, value, item);
  } else {
    writer.removeAttribute(key, item);
  }
}
function createEmptyTableCell(writer, insertPosition, attributes = {}) {
  const tableCell = writer.createElement("tableCell", attributes);
  writer.insertElement("paragraph", tableCell);
  writer.insert(tableCell, insertPosition);
  return tableCell;
}
function isHeadingColumnCell(tableUtils, tableCell) {
  const table = tableCell.parent.parent;
  const headingColumns = parseInt(table.getAttribute("headingColumns") || "0");
  const { column } = tableUtils.getCellLocation(tableCell);
  return !!headingColumns && column < headingColumns;
}
function enableProperty$1(schema, conversion, options2) {
  const { modelAttribute } = options2;
  schema.extend("tableCell", {
    allowAttributes: [
      modelAttribute
    ]
  });
  upcastStyleToAttribute(conversion, {
    viewElement: /^(td|th)$/,
    ...options2
  });
  downcastAttributeToStyle(conversion, {
    modelElement: "tableCell",
    ...options2
  });
}
function getSelectionAffectedTable(selection) {
  const selectedElement = selection.getSelectedElement();
  if (selectedElement && selectedElement.is("element", "table")) {
    return selectedElement;
  }
  return selection.getFirstPosition().findAncestor("table");
}
function upcastTableFigure() {
  return (dispatcher) => {
    dispatcher.on("element:figure", (evt, data, conversionApi) => {
      if (!conversionApi.consumable.test(data.viewItem, {
        name: true,
        classes: "table"
      })) {
        return;
      }
      const viewTable = getViewTableFromFigure(data.viewItem);
      if (!viewTable || !conversionApi.consumable.test(viewTable, {
        name: true
      })) {
        return;
      }
      conversionApi.consumable.consume(data.viewItem, {
        name: true,
        classes: "table"
      });
      const conversionResult = conversionApi.convertItem(viewTable, data.modelCursor);
      const modelTable = first(conversionResult.modelRange.getItems());
      if (!modelTable) {
        conversionApi.consumable.revert(data.viewItem, {
          name: true,
          classes: "table"
        });
        return;
      }
      conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelTable, "end"));
      conversionApi.updateConversionResult(modelTable, data);
    });
  };
}
function upcastTable() {
  return (dispatcher) => {
    dispatcher.on("element:table", (evt, data, conversionApi) => {
      const viewTable = data.viewItem;
      if (!conversionApi.consumable.test(viewTable, {
        name: true
      })) {
        return;
      }
      const { rows, headingRows, headingColumns } = scanTable(viewTable);
      const attributes = {};
      if (headingColumns) {
        attributes.headingColumns = headingColumns;
      }
      if (headingRows) {
        attributes.headingRows = headingRows;
      }
      const table = conversionApi.writer.createElement("table", attributes);
      if (!conversionApi.safeInsert(table, data.modelCursor)) {
        return;
      }
      conversionApi.consumable.consume(viewTable, {
        name: true
      });
      rows.forEach((row) => conversionApi.convertItem(row, conversionApi.writer.createPositionAt(table, "end")));
      conversionApi.convertChildren(viewTable, conversionApi.writer.createPositionAt(table, "end"));
      if (table.isEmpty) {
        const row = conversionApi.writer.createElement("tableRow");
        conversionApi.writer.insert(row, conversionApi.writer.createPositionAt(table, "end"));
        createEmptyTableCell(conversionApi.writer, conversionApi.writer.createPositionAt(row, "end"));
      }
      conversionApi.updateConversionResult(table, data);
    });
  };
}
function skipEmptyTableRow() {
  return (dispatcher) => {
    dispatcher.on("element:tr", (evt, data) => {
      if (data.viewItem.isEmpty && data.modelCursor.index == 0) {
        evt.stop();
      }
    }, {
      priority: "high"
    });
  };
}
function ensureParagraphInTableCell(elementName) {
  return (dispatcher) => {
    dispatcher.on(`element:${elementName}`, (evt, data, { writer }) => {
      if (!data.modelRange) {
        return;
      }
      const tableCell = data.modelRange.start.nodeAfter;
      const modelCursor = writer.createPositionAt(tableCell, 0);
      if (data.viewItem.isEmpty) {
        writer.insertElement("paragraph", modelCursor);
        return;
      }
      const childNodes = Array.from(tableCell.getChildren());
      if (childNodes.every((node) => node.is("element", "$marker"))) {
        const paragraph = writer.createElement("paragraph");
        writer.insert(paragraph, writer.createPositionAt(tableCell, 0));
        for (const node of childNodes) {
          writer.move(writer.createRangeOn(node), writer.createPositionAt(paragraph, "end"));
        }
      }
    }, {
      priority: "low"
    });
  };
}
function getViewTableFromFigure(figureView) {
  for (const figureChild of figureView.getChildren()) {
    if (figureChild.is("element", "table")) {
      return figureChild;
    }
  }
}
function scanTable(viewTable) {
  let headingRows = 0;
  let headingColumns = void 0;
  const headRows = [];
  const bodyRows = [];
  let firstTheadElement;
  for (const tableChild of Array.from(viewTable.getChildren())) {
    if (tableChild.name !== "tbody" && tableChild.name !== "thead" && tableChild.name !== "tfoot") {
      continue;
    }
    if (tableChild.name === "thead" && !firstTheadElement) {
      firstTheadElement = tableChild;
    }
    const trs = Array.from(tableChild.getChildren()).filter((el) => el.is("element", "tr"));
    for (const tr of trs) {
      if (firstTheadElement && tableChild === firstTheadElement || tableChild.name === "tbody" && Array.from(tr.getChildren()).length && Array.from(tr.getChildren()).every((e) => e.is("element", "th"))) {
        headingRows++;
        headRows.push(tr);
      } else {
        bodyRows.push(tr);
        const headingCols = scanRowForHeadingColumns(tr);
        if (!headingColumns || headingCols < headingColumns) {
          headingColumns = headingCols;
        }
      }
    }
  }
  return {
    headingRows,
    headingColumns: headingColumns || 0,
    rows: [
      ...headRows,
      ...bodyRows
    ]
  };
}
function scanRowForHeadingColumns(tr) {
  let headingColumns = 0;
  let index = 0;
  const children = Array.from(tr.getChildren()).filter((child) => child.name === "th" || child.name === "td");
  while (index < children.length && children[index].name === "th") {
    const th = children[index];
    const colspan = parseInt(th.getAttribute("colspan") || "1");
    headingColumns = headingColumns + colspan;
    index++;
  }
  return headingColumns;
}
var TableWalker = class {
  /**
  * Creates an instance of the table walker.
  *
  * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
  * It walks row by row and column by column in order to output values defined in the constructor.
  * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
  * pass the `includeAllSlots` option to the constructor.
  *
  * The most important values of the iterator are column and row indexes of a cell.
  *
  * See {@link module:table/tablewalker~TableSlot} what values are returned by the table walker.
  *
  * To iterate over a given row:
  *
  * ```ts
  * const tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );
  *
  * for ( const tableSlot of tableWalker ) {
  *   console.log( 'A cell at row', tableSlot.row, 'and column', tableSlot.column );
  * }
  * ```
  *
  * For instance the code above for the following table:
  *
  *  +----+----+----+----+----+----+
  *  | 00      | 02 | 03 | 04 | 05 |
  *  |         +----+----+----+----+
  *  |         | 12      | 14 | 15 |
  *  |         +----+----+----+    +
  *  |         | 22           |    |
  *  |----+----+----+----+----+    +
  *  | 30 | 31 | 32 | 33 | 34 |    |
  *  +----+----+----+----+----+----+
  *
  * will log in the console:
  *
  *  'A cell at row 1 and column 2'
  *  'A cell at row 1 and column 4'
  *  'A cell at row 1 and column 5'
  *  'A cell at row 2 and column 2'
  *
  * To also iterate over spanned cells:
  *
  * ```ts
  * const tableWalker = new TableWalker( table, { row: 1, includeAllSlots: true } );
  *
  * for ( const tableSlot of tableWalker ) {
  *   console.log( 'Slot at', tableSlot.row, 'x', tableSlot.column, ':', tableSlot.isAnchor ? 'is anchored' : 'is spanned' );
  * }
  * ```
  *
  * will log in the console for the table from the previous example:
  *
  *  'Cell at 1 x 0 : is spanned'
  *  'Cell at 1 x 1 : is spanned'
  *  'Cell at 1 x 2 : is anchored'
  *  'Cell at 1 x 3 : is spanned'
  *  'Cell at 1 x 4 : is anchored'
  *  'Cell at 1 x 5 : is anchored'
  *
  * **Note**: Option `row` is a shortcut that sets both `startRow` and `endRow` to the same row.
  * (Use either `row` or `startRow` and `endRow` but never together). Similarly the `column` option sets both `startColumn`
  * and `endColumn` to the same column (Use either `column` or `startColumn` and `endColumn` but never together).
  *
  * @param table A table over which the walker iterates.
  * @param options An object with configuration.
  * @param options.row A row index for which this iterator will output cells. Can't be used together with `startRow` and `endRow`.
  * @param options.startRow A row index from which this iterator should start. Can't be used together with `row`. Default value is 0.
  * @param options.endRow A row index at which this iterator should end. Can't be used together with `row`.
  * @param options.column A column index for which this iterator will output cells.
  * Can't be used together with `startColumn` and `endColumn`.
  * @param options.startColumn A column index from which this iterator should start.
  * Can't be used together with `column`. Default value is 0.
  * @param options.endColumn A column index at which this iterator should end. Can't be used together with `column`.
  * @param options.includeAllSlots Also return values for spanned cells. Default value is "false".
  */
  constructor(table, options2 = {}) {
    /**
    * The walker's table element.
    *
    * @internal
    */
    __publicField(this, "_table");
    /**
    * A row index from which this iterator will start.
    */
    __publicField(this, "_startRow");
    /**
    * A row index at which this iterator will end.
    */
    __publicField(this, "_endRow");
    /**
    * If set, the table walker will only output cells from a given column and following ones or cells that overlap them.
    */
    __publicField(this, "_startColumn");
    /**
    * If set, the table walker will only output cells up to a given column.
    */
    __publicField(this, "_endColumn");
    /**
    * Enables output of spanned cells that are normally not yielded.
    */
    __publicField(this, "_includeAllSlots");
    /**
    * Row indexes to skip from the iteration.
    */
    __publicField(this, "_skipRows");
    /**
    * The current row index.
    *
    * @internal
    */
    __publicField(this, "_row");
    /**
    * The index of the current row element in the table.
    *
    * @internal
    */
    __publicField(this, "_rowIndex");
    /**
    * The current column index.
    *
    * @internal
    */
    __publicField(this, "_column");
    /**
    * The cell index in a parent row. For spanned cells when {@link #_includeAllSlots} is set to `true`,
    * this represents the index of the next table cell.
    *
    * @internal
    */
    __publicField(this, "_cellIndex");
    /**
    * Holds a map of spanned cells in a table.
    */
    __publicField(this, "_spannedCells");
    /**
    * Index of the next column where a cell is anchored.
    */
    __publicField(this, "_nextCellAtColumn");
    /**
    * Indicates whether the iterator jumped to (or close to) the start row, ignoring rows that don't need to be traversed.
    */
    __publicField(this, "_jumpedToStartRow", false);
    this._table = table;
    this._startRow = options2.row !== void 0 ? options2.row : options2.startRow || 0;
    this._endRow = options2.row !== void 0 ? options2.row : options2.endRow;
    this._startColumn = options2.column !== void 0 ? options2.column : options2.startColumn || 0;
    this._endColumn = options2.column !== void 0 ? options2.column : options2.endColumn;
    this._includeAllSlots = !!options2.includeAllSlots;
    this._skipRows = /* @__PURE__ */ new Set();
    this._row = 0;
    this._rowIndex = 0;
    this._column = 0;
    this._cellIndex = 0;
    this._spannedCells = /* @__PURE__ */ new Map();
    this._nextCellAtColumn = -1;
  }
  /**
  * Iterable interface.
  */
  [Symbol.iterator]() {
    return this;
  }
  /**
  * Gets the next table walker's value.
  *
  * @returns The next table walker's value.
  */
  next() {
    if (this._canJumpToStartRow()) {
      this._jumpToNonSpannedRowClosestToStartRow();
    }
    const row = this._table.getChild(this._rowIndex);
    if (!row || this._isOverEndRow()) {
      return {
        done: true,
        value: void 0
      };
    }
    if (!row.is("element", "tableRow")) {
      this._rowIndex++;
      return this.next();
    }
    if (this._isOverEndColumn()) {
      return this._advanceToNextRow();
    }
    let outValue = null;
    const spanData = this._getSpanned();
    if (spanData) {
      if (this._includeAllSlots && !this._shouldSkipSlot()) {
        outValue = this._formatOutValue(spanData.cell, spanData.row, spanData.column);
      }
    } else {
      const cell2 = row.getChild(this._cellIndex);
      if (!cell2) {
        return this._advanceToNextRow();
      }
      const colspan = parseInt(cell2.getAttribute("colspan") || "1");
      const rowspan = parseInt(cell2.getAttribute("rowspan") || "1");
      if (colspan > 1 || rowspan > 1) {
        this._recordSpans(cell2, rowspan, colspan);
      }
      if (!this._shouldSkipSlot()) {
        outValue = this._formatOutValue(cell2);
      }
      this._nextCellAtColumn = this._column + colspan;
    }
    this._column++;
    if (this._column == this._nextCellAtColumn) {
      this._cellIndex++;
    }
    return outValue || this.next();
  }
  /**
  * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row
  * to output.
  *
  * @param row The row index to skip.
  */
  skipRow(row) {
    this._skipRows.add(row);
  }
  /**
  * Advances internal cursor to the next row.
  */
  _advanceToNextRow() {
    this._row++;
    this._rowIndex++;
    this._column = 0;
    this._cellIndex = 0;
    this._nextCellAtColumn = -1;
    return this.next();
  }
  /**
  * Checks if the current row is over {@link #_endRow}.
  */
  _isOverEndRow() {
    return this._endRow !== void 0 && this._row > this._endRow;
  }
  /**
  * Checks if the current cell is over {@link #_endColumn}
  */
  _isOverEndColumn() {
    return this._endColumn !== void 0 && this._column > this._endColumn;
  }
  /**
  * A common method for formatting the iterator's output value.
  *
  * @param cell The table cell to output.
  * @param anchorRow The row index of a cell anchor slot.
  * @param anchorColumn The column index of a cell anchor slot.
  */
  _formatOutValue(cell2, anchorRow = this._row, anchorColumn = this._column) {
    return {
      done: false,
      value: new TableSlot(this, cell2, anchorRow, anchorColumn)
    };
  }
  /**
  * Checks if the current slot should be skipped.
  */
  _shouldSkipSlot() {
    const rowIsMarkedAsSkipped = this._skipRows.has(this._row);
    const rowIsBeforeStartRow = this._row < this._startRow;
    const columnIsBeforeStartColumn = this._column < this._startColumn;
    const columnIsAfterEndColumn = this._endColumn !== void 0 && this._column > this._endColumn;
    return rowIsMarkedAsSkipped || rowIsBeforeStartRow || columnIsBeforeStartColumn || columnIsAfterEndColumn;
  }
  /**
  * Returns the cell element that is spanned over the current cell location.
  */
  _getSpanned() {
    const rowMap = this._spannedCells.get(this._row);
    if (!rowMap) {
      return null;
    }
    return rowMap.get(this._column) || null;
  }
  /**
  * Updates spanned cells map relative to the current cell location and its span dimensions.
  *
  * @param cell A cell that is spanned.
  * @param rowspan Cell height.
  * @param colspan Cell width.
  */
  _recordSpans(cell2, rowspan, colspan) {
    const data = {
      cell: cell2,
      row: this._row,
      column: this._column
    };
    for (let rowToUpdate = this._row; rowToUpdate < this._row + rowspan; rowToUpdate++) {
      for (let columnToUpdate = this._column; columnToUpdate < this._column + colspan; columnToUpdate++) {
        if (rowToUpdate != this._row || columnToUpdate != this._column) {
          this._markSpannedCell(rowToUpdate, columnToUpdate, data);
        }
      }
    }
  }
  /**
  * Marks the cell location as spanned by another cell.
  *
  * @param row The row index of the cell location.
  * @param column The column index of the cell location.
  * @param data A spanned cell details (cell element, anchor row and column).
  */
  _markSpannedCell(row, column, data) {
    if (!this._spannedCells.has(row)) {
      this._spannedCells.set(row, /* @__PURE__ */ new Map());
    }
    const rowSpans = this._spannedCells.get(row);
    rowSpans.set(column, data);
  }
  /**
  * Checks if part of the table can be skipped.
  */
  _canJumpToStartRow() {
    return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow;
  }
  /**
  * Sets the current row to `this._startRow` or the first row before it that has the number of cells
  * equal to the number of columns in the table.
  *
  * Example:
  * 	+----+----+----+
  *  | 00 | 01 | 02 |
  *  |----+----+----+
  *  | 10      | 12 |
  *  |         +----+
  *  |         | 22 |
  *  |         +----+
  *  |         | 32 | <--- Start row
  *  +----+----+----+
  *  | 40 | 41 | 42 |
  *  +----+----+----+
  *
  * If the 4th row is a `this._startRow`, this method will:
  * 1.) Count the number of columns this table has based on the first row (3 columns in this case).
  * 2.) Check if the 4th row contains 3 cells. It doesn't, so go to the row before it.
  * 3.) Check if the 3rd row contains 3 cells. It doesn't, so go to the row before it.
  * 4.) Check if the 2nd row contains 3 cells. It does, so set the current row to that row.
  *
  * Setting the current row this way is necessary to let the `next()`  method loop over the cells
  * spanning multiple rows or columns and update the `this._spannedCells` property.
  */
  _jumpToNonSpannedRowClosestToStartRow() {
    const firstRowLength = this._getRowLength(0);
    for (let i = this._startRow; !this._jumpedToStartRow; i--) {
      if (firstRowLength === this._getRowLength(i)) {
        this._row = i;
        this._rowIndex = i;
        this._jumpedToStartRow = true;
      }
    }
  }
  /**
  * Returns a number of columns in a row taking `colspan` into consideration.
  */
  _getRowLength(rowIndex) {
    const row = this._table.getChild(rowIndex);
    return [
      ...row.getChildren()
    ].reduce((cols, row2) => {
      return cols + parseInt(row2.getAttribute("colspan") || "1");
    }, 0);
  }
};
var TableSlot = class {
  /**
  * Creates an instance of the table walker value.
  *
  * @param tableWalker The table walker instance.
  * @param cell The current table cell.
  * @param anchorRow The row index of a cell anchor slot.
  * @param anchorColumn The column index of a cell anchor slot.
  */
  constructor(tableWalker, cell2, anchorRow, anchorColumn) {
    /**
    * The current table cell.
    */
    __publicField(this, "cell");
    /**
    * The row index of a table slot.
    */
    __publicField(this, "row");
    /**
    * The column index of a table slot.
    */
    __publicField(this, "column");
    /**
    * The row index of a cell anchor slot.
    */
    __publicField(this, "cellAnchorRow");
    /**
    * The column index of a cell anchor slot.
    */
    __publicField(this, "cellAnchorColumn");
    /**
    * The index of the current cell in the parent row.
    */
    __publicField(this, "_cellIndex");
    /**
    * The index of the current row element in the table.
    */
    __publicField(this, "_rowIndex");
    /**
    * The table element.
    */
    __publicField(this, "_table");
    this.cell = cell2;
    this.row = tableWalker._row;
    this.column = tableWalker._column;
    this.cellAnchorRow = anchorRow;
    this.cellAnchorColumn = anchorColumn;
    this._cellIndex = tableWalker._cellIndex;
    this._rowIndex = tableWalker._rowIndex;
    this._table = tableWalker._table;
  }
  // @if CK_DEBUG // public get isSpanned(): unknown { return throwMissingGetterError( 'isSpanned' ); }
  // @if CK_DEBUG // public get colspan(): unknown { return throwMissingGetterError( 'colspan' ); }
  // @if CK_DEBUG // public get rowspan(): unknown { return throwMissingGetterError( 'rowspan' ); }
  // @if CK_DEBUG // public get cellIndex(): unknown { return throwMissingGetterError( 'cellIndex' ); }
  /**
  * Whether the cell is anchored in the current slot.
  */
  get isAnchor() {
    return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
  }
  /**
  * The width of a cell defined by a `colspan` attribute. If the model attribute is not present, it is set to `1`.
  */
  get cellWidth() {
    return parseInt(this.cell.getAttribute("colspan") || "1");
  }
  /**
  * The height of a cell defined by a `rowspan` attribute. If the model attribute is not present, it is set to `1`.
  */
  get cellHeight() {
    return parseInt(this.cell.getAttribute("rowspan") || "1");
  }
  /**
  * The index of the current row element in the table.
  */
  get rowIndex() {
    return this._rowIndex;
  }
  /**
  * Returns the {@link module:engine/model/position~Position} before the table slot.
  */
  getPositionBefore() {
    const model = this._table.root.document.model;
    return model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
  }
};
function downcastTable(tableUtils, options2) {
  return (table, { writer }) => {
    const headingRows = table.getAttribute("headingRows") || 0;
    const tableElement = writer.createContainerElement("table", null, []);
    const figureElement = writer.createContainerElement("figure", {
      class: "table"
    }, tableElement);
    if (headingRows > 0) {
      writer.insert(writer.createPositionAt(tableElement, "end"), writer.createContainerElement("thead", null, writer.createSlot((element) => element.is("element", "tableRow") && element.index < headingRows)));
    }
    if (headingRows < tableUtils.getRows(table)) {
      writer.insert(writer.createPositionAt(tableElement, "end"), writer.createContainerElement("tbody", null, writer.createSlot((element) => element.is("element", "tableRow") && element.index >= headingRows)));
    }
    for (const { positionOffset, filter } of options2.additionalSlots) {
      writer.insert(writer.createPositionAt(tableElement, positionOffset), writer.createSlot(filter));
    }
    writer.insert(writer.createPositionAt(tableElement, "after"), writer.createSlot((element) => {
      if (element.is("element", "tableRow")) {
        return false;
      }
      return !options2.additionalSlots.some(({ filter }) => filter(element));
    }));
    return options2.asWidget ? toTableWidget(figureElement, writer) : figureElement;
  };
}
function downcastRow() {
  return (tableRow, { writer }) => {
    return tableRow.isEmpty ? writer.createEmptyElement("tr") : writer.createContainerElement("tr");
  };
}
function downcastCell(options2 = {}) {
  return (tableCell, { writer }) => {
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const rowIndex = table.getChildIndex(tableRow);
    const tableWalker = new TableWalker(table, {
      row: rowIndex
    });
    const headingRows = table.getAttribute("headingRows") || 0;
    const headingColumns = table.getAttribute("headingColumns") || 0;
    let result = null;
    for (const tableSlot of tableWalker) {
      if (tableSlot.cell == tableCell) {
        const isHeading = tableSlot.row < headingRows || tableSlot.column < headingColumns;
        const cellElementName = isHeading ? "th" : "td";
        result = options2.asWidget ? toWidgetEditable(writer.createEditableElement(cellElementName), writer) : writer.createContainerElement(cellElementName);
        break;
      }
    }
    return result;
  };
}
function convertParagraphInTableCell(options2 = {}) {
  return (modelElement, { writer }) => {
    if (!modelElement.parent.is("element", "tableCell")) {
      return null;
    }
    if (!isSingleParagraphWithoutAttributes(modelElement)) {
      return null;
    }
    if (options2.asWidget) {
      return writer.createContainerElement("span", {
        class: "ck-table-bogus-paragraph"
      });
    } else {
      const viewElement = writer.createContainerElement("p");
      writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
      return viewElement;
    }
  };
}
function isSingleParagraphWithoutAttributes(modelElement) {
  const tableCell = modelElement.parent;
  const isSingleParagraph = tableCell.childCount == 1;
  return isSingleParagraph && !hasAnyAttribute(modelElement);
}
function toTableWidget(viewElement, writer) {
  writer.setCustomProperty("table", true, viewElement);
  return toWidget(viewElement, writer, {
    hasSelectionHandle: true
  });
}
function hasAnyAttribute(element) {
  const iteratorItem = element.getAttributeKeys().next();
  return !iteratorItem.done;
}
var InsertTableCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const schema = model.schema;
    this.isEnabled = isAllowedInParent2(selection, schema);
  }
  /**
  * Executes the command.
  *
  * Inserts a table with the given number of rows and columns into the editor.
  *
  * @param options.rows The number of rows to create in the inserted table. Default value is 2.
  * @param options.columns The number of columns to create in the inserted table. Default value is 2.
  * @param options.headingRows The number of heading rows. If not provided it will default to
  * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.rows`} table config.
  * @param options.headingColumns The number of heading columns. If not provided it will default to
  * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.columns`} table config.
  * @fires execute
  */
  execute(options2 = {}) {
    const editor = this.editor;
    const model = editor.model;
    const tableUtils = editor.plugins.get("TableUtils");
    const defaultRows = editor.config.get("table.defaultHeadings.rows");
    const defaultColumns = editor.config.get("table.defaultHeadings.columns");
    if (options2.headingRows === void 0 && defaultRows) {
      options2.headingRows = defaultRows;
    }
    if (options2.headingColumns === void 0 && defaultColumns) {
      options2.headingColumns = defaultColumns;
    }
    model.change((writer) => {
      const table = tableUtils.createTable(writer, options2);
      model.insertObject(table, null, null, {
        findOptimalPosition: "auto"
      });
      writer.setSelection(writer.createPositionAt(table.getNodeByPath([
        0,
        0,
        0
      ]), 0));
    });
  }
};
function isAllowedInParent2(selection, schema) {
  const positionParent = selection.getFirstPosition().parent;
  const validParent = positionParent === positionParent.root ? positionParent : positionParent.parent;
  return schema.checkChild(validParent, "table");
}
var InsertRowCommand = class extends Command {
  /**
  * Creates a new `InsertRowCommand` instance.
  *
  * @param editor The editor on which this command will be used.
  * @param options.order The order of insertion relative to the row in which the caret is located.
  * Possible values: `"above"` and `"below"`. Default value is "below"
  */
  constructor(editor, options2 = {}) {
    super(editor);
    /**
    * The order of insertion relative to the row in which the caret is located.
    */
    __publicField(this, "order");
    this.order = options2.order || "below";
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const selection = this.editor.model.document.selection;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const isAnyCellSelected = !!tableUtils.getSelectionAffectedTableCells(selection).length;
    this.isEnabled = isAnyCellSelected;
  }
  /**
  * Executes the command.
  *
  * Depending on the command's {@link #order} value, it inserts a row `'below'` or `'above'` the row in which selection is set.
  *
  * @fires execute
  */
  execute() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const tableUtils = editor.plugins.get("TableUtils");
    const insertAbove = this.order === "above";
    const affectedTableCells = tableUtils.getSelectionAffectedTableCells(selection);
    const rowIndexes = tableUtils.getRowIndexes(affectedTableCells);
    const row = insertAbove ? rowIndexes.first : rowIndexes.last;
    const table = affectedTableCells[0].findAncestor("table");
    tableUtils.insertRows(table, {
      at: insertAbove ? row : row + 1,
      copyStructureFromAbove: !insertAbove
    });
  }
};
var InsertColumnCommand = class extends Command {
  /**
  * Creates a new `InsertColumnCommand` instance.
  *
  * @param editor An editor on which this command will be used.
  * @param options.order The order of insertion relative to the column in which the caret is located.
  * Possible values: `"left"` and `"right"`. Default value is "right".
  */
  constructor(editor, options2 = {}) {
    super(editor);
    /**
    * The order of insertion relative to the column in which the caret is located.
    */
    __publicField(this, "order");
    this.order = options2.order || "right";
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const selection = this.editor.model.document.selection;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const isAnyCellSelected = !!tableUtils.getSelectionAffectedTableCells(selection).length;
    this.isEnabled = isAnyCellSelected;
  }
  /**
  * Executes the command.
  *
  * Depending on the command's {@link #order} value, it inserts a column to the `'left'` or `'right'` of the column
  * in which the selection is set.
  *
  * @fires execute
  */
  execute() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const tableUtils = editor.plugins.get("TableUtils");
    const insertBefore = this.order === "left";
    const affectedTableCells = tableUtils.getSelectionAffectedTableCells(selection);
    const columnIndexes = tableUtils.getColumnIndexes(affectedTableCells);
    const column = insertBefore ? columnIndexes.first : columnIndexes.last;
    const table = affectedTableCells[0].findAncestor("table");
    tableUtils.insertColumns(table, {
      columns: 1,
      at: insertBefore ? column : column + 1
    });
  }
};
var SplitCellCommand = class extends Command {
  /**
  * Creates a new `SplitCellCommand` instance.
  *
  * @param editor The editor on which this command will be used.
  * @param options.direction Indicates whether the command should split cells `'horizontally'` or `'vertically'`.
  */
  constructor(editor, options2 = {}) {
    super(editor);
    /**
    * The direction that indicates which cell will be split.
    */
    __publicField(this, "direction");
    this.direction = options2.direction || "horizontally";
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = selectedCells.length === 1;
  }
  /**
  * @inheritDoc
  */
  execute() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const tableCell = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
    const isHorizontal = this.direction === "horizontally";
    if (isHorizontal) {
      tableUtils.splitCellHorizontally(tableCell, 2);
    } else {
      tableUtils.splitCellVertically(tableCell, 2);
    }
  }
};
function cropTableToDimensions(sourceTable, cropDimensions, writer) {
  const { startRow, startColumn, endRow, endColumn } = cropDimensions;
  const croppedTable = writer.createElement("table");
  const cropHeight = endRow - startRow + 1;
  for (let i = 0; i < cropHeight; i++) {
    writer.insertElement("tableRow", croppedTable, "end");
  }
  const tableMap = [
    ...new TableWalker(sourceTable, {
      startRow,
      endRow,
      startColumn,
      endColumn,
      includeAllSlots: true
    })
  ];
  for (const { row: sourceRow, column: sourceColumn, cell: tableCell, isAnchor, cellAnchorRow, cellAnchorColumn } of tableMap) {
    const rowInCroppedTable = sourceRow - startRow;
    const row = croppedTable.getChild(rowInCroppedTable);
    if (!isAnchor) {
      if (cellAnchorRow < startRow || cellAnchorColumn < startColumn) {
        createEmptyTableCell(writer, writer.createPositionAt(row, "end"));
      }
    } else {
      const tableCellCopy = writer.cloneElement(tableCell);
      writer.append(tableCellCopy, row);
      trimTableCellIfNeeded(tableCellCopy, sourceRow, sourceColumn, endRow, endColumn, writer);
    }
  }
  addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer);
  return croppedTable;
}
function getVerticallyOverlappingCells(table, overlapRow, startRow = 0) {
  const cells = [];
  const tableWalker = new TableWalker(table, {
    startRow,
    endRow: overlapRow - 1
  });
  for (const slotInfo of tableWalker) {
    const { row, cellHeight } = slotInfo;
    const cellEndRow = row + cellHeight - 1;
    if (row < overlapRow && overlapRow <= cellEndRow) {
      cells.push(slotInfo);
    }
  }
  return cells;
}
function splitHorizontally(tableCell, splitRow, writer) {
  const tableRow = tableCell.parent;
  const table = tableRow.parent;
  const rowIndex = tableRow.index;
  const rowspan = parseInt(tableCell.getAttribute("rowspan"));
  const newRowspan = splitRow - rowIndex;
  const newCellAttributes = {};
  const newCellRowSpan = rowspan - newRowspan;
  if (newCellRowSpan > 1) {
    newCellAttributes.rowspan = newCellRowSpan;
  }
  const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
  if (colspan > 1) {
    newCellAttributes.colspan = colspan;
  }
  const startRow = rowIndex;
  const endRow = startRow + newRowspan;
  const tableMap = [
    ...new TableWalker(table, {
      startRow,
      endRow,
      includeAllSlots: true
    })
  ];
  let newCell = null;
  let columnIndex;
  for (const tableSlot of tableMap) {
    const { row, column, cell: cell2 } = tableSlot;
    if (cell2 === tableCell && columnIndex === void 0) {
      columnIndex = column;
    }
    if (columnIndex !== void 0 && columnIndex === column && row === endRow) {
      newCell = createEmptyTableCell(writer, tableSlot.getPositionBefore(), newCellAttributes);
    }
  }
  updateNumericAttribute("rowspan", newRowspan, tableCell, writer);
  return newCell;
}
function getHorizontallyOverlappingCells(table, overlapColumn) {
  const cellsToSplit = [];
  const tableWalker = new TableWalker(table);
  for (const slotInfo of tableWalker) {
    const { column, cellWidth } = slotInfo;
    const cellEndColumn = column + cellWidth - 1;
    if (column < overlapColumn && overlapColumn <= cellEndColumn) {
      cellsToSplit.push(slotInfo);
    }
  }
  return cellsToSplit;
}
function splitVertically(tableCell, columnIndex, splitColumn, writer) {
  const colspan = parseInt(tableCell.getAttribute("colspan"));
  const newColspan = splitColumn - columnIndex;
  const newCellAttributes = {};
  const newCellColSpan = colspan - newColspan;
  if (newCellColSpan > 1) {
    newCellAttributes.colspan = newCellColSpan;
  }
  const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
  if (rowspan > 1) {
    newCellAttributes.rowspan = rowspan;
  }
  const newCell = createEmptyTableCell(writer, writer.createPositionAfter(tableCell), newCellAttributes);
  updateNumericAttribute("colspan", newColspan, tableCell, writer);
  return newCell;
}
function trimTableCellIfNeeded(tableCell, cellRow, cellColumn, limitRow, limitColumn, writer) {
  const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
  const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
  const endColumn = cellColumn + colspan - 1;
  if (endColumn > limitColumn) {
    const trimmedSpan = limitColumn - cellColumn + 1;
    updateNumericAttribute("colspan", trimmedSpan, tableCell, writer, 1);
  }
  const endRow = cellRow + rowspan - 1;
  if (endRow > limitRow) {
    const trimmedSpan = limitRow - cellRow + 1;
    updateNumericAttribute("rowspan", trimmedSpan, tableCell, writer, 1);
  }
}
function addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer) {
  const headingRows = parseInt(sourceTable.getAttribute("headingRows") || "0");
  if (headingRows > 0) {
    const headingRowsInCrop = headingRows - startRow;
    updateNumericAttribute("headingRows", headingRowsInCrop, croppedTable, writer, 0);
  }
  const headingColumns = parseInt(sourceTable.getAttribute("headingColumns") || "0");
  if (headingColumns > 0) {
    const headingColumnsInCrop = headingColumns - startColumn;
    updateNumericAttribute("headingColumns", headingColumnsInCrop, croppedTable, writer, 0);
  }
}
function removeEmptyColumns(table, tableUtils) {
  const width = tableUtils.getColumns(table);
  const columnsMap = new Array(width).fill(0);
  for (const { column } of new TableWalker(table)) {
    columnsMap[column]++;
  }
  const emptyColumns = columnsMap.reduce((result, cellsCount, column) => {
    return cellsCount ? result : [
      ...result,
      column
    ];
  }, []);
  if (emptyColumns.length > 0) {
    const emptyColumn = emptyColumns[emptyColumns.length - 1];
    tableUtils.removeColumns(table, {
      at: emptyColumn
    });
    return true;
  }
  return false;
}
function removeEmptyRows(table, tableUtils) {
  const emptyRows = [];
  const tableRowCount = tableUtils.getRows(table);
  for (let rowIndex = 0; rowIndex < tableRowCount; rowIndex++) {
    const tableRow = table.getChild(rowIndex);
    if (tableRow.isEmpty) {
      emptyRows.push(rowIndex);
    }
  }
  if (emptyRows.length > 0) {
    const emptyRow = emptyRows[emptyRows.length - 1];
    tableUtils.removeRows(table, {
      at: emptyRow
    });
    return true;
  }
  return false;
}
function removeEmptyRowsColumns(table, tableUtils) {
  const removedColumns = removeEmptyColumns(table, tableUtils);
  if (!removedColumns) {
    removeEmptyRows(table, tableUtils);
  }
}
function adjustLastRowIndex(table, dimensions) {
  const lastRowMap = Array.from(new TableWalker(table, {
    startColumn: dimensions.firstColumn,
    endColumn: dimensions.lastColumn,
    row: dimensions.lastRow
  }));
  const everyCellHasSingleRowspan = lastRowMap.every(({ cellHeight }) => cellHeight === 1);
  if (everyCellHasSingleRowspan) {
    return dimensions.lastRow;
  }
  const rowspanAdjustment = lastRowMap[0].cellHeight - 1;
  return dimensions.lastRow + rowspanAdjustment;
}
function adjustLastColumnIndex(table, dimensions) {
  const lastColumnMap = Array.from(new TableWalker(table, {
    startRow: dimensions.firstRow,
    endRow: dimensions.lastRow,
    column: dimensions.lastColumn
  }));
  const everyCellHasSingleColspan = lastColumnMap.every(({ cellWidth }) => cellWidth === 1);
  if (everyCellHasSingleColspan) {
    return dimensions.lastColumn;
  }
  const colspanAdjustment = lastColumnMap[0].cellWidth - 1;
  return dimensions.lastColumn + colspanAdjustment;
}
var MergeCellCommand = class extends Command {
  /**
  * Creates a new `MergeCellCommand` instance.
  *
  * @param editor The editor on which this command will be used.
  * @param options.direction Indicates which cell to merge with the currently selected one.
  * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.
  */
  constructor(editor, options2) {
    super(editor);
    /**
    * The direction that indicates which cell will be merged with the currently selected one.
    */
    __publicField(this, "direction");
    /**
    * Whether the merge is horizontal (left/right) or vertical (up/down).
    */
    __publicField(this, "isHorizontal");
    this.direction = options2.direction;
    this.isHorizontal = this.direction == "right" || this.direction == "left";
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const cellToMerge = this._getMergeableCell();
    this.value = cellToMerge;
    this.isEnabled = !!cellToMerge;
  }
  /**
  * Executes the command.
  *
  * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.
  *
  * @fires execute
  */
  execute() {
    const model = this.editor.model;
    const doc = model.document;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const tableCell = tableUtils.getTableCellsContainingSelection(doc.selection)[0];
    const cellToMerge = this.value;
    const direction = this.direction;
    model.change((writer) => {
      const isMergeNext = direction == "right" || direction == "down";
      const cellToExpand = isMergeNext ? tableCell : cellToMerge;
      const cellToRemove = isMergeNext ? cellToMerge : tableCell;
      const removedTableCellRow = cellToRemove.parent;
      mergeTableCells$1(cellToRemove, cellToExpand, writer);
      const spanAttribute = this.isHorizontal ? "colspan" : "rowspan";
      const cellSpan = parseInt(tableCell.getAttribute(spanAttribute) || "1");
      const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || "1");
      writer.setAttribute(spanAttribute, cellSpan + cellToMergeSpan, cellToExpand);
      writer.setSelection(writer.createRangeIn(cellToExpand));
      const tableUtils2 = this.editor.plugins.get("TableUtils");
      const table = removedTableCellRow.findAncestor("table");
      removeEmptyRowsColumns(table, tableUtils2);
    });
  }
  /**
  * Returns a cell that can be merged with the current cell depending on the command's direction.
  */
  _getMergeableCell() {
    const model = this.editor.model;
    const doc = model.document;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const tableCell = tableUtils.getTableCellsContainingSelection(doc.selection)[0];
    if (!tableCell) {
      return;
    }
    const cellToMerge = this.isHorizontal ? getHorizontalCell(tableCell, this.direction, tableUtils) : getVerticalCell(tableCell, this.direction, tableUtils);
    if (!cellToMerge) {
      return;
    }
    const spanAttribute = this.isHorizontal ? "rowspan" : "colspan";
    const span = parseInt(tableCell.getAttribute(spanAttribute) || "1");
    const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || "1");
    if (cellToMergeSpan === span) {
      return cellToMerge;
    }
  }
};
function getHorizontalCell(tableCell, direction, tableUtils) {
  const tableRow = tableCell.parent;
  const table = tableRow.parent;
  const horizontalCell = direction == "right" ? tableCell.nextSibling : tableCell.previousSibling;
  const hasHeadingColumns = (table.getAttribute("headingColumns") || 0) > 0;
  if (!horizontalCell) {
    return;
  }
  const cellOnLeft = direction == "right" ? tableCell : horizontalCell;
  const cellOnRight = direction == "right" ? horizontalCell : tableCell;
  const { column: leftCellColumn } = tableUtils.getCellLocation(cellOnLeft);
  const { column: rightCellColumn } = tableUtils.getCellLocation(cellOnRight);
  const leftCellSpan = parseInt(cellOnLeft.getAttribute("colspan") || "1");
  const isCellOnLeftInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnLeft);
  const isCellOnRightInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnRight);
  if (hasHeadingColumns && isCellOnLeftInHeadingColumn != isCellOnRightInHeadingColumn) {
    return;
  }
  const cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn;
  return cellsAreTouching ? horizontalCell : void 0;
}
function getVerticalCell(tableCell, direction, tableUtils) {
  const tableRow = tableCell.parent;
  const table = tableRow.parent;
  const rowIndex = table.getChildIndex(tableRow);
  if (direction == "down" && rowIndex === tableUtils.getRows(table) - 1 || direction == "up" && rowIndex === 0) {
    return null;
  }
  const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
  const headingRows = table.getAttribute("headingRows") || 0;
  const isMergeWithBodyCell = direction == "down" && rowIndex + rowspan === headingRows;
  const isMergeWithHeadCell = direction == "up" && rowIndex === headingRows;
  if (headingRows && (isMergeWithBodyCell || isMergeWithHeadCell)) {
    return null;
  }
  const currentCellRowSpan = parseInt(tableCell.getAttribute("rowspan") || "1");
  const rowOfCellToMerge = direction == "down" ? rowIndex + currentCellRowSpan : rowIndex;
  const tableMap = [
    ...new TableWalker(table, {
      endRow: rowOfCellToMerge
    })
  ];
  const currentCellData = tableMap.find((value) => value.cell === tableCell);
  const mergeColumn = currentCellData.column;
  const cellToMergeData = tableMap.find(({ row, cellHeight, column }) => {
    if (column !== mergeColumn) {
      return false;
    }
    if (direction == "down") {
      return row === rowOfCellToMerge;
    } else {
      return rowOfCellToMerge === row + cellHeight;
    }
  });
  return cellToMergeData && cellToMergeData.cell ? cellToMergeData.cell : null;
}
function mergeTableCells$1(cellToRemove, cellToExpand, writer) {
  if (!isEmpty$2(cellToRemove)) {
    if (isEmpty$2(cellToExpand)) {
      writer.remove(writer.createRangeIn(cellToExpand));
    }
    writer.move(writer.createRangeIn(cellToRemove), writer.createPositionAt(cellToExpand, "end"));
  }
  writer.remove(cellToRemove);
}
function isEmpty$2(tableCell) {
  const firstTableChild = tableCell.getChild(0);
  return tableCell.childCount == 1 && firstTableChild.is("element", "paragraph") && firstTableChild.isEmpty;
}
var RemoveRowCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    const firstCell = selectedCells[0];
    if (firstCell) {
      const table = firstCell.findAncestor("table");
      const tableRowCount = tableUtils.getRows(table);
      const lastRowIndex = tableRowCount - 1;
      const selectedRowIndexes = tableUtils.getRowIndexes(selectedCells);
      const areAllRowsSelected = selectedRowIndexes.first === 0 && selectedRowIndexes.last === lastRowIndex;
      this.isEnabled = !areAllRowsSelected;
    } else {
      this.isEnabled = false;
    }
  }
  /**
  * @inheritDoc
  */
  execute() {
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const removedRowIndexes = tableUtils.getRowIndexes(referenceCells);
    const firstCell = referenceCells[0];
    const table = firstCell.findAncestor("table");
    const columnIndexToFocus = tableUtils.getCellLocation(firstCell).column;
    model.change((writer) => {
      const rowsToRemove = removedRowIndexes.last - removedRowIndexes.first + 1;
      tableUtils.removeRows(table, {
        at: removedRowIndexes.first,
        rows: rowsToRemove
      });
      const cellToFocus = getCellToFocus$1(table, removedRowIndexes.first, columnIndexToFocus, tableUtils.getRows(table));
      writer.setSelection(writer.createPositionAt(cellToFocus, 0));
    });
  }
};
function getCellToFocus$1(table, removedRowIndex, columnToFocus, tableRowCount) {
  const row = table.getChild(Math.min(removedRowIndex, tableRowCount - 1));
  let cellToFocus = row.getChild(0);
  let column = 0;
  for (const tableCell of row.getChildren()) {
    if (column > columnToFocus) {
      return cellToFocus;
    }
    cellToFocus = tableCell;
    column += parseInt(tableCell.getAttribute("colspan") || "1");
  }
  return cellToFocus;
}
var RemoveColumnCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    const firstCell = selectedCells[0];
    if (firstCell) {
      const table = firstCell.findAncestor("table");
      const tableColumnCount = tableUtils.getColumns(table);
      const { first: first2, last } = tableUtils.getColumnIndexes(selectedCells);
      this.isEnabled = last - first2 < tableColumnCount - 1;
    } else {
      this.isEnabled = false;
    }
  }
  /**
  * @inheritDoc
  */
  execute() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const [firstCell, lastCell] = getBoundaryCells(this.editor.model.document.selection, tableUtils);
    const table = firstCell.parent.parent;
    const tableMap = [
      ...new TableWalker(table)
    ];
    const removedColumnIndexes = {
      first: tableMap.find((value) => value.cell === firstCell).column,
      last: tableMap.find((value) => value.cell === lastCell).column
    };
    const cellToFocus = getCellToFocus(tableMap, firstCell, lastCell, removedColumnIndexes);
    this.editor.model.change((writer) => {
      const columnsToRemove = removedColumnIndexes.last - removedColumnIndexes.first + 1;
      tableUtils.removeColumns(table, {
        at: removedColumnIndexes.first,
        columns: columnsToRemove
      });
      writer.setSelection(writer.createPositionAt(cellToFocus, 0));
    });
  }
};
function getCellToFocus(tableMap, firstCell, lastCell, removedColumnIndexes) {
  const colspan = parseInt(lastCell.getAttribute("colspan") || "1");
  if (colspan > 1) {
    return lastCell;
  } else if (firstCell.previousSibling || lastCell.nextSibling) {
    return lastCell.nextSibling || firstCell.previousSibling;
  } else {
    if (removedColumnIndexes.first) {
      return tableMap.reverse().find(({ column }) => {
        return column < removedColumnIndexes.first;
      }).cell;
    } else {
      return tableMap.reverse().find(({ column }) => {
        return column > removedColumnIndexes.last;
      }).cell;
    }
  }
}
function getBoundaryCells(selection, tableUtils) {
  const referenceCells = tableUtils.getSelectionAffectedTableCells(selection);
  const firstCell = referenceCells[0];
  const lastCell = referenceCells.pop();
  const returnValue = [
    firstCell,
    lastCell
  ];
  return firstCell.isBefore(lastCell) ? returnValue : returnValue.reverse();
}
var SetHeaderRowCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const model = this.editor.model;
    const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const isInTable = selectedCells.length > 0;
    this.isEnabled = isInTable;
    this.value = isInTable && selectedCells.every((cell2) => this._isInHeading(cell2, cell2.parent.parent));
  }
  /**
  * Executes the command.
  *
  * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.
  *
  * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.
  *
  * @fires execute
  * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header rows according to
  * the `forceValue` parameter instead of the current model state.
  */
  execute(options2 = {}) {
    if (options2.forceValue === this.value) {
      return;
    }
    const tableUtils = this.editor.plugins.get("TableUtils");
    const model = this.editor.model;
    const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const table = selectedCells[0].findAncestor("table");
    const { first: first2, last } = tableUtils.getRowIndexes(selectedCells);
    const headingRowsToSet = this.value ? first2 : last + 1;
    const currentHeadingRows = table.getAttribute("headingRows") || 0;
    model.change((writer) => {
      if (headingRowsToSet) {
        const startRow = headingRowsToSet > currentHeadingRows ? currentHeadingRows : 0;
        const overlappingCells = getVerticallyOverlappingCells(table, headingRowsToSet, startRow);
        for (const { cell: cell2 } of overlappingCells) {
          splitHorizontally(cell2, headingRowsToSet, writer);
        }
      }
      updateNumericAttribute("headingRows", headingRowsToSet, table, writer, 0);
    });
  }
  /**
  * Checks if a table cell is in the heading section.
  */
  _isInHeading(tableCell, table) {
    const headingRows = parseInt(table.getAttribute("headingRows") || "0");
    return !!headingRows && tableCell.parent.index < headingRows;
  }
};
var SetHeaderColumnCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const isInTable = selectedCells.length > 0;
    this.isEnabled = isInTable;
    this.value = isInTable && selectedCells.every((cell2) => isHeadingColumnCell(tableUtils, cell2));
  }
  /**
  * Executes the command.
  *
  * When the selection is in a non-header column, the command will set the `headingColumns` table attribute to cover that column.
  *
  * When the selection is already in a header column, it will set `headingColumns` so the heading section will end before that column.
  *
  * @fires execute
  * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header columns according to
  * the `forceValue` parameter instead of the current model state.
  */
  execute(options2 = {}) {
    if (options2.forceValue === this.value) {
      return;
    }
    const tableUtils = this.editor.plugins.get("TableUtils");
    const model = this.editor.model;
    const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const table = selectedCells[0].findAncestor("table");
    const { first: first2, last } = tableUtils.getColumnIndexes(selectedCells);
    const headingColumnsToSet = this.value ? first2 : last + 1;
    model.change((writer) => {
      if (headingColumnsToSet) {
        const overlappingCells = getHorizontallyOverlappingCells(table, headingColumnsToSet);
        for (const { cell: cell2, column } of overlappingCells) {
          splitVertically(cell2, column, headingColumnsToSet, writer);
        }
      }
      updateNumericAttribute("headingColumns", headingColumnsToSet, table, writer, 0);
    });
  }
};
var COLUMN_MIN_WIDTH_AS_PERCENTAGE = 5;
var COLUMN_MIN_WIDTH_IN_PIXELS = 40;
var COLUMN_WIDTH_PRECISION = 2;
function getChangedResizedTables(model) {
  const affectedTables = /* @__PURE__ */ new Set();
  for (const change of model.document.differ.getChanges()) {
    let referencePosition = null;
    switch (change.type) {
      case "insert":
        referencePosition = [
          "table",
          "tableRow",
          "tableCell"
        ].includes(change.name) ? change.position : null;
        break;
      case "remove":
        referencePosition = [
          "tableRow",
          "tableCell"
        ].includes(change.name) ? change.position : null;
        break;
      case "attribute":
        if (change.range.start.nodeAfter) {
          referencePosition = [
            "table",
            "tableRow",
            "tableCell"
          ].includes(change.range.start.nodeAfter.name) ? change.range.start : null;
        }
        break;
    }
    if (!referencePosition) {
      continue;
    }
    const tableNode = referencePosition.nodeAfter && referencePosition.nodeAfter.is("element", "table") ? referencePosition.nodeAfter : referencePosition.findAncestor("table");
    for (const node of model.createRangeOn(tableNode).getItems()) {
      if (!node.is("element", "table")) {
        continue;
      }
      if (!getColumnGroupElement(node)) {
        continue;
      }
      affectedTables.add(node);
    }
  }
  return affectedTables;
}
function getColumnMinWidthAsPercentage(modelTable, editor) {
  return COLUMN_MIN_WIDTH_IN_PIXELS * 100 / getTableWidthInPixels(modelTable, editor);
}
function getTableWidthInPixels(modelTable, editor) {
  const referenceElement = getChildrenViewElement(modelTable, "tbody", editor) || getChildrenViewElement(modelTable, "thead", editor);
  const domReferenceElement = editor.editing.view.domConverter.mapViewToDom(referenceElement);
  return getElementWidthInPixels(domReferenceElement);
}
function getChildrenViewElement(modelTable, elementName, editor) {
  const viewFigure = editor.editing.mapper.toViewElement(modelTable);
  const viewTable = [
    ...viewFigure.getChildren()
  ].find((node) => node.is("element", "table"));
  return [
    ...viewTable.getChildren()
  ].find((node) => node.is("element", elementName));
}
function getElementWidthInPixels(domElement) {
  const styles = global.window.getComputedStyle(domElement);
  if (styles.boxSizing === "border-box") {
    return parseFloat(styles.width) - parseFloat(styles.paddingLeft) - parseFloat(styles.paddingRight) - parseFloat(styles.borderLeftWidth) - parseFloat(styles.borderRightWidth);
  } else {
    return parseFloat(styles.width);
  }
}
function getColumnEdgesIndexes(cell2, tableUtils) {
  const cellColumnIndex = tableUtils.getCellLocation(cell2).column;
  const cellWidth = cell2.getAttribute("colspan") || 1;
  return {
    leftEdge: cellColumnIndex,
    rightEdge: cellColumnIndex + cellWidth - 1
  };
}
function toPrecision(value) {
  const multiplier = Math.pow(10, COLUMN_WIDTH_PRECISION);
  const number = typeof value === "number" ? value : parseFloat(value);
  return Math.round(number * multiplier) / multiplier;
}
function clamp(number, min, max) {
  if (number <= min) {
    return toPrecision(min);
  }
  if (number >= max) {
    return toPrecision(max);
  }
  return toPrecision(number);
}
function createFilledArray(length, value) {
  return Array(length).fill(value);
}
function sumArray(array) {
  return array.map((value) => typeof value === "number" ? value : parseFloat(value)).filter((value) => !Number.isNaN(value)).reduce((result, item) => result + item, 0);
}
function normalizeColumnWidths(columnWidths) {
  const widths = columnWidths.map((width) => {
    if (width === "auto") {
      return width;
    }
    return parseFloat(width.replace("%", ""));
  });
  let normalizedWidths = calculateMissingColumnWidths(widths);
  const totalWidth = sumArray(normalizedWidths);
  if (totalWidth !== 100) {
    normalizedWidths = normalizedWidths.map((width) => toPrecision(width * 100 / totalWidth)).map((columnWidth, columnIndex, width) => {
      const isLastColumn = columnIndex === width.length - 1;
      if (!isLastColumn) {
        return columnWidth;
      }
      const totalWidth2 = sumArray(width);
      return toPrecision(columnWidth + 100 - totalWidth2);
    });
  }
  return normalizedWidths.map((width) => width + "%");
}
function calculateMissingColumnWidths(columnWidths) {
  const numberOfUninitializedColumns = columnWidths.filter((columnWidth) => columnWidth === "auto").length;
  if (numberOfUninitializedColumns === 0) {
    return columnWidths.map((columnWidth) => toPrecision(columnWidth));
  }
  const totalWidthOfInitializedColumns = sumArray(columnWidths);
  const widthForUninitializedColumn = Math.max((100 - totalWidthOfInitializedColumns) / numberOfUninitializedColumns, COLUMN_MIN_WIDTH_AS_PERCENTAGE);
  return columnWidths.map((columnWidth) => columnWidth === "auto" ? widthForUninitializedColumn : columnWidth).map((columnWidth) => toPrecision(columnWidth));
}
function getDomCellOuterWidth(domCell) {
  const styles = global.window.getComputedStyle(domCell);
  if (styles.boxSizing === "border-box") {
    return parseInt(styles.width);
  } else {
    return parseFloat(styles.width) + parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight) + parseFloat(styles.borderWidth);
  }
}
function updateColumnElements(columns, tableColumnGroup, normalizedWidths, writer) {
  for (let i = 0; i < Math.max(normalizedWidths.length, columns.length); i++) {
    const column = columns[i];
    const columnWidth = normalizedWidths[i];
    if (!columnWidth) {
      writer.remove(column);
    } else if (!column) {
      writer.appendElement("tableColumn", {
        columnWidth
      }, tableColumnGroup);
    } else {
      writer.setAttribute("columnWidth", columnWidth, column);
    }
  }
}
function getColumnGroupElement(element) {
  if (element.is("element", "tableColumnGroup")) {
    return element;
  }
  const children = element.getChildren();
  return Array.from(children).find((element2) => element2.is("element", "tableColumnGroup"));
}
function getTableColumnElements(element) {
  const columnGroupElement = getColumnGroupElement(element);
  if (!columnGroupElement) {
    return [];
  }
  return Array.from(columnGroupElement.getChildren());
}
function getTableColumnsWidths(element) {
  return getTableColumnElements(element).map((column) => column.getAttribute("columnWidth"));
}
function translateColSpanAttribute(element, writer) {
  const tableColumnElements = getTableColumnElements(element);
  return tableColumnElements.reduce((acc, element2) => {
    const columnWidth = element2.getAttribute("columnWidth");
    const colSpan = element2.getAttribute("colSpan");
    if (!colSpan) {
      acc.push(columnWidth);
      return acc;
    }
    for (let i = 0; i < colSpan; i++) {
      acc.push(columnWidth);
    }
    writer.removeAttribute("colSpan", element2);
    return acc;
  }, []);
}
var TableUtils = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableUtils";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this.decorate("insertColumns");
    this.decorate("insertRows");
  }
  /**
  * Returns the table cell location as an object with table row and table column indexes.
  *
  * For instance, in the table below:
  *
  *      0   1   2   3
  *    +---+---+---+---+
  *  0 | a     | b | c |
  *    +       +   +---+
  *  1 |       |   | d |
  *    +---+---+   +---+
  *  2 | e     |   | f |
  *    +---+---+---+---+
  *
  * the method will return:
  *
  * ```ts
  * const cellA = table.getNodeByPath( [ 0, 0 ] );
  * editor.plugins.get( 'TableUtils' ).getCellLocation( cellA );
  * // will return { row: 0, column: 0 }
  *
  * const cellD = table.getNodeByPath( [ 1, 0 ] );
  * editor.plugins.get( 'TableUtils' ).getCellLocation( cellD );
  * // will return { row: 1, column: 3 }
  * ```
  *
  * @returns Returns a `{row, column}` object.
  */
  getCellLocation(tableCell) {
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const rowIndex = table.getChildIndex(tableRow);
    const tableWalker = new TableWalker(table, {
      row: rowIndex
    });
    for (const { cell: cell2, row, column } of tableWalker) {
      if (cell2 === tableCell) {
        return {
          row,
          column
        };
      }
    }
    return void 0;
  }
  /**
  * Creates an empty table with a proper structure. The table needs to be inserted into the model,
  * for example, by using the {@link module:engine/model/model~Model#insertContent} function.
  *
  * ```ts
  * model.change( ( writer ) => {
  *   // Create a table of 2 rows and 7 columns:
  *   const table = tableUtils.createTable( writer, { rows: 2, columns: 7 } );
  *
  *   // Insert a table to the model at the best position taking the current selection:
  *   model.insertContent( table );
  * }
  * ```
  *
  * @param writer The model writer.
  * @param options.rows The number of rows to create. Default value is 2.
  * @param options.columns The number of columns to create. Default value is 2.
  * @param options.headingRows The number of heading rows. Default value is 0.
  * @param options.headingColumns The number of heading columns. Default value is 0.
  * @returns The created table element.
  */
  createTable(writer, options2) {
    const table = writer.createElement("table");
    const rows = options2.rows || 2;
    const columns = options2.columns || 2;
    createEmptyRows(writer, table, 0, rows, columns);
    if (options2.headingRows) {
      updateNumericAttribute("headingRows", Math.min(options2.headingRows, rows), table, writer, 0);
    }
    if (options2.headingColumns) {
      updateNumericAttribute("headingColumns", Math.min(options2.headingColumns, columns), table, writer, 0);
    }
    return table;
  }
  /**
  * Inserts rows into a table.
  *
  * ```ts
  * editor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );
  * ```
  *
  * Assuming the table on the left, the above code will transform it to the table on the right:
  *
  *  row index
  *    0 +---+---+---+       `at` = 1,      +---+---+---+ 0
  *      | a | b | c |       `rows` = 2,    | a | b | c |
  *    1 +   +---+---+   <-- insert here    +   +---+---+ 1
  *      |   | d | e |                      |   |   |   |
  *    2 +   +---+---+       will give:     +   +---+---+ 2
  *      |   | f | g |                      |   |   |   |
  *    3 +---+---+---+                      +   +---+---+ 3
  *                                         |   | d | e |
  *                                         +   +---+---+ 4
  *                                         +   + f | g |
  *                                         +---+---+---+ 5
  *
  * @param table The table model element where the rows will be inserted.
  * @param options.at The row index at which the rows will be inserted.  Default value is 0.
  * @param options.rows The number of rows to insert.  Default value is 1.
  * @param options.copyStructureFromAbove The flag for copying row structure. Note that
  * the row structure will not be copied if this option is not provided.
  */
  insertRows(table, options2 = {}) {
    const model = this.editor.model;
    const insertAt2 = options2.at || 0;
    const rowsToInsert = options2.rows || 1;
    const isCopyStructure = options2.copyStructureFromAbove !== void 0;
    const copyStructureFrom = options2.copyStructureFromAbove ? insertAt2 - 1 : insertAt2;
    const rows = this.getRows(table);
    const columns = this.getColumns(table);
    if (insertAt2 > rows) {
      throw new CKEditorError("tableutils-insertrows-insert-out-of-range", this, {
        options: options2
      });
    }
    model.change((writer) => {
      const headingRows = table.getAttribute("headingRows") || 0;
      if (headingRows > insertAt2) {
        updateNumericAttribute("headingRows", headingRows + rowsToInsert, table, writer, 0);
      }
      if (!isCopyStructure && (insertAt2 === 0 || insertAt2 === rows)) {
        createEmptyRows(writer, table, insertAt2, rowsToInsert, columns);
        return;
      }
      const walkerEndRow = isCopyStructure ? Math.max(insertAt2, copyStructureFrom) : insertAt2;
      const tableIterator = new TableWalker(table, {
        endRow: walkerEndRow
      });
      const rowColSpansMap = new Array(columns).fill(1);
      for (const { row, column, cellHeight, cellWidth, cell: cell2 } of tableIterator) {
        const lastCellRow = row + cellHeight - 1;
        const isOverlappingInsertedRow = row < insertAt2 && insertAt2 <= lastCellRow;
        const isReferenceRow = row <= copyStructureFrom && copyStructureFrom <= lastCellRow;
        if (isOverlappingInsertedRow) {
          writer.setAttribute("rowspan", cellHeight + rowsToInsert, cell2);
          rowColSpansMap[column] = -cellWidth;
        } else if (isCopyStructure && isReferenceRow) {
          rowColSpansMap[column] = cellWidth;
        }
      }
      for (let rowIndex = 0; rowIndex < rowsToInsert; rowIndex++) {
        const tableRow = writer.createElement("tableRow");
        writer.insert(tableRow, table, insertAt2);
        for (let cellIndex = 0; cellIndex < rowColSpansMap.length; cellIndex++) {
          const colspan = rowColSpansMap[cellIndex];
          const insertPosition = writer.createPositionAt(tableRow, "end");
          if (colspan > 0) {
            createEmptyTableCell(writer, insertPosition, colspan > 1 ? {
              colspan
            } : void 0);
          }
          cellIndex += Math.abs(colspan) - 1;
        }
      }
    });
  }
  /**
  * Inserts columns into a table.
  *
  * ```ts
  * editor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );
  * ```
  *
  * Assuming the table on the left, the above code will transform it to the table on the right:
  *
  *  0   1   2   3                   0   1   2   3   4   5
  *  +---+---+---+                   +---+---+---+---+---+
  *  | a     | b |                   | a             | b |
  *  +       +---+                   +               +---+
  *  |       | c |                   |               | c |
  *  +---+---+---+     will give:    +---+---+---+---+---+
  *  | d | e | f |                   | d |   |   | e | f |
  *  +---+   +---+                   +---+---+---+   +---+
  *  | g |   | h |                   | g |   |   |   | h |
  *  +---+---+---+                   +---+---+---+---+---+
  *  | i         |                   | i                 |
  *  +---+---+---+                   +---+---+---+---+---+
  *      ^---- insert here, `at` = 1, `columns` = 2
  *
  * @param table The table model element where the columns will be inserted.
  * @param options.at The column index at which the columns will be inserted. Default value is 0.
  * @param options.columns The number of columns to insert. Default value is 1.
  */
  insertColumns(table, options2 = {}) {
    const model = this.editor.model;
    const insertAt2 = options2.at || 0;
    const columnsToInsert = options2.columns || 1;
    model.change((writer) => {
      const headingColumns = table.getAttribute("headingColumns");
      if (insertAt2 < headingColumns) {
        writer.setAttribute("headingColumns", headingColumns + columnsToInsert, table);
      }
      const tableColumns = this.getColumns(table);
      if (insertAt2 === 0 || tableColumns === insertAt2) {
        for (const tableRow of table.getChildren()) {
          if (!tableRow.is("element", "tableRow")) {
            continue;
          }
          createCells(columnsToInsert, writer, writer.createPositionAt(tableRow, insertAt2 ? "end" : 0));
        }
        return;
      }
      const tableWalker = new TableWalker(table, {
        column: insertAt2,
        includeAllSlots: true
      });
      for (const tableSlot of tableWalker) {
        const { row, cell: cell2, cellAnchorColumn, cellAnchorRow, cellWidth, cellHeight } = tableSlot;
        if (cellAnchorColumn < insertAt2) {
          writer.setAttribute("colspan", cellWidth + columnsToInsert, cell2);
          const lastCellRow = cellAnchorRow + cellHeight - 1;
          for (let i = row; i <= lastCellRow; i++) {
            tableWalker.skipRow(i);
          }
        } else {
          createCells(columnsToInsert, writer, tableSlot.getPositionBefore());
        }
      }
    });
  }
  /**
  * Removes rows from the given `table`.
  *
  * This method re-calculates the table geometry including `rowspan` attribute of table cells overlapping removed rows
  * and table headings values.
  *
  * ```ts
  * editor.plugins.get( 'TableUtils' ).removeRows( table, { at: 1, rows: 2 } );
  * ```
  *
  * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
  *
  *  row index
  *              `at` = 1        
  *    0  a  b  c         `rows` = 2       a  b  c  0
  *                                    
  *    1     d  e   <-- remove from here      d  g  1
  *                    will give:      
  *    2        f                          h  i  j  2
  *                                    
  *    3        g 
  *      
  *    4  h  i  j 
  *      
  *
  * @param options.at The row index at which the removing rows will start.
  * @param options.rows The number of rows to remove. Default value is 1.
  */
  removeRows(table, options2) {
    const model = this.editor.model;
    const rowsToRemove = options2.rows || 1;
    const rowCount = this.getRows(table);
    const first2 = options2.at;
    const last = first2 + rowsToRemove - 1;
    if (last > rowCount - 1) {
      throw new CKEditorError("tableutils-removerows-row-index-out-of-range", this, {
        table,
        options: options2
      });
    }
    model.change((writer) => {
      const indexesObject = {
        first: first2,
        last
      };
      const { cellsToMove, cellsToTrim } = getCellsToMoveAndTrimOnRemoveRow(table, indexesObject);
      if (cellsToMove.size) {
        const rowAfterRemovedSection = last + 1;
        moveCellsToRow(table, rowAfterRemovedSection, cellsToMove, writer);
      }
      for (let i = last; i >= first2; i--) {
        writer.remove(table.getChild(i));
      }
      for (const { rowspan, cell: cell2 } of cellsToTrim) {
        updateNumericAttribute("rowspan", rowspan, cell2, writer);
      }
      updateHeadingRows(table, indexesObject, writer);
      if (!removeEmptyColumns(table, this)) {
        removeEmptyRows(table, this);
      }
    });
  }
  /**
  * Removes columns from the given `table`.
  *
  * This method re-calculates the table geometry including the `colspan` attribute of table cells overlapping removed columns
  * and table headings values.
  *
  * ```ts
  * editor.plugins.get( 'TableUtils' ).removeColumns( table, { at: 1, columns: 2 } );
  * ```
  *
  * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
  *
  *    0   1   2   3   4                       0   1   2
  *                     
  *   a              b                     a      b 
  *                                           
  *                  c                            c 
  *       will give:    
  *   d  e  f  g  h                     d  g  h 
  *                           
  *   i  j  k     l                     i     l 
  *                     
  *   m                                     m         
  *                     
  *        ^---- remove from here, `at` = 1, `columns` = 2
  *
  * @param options.at The row index at which the removing columns will start.
  * @param options.columns The number of columns to remove.
  */
  removeColumns(table, options2) {
    const model = this.editor.model;
    const first2 = options2.at;
    const columnsToRemove = options2.columns || 1;
    const last = options2.at + columnsToRemove - 1;
    model.change((writer) => {
      adjustHeadingColumns(table, {
        first: first2,
        last
      }, writer);
      const tableColumns = getTableColumnElements(table);
      for (let removedColumnIndex = last; removedColumnIndex >= first2; removedColumnIndex--) {
        for (const { cell: cell2, column, cellWidth } of [
          ...new TableWalker(table)
        ]) {
          if (column <= removedColumnIndex && cellWidth > 1 && column + cellWidth > removedColumnIndex) {
            updateNumericAttribute("colspan", cellWidth - 1, cell2, writer);
          } else if (column === removedColumnIndex) {
            writer.remove(cell2);
          }
        }
        if (tableColumns[removedColumnIndex]) {
          const adjacentColumn = removedColumnIndex === 0 ? tableColumns[1] : tableColumns[removedColumnIndex - 1];
          const removedColumnWidth = parseFloat(tableColumns[removedColumnIndex].getAttribute("columnWidth"));
          const adjacentColumnWidth = parseFloat(adjacentColumn.getAttribute("columnWidth"));
          writer.remove(tableColumns[removedColumnIndex]);
          writer.setAttribute("columnWidth", removedColumnWidth + adjacentColumnWidth + "%", adjacentColumn);
        }
      }
      if (!removeEmptyRows(table, this)) {
        removeEmptyColumns(table, this);
      }
    });
  }
  /**
  * Divides a table cell vertically into several ones.
  *
  * The cell will be visually split into more cells by updating colspans of other cells in a column
  * and inserting cells (columns) after that cell.
  *
  * In the table below, if cell "a" is split into 3 cells:
  *
  *  +---+---+---+
  *  | a | b | c |
  *  +---+---+---+
  *  | d | e | f |
  *  +---+---+---+
  *
  * it will result in the table below:
  *
  *  +---+---+---+---+---+
  *  | a |   |   | b | c |
  *  +---+---+---+---+---+
  *  | d         | e | f |
  *  +---+---+---+---+---+
  *
  * So cell "d" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).
  *
  * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder
  * will be left to the original cell:
  *
  *  +---+---+---+
  *  | a         |
  *  +---+---+---+
  *  | b | c | d |
  *  +---+---+---+
  *
  * Splitting cell "a" with `colspan=3` into 2 cells will create 1 cell with a `colspan=a` and cell "a" that will have `colspan=2`:
  *
  *  +---+---+---+
  *  | a     |   |
  *  +---+---+---+
  *  | b | c | d |
  *  +---+---+---+
  */
  splitCellVertically(tableCell, numberOfCells = 2) {
    const model = this.editor.model;
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
    const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
    model.change((writer) => {
      if (colspan > 1) {
        const { newCellsSpan, updatedSpan } = breakSpanEvenly(colspan, numberOfCells);
        updateNumericAttribute("colspan", updatedSpan, tableCell, writer);
        const newCellsAttributes = {};
        if (newCellsSpan > 1) {
          newCellsAttributes.colspan = newCellsSpan;
        }
        if (rowspan > 1) {
          newCellsAttributes.rowspan = rowspan;
        }
        const cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;
        createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);
      }
      if (colspan < numberOfCells) {
        const cellsToInsert = numberOfCells - colspan;
        const tableMap = [
          ...new TableWalker(table)
        ];
        const { column: splitCellColumn } = tableMap.find(({ cell: cell2 }) => cell2 === tableCell);
        const cellsToUpdate = tableMap.filter(({ cell: cell2, cellWidth, column }) => {
          const isOnSameColumn = cell2 !== tableCell && column === splitCellColumn;
          const spansOverColumn = column < splitCellColumn && column + cellWidth > splitCellColumn;
          return isOnSameColumn || spansOverColumn;
        });
        for (const { cell: cell2, cellWidth } of cellsToUpdate) {
          writer.setAttribute("colspan", cellWidth + cellsToInsert, cell2);
        }
        const newCellsAttributes = {};
        if (rowspan > 1) {
          newCellsAttributes.rowspan = rowspan;
        }
        createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);
        const headingColumns = table.getAttribute("headingColumns") || 0;
        if (headingColumns > splitCellColumn) {
          updateNumericAttribute("headingColumns", headingColumns + cellsToInsert, table, writer);
        }
      }
    });
  }
  /**
  * Divides a table cell horizontally into several ones.
  *
  * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell
  * below.
  *
  * If in the table below cell "b" is split into 3 cells:
  *
  *  +---+---+---+
  *  | a | b | c |
  *  +---+---+---+
  *  | d | e | f |
  *  +---+---+---+
  *
  * It will result in the table below:
  *
  *  +---+---+---+
  *  | a | b | c |
  *  +   +---+   +
  *  |   |   |   |
  *  +   +---+   +
  *  |   |   |   |
  *  +---+---+---+
  *  | d | e | f |
  *  +---+---+---+
  *
  * So cells "a" and "b" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.
  *
  * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder
  * will be left to the original cell:
  *
  *  +---+---+---+
  *  | a | b | c |
  *  +   +---+---+
  *  |   | d | e |
  *  +   +---+---+
  *  |   | f | g |
  *  +   +---+---+
  *  |   | h | i |
  *  +---+---+---+
  *
  * Splitting cell "a" with `rowspan=4` into 3 cells will create 2 cells with a `rowspan=1` and cell "a" will have `rowspan=2`:
  *
  *  +---+---+---+
  *  | a | b | c |
  *  +   +---+---+
  *  |   | d | e |
  *  +---+---+---+
  *  |   | f | g |
  *  +---+---+---+
  *  |   | h | i |
  *  +---+---+---+
  */
  splitCellHorizontally(tableCell, numberOfCells = 2) {
    const model = this.editor.model;
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const splitCellRow = table.getChildIndex(tableRow);
    const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
    const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
    model.change((writer) => {
      if (rowspan > 1) {
        const tableMap = [
          ...new TableWalker(table, {
            startRow: splitCellRow,
            endRow: splitCellRow + rowspan - 1,
            includeAllSlots: true
          })
        ];
        const { newCellsSpan, updatedSpan } = breakSpanEvenly(rowspan, numberOfCells);
        updateNumericAttribute("rowspan", updatedSpan, tableCell, writer);
        const { column: cellColumn } = tableMap.find(({ cell: cell2 }) => cell2 === tableCell);
        const newCellsAttributes = {};
        if (newCellsSpan > 1) {
          newCellsAttributes.rowspan = newCellsSpan;
        }
        if (colspan > 1) {
          newCellsAttributes.colspan = colspan;
        }
        let distanceFromLastCellSpan = 0;
        for (const tableSlot of tableMap) {
          const { column, row } = tableSlot;
          const isAfterSplitCell = row >= splitCellRow + updatedSpan;
          const isOnSameColumn = column === cellColumn;
          if (distanceFromLastCellSpan >= newCellsSpan && isOnSameColumn) {
            distanceFromLastCellSpan = 0;
          }
          if (isAfterSplitCell && isOnSameColumn) {
            if (!distanceFromLastCellSpan) {
              createCells(1, writer, tableSlot.getPositionBefore(), newCellsAttributes);
            }
            distanceFromLastCellSpan++;
          }
        }
      }
      if (rowspan < numberOfCells) {
        const cellsToInsert = numberOfCells - rowspan;
        const tableMap = [
          ...new TableWalker(table, {
            startRow: 0,
            endRow: splitCellRow
          })
        ];
        for (const { cell: cell2, cellHeight, row } of tableMap) {
          if (cell2 !== tableCell && row + cellHeight > splitCellRow) {
            const rowspanToSet = cellHeight + cellsToInsert;
            writer.setAttribute("rowspan", rowspanToSet, cell2);
          }
        }
        const newCellsAttributes = {};
        if (colspan > 1) {
          newCellsAttributes.colspan = colspan;
        }
        createEmptyRows(writer, table, splitCellRow + 1, cellsToInsert, 1, newCellsAttributes);
        const headingRows = table.getAttribute("headingRows") || 0;
        if (headingRows > splitCellRow) {
          updateNumericAttribute("headingRows", headingRows + cellsToInsert, table, writer);
        }
      }
    });
  }
  /**
  * Returns the number of columns for a given table.
  *
  * ```ts
  * editor.plugins.get( 'TableUtils' ).getColumns( table );
  * ```
  *
  * @param table The table to analyze.
  */
  getColumns(table) {
    const row = table.getChild(0);
    return [
      ...row.getChildren()
    ].filter((node) => node.is("element", "tableCell")).reduce((columns, row2) => {
      const columnWidth = parseInt(row2.getAttribute("colspan") || "1");
      return columns + columnWidth;
    }, 0);
  }
  /**
  * Returns the number of rows for a given table. Any other element present in the table model is omitted.
  *
  * ```ts
  * editor.plugins.get( 'TableUtils' ).getRows( table );
  * ```
  *
  * @param table The table to analyze.
  */
  getRows(table) {
    return Array.from(table.getChildren()).reduce((rowCount, child) => child.is("element", "tableRow") ? rowCount + 1 : rowCount, 0);
  }
  /**
  * Creates an instance of the table walker.
  *
  * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
  * It walks row by row and column by column in order to output values defined in the options.
  * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
  * pass the `includeAllSlots` option.
  *
  * @internal
  * @param table A table over which the walker iterates.
  * @param options An object with configuration.
  */
  createTableWalker(table, options2 = {}) {
    return new TableWalker(table, options2);
  }
  /**
  * Returns all model table cells that are fully selected (from the outside)
  * within the provided model selection's ranges.
  *
  * To obtain the cells selected from the inside, use
  * {@link #getTableCellsContainingSelection}.
  */
  getSelectedTableCells(selection) {
    const cells = [];
    for (const range of this.sortRanges(selection.getRanges())) {
      const element = range.getContainedElement();
      if (element && element.is("element", "tableCell")) {
        cells.push(element);
      }
    }
    return cells;
  }
  /**
  * Returns all model table cells that the provided model selection's ranges
  * {@link module:engine/model/range~Range#start} inside.
  *
  * To obtain the cells selected from the outside, use
  * {@link #getSelectedTableCells}.
  */
  getTableCellsContainingSelection(selection) {
    const cells = [];
    for (const range of selection.getRanges()) {
      const cellWithSelection = range.start.findAncestor("tableCell");
      if (cellWithSelection) {
        cells.push(cellWithSelection);
      }
    }
    return cells;
  }
  /**
  * Returns all model table cells that are either completely selected
  * by selection ranges or host selection range
  * {@link module:engine/model/range~Range#start start positions} inside them.
  *
  * Combines {@link #getTableCellsContainingSelection} and
  * {@link #getSelectedTableCells}.
  */
  getSelectionAffectedTableCells(selection) {
    const selectedCells = this.getSelectedTableCells(selection);
    if (selectedCells.length) {
      return selectedCells;
    }
    return this.getTableCellsContainingSelection(selection);
  }
  /**
  * Returns an object with the `first` and `last` row index contained in the given `tableCells`.
  *
  * ```ts
  * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
  *
  * const { first, last } = getRowIndexes( selectedTableCells );
  *
  * console.log( `Selected rows: ${ first } to ${ last }` );
  * ```
  *
  * @returns Returns an object with the `first` and `last` table row indexes.
  */
  getRowIndexes(tableCells) {
    const indexes = tableCells.map((cell2) => cell2.parent.index);
    return this._getFirstLastIndexesObject(indexes);
  }
  /**
  * Returns an object with the `first` and `last` column index contained in the given `tableCells`.
  *
  * ```ts
  * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
  *
  * const { first, last } = getColumnIndexes( selectedTableCells );
  *
  * console.log( `Selected columns: ${ first } to ${ last }` );
  * ```
  *
  * @returns Returns an object with the `first` and `last` table column indexes.
  */
  getColumnIndexes(tableCells) {
    const table = tableCells[0].findAncestor("table");
    const tableMap = [
      ...new TableWalker(table)
    ];
    const indexes = tableMap.filter((entry) => tableCells.includes(entry.cell)).map((entry) => entry.column);
    return this._getFirstLastIndexesObject(indexes);
  }
  /**
  * Checks if the selection contains cells that do not exceed rectangular selection.
  *
  * In a table below:
  *
  *  
  *   a  b  c  d 
  *     
  *   e      f    
  *         
  *          g  h 
  *  
  *
  * Valid selections are these which create a solid rectangle (without gaps), such as:
  *   - a, b (two horizontal cells)
  *   - c, f (two vertical cells)
  *   - a, b, e (cell "e" spans over four cells)
  *   - c, d, f (cell d spans over a cell in the row below)
  *
  * While an invalid selection would be:
  *   - a, c (the unselected cell "b" creates a gap)
  *   - f, g, h (cell "d" spans over a cell from the row of "f" cell - thus creates a gap)
  */
  isSelectionRectangular(selectedTableCells) {
    if (selectedTableCells.length < 2 || !this._areCellInTheSameTableSection(selectedTableCells)) {
      return false;
    }
    const rows = /* @__PURE__ */ new Set();
    const columns = /* @__PURE__ */ new Set();
    let areaOfSelectedCells = 0;
    for (const tableCell of selectedTableCells) {
      const { row, column } = this.getCellLocation(tableCell);
      const rowspan = parseInt(tableCell.getAttribute("rowspan")) || 1;
      const colspan = parseInt(tableCell.getAttribute("colspan")) || 1;
      rows.add(row);
      columns.add(column);
      if (rowspan > 1) {
        rows.add(row + rowspan - 1);
      }
      if (colspan > 1) {
        columns.add(column + colspan - 1);
      }
      areaOfSelectedCells += rowspan * colspan;
    }
    const areaOfValidSelection = getBiggestRectangleArea(rows, columns);
    return areaOfValidSelection == areaOfSelectedCells;
  }
  /**
  * Returns array of sorted ranges.
  */
  sortRanges(ranges) {
    return Array.from(ranges).sort(compareRangeOrder);
  }
  /**
  * Helper method to get an object with `first` and `last` indexes from an unsorted array of indexes.
  */
  _getFirstLastIndexesObject(indexes) {
    const allIndexesSorted = indexes.sort((indexA, indexB) => indexA - indexB);
    const first2 = allIndexesSorted[0];
    const last = allIndexesSorted[allIndexesSorted.length - 1];
    return {
      first: first2,
      last
    };
  }
  /**
  * Checks if the selection does not mix a header (column or row) with other cells.
  *
  * For instance, in the table below valid selections consist of cells with the same letter only.
  * So, a-a (same heading row and column) or d-d (body cells) are valid while c-d or a-b are not.
  *
  * header columns
  *       
  *  
  *   a  a  b  b    header row
  *  
  *   c  c  d  d 
  *  
  *   c  c  d  d 
  *  
  */
  _areCellInTheSameTableSection(tableCells) {
    const table = tableCells[0].findAncestor("table");
    const rowIndexes = this.getRowIndexes(tableCells);
    const headingRows = parseInt(table.getAttribute("headingRows")) || 0;
    if (!this._areIndexesInSameSection(rowIndexes, headingRows)) {
      return false;
    }
    const columnIndexes = this.getColumnIndexes(tableCells);
    const headingColumns = parseInt(table.getAttribute("headingColumns")) || 0;
    return this._areIndexesInSameSection(columnIndexes, headingColumns);
  }
  /**
  * Unified check if table rows/columns indexes are in the same heading/body section.
  */
  _areIndexesInSameSection({ first: first2, last }, headingSectionSize) {
    const firstCellIsInHeading = first2 < headingSectionSize;
    const lastCellIsInHeading = last < headingSectionSize;
    return firstCellIsInHeading === lastCellIsInHeading;
  }
};
function createEmptyRows(writer, table, insertAt2, rows, tableCellToInsert, attributes = {}) {
  for (let i = 0; i < rows; i++) {
    const tableRow = writer.createElement("tableRow");
    writer.insert(tableRow, table, insertAt2);
    createCells(tableCellToInsert, writer, writer.createPositionAt(tableRow, "end"), attributes);
  }
}
function createCells(cells, writer, insertPosition, attributes = {}) {
  for (let i = 0; i < cells; i++) {
    createEmptyTableCell(writer, insertPosition, attributes);
  }
}
function breakSpanEvenly(span, numberOfCells) {
  if (span < numberOfCells) {
    return {
      newCellsSpan: 1,
      updatedSpan: 1
    };
  }
  const newCellsSpan = Math.floor(span / numberOfCells);
  const updatedSpan = span - newCellsSpan * numberOfCells + newCellsSpan;
  return {
    newCellsSpan,
    updatedSpan
  };
}
function adjustHeadingColumns(table, removedColumnIndexes, writer) {
  const headingColumns = table.getAttribute("headingColumns") || 0;
  if (headingColumns && removedColumnIndexes.first < headingColumns) {
    const headingsRemoved = Math.min(headingColumns - 1, removedColumnIndexes.last) - removedColumnIndexes.first + 1;
    writer.setAttribute("headingColumns", headingColumns - headingsRemoved, table);
  }
}
function updateHeadingRows(table, { first: first2, last }, writer) {
  const headingRows = table.getAttribute("headingRows") || 0;
  if (first2 < headingRows) {
    const newRows = last < headingRows ? headingRows - (last - first2 + 1) : first2;
    updateNumericAttribute("headingRows", newRows, table, writer, 0);
  }
}
function getCellsToMoveAndTrimOnRemoveRow(table, { first: first2, last }) {
  const cellsToMove = /* @__PURE__ */ new Map();
  const cellsToTrim = [];
  for (const { row, column, cellHeight, cell: cell2 } of new TableWalker(table, {
    endRow: last
  })) {
    const lastRowOfCell = row + cellHeight - 1;
    const isCellStickingOutFromRemovedRows = row >= first2 && row <= last && lastRowOfCell > last;
    if (isCellStickingOutFromRemovedRows) {
      const rowspanInRemovedSection = last - row + 1;
      const rowSpanToSet = cellHeight - rowspanInRemovedSection;
      cellsToMove.set(column, {
        cell: cell2,
        rowspan: rowSpanToSet
      });
    }
    const isCellOverlappingRemovedRows = row < first2 && lastRowOfCell >= first2;
    if (isCellOverlappingRemovedRows) {
      let rowspanAdjustment;
      if (lastRowOfCell >= last) {
        rowspanAdjustment = last - first2 + 1;
      } else {
        rowspanAdjustment = lastRowOfCell - first2 + 1;
      }
      cellsToTrim.push({
        cell: cell2,
        rowspan: cellHeight - rowspanAdjustment
      });
    }
  }
  return {
    cellsToMove,
    cellsToTrim
  };
}
function moveCellsToRow(table, targetRowIndex, cellsToMove, writer) {
  const tableWalker = new TableWalker(table, {
    includeAllSlots: true,
    row: targetRowIndex
  });
  const tableRowMap = [
    ...tableWalker
  ];
  const row = table.getChild(targetRowIndex);
  let previousCell;
  for (const { column, cell: cell2, isAnchor } of tableRowMap) {
    if (cellsToMove.has(column)) {
      const { cell: cellToMove, rowspan } = cellsToMove.get(column);
      const targetPosition = previousCell ? writer.createPositionAfter(previousCell) : writer.createPositionAt(row, 0);
      writer.move(writer.createRangeOn(cellToMove), targetPosition);
      updateNumericAttribute("rowspan", rowspan, cellToMove, writer);
      previousCell = cellToMove;
    } else if (isAnchor) {
      previousCell = cell2;
    }
  }
}
function compareRangeOrder(rangeA, rangeB) {
  const posA = rangeA.start;
  const posB = rangeB.start;
  return posA.isBefore(posB) ? -1 : 1;
}
function getBiggestRectangleArea(rows, columns) {
  const rowsIndexes = Array.from(rows.values());
  const columnIndexes = Array.from(columns.values());
  const lastRow = Math.max(...rowsIndexes);
  const firstRow = Math.min(...rowsIndexes);
  const lastColumn = Math.max(...columnIndexes);
  const firstColumn = Math.min(...columnIndexes);
  return (lastRow - firstRow + 1) * (lastColumn - firstColumn + 1);
}
var MergeCellsCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const selectedTableCells = tableUtils.getSelectedTableCells(this.editor.model.document.selection);
    this.isEnabled = tableUtils.isSelectionRectangular(selectedTableCells);
  }
  /**
  * Executes the command.
  *
  * @fires execute
  */
  execute() {
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get(TableUtils);
    model.change((writer) => {
      const selectedTableCells = tableUtils.getSelectedTableCells(model.document.selection);
      const firstTableCell = selectedTableCells.shift();
      const { mergeWidth, mergeHeight } = getMergeDimensions(firstTableCell, selectedTableCells, tableUtils);
      updateNumericAttribute("colspan", mergeWidth, firstTableCell, writer);
      updateNumericAttribute("rowspan", mergeHeight, firstTableCell, writer);
      for (const tableCell of selectedTableCells) {
        mergeTableCells(tableCell, firstTableCell, writer);
      }
      const table = firstTableCell.findAncestor("table");
      removeEmptyRowsColumns(table, tableUtils);
      writer.setSelection(firstTableCell, "in");
    });
  }
};
function mergeTableCells(cellBeingMerged, targetCell, writer) {
  if (!isEmpty$1(cellBeingMerged)) {
    if (isEmpty$1(targetCell)) {
      writer.remove(writer.createRangeIn(targetCell));
    }
    writer.move(writer.createRangeIn(cellBeingMerged), writer.createPositionAt(targetCell, "end"));
  }
  writer.remove(cellBeingMerged);
}
function isEmpty$1(tableCell) {
  const firstTableChild = tableCell.getChild(0);
  return tableCell.childCount == 1 && firstTableChild.is("element", "paragraph") && firstTableChild.isEmpty;
}
function getMergeDimensions(firstTableCell, selectedTableCells, tableUtils) {
  let maxWidthOffset = 0;
  let maxHeightOffset = 0;
  for (const tableCell of selectedTableCells) {
    const { row, column } = tableUtils.getCellLocation(tableCell);
    maxWidthOffset = getMaxOffset(tableCell, column, maxWidthOffset, "colspan");
    maxHeightOffset = getMaxOffset(tableCell, row, maxHeightOffset, "rowspan");
  }
  const { row: firstCellRow, column: firstCellColumn } = tableUtils.getCellLocation(firstTableCell);
  const mergeWidth = maxWidthOffset - firstCellColumn;
  const mergeHeight = maxHeightOffset - firstCellRow;
  return {
    mergeWidth,
    mergeHeight
  };
}
function getMaxOffset(tableCell, start, currentMaxOffset, which) {
  const dimensionValue = parseInt(tableCell.getAttribute(which) || "1");
  return Math.max(currentMaxOffset, start + dimensionValue);
}
var SelectRowCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    this.affectsData = false;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = selectedCells.length > 0;
  }
  /**
  * @inheritDoc
  */
  execute() {
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const rowIndexes = tableUtils.getRowIndexes(referenceCells);
    const table = referenceCells[0].findAncestor("table");
    const rangesToSelect = [];
    for (let rowIndex = rowIndexes.first; rowIndex <= rowIndexes.last; rowIndex++) {
      for (const cell2 of table.getChild(rowIndex).getChildren()) {
        rangesToSelect.push(model.createRangeOn(cell2));
      }
    }
    model.change((writer) => {
      writer.setSelection(rangesToSelect);
    });
  }
};
var SelectColumnCommand = class extends Command {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    this.affectsData = false;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = selectedCells.length > 0;
  }
  /**
  * @inheritDoc
  */
  execute() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const model = this.editor.model;
    const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const firstCell = referenceCells[0];
    const lastCell = referenceCells.pop();
    const table = firstCell.findAncestor("table");
    const startLocation = tableUtils.getCellLocation(firstCell);
    const endLocation = tableUtils.getCellLocation(lastCell);
    const startColumn = Math.min(startLocation.column, endLocation.column);
    const endColumn = Math.max(startLocation.column, endLocation.column);
    const rangesToSelect = [];
    for (const cellInfo of new TableWalker(table, {
      startColumn,
      endColumn
    })) {
      rangesToSelect.push(model.createRangeOn(cellInfo.cell));
    }
    model.change((writer) => {
      writer.setSelection(rangesToSelect);
    });
  }
};
function injectTableLayoutPostFixer(model) {
  model.document.registerPostFixer((writer) => tableLayoutPostFixer(writer, model));
}
function tableLayoutPostFixer(writer, model) {
  const changes = model.document.differ.getChanges();
  let wasFixed = false;
  const analyzedTables = /* @__PURE__ */ new Set();
  for (const entry of changes) {
    let table = null;
    if (entry.type == "insert" && entry.name == "table") {
      table = entry.position.nodeAfter;
    }
    if ((entry.type == "insert" || entry.type == "remove") && (entry.name == "tableRow" || entry.name == "tableCell")) {
      table = entry.position.findAncestor("table");
    }
    if (isTableAttributeEntry(entry)) {
      table = entry.range.start.findAncestor("table");
    }
    if (table && !analyzedTables.has(table)) {
      wasFixed = fixTableCellsRowspan(table, writer) || wasFixed;
      wasFixed = fixTableRowsSizes(table, writer) || wasFixed;
      analyzedTables.add(table);
    }
  }
  return wasFixed;
}
function fixTableCellsRowspan(table, writer) {
  let wasFixed = false;
  const cellsToTrim = findCellsToTrim(table);
  if (cellsToTrim.length) {
    wasFixed = true;
    for (const data of cellsToTrim) {
      updateNumericAttribute("rowspan", data.rowspan, data.cell, writer, 1);
    }
  }
  return wasFixed;
}
function fixTableRowsSizes(table, writer) {
  let wasFixed = false;
  const childrenLengths = getChildrenLengths(table);
  const rowsToRemove = [];
  for (const [rowIndex, size] of childrenLengths.entries()) {
    if (!size && table.getChild(rowIndex).is("element", "tableRow")) {
      rowsToRemove.push(rowIndex);
    }
  }
  if (rowsToRemove.length) {
    wasFixed = true;
    for (const rowIndex of rowsToRemove.reverse()) {
      writer.remove(table.getChild(rowIndex));
      childrenLengths.splice(rowIndex, 1);
    }
  }
  const rowsLengths = childrenLengths.filter((row, rowIndex) => table.getChild(rowIndex).is("element", "tableRow"));
  const tableSize = rowsLengths[0];
  const isValid = rowsLengths.every((length) => length === tableSize);
  if (!isValid) {
    const maxColumns = rowsLengths.reduce((prev, current) => current > prev ? current : prev, 0);
    for (const [rowIndex, size] of rowsLengths.entries()) {
      const columnsToInsert = maxColumns - size;
      if (columnsToInsert) {
        for (let i = 0; i < columnsToInsert; i++) {
          createEmptyTableCell(writer, writer.createPositionAt(table.getChild(rowIndex), "end"));
        }
        wasFixed = true;
      }
    }
  }
  return wasFixed;
}
function findCellsToTrim(table) {
  const headingRows = parseInt(table.getAttribute("headingRows") || "0");
  const maxRows = Array.from(table.getChildren()).reduce((count2, row) => row.is("element", "tableRow") ? count2 + 1 : count2, 0);
  const cellsToTrim = [];
  for (const { row, cell: cell2, cellHeight } of new TableWalker(table)) {
    if (cellHeight < 2) {
      continue;
    }
    const isInHeader = row < headingRows;
    const rowLimit = isInHeader ? headingRows : maxRows;
    if (row + cellHeight > rowLimit) {
      const newRowspan = rowLimit - row;
      cellsToTrim.push({
        cell: cell2,
        rowspan: newRowspan
      });
    }
  }
  return cellsToTrim;
}
function getChildrenLengths(table) {
  const lengths = new Array(table.childCount).fill(0);
  for (const { rowIndex } of new TableWalker(table, {
    includeAllSlots: true
  })) {
    lengths[rowIndex]++;
  }
  return lengths;
}
function isTableAttributeEntry(entry) {
  if (entry.type !== "attribute") {
    return false;
  }
  const key = entry.attributeKey;
  return key === "headingRows" || key === "colspan" || key === "rowspan";
}
function injectTableCellParagraphPostFixer(model) {
  model.document.registerPostFixer((writer) => tableCellContentsPostFixer(writer, model));
}
function tableCellContentsPostFixer(writer, model) {
  const changes = model.document.differ.getChanges();
  let wasFixed = false;
  for (const entry of changes) {
    if (entry.type == "insert" && entry.name == "table") {
      wasFixed = fixTable(entry.position.nodeAfter, writer) || wasFixed;
    }
    if (entry.type == "insert" && entry.name == "tableRow") {
      wasFixed = fixTableRow(entry.position.nodeAfter, writer) || wasFixed;
    }
    if (entry.type == "insert" && entry.name == "tableCell") {
      wasFixed = fixTableCellContent(entry.position.nodeAfter, writer) || wasFixed;
    }
    if ((entry.type == "remove" || entry.type == "insert") && checkTableCellChange(entry)) {
      wasFixed = fixTableCellContent(entry.position.parent, writer) || wasFixed;
    }
  }
  return wasFixed;
}
function fixTable(table, writer) {
  let wasFixed = false;
  for (const row of table.getChildren()) {
    if (row.is("element", "tableRow")) {
      wasFixed = fixTableRow(row, writer) || wasFixed;
    }
  }
  return wasFixed;
}
function fixTableRow(tableRow, writer) {
  let wasFixed = false;
  for (const tableCell of tableRow.getChildren()) {
    wasFixed = fixTableCellContent(tableCell, writer) || wasFixed;
  }
  return wasFixed;
}
function fixTableCellContent(tableCell, writer) {
  if (tableCell.childCount == 0) {
    writer.insertElement("paragraph", tableCell);
    return true;
  }
  const textNodes = Array.from(tableCell.getChildren()).filter((child) => child.is("$text"));
  for (const child of textNodes) {
    writer.wrap(writer.createRangeOn(child), "paragraph");
  }
  return !!textNodes.length;
}
function checkTableCellChange(entry) {
  if (!entry.position.parent.is("element", "tableCell")) {
    return false;
  }
  return entry.type == "insert" && entry.name == "$text" || entry.type == "remove";
}
function tableHeadingsRefreshHandler(model, editing) {
  const differ = model.document.differ;
  for (const change of differ.getChanges()) {
    let table;
    let isRowChange = false;
    if (change.type == "attribute") {
      const element = change.range.start.nodeAfter;
      if (!element || !element.is("element", "table")) {
        continue;
      }
      if (change.attributeKey != "headingRows" && change.attributeKey != "headingColumns") {
        continue;
      }
      table = element;
      isRowChange = change.attributeKey == "headingRows";
    } else if (change.name == "tableRow" || change.name == "tableCell") {
      table = change.position.findAncestor("table");
      isRowChange = change.name == "tableRow";
    }
    if (!table) {
      continue;
    }
    const headingRows = table.getAttribute("headingRows") || 0;
    const headingColumns = table.getAttribute("headingColumns") || 0;
    const tableWalker = new TableWalker(table);
    for (const tableSlot of tableWalker) {
      const isHeading = tableSlot.row < headingRows || tableSlot.column < headingColumns;
      const expectedElementName = isHeading ? "th" : "td";
      const viewElement = editing.mapper.toViewElement(tableSlot.cell);
      if (viewElement && viewElement.is("element") && viewElement.name != expectedElementName) {
        editing.reconvertItem(isRowChange ? tableSlot.cell.parent : tableSlot.cell);
      }
    }
  }
}
function tableCellRefreshHandler(model, editing) {
  const differ = model.document.differ;
  const cellsToCheck = /* @__PURE__ */ new Set();
  for (const change of differ.getChanges()) {
    const parent = change.type == "attribute" ? change.range.start.parent : change.position.parent;
    if (parent.is("element", "tableCell")) {
      cellsToCheck.add(parent);
    }
  }
  for (const tableCell of cellsToCheck.values()) {
    const paragraphsToRefresh = Array.from(tableCell.getChildren()).filter((child) => shouldRefresh(child, editing.mapper));
    for (const paragraph of paragraphsToRefresh) {
      editing.reconvertItem(paragraph);
    }
  }
}
function shouldRefresh(child, mapper) {
  if (!child.is("element", "paragraph")) {
    return false;
  }
  const viewElement = mapper.toViewElement(child);
  if (!viewElement) {
    return false;
  }
  return isSingleParagraphWithoutAttributes(child) !== viewElement.is("element", "span");
}
var TableEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * Handlers for creating additional slots in the table.
    */
    __publicField(this, "_additionalSlots");
    this._additionalSlots = [];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const schema = model.schema;
    const conversion = editor.conversion;
    const tableUtils = editor.plugins.get(TableUtils);
    schema.register("table", {
      inheritAllFrom: "$blockObject",
      allowAttributes: [
        "headingRows",
        "headingColumns"
      ]
    });
    schema.register("tableRow", {
      allowIn: "table",
      isLimit: true
    });
    schema.register("tableCell", {
      allowContentOf: "$container",
      allowIn: "tableRow",
      allowAttributes: [
        "colspan",
        "rowspan"
      ],
      isLimit: true,
      isSelectable: true
    });
    conversion.for("upcast").add(upcastTableFigure());
    conversion.for("upcast").add(upcastTable());
    conversion.for("editingDowncast").elementToStructure({
      model: {
        name: "table",
        attributes: [
          "headingRows"
        ]
      },
      view: downcastTable(tableUtils, {
        asWidget: true,
        additionalSlots: this._additionalSlots
      })
    });
    conversion.for("dataDowncast").elementToStructure({
      model: {
        name: "table",
        attributes: [
          "headingRows"
        ]
      },
      view: downcastTable(tableUtils, {
        additionalSlots: this._additionalSlots
      })
    });
    conversion.for("upcast").elementToElement({
      model: "tableRow",
      view: "tr"
    });
    conversion.for("upcast").add(skipEmptyTableRow());
    conversion.for("downcast").elementToElement({
      model: "tableRow",
      view: downcastRow()
    });
    conversion.for("upcast").elementToElement({
      model: "tableCell",
      view: "td"
    });
    conversion.for("upcast").elementToElement({
      model: "tableCell",
      view: "th"
    });
    conversion.for("upcast").add(ensureParagraphInTableCell("td"));
    conversion.for("upcast").add(ensureParagraphInTableCell("th"));
    conversion.for("editingDowncast").elementToElement({
      model: "tableCell",
      view: downcastCell({
        asWidget: true
      })
    });
    conversion.for("dataDowncast").elementToElement({
      model: "tableCell",
      view: downcastCell()
    });
    conversion.for("editingDowncast").elementToElement({
      model: "paragraph",
      view: convertParagraphInTableCell({
        asWidget: true
      }),
      converterPriority: "high"
    });
    conversion.for("dataDowncast").elementToElement({
      model: "paragraph",
      view: convertParagraphInTableCell(),
      converterPriority: "high"
    });
    conversion.for("downcast").attributeToAttribute({
      model: "colspan",
      view: "colspan"
    });
    conversion.for("upcast").attributeToAttribute({
      model: {
        key: "colspan",
        value: upcastCellSpan("colspan")
      },
      view: "colspan"
    });
    conversion.for("downcast").attributeToAttribute({
      model: "rowspan",
      view: "rowspan"
    });
    conversion.for("upcast").attributeToAttribute({
      model: {
        key: "rowspan",
        value: upcastCellSpan("rowspan")
      },
      view: "rowspan"
    });
    editor.config.define("table.defaultHeadings.rows", 0);
    editor.config.define("table.defaultHeadings.columns", 0);
    editor.commands.add("insertTable", new InsertTableCommand(editor));
    editor.commands.add("insertTableRowAbove", new InsertRowCommand(editor, {
      order: "above"
    }));
    editor.commands.add("insertTableRowBelow", new InsertRowCommand(editor, {
      order: "below"
    }));
    editor.commands.add("insertTableColumnLeft", new InsertColumnCommand(editor, {
      order: "left"
    }));
    editor.commands.add("insertTableColumnRight", new InsertColumnCommand(editor, {
      order: "right"
    }));
    editor.commands.add("removeTableRow", new RemoveRowCommand(editor));
    editor.commands.add("removeTableColumn", new RemoveColumnCommand(editor));
    editor.commands.add("splitTableCellVertically", new SplitCellCommand(editor, {
      direction: "vertically"
    }));
    editor.commands.add("splitTableCellHorizontally", new SplitCellCommand(editor, {
      direction: "horizontally"
    }));
    editor.commands.add("mergeTableCells", new MergeCellsCommand(editor));
    editor.commands.add("mergeTableCellRight", new MergeCellCommand(editor, {
      direction: "right"
    }));
    editor.commands.add("mergeTableCellLeft", new MergeCellCommand(editor, {
      direction: "left"
    }));
    editor.commands.add("mergeTableCellDown", new MergeCellCommand(editor, {
      direction: "down"
    }));
    editor.commands.add("mergeTableCellUp", new MergeCellCommand(editor, {
      direction: "up"
    }));
    editor.commands.add("setTableColumnHeader", new SetHeaderColumnCommand(editor));
    editor.commands.add("setTableRowHeader", new SetHeaderRowCommand(editor));
    editor.commands.add("selectTableRow", new SelectRowCommand(editor));
    editor.commands.add("selectTableColumn", new SelectColumnCommand(editor));
    injectTableLayoutPostFixer(model);
    injectTableCellParagraphPostFixer(model);
    this.listenTo(model.document, "change:data", () => {
      tableHeadingsRefreshHandler(model, editor.editing);
      tableCellRefreshHandler(model, editor.editing);
    });
  }
  /**
  * Registers downcast handler for the additional table slot.
  */
  registerAdditionalSlot(slotHandler) {
    this._additionalSlots.push(slotHandler);
  }
};
function upcastCellSpan(type) {
  return (cell2) => {
    const span = parseInt(cell2.getAttribute(type));
    if (Number.isNaN(span) || span <= 0) {
      return null;
    }
    return span;
  };
}
var InsertTableView = class extends View2 {
  /**
  * @inheritDoc
  */
  constructor(locale) {
    super(locale);
    /**
    * A collection of table size box items.
    */
    __publicField(this, "items");
    /**
    * Listen to `keydown` events fired in this view's main element.
    */
    __publicField(this, "keystrokes");
    /**
    * Tracks information about the DOM focus in the grid.
    */
    __publicField(this, "focusTracker");
    const bind = this.bindTemplate;
    this.items = this._createGridCollection();
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.set("rows", 0);
    this.set("columns", 0);
    this.bind("label").to(this, "columns", this, "rows", (columns, rows) => `${rows}  ${columns}`);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck"
        ]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck-insert-table-dropdown__grid"
            ]
          },
          on: {
            "mouseover@.ck-insert-table-dropdown-grid-box": bind.to("boxover")
          },
          children: this.items
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-insert-table-dropdown__label"
            ],
            "aria-hidden": true
          },
          children: [
            {
              text: bind.to("label")
            }
          ]
        }
      ],
      on: {
        mousedown: bind.to((evt) => {
          evt.preventDefault();
        }),
        click: bind.to(() => {
          this.fire("execute");
        })
      }
    });
    this.on("boxover", (evt, domEvt) => {
      const { row, column } = domEvt.target.dataset;
      this.items.get((parseInt(row, 10) - 1) * 10 + (parseInt(column, 10) - 1)).focus();
    });
    this.focusTracker.on("change:focusedElement", (evt, name, focusedElement) => {
      if (!focusedElement) {
        return;
      }
      const { row, column } = focusedElement.dataset;
      this.set({
        rows: parseInt(row),
        columns: parseInt(column)
      });
    });
    this.on("change:columns", () => this._highlightGridBoxes());
    this.on("change:rows", () => this._highlightGridBoxes());
  }
  render() {
    super.render();
    addKeyboardHandlingForGrid({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.items,
      numberOfColumns: 10,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
    for (const item of this.items) {
      this.focusTracker.add(item.element);
    }
    this.keystrokes.listenTo(this.element);
  }
  /**
  * Resets the rows and columns selection.
  */
  reset() {
    this.set({
      rows: 1,
      columns: 1
    });
  }
  /**
  * @inheritDoc
  */
  focus() {
    this.items.get(0).focus();
  }
  /**
  * @inheritDoc
  */
  focusLast() {
    this.items.get(0).focus();
  }
  /**
  * Highlights grid boxes depending on rows and columns selected.
  */
  _highlightGridBoxes() {
    const rows = this.rows;
    const columns = this.columns;
    this.items.map((boxView, index) => {
      const itemRow = Math.floor(index / 10);
      const itemColumn = index % 10;
      const isOn = itemRow < rows && itemColumn < columns;
      boxView.set("isOn", isOn);
    });
  }
  /**
  * Creates a new Button for the grid.
  *
  * @param locale The locale instance.
  * @param row Row number.
  * @param column Column number.
  * @param label The grid button label.
  */
  _createGridButton(locale, row, column, label) {
    const button = new ButtonView(locale);
    button.set({
      label,
      class: "ck-insert-table-dropdown-grid-box"
    });
    button.extendTemplate({
      attributes: {
        "data-row": row,
        "data-column": column
      }
    });
    return button;
  }
  /**
  * @returns A view collection containing boxes to be placed in a table grid.
  */
  _createGridCollection() {
    const boxes = [];
    for (let index = 0; index < 100; index++) {
      const row = Math.floor(index / 10);
      const column = index % 10;
      const label = `${row + 1}  ${column + 1}`;
      boxes.push(this._createGridButton(this.locale, row + 1, column + 1, label));
    }
    return this.createCollection(boxes);
  }
};
var tableColumnIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>';
var tableRowIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>';
var tableMergeCellIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>';
var TableUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    const contentLanguageDirection = editor.locale.contentLanguageDirection;
    const isContentLtr = contentLanguageDirection === "ltr";
    editor.ui.componentFactory.add("insertTable", (locale) => {
      const command = editor.commands.get("insertTable");
      const dropdownView = createDropdown(locale);
      dropdownView.bind("isEnabled").to(command);
      dropdownView.buttonView.set({
        icon: icons.table,
        label: t("Insert table"),
        tooltip: true
      });
      let insertTableView;
      dropdownView.on("change:isOpen", () => {
        if (insertTableView) {
          return;
        }
        insertTableView = new InsertTableView(locale);
        dropdownView.panelView.children.add(insertTableView);
        insertTableView.delegate("execute").to(dropdownView);
        dropdownView.on("execute", () => {
          editor.execute("insertTable", {
            rows: insertTableView.rows,
            columns: insertTableView.columns
          });
          editor.editing.view.focus();
        });
      });
      return dropdownView;
    });
    editor.ui.componentFactory.add("menuBar:insertTable", (locale) => {
      const command = editor.commands.get("insertTable");
      const menuView = new MenuBarMenuView(locale);
      const insertTableView = new InsertTableView(locale);
      insertTableView.delegate("execute").to(menuView);
      menuView.on("change:isOpen", (event, name, isOpen) => {
        if (!isOpen) {
          insertTableView.reset();
        }
      });
      insertTableView.on("execute", () => {
        editor.execute("insertTable", {
          rows: insertTableView.rows,
          columns: insertTableView.columns
        });
        editor.editing.view.focus();
      });
      menuView.buttonView.set({
        label: t("Table"),
        icon: icons.table
      });
      menuView.panelView.children.add(insertTableView);
      menuView.bind("isEnabled").to(command);
      return menuView;
    });
    editor.ui.componentFactory.add("tableColumn", (locale) => {
      const options2 = [
        {
          type: "switchbutton",
          model: {
            commandName: "setTableColumnHeader",
            label: t("Header column"),
            bindIsOn: true
          }
        },
        {
          type: "separator"
        },
        {
          type: "button",
          model: {
            commandName: isContentLtr ? "insertTableColumnLeft" : "insertTableColumnRight",
            label: t("Insert column left")
          }
        },
        {
          type: "button",
          model: {
            commandName: isContentLtr ? "insertTableColumnRight" : "insertTableColumnLeft",
            label: t("Insert column right")
          }
        },
        {
          type: "button",
          model: {
            commandName: "removeTableColumn",
            label: t("Delete column")
          }
        },
        {
          type: "button",
          model: {
            commandName: "selectTableColumn",
            label: t("Select column")
          }
        }
      ];
      return this._prepareDropdown(t("Column"), tableColumnIcon, options2, locale);
    });
    editor.ui.componentFactory.add("tableRow", (locale) => {
      const options2 = [
        {
          type: "switchbutton",
          model: {
            commandName: "setTableRowHeader",
            label: t("Header row"),
            bindIsOn: true
          }
        },
        {
          type: "separator"
        },
        {
          type: "button",
          model: {
            commandName: "insertTableRowAbove",
            label: t("Insert row above")
          }
        },
        {
          type: "button",
          model: {
            commandName: "insertTableRowBelow",
            label: t("Insert row below")
          }
        },
        {
          type: "button",
          model: {
            commandName: "removeTableRow",
            label: t("Delete row")
          }
        },
        {
          type: "button",
          model: {
            commandName: "selectTableRow",
            label: t("Select row")
          }
        }
      ];
      return this._prepareDropdown(t("Row"), tableRowIcon, options2, locale);
    });
    editor.ui.componentFactory.add("mergeTableCells", (locale) => {
      const options2 = [
        {
          type: "button",
          model: {
            commandName: "mergeTableCellUp",
            label: t("Merge cell up")
          }
        },
        {
          type: "button",
          model: {
            commandName: isContentLtr ? "mergeTableCellRight" : "mergeTableCellLeft",
            label: t("Merge cell right")
          }
        },
        {
          type: "button",
          model: {
            commandName: "mergeTableCellDown",
            label: t("Merge cell down")
          }
        },
        {
          type: "button",
          model: {
            commandName: isContentLtr ? "mergeTableCellLeft" : "mergeTableCellRight",
            label: t("Merge cell left")
          }
        },
        {
          type: "separator"
        },
        {
          type: "button",
          model: {
            commandName: "splitTableCellVertically",
            label: t("Split cell vertically")
          }
        },
        {
          type: "button",
          model: {
            commandName: "splitTableCellHorizontally",
            label: t("Split cell horizontally")
          }
        }
      ];
      return this._prepareMergeSplitButtonDropdown(t("Merge cells"), tableMergeCellIcon, options2, locale);
    });
  }
  /**
  * Creates a dropdown view from a set of options.
  *
  * @param label The dropdown button label.
  * @param icon An icon for the dropdown button.
  * @param options The list of options for the dropdown.
  */
  _prepareDropdown(label, icon, options2, locale) {
    const editor = this.editor;
    const dropdownView = createDropdown(locale);
    const commands = this._fillDropdownWithListOptions(dropdownView, options2);
    dropdownView.buttonView.set({
      label,
      icon,
      tooltip: true
    });
    dropdownView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
      return areEnabled.some((isEnabled) => isEnabled);
    });
    this.listenTo(dropdownView, "execute", (evt) => {
      editor.execute(evt.source.commandName);
      if (!(evt.source instanceof SwitchButtonView)) {
        editor.editing.view.focus();
      }
    });
    return dropdownView;
  }
  /**
  * Creates a dropdown view with a {@link module:ui/dropdown/button/splitbuttonview~SplitButtonView} for
  * merge (and split)related commands.
  *
  * @param label The dropdown button label.
  * @param icon An icon for the dropdown button.
  * @param options The list of options for the dropdown.
  */
  _prepareMergeSplitButtonDropdown(label, icon, options2, locale) {
    const editor = this.editor;
    const dropdownView = createDropdown(locale, SplitButtonView);
    const mergeCommandName = "mergeTableCells";
    const mergeCommand = editor.commands.get(mergeCommandName);
    const commands = this._fillDropdownWithListOptions(dropdownView, options2);
    dropdownView.buttonView.set({
      label,
      icon,
      tooltip: true,
      isEnabled: true
    });
    dropdownView.bind("isEnabled").toMany([
      mergeCommand,
      ...commands
    ], "isEnabled", (...areEnabled) => {
      return areEnabled.some((isEnabled) => isEnabled);
    });
    this.listenTo(dropdownView.buttonView, "execute", () => {
      editor.execute(mergeCommandName);
      editor.editing.view.focus();
    });
    this.listenTo(dropdownView, "execute", (evt) => {
      editor.execute(evt.source.commandName);
      editor.editing.view.focus();
    });
    return dropdownView;
  }
  /**
  * Injects a {@link module:ui/list/listview~ListView} into the passed dropdown with buttons
  * which execute editor commands as configured in passed options.
  *
  * @param options The list of options for the dropdown.
  * @returns Commands the list options are interacting with.
  */
  _fillDropdownWithListOptions(dropdownView, options2) {
    const editor = this.editor;
    const commands = [];
    const itemDefinitions = new Collection();
    for (const option of options2) {
      addListOption(option, editor, commands, itemDefinitions);
    }
    addListToDropdown(dropdownView, itemDefinitions);
    return commands;
  }
};
function addListOption(option, editor, commands, itemDefinitions) {
  if (option.type === "button" || option.type === "switchbutton") {
    const model = option.model = new Model2(option.model);
    const { commandName, bindIsOn } = option.model;
    const command = editor.commands.get(commandName);
    commands.push(command);
    model.set({
      commandName
    });
    model.bind("isEnabled").to(command);
    if (bindIsOn) {
      model.bind("isOn").to(command, "value");
    }
    model.set({
      withText: true
    });
  }
  itemDefinitions.add(option);
}
var TableSelection = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableSelection";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableUtils,
      TableUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    this.listenTo(model, "deleteContent", (evt, args) => this._handleDeleteContent(evt, args), {
      priority: "high"
    });
    this.listenTo(view.document, "insertText", (evt, data) => this._handleInsertTextEvent(evt, data), {
      priority: "high"
    });
    this._defineSelectionConverter();
    this._enablePluginDisabling();
  }
  /**
  * Returns the currently selected table cells or `null` if it is not a table cells selection.
  */
  getSelectedTableCells() {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const selection = this.editor.model.document.selection;
    const selectedCells = tableUtils.getSelectedTableCells(selection);
    if (selectedCells.length == 0) {
      return null;
    }
    return selectedCells;
  }
  /**
  * Returns the selected table fragment as a document fragment.
  */
  getSelectionAsFragment() {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const selectedCells = this.getSelectedTableCells();
    if (!selectedCells) {
      return null;
    }
    return this.editor.model.change((writer) => {
      const documentFragment = writer.createDocumentFragment();
      const { first: firstColumn, last: lastColumn } = tableUtils.getColumnIndexes(selectedCells);
      const { first: firstRow, last: lastRow } = tableUtils.getRowIndexes(selectedCells);
      const sourceTable = selectedCells[0].findAncestor("table");
      let adjustedLastRow = lastRow;
      let adjustedLastColumn = lastColumn;
      if (tableUtils.isSelectionRectangular(selectedCells)) {
        const dimensions = {
          firstColumn,
          lastColumn,
          firstRow,
          lastRow
        };
        adjustedLastRow = adjustLastRowIndex(sourceTable, dimensions);
        adjustedLastColumn = adjustLastColumnIndex(sourceTable, dimensions);
      }
      const cropDimensions = {
        startRow: firstRow,
        startColumn: firstColumn,
        endRow: adjustedLastRow,
        endColumn: adjustedLastColumn
      };
      const table = cropTableToDimensions(sourceTable, cropDimensions, writer);
      writer.insert(table, documentFragment, 0);
      return documentFragment;
    });
  }
  /**
  * Sets the model selection based on given anchor and target cells (can be the same cell).
  * Takes care of setting the backward flag.
  *
  * ```ts
  * const modelRoot = editor.model.document.getRoot();
  * const firstCell = modelRoot.getNodeByPath( [ 0, 0, 0 ] );
  * const lastCell = modelRoot.getNodeByPath( [ 0, 0, 1 ] );
  *
  * const tableSelection = editor.plugins.get( 'TableSelection' );
  * tableSelection.setCellSelection( firstCell, lastCell );
  * ```
  */
  setCellSelection(anchorCell, targetCell) {
    const cellsToSelect = this._getCellsToSelect(anchorCell, targetCell);
    this.editor.model.change((writer) => {
      writer.setSelection(cellsToSelect.cells.map((cell2) => writer.createRangeOn(cell2)), {
        backward: cellsToSelect.backward
      });
    });
  }
  /**
  * Returns the focus cell from the current selection.
  */
  getFocusCell() {
    const selection = this.editor.model.document.selection;
    const focusCellRange = [
      ...selection.getRanges()
    ].pop();
    const element = focusCellRange.getContainedElement();
    if (element && element.is("element", "tableCell")) {
      return element;
    }
    return null;
  }
  /**
  * Returns the anchor cell from the current selection.
  */
  getAnchorCell() {
    const selection = this.editor.model.document.selection;
    const anchorCellRange = first(selection.getRanges());
    const element = anchorCellRange.getContainedElement();
    if (element && element.is("element", "tableCell")) {
      return element;
    }
    return null;
  }
  /**
  * Defines a selection converter which marks the selected cells with a specific class.
  *
  * The real DOM selection is put in the last cell. Since the order of ranges is dependent on whether the
  * selection is backward or not, the last cell will usually be close to the "focus" end of the selection
  * (a selection has anchor and focus).
  *
  * The real DOM selection is then hidden with CSS.
  */
  _defineSelectionConverter() {
    const editor = this.editor;
    const highlighted = /* @__PURE__ */ new Set();
    editor.conversion.for("editingDowncast").add((dispatcher) => dispatcher.on("selection", (evt, data, conversionApi) => {
      const viewWriter = conversionApi.writer;
      clearHighlightedTableCells(viewWriter);
      const selectedCells = this.getSelectedTableCells();
      if (!selectedCells) {
        return;
      }
      for (const tableCell of selectedCells) {
        const viewElement = conversionApi.mapper.toViewElement(tableCell);
        viewWriter.addClass("ck-editor__editable_selected", viewElement);
        highlighted.add(viewElement);
      }
      const lastViewCell = conversionApi.mapper.toViewElement(selectedCells[selectedCells.length - 1]);
      viewWriter.setSelection(lastViewCell, 0);
    }, {
      priority: "lowest"
    }));
    function clearHighlightedTableCells(viewWriter) {
      for (const previouslyHighlighted of highlighted) {
        viewWriter.removeClass("ck-editor__editable_selected", previouslyHighlighted);
      }
      highlighted.clear();
    }
  }
  /**
  * Creates a listener that reacts to changes in {@link #isEnabled} and, if the plugin was disabled,
  * it collapses the multi-cell selection to a regular selection placed inside a table cell.
  *
  * This listener helps features that disable the table selection plugin bring the selection
  * to a clear state they can work with (for instance, because they don't support multiple cell selection).
  */
  _enablePluginDisabling() {
    const editor = this.editor;
    this.on("change:isEnabled", () => {
      if (!this.isEnabled) {
        const selectedCells = this.getSelectedTableCells();
        if (!selectedCells) {
          return;
        }
        editor.model.change((writer) => {
          const position = writer.createPositionAt(selectedCells[0], 0);
          const range = editor.model.schema.getNearestSelectionRange(position);
          writer.setSelection(range);
        });
      }
    });
  }
  /**
  * Overrides the default `model.deleteContent()` behavior over a selected table fragment.
  *
  * @param args Delete content method arguments.
  */
  _handleDeleteContent(event, args) {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const selection = args[0];
    const options2 = args[1];
    const model = this.editor.model;
    const isBackward = !options2 || options2.direction == "backward";
    const selectedTableCells = tableUtils.getSelectedTableCells(selection);
    if (!selectedTableCells.length) {
      return;
    }
    event.stop();
    model.change((writer) => {
      const tableCellToSelect = selectedTableCells[isBackward ? selectedTableCells.length - 1 : 0];
      model.change((writer2) => {
        for (const tableCell of selectedTableCells) {
          model.deleteContent(writer2.createSelection(tableCell, "in"));
        }
      });
      const rangeToSelect = model.schema.getNearestSelectionRange(writer.createPositionAt(tableCellToSelect, 0));
      if (selection.is("documentSelection")) {
        writer.setSelection(rangeToSelect);
      } else {
        selection.setTo(rangeToSelect);
      }
    });
  }
  /**
  * This handler makes it possible to remove the content of all selected cells by starting to type.
  * If you take a look at {@link #_defineSelectionConverter} you will find out that despite the multi-cell selection being set
  * in the model, the view selection is collapsed in the last cell (because most browsers are unable to render multi-cell selections;
  * yes, it's a hack).
  *
  * When multiple cells are selected in the model and the user starts to type, the
  * {@link module:engine/view/document~Document#event:insertText} event carries information provided by the
  * beforeinput DOM  event, that in turn only knows about this collapsed DOM selection in the last cell.
  *
  * As a result, the selected cells have no chance to be cleaned up. To fix this, this listener intercepts
  * the event and injects the custom view selection in the data that translates correctly to the actual state
  * of the multi-cell selection in the model.
  *
  * @param data Insert text event data.
  */
  _handleInsertTextEvent(evt, data) {
    const editor = this.editor;
    const selectedCells = this.getSelectedTableCells();
    if (!selectedCells) {
      return;
    }
    const view = editor.editing.view;
    const mapper = editor.editing.mapper;
    const viewRanges = selectedCells.map((tableCell) => view.createRangeOn(mapper.toViewElement(tableCell)));
    data.selection = view.createSelection(viewRanges);
  }
  /**
  * Returns an array of table cells that should be selected based on the
  * given anchor cell and target (focus) cell.
  *
  * The cells are returned in a reverse direction if the selection is backward.
  */
  _getCellsToSelect(anchorCell, targetCell) {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const startLocation = tableUtils.getCellLocation(anchorCell);
    const endLocation = tableUtils.getCellLocation(targetCell);
    const startRow = Math.min(startLocation.row, endLocation.row);
    const endRow = Math.max(startLocation.row, endLocation.row);
    const startColumn = Math.min(startLocation.column, endLocation.column);
    const endColumn = Math.max(startLocation.column, endLocation.column);
    const selectionMap = new Array(endRow - startRow + 1).fill(null).map(() => []);
    const walkerOptions = {
      startRow,
      endRow,
      startColumn,
      endColumn
    };
    for (const { row, cell: cell2 } of new TableWalker(anchorCell.findAncestor("table"), walkerOptions)) {
      selectionMap[row - startRow].push(cell2);
    }
    const flipVertically = endLocation.row < startLocation.row;
    const flipHorizontally = endLocation.column < startLocation.column;
    if (flipVertically) {
      selectionMap.reverse();
    }
    if (flipHorizontally) {
      selectionMap.forEach((row) => row.reverse());
    }
    return {
      cells: selectionMap.flat(),
      backward: flipVertically || flipHorizontally
    };
  }
};
var TableClipboard = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableClipboard";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ClipboardMarkersUtils,
      ClipboardPipeline,
      TableSelection,
      TableUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this.listenTo(viewDocument, "copy", (evt, data) => this._onCopyCut(evt, data));
    this.listenTo(viewDocument, "cut", (evt, data) => this._onCopyCut(evt, data));
    this.listenTo(editor.model, "insertContent", (evt, [content, selectable]) => this._onInsertContent(evt, content, selectable), {
      priority: "high"
    });
    this.decorate("_replaceTableSlotCell");
  }
  /**
  * Copies table content to a clipboard on "copy" & "cut" events.
  *
  * @param evt An object containing information about the handled event.
  * @param data Clipboard event data.
  */
  _onCopyCut(evt, data) {
    const view = this.editor.editing.view;
    const tableSelection = this.editor.plugins.get(TableSelection);
    const clipboardMarkersUtils = this.editor.plugins.get(ClipboardMarkersUtils);
    if (!tableSelection.getSelectedTableCells()) {
      return;
    }
    if (evt.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection)) {
      return;
    }
    data.preventDefault();
    evt.stop();
    this.editor.model.enqueueChange({
      isUndoable: evt.name === "cut"
    }, () => {
      const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(evt.name, this.editor.model.document.selection, () => tableSelection.getSelectionAsFragment());
      view.document.fire("clipboardOutput", {
        dataTransfer: data.dataTransfer,
        content: this.editor.data.toView(documentFragment),
        method: evt.name
      });
    });
  }
  /**
  * Overrides default {@link module:engine/model/model~Model#insertContent `model.insertContent()`} method to handle pasting table inside
  * selected table fragment.
  *
  * Depending on selected table fragment:
  * - If a selected table fragment is smaller than paste table it will crop pasted table to match dimensions.
  * - If dimensions are equal it will replace selected table fragment with a pasted table contents.
  *
  * @param content The content to insert.
  * @param selectable The selection into which the content should be inserted.
  * If not provided the current model document selection will be used.
  */
  _onInsertContent(evt, content, selectable) {
    if (selectable && !selectable.is("documentSelection")) {
      return;
    }
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get(TableUtils);
    const clipboardMarkersUtils = this.editor.plugins.get(ClipboardMarkersUtils);
    const pastedTable = this.getTableIfOnlyTableInContent(content, model);
    if (!pastedTable) {
      return;
    }
    const selectedTableCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    if (!selectedTableCells.length) {
      removeEmptyRowsColumns(pastedTable, tableUtils);
      return;
    }
    evt.stop();
    if (content.is("documentFragment")) {
      clipboardMarkersUtils._pasteMarkersIntoTransformedElement(content.markers, (writer) => this._replaceSelectedCells(pastedTable, selectedTableCells, writer));
    } else {
      this.editor.model.change((writer) => {
        this._replaceSelectedCells(pastedTable, selectedTableCells, writer);
      });
    }
  }
  /**
  * Inserts provided `selectedTableCells` into `pastedTable`.
  */
  _replaceSelectedCells(pastedTable, selectedTableCells, writer) {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const pastedDimensions = {
      width: tableUtils.getColumns(pastedTable),
      height: tableUtils.getRows(pastedTable)
    };
    const selection = prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils);
    const selectionHeight = selection.lastRow - selection.firstRow + 1;
    const selectionWidth = selection.lastColumn - selection.firstColumn + 1;
    const cropDimensions = {
      startRow: 0,
      startColumn: 0,
      endRow: Math.min(selectionHeight, pastedDimensions.height) - 1,
      endColumn: Math.min(selectionWidth, pastedDimensions.width) - 1
    };
    pastedTable = cropTableToDimensions(pastedTable, cropDimensions, writer);
    const selectedTable = selectedTableCells[0].findAncestor("table");
    const cellsToSelect = this._replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer);
    if (this.editor.plugins.get("TableSelection").isEnabled) {
      const selectionRanges = tableUtils.sortRanges(cellsToSelect.map((cell2) => writer.createRangeOn(cell2)));
      writer.setSelection(selectionRanges);
    } else {
      writer.setSelection(cellsToSelect[0], 0);
    }
    return selectedTable;
  }
  /**
  * Replaces the part of selectedTable with pastedTable.
  */
  _replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer) {
    const { width: pastedWidth, height: pastedHeight } = pastedDimensions;
    const pastedTableLocationMap = createLocationMap(pastedTable, pastedWidth, pastedHeight);
    const selectedTableMap = [
      ...new TableWalker(selectedTable, {
        startRow: selection.firstRow,
        endRow: selection.lastRow,
        startColumn: selection.firstColumn,
        endColumn: selection.lastColumn,
        includeAllSlots: true
      })
    ];
    const cellsToSelect = [];
    let insertPosition;
    for (const tableSlot of selectedTableMap) {
      const { row, column } = tableSlot;
      if (column === selection.firstColumn) {
        insertPosition = tableSlot.getPositionBefore();
      }
      const pastedRow = row - selection.firstRow;
      const pastedColumn = column - selection.firstColumn;
      const pastedCell = pastedTableLocationMap[pastedRow % pastedHeight][pastedColumn % pastedWidth];
      const cellToInsert = pastedCell ? writer.cloneElement(pastedCell) : null;
      const newTableCell = this._replaceTableSlotCell(tableSlot, cellToInsert, insertPosition, writer);
      if (!newTableCell) {
        continue;
      }
      trimTableCellIfNeeded(newTableCell, row, column, selection.lastRow, selection.lastColumn, writer);
      cellsToSelect.push(newTableCell);
      insertPosition = writer.createPositionAfter(newTableCell);
    }
    const headingRows = parseInt(selectedTable.getAttribute("headingRows") || "0");
    const headingColumns = parseInt(selectedTable.getAttribute("headingColumns") || "0");
    const areHeadingRowsIntersectingSelection = selection.firstRow < headingRows && headingRows <= selection.lastRow;
    const areHeadingColumnsIntersectingSelection = selection.firstColumn < headingColumns && headingColumns <= selection.lastColumn;
    if (areHeadingRowsIntersectingSelection) {
      const columnsLimit = {
        first: selection.firstColumn,
        last: selection.lastColumn
      };
      const newCells = doHorizontalSplit(selectedTable, headingRows, columnsLimit, writer, selection.firstRow);
      cellsToSelect.push(...newCells);
    }
    if (areHeadingColumnsIntersectingSelection) {
      const rowsLimit = {
        first: selection.firstRow,
        last: selection.lastRow
      };
      const newCells = doVerticalSplit(selectedTable, headingColumns, rowsLimit, writer);
      cellsToSelect.push(...newCells);
    }
    return cellsToSelect;
  }
  /**
  * Replaces a single table slot.
  *
  * @returns Inserted table cell or null if slot should remain empty.
  * @private
  */
  _replaceTableSlotCell(tableSlot, cellToInsert, insertPosition, writer) {
    const { cell: cell2, isAnchor } = tableSlot;
    if (isAnchor) {
      writer.remove(cell2);
    }
    if (!cellToInsert) {
      return null;
    }
    writer.insert(cellToInsert, insertPosition);
    return cellToInsert;
  }
  /**
  * Extracts the table for pasting into a table.
  *
  * @param content The content to insert.
  * @param model The editor model.
  */
  getTableIfOnlyTableInContent(content, model) {
    if (!content.is("documentFragment") && !content.is("element")) {
      return null;
    }
    if (content.is("element", "table")) {
      return content;
    }
    if (content.childCount == 1 && content.getChild(0).is("element", "table")) {
      return content.getChild(0);
    }
    const contentRange = model.createRangeIn(content);
    for (const element of contentRange.getItems()) {
      if (element.is("element", "table")) {
        const rangeBefore = model.createRange(contentRange.start, model.createPositionBefore(element));
        if (model.hasContent(rangeBefore, {
          ignoreWhitespaces: true
        })) {
          return null;
        }
        const rangeAfter = model.createRange(model.createPositionAfter(element), contentRange.end);
        if (model.hasContent(rangeAfter, {
          ignoreWhitespaces: true
        })) {
          return null;
        }
        return element;
      }
    }
    return null;
  }
};
function prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils) {
  const selectedTable = selectedTableCells[0].findAncestor("table");
  const columnIndexes = tableUtils.getColumnIndexes(selectedTableCells);
  const rowIndexes = tableUtils.getRowIndexes(selectedTableCells);
  const selection = {
    firstColumn: columnIndexes.first,
    lastColumn: columnIndexes.last,
    firstRow: rowIndexes.first,
    lastRow: rowIndexes.last
  };
  const shouldExpandSelection = selectedTableCells.length === 1;
  if (shouldExpandSelection) {
    selection.lastRow += pastedDimensions.height - 1;
    selection.lastColumn += pastedDimensions.width - 1;
    expandTableSize(selectedTable, selection.lastRow + 1, selection.lastColumn + 1, tableUtils);
  }
  if (shouldExpandSelection || !tableUtils.isSelectionRectangular(selectedTableCells)) {
    splitCellsToRectangularSelection(selectedTable, selection, writer);
  } else {
    selection.lastRow = adjustLastRowIndex(selectedTable, selection);
    selection.lastColumn = adjustLastColumnIndex(selectedTable, selection);
  }
  return selection;
}
function expandTableSize(table, expectedHeight, expectedWidth, tableUtils) {
  const tableWidth = tableUtils.getColumns(table);
  const tableHeight = tableUtils.getRows(table);
  if (expectedWidth > tableWidth) {
    tableUtils.insertColumns(table, {
      at: tableWidth,
      columns: expectedWidth - tableWidth
    });
  }
  if (expectedHeight > tableHeight) {
    tableUtils.insertRows(table, {
      at: tableHeight,
      rows: expectedHeight - tableHeight
    });
  }
}
function createLocationMap(table, width, height) {
  const map = new Array(height).fill(null).map(() => new Array(width).fill(null));
  for (const { column, row, cell: cell2 } of new TableWalker(table)) {
    map[row][column] = cell2;
  }
  return map;
}
function splitCellsToRectangularSelection(table, dimensions, writer) {
  const { firstRow, lastRow, firstColumn, lastColumn } = dimensions;
  const rowIndexes = {
    first: firstRow,
    last: lastRow
  };
  const columnIndexes = {
    first: firstColumn,
    last: lastColumn
  };
  doVerticalSplit(table, firstColumn, rowIndexes, writer);
  doVerticalSplit(table, lastColumn + 1, rowIndexes, writer);
  doHorizontalSplit(table, firstRow, columnIndexes, writer);
  doHorizontalSplit(table, lastRow + 1, columnIndexes, writer, firstRow);
}
function doHorizontalSplit(table, splitRow, limitColumns, writer, startRow = 0) {
  if (splitRow < 1) {
    return;
  }
  const overlappingCells = getVerticallyOverlappingCells(table, splitRow, startRow);
  const cellsToSplit = overlappingCells.filter(({ column, cellWidth }) => isAffectedBySelection(column, cellWidth, limitColumns));
  return cellsToSplit.map(({ cell: cell2 }) => splitHorizontally(cell2, splitRow, writer));
}
function doVerticalSplit(table, splitColumn, limitRows, writer) {
  if (splitColumn < 1) {
    return;
  }
  const overlappingCells = getHorizontallyOverlappingCells(table, splitColumn);
  const cellsToSplit = overlappingCells.filter(({ row, cellHeight }) => isAffectedBySelection(row, cellHeight, limitRows));
  return cellsToSplit.map(({ cell: cell2, column }) => splitVertically(cell2, column, splitColumn, writer));
}
function isAffectedBySelection(index, span, limit) {
  const endIndex = index + span - 1;
  const { first: first2, last } = limit;
  const isInsideSelection = index >= first2 && index <= last;
  const overlapsSelectionFromOutside = index < first2 && endIndex >= first2;
  return isInsideSelection || overlapsSelectionFromOutside;
}
var TableKeyboard = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableKeyboard";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableSelection,
      TableUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const t = editor.t;
    this.listenTo(viewDocument, "arrowKey", (...args) => this._onArrowKey(...args), {
      context: "table"
    });
    this.listenTo(viewDocument, "tab", (...args) => this._handleTabOnSelectedTable(...args), {
      context: "figure"
    });
    this.listenTo(viewDocument, "tab", (...args) => this._handleTab(...args), {
      context: [
        "th",
        "td"
      ]
    });
    editor.accessibility.addKeystrokeInfoGroup({
      id: "table",
      label: t("Keystrokes that can be used in a table cell"),
      keystrokes: [
        {
          label: t("Move the selection to the next cell"),
          keystroke: "Tab"
        },
        {
          label: t("Move the selection to the previous cell"),
          keystroke: "Shift+Tab"
        },
        {
          label: t("Insert a new table row (when in the last cell of a table)"),
          keystroke: "Tab"
        },
        {
          label: t("Navigate through the table"),
          keystroke: [
            [
              "arrowup"
            ],
            [
              "arrowright"
            ],
            [
              "arrowdown"
            ],
            [
              "arrowleft"
            ]
          ]
        }
      ]
    });
  }
  /**
  * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
  * when the table widget is selected.
  */
  _handleTabOnSelectedTable(bubblingEventInfo, domEventData) {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (!selectedElement || !selectedElement.is("element", "table")) {
      return;
    }
    domEventData.preventDefault();
    domEventData.stopPropagation();
    bubblingEventInfo.stop();
    editor.model.change((writer) => {
      writer.setSelection(writer.createRangeIn(selectedElement.getChild(0).getChild(0)));
    });
  }
  /**
  * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
  * inside table cells.
  */
  _handleTab(bubblingEventInfo, domEventData) {
    const editor = this.editor;
    const tableUtils = this.editor.plugins.get(TableUtils);
    const tableSelection = this.editor.plugins.get("TableSelection");
    const selection = editor.model.document.selection;
    const isForward = !domEventData.shiftKey;
    let tableCell = tableUtils.getTableCellsContainingSelection(selection)[0];
    if (!tableCell) {
      tableCell = tableSelection.getFocusCell();
    }
    if (!tableCell) {
      return;
    }
    domEventData.preventDefault();
    domEventData.stopPropagation();
    bubblingEventInfo.stop();
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const currentRowIndex = table.getChildIndex(tableRow);
    const currentCellIndex = tableRow.getChildIndex(tableCell);
    const isFirstCellInRow = currentCellIndex === 0;
    if (!isForward && isFirstCellInRow && currentRowIndex === 0) {
      editor.model.change((writer) => {
        writer.setSelection(writer.createRangeOn(table));
      });
      return;
    }
    const isLastCellInRow = currentCellIndex === tableRow.childCount - 1;
    const isLastRow = currentRowIndex === tableUtils.getRows(table) - 1;
    if (isForward && isLastRow && isLastCellInRow) {
      editor.execute("insertTableRowBelow");
      if (currentRowIndex === tableUtils.getRows(table) - 1) {
        editor.model.change((writer) => {
          writer.setSelection(writer.createRangeOn(table));
        });
        return;
      }
    }
    let cellToFocus;
    if (isForward && isLastCellInRow) {
      const nextRow = table.getChild(currentRowIndex + 1);
      cellToFocus = nextRow.getChild(0);
    } else if (!isForward && isFirstCellInRow) {
      const previousRow = table.getChild(currentRowIndex - 1);
      cellToFocus = previousRow.getChild(previousRow.childCount - 1);
    } else {
      cellToFocus = tableRow.getChild(currentCellIndex + (isForward ? 1 : -1));
    }
    editor.model.change((writer) => {
      writer.setSelection(writer.createRangeIn(cellToFocus));
    });
  }
  /**
  * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.
  */
  _onArrowKey(eventInfo, domEventData) {
    const editor = this.editor;
    const keyCode = domEventData.keyCode;
    const direction = getLocalizedArrowKeyCodeDirection(keyCode, editor.locale.contentLanguageDirection);
    const wasHandled = this._handleArrowKeys(direction, domEventData.shiftKey);
    if (wasHandled) {
      domEventData.preventDefault();
      domEventData.stopPropagation();
      eventInfo.stop();
    }
  }
  /**
  * Handles arrow keys to move the selection around the table.
  *
  * @param direction The direction of the arrow key.
  * @param expandSelection If the current selection should be expanded.
  * @returns Returns `true` if key was handled.
  */
  _handleArrowKeys(direction, expandSelection) {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const tableSelection = this.editor.plugins.get("TableSelection");
    const model = this.editor.model;
    const selection = model.document.selection;
    const isForward = [
      "right",
      "down"
    ].includes(direction);
    const selectedCells = tableUtils.getSelectedTableCells(selection);
    if (selectedCells.length) {
      let focusCell;
      if (expandSelection) {
        focusCell = tableSelection.getFocusCell();
      } else {
        focusCell = isForward ? selectedCells[selectedCells.length - 1] : selectedCells[0];
      }
      this._navigateFromCellInDirection(focusCell, direction, expandSelection);
      return true;
    }
    const tableCell = selection.focus.findAncestor("tableCell");
    if (!tableCell) {
      return false;
    }
    if (!selection.isCollapsed) {
      if (expandSelection) {
        if (selection.isBackward == isForward && !selection.containsEntireContent(tableCell)) {
          return false;
        }
      } else {
        const selectedElement = selection.getSelectedElement();
        if (!selectedElement || !model.schema.isObject(selectedElement)) {
          return false;
        }
      }
    }
    if (this._isSelectionAtCellEdge(selection, tableCell, isForward)) {
      this._navigateFromCellInDirection(tableCell, direction, expandSelection);
      return true;
    }
    return false;
  }
  /**
  * Returns `true` if the selection is at the boundary of a table cell according to the navigation direction.
  *
  * @param selection The current selection.
  * @param tableCell The current table cell element.
  * @param isForward The expected navigation direction.
  */
  _isSelectionAtCellEdge(selection, tableCell, isForward) {
    const model = this.editor.model;
    const schema = this.editor.model.schema;
    const focus = isForward ? selection.getLastPosition() : selection.getFirstPosition();
    if (!schema.getLimitElement(focus).is("element", "tableCell")) {
      const boundaryPosition = model.createPositionAt(tableCell, isForward ? "end" : 0);
      return boundaryPosition.isTouching(focus);
    }
    const probe = model.createSelection(focus);
    model.modifySelection(probe, {
      direction: isForward ? "forward" : "backward"
    });
    return focus.isEqual(probe.focus);
  }
  /**
  * Moves the selection from the given table cell in the specified direction.
  *
  * @param focusCell The table cell that is current multi-cell selection focus.
  * @param direction Direction in which selection should move.
  * @param expandSelection If the current selection should be expanded. Default value is false.
  */
  _navigateFromCellInDirection(focusCell, direction, expandSelection = false) {
    const model = this.editor.model;
    const table = focusCell.findAncestor("table");
    const tableMap = [
      ...new TableWalker(table, {
        includeAllSlots: true
      })
    ];
    const { row: lastRow, column: lastColumn } = tableMap[tableMap.length - 1];
    const currentCellInfo = tableMap.find(({ cell: cell2 }) => cell2 == focusCell);
    let { row, column } = currentCellInfo;
    switch (direction) {
      case "left":
        column--;
        break;
      case "up":
        row--;
        break;
      case "right":
        column += currentCellInfo.cellWidth;
        break;
      case "down":
        row += currentCellInfo.cellHeight;
        break;
    }
    const isOutsideVertically = row < 0 || row > lastRow;
    const isBeforeFirstCell = column < 0 && row <= 0;
    const isAfterLastCell = column > lastColumn && row >= lastRow;
    if (isOutsideVertically || isBeforeFirstCell || isAfterLastCell) {
      model.change((writer) => {
        writer.setSelection(writer.createRangeOn(table));
      });
      return;
    }
    if (column < 0) {
      column = expandSelection ? 0 : lastColumn;
      row--;
    } else if (column > lastColumn) {
      column = expandSelection ? lastColumn : 0;
      row++;
    }
    const cellToSelect = tableMap.find((cellInfo) => cellInfo.row == row && cellInfo.column == column).cell;
    const isForward = [
      "right",
      "down"
    ].includes(direction);
    const tableSelection = this.editor.plugins.get("TableSelection");
    if (expandSelection && tableSelection.isEnabled) {
      const anchorCell = tableSelection.getAnchorCell() || focusCell;
      tableSelection.setCellSelection(anchorCell, cellToSelect);
    } else {
      const positionToSelect = model.createPositionAt(cellToSelect, isForward ? 0 : "end");
      model.change((writer) => {
        writer.setSelection(positionToSelect);
      });
    }
  }
};
var MouseEventsObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    __publicField(this, "domEventType", [
      "mousemove",
      "mouseleave"
    ]);
  }
  /**
  * @inheritDoc
  */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};
var TableMouse = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableMouse";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableSelection,
      TableUtils
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.editing.view.addObserver(MouseEventsObserver);
    this._enableShiftClickSelection();
    this._enableMouseDragSelection();
  }
  /**
  * Enables making cells selection by <kbd>Shift</kbd>+click. Creates a selection from the cell which previously held
  * the selection to the cell which was clicked. It can be the same cell, in which case it selects a single cell.
  */
  _enableShiftClickSelection() {
    const editor = this.editor;
    const tableUtils = editor.plugins.get(TableUtils);
    let blockSelectionChange = false;
    const tableSelection = editor.plugins.get(TableSelection);
    this.listenTo(editor.editing.view.document, "mousedown", (evt, domEventData) => {
      const selection = editor.model.document.selection;
      if (!this.isEnabled || !tableSelection.isEnabled) {
        return;
      }
      if (!domEventData.domEvent.shiftKey) {
        return;
      }
      const anchorCell = tableSelection.getAnchorCell() || tableUtils.getTableCellsContainingSelection(selection)[0];
      if (!anchorCell) {
        return;
      }
      const targetCell = this._getModelTableCellFromDomEvent(domEventData);
      if (targetCell && haveSameTableParent(anchorCell, targetCell)) {
        blockSelectionChange = true;
        tableSelection.setCellSelection(anchorCell, targetCell);
        domEventData.preventDefault();
      }
    });
    this.listenTo(editor.editing.view.document, "mouseup", () => {
      blockSelectionChange = false;
    });
    this.listenTo(editor.editing.view.document, "selectionChange", (evt) => {
      if (blockSelectionChange) {
        evt.stop();
      }
    }, {
      priority: "highest"
    });
  }
  /**
  * Enables making cells selection by dragging.
  *
  * The selection is made only on mousemove. Mouse tracking is started on mousedown.
  * However, the cells selection is enabled only after the mouse cursor left the anchor cell.
  * Thanks to that normal text selection within one cell works just fine. However, you can still select
  * just one cell by leaving the anchor cell and moving back to it.
  */
  _enableMouseDragSelection() {
    const editor = this.editor;
    let anchorCell, targetCell;
    let beganCellSelection = false;
    let blockSelectionChange = false;
    const tableSelection = editor.plugins.get(TableSelection);
    this.listenTo(editor.editing.view.document, "mousedown", (evt, domEventData) => {
      if (!this.isEnabled || !tableSelection.isEnabled) {
        return;
      }
      if (domEventData.domEvent.shiftKey || domEventData.domEvent.ctrlKey || domEventData.domEvent.altKey) {
        return;
      }
      anchorCell = this._getModelTableCellFromDomEvent(domEventData);
    });
    this.listenTo(editor.editing.view.document, "mousemove", (evt, domEventData) => {
      if (!domEventData.domEvent.buttons) {
        return;
      }
      if (!anchorCell) {
        return;
      }
      const newTargetCell = this._getModelTableCellFromDomEvent(domEventData);
      if (newTargetCell && haveSameTableParent(anchorCell, newTargetCell)) {
        targetCell = newTargetCell;
        if (!beganCellSelection && targetCell != anchorCell) {
          beganCellSelection = true;
        }
      }
      if (!beganCellSelection) {
        return;
      }
      blockSelectionChange = true;
      tableSelection.setCellSelection(anchorCell, targetCell);
      domEventData.preventDefault();
    });
    this.listenTo(editor.editing.view.document, "mouseup", () => {
      beganCellSelection = false;
      blockSelectionChange = false;
      anchorCell = null;
      targetCell = null;
    });
    this.listenTo(editor.editing.view.document, "selectionChange", (evt) => {
      if (blockSelectionChange) {
        evt.stop();
      }
    }, {
      priority: "highest"
    });
  }
  /**
  * Returns the model table cell element based on the target element of the passed DOM event.
  *
  * @returns Returns the table cell or `undefined`.
  */
  _getModelTableCellFromDomEvent(domEventData) {
    const viewTargetElement = domEventData.target;
    const viewPosition = this.editor.editing.view.createPositionAt(viewTargetElement, 0);
    const modelPosition = this.editor.editing.mapper.toModelPosition(viewPosition);
    const modelElement = modelPosition.parent;
    return modelElement.findAncestor("tableCell", {
      includeSelf: true
    });
  }
};
function haveSameTableParent(cellA, cellB) {
  return cellA.parent.parent == cellB.parent.parent;
}
var Table = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableEditing,
      TableUI,
      TableSelection,
      TableMouse,
      TableKeyboard,
      TableClipboard,
      Widget
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "Table";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};
var PlainTableOutput = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "PlainTableOutput";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      Table
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.conversion.for("dataDowncast").elementToStructure({
      model: "table",
      view: downcastTableElement,
      converterPriority: "high"
    });
    if (editor.plugins.has("TableCaption")) {
      editor.conversion.for("dataDowncast").elementToElement({
        model: "caption",
        view: (modelElement, { writer }) => {
          if (modelElement.parent.name === "table") {
            return writer.createContainerElement("caption");
          }
        },
        converterPriority: "high"
      });
    }
    if (editor.plugins.has("TableProperties")) {
      downcastTableBorderAndBackgroundAttributes(editor);
    }
  }
};
function downcastTableElement(table, { writer }) {
  const headingRows = table.getAttribute("headingRows") || 0;
  const headRowsSlot = writer.createSlot((element) => element.is("element", "tableRow") && element.index < headingRows);
  const bodyRowsSlot = writer.createSlot((element) => element.is("element", "tableRow") && element.index >= headingRows);
  const childrenSlot = writer.createSlot((element) => !element.is("element", "tableRow"));
  const theadElement = writer.createContainerElement("thead", null, headRowsSlot);
  const tbodyElement = writer.createContainerElement("tbody", null, bodyRowsSlot);
  const tableContentElements = [];
  if (headingRows) {
    tableContentElements.push(theadElement);
  }
  if (headingRows < table.childCount) {
    tableContentElements.push(tbodyElement);
  }
  return writer.createContainerElement("table", null, [
    childrenSlot,
    ...tableContentElements
  ]);
}
function downcastTableBorderAndBackgroundAttributes(editor) {
  const modelAttributes = {
    "border-width": "tableBorderWidth",
    "border-color": "tableBorderColor",
    "border-style": "tableBorderStyle",
    "background-color": "tableBackgroundColor"
  };
  for (const [styleName, modelAttribute] of Object.entries(modelAttributes)) {
    editor.conversion.for("dataDowncast").add((dispatcher) => {
      return dispatcher.on(`attribute:${modelAttribute}:table`, (evt, data, conversionApi) => {
        const { item, attributeNewValue } = data;
        const { mapper, writer } = conversionApi;
        if (!conversionApi.consumable.consume(item, evt.name)) {
          return;
        }
        const table = mapper.toViewElement(item);
        if (attributeNewValue) {
          writer.setStyle(styleName, attributeNewValue, table);
        } else {
          writer.removeStyle(styleName, table);
        }
      }, {
        priority: "high"
      });
    });
  }
}
function getSelectionAffectedTableWidget(selection) {
  const selectedTable = getSelectedTableWidget(selection);
  if (selectedTable) {
    return selectedTable;
  }
  return getTableWidgetAncestor(selection);
}
function getSelectedTableWidget(selection) {
  const viewElement = selection.getSelectedElement();
  if (viewElement && isTableWidget(viewElement)) {
    return viewElement;
  }
  return null;
}
function getTableWidgetAncestor(selection) {
  const selectionPosition = selection.getFirstPosition();
  if (!selectionPosition) {
    return null;
  }
  let parent = selectionPosition.parent;
  while (parent) {
    if (parent.is("element") && isTableWidget(parent)) {
      return parent;
    }
    parent = parent.parent;
  }
  return null;
}
function isTableWidget(viewElement) {
  return !!viewElement.getCustomProperty("table") && isWidget(viewElement);
}
var TableToolbar = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      WidgetToolbarRepository
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableToolbar";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  afterInit() {
    const editor = this.editor;
    const t = editor.t;
    const widgetToolbarRepository = editor.plugins.get(WidgetToolbarRepository);
    const tableContentToolbarItems = editor.config.get("table.contentToolbar");
    const tableToolbarItems = editor.config.get("table.tableToolbar");
    if (tableContentToolbarItems) {
      widgetToolbarRepository.register("tableContent", {
        ariaLabel: t("Table toolbar"),
        items: tableContentToolbarItems,
        getRelatedElement: getTableWidgetAncestor
      });
    }
    if (tableToolbarItems) {
      widgetToolbarRepository.register("table", {
        ariaLabel: t("Table toolbar"),
        items: tableToolbarItems,
        getRelatedElement: getSelectedTableWidget
      });
    }
  }
};
var ColorInputView = class extends View2 {
  /**
  * Creates an instance of the color input view.
  *
  * @param locale The locale instance.
  * @param options The input options.
  * @param options.colorDefinitions The colors to be displayed in the palette inside the input's dropdown.
  * @param options.columns The number of columns in which the colors will be displayed.
  * @param options.defaultColorValue If specified, the color input view will replace the "Remove color" button with
  * the "Restore default" button. Instead of clearing the input field, the default color value will be set.
  */
  constructor(locale, options2) {
    super(locale);
    /**
    * A cached reference to the options passed to the constructor.
    */
    __publicField(this, "options");
    /**
    * Tracks information about the DOM focus in the view.
    */
    __publicField(this, "focusTracker");
    /**
    * Helps cycling over focusable children in the input view.
    */
    __publicField(this, "focusCycler");
    /**
    * A collection of views that can be focused in the view.
    */
    __publicField(this, "_focusables");
    /**
    * An instance of the dropdown allowing to select a color from a grid.
    */
    __publicField(this, "dropdownView");
    /**
    * An instance of the input allowing the user to type a color value.
    */
    __publicField(this, "inputView");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * The flag that indicates whether the user is still typing.
    * If set to true, it means that the text input field ({@link #inputView}) still has the focus.
    * So, we should interrupt the user by replacing the input's value.
    */
    __publicField(this, "_stillTyping");
    this.set("value", "");
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("isEmpty", true);
    this.options = options2;
    this.focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this.dropdownView = this._createDropdownView();
    this.inputView = this._createInputTextView();
    this.keystrokes = new KeystrokeHandler();
    this._stillTyping = false;
    this.focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate items forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-input-color"
        ]
      },
      children: [
        this.dropdownView,
        this.inputView
      ]
    });
    this.on("change:value", (evt, name, inputValue) => this._setInputValue(inputValue));
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    [
      this.inputView,
      this.dropdownView.buttonView
    ].forEach((view) => {
      this.focusTracker.add(view.element);
      this._focusables.add(view);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * Focuses the view.
  */
  focus(direction) {
    if (direction === -1) {
      this.focusCycler.focusLast();
    } else {
      this.focusCycler.focusFirst();
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Creates and configures the {@link #dropdownView}.
  */
  _createDropdownView() {
    const locale = this.locale;
    const t = locale.t;
    const bind = this.bindTemplate;
    const colorSelector = this._createColorSelector(locale);
    const dropdown = createDropdown(locale);
    const colorPreview = new View2();
    colorPreview.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-input-color__button__preview"
        ],
        style: {
          backgroundColor: bind.to("value")
        }
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-input-color__button__preview__no-color-indicator",
              bind.if("value", "ck-hidden", (value) => value != "")
            ]
          }
        }
      ]
    });
    dropdown.buttonView.extendTemplate({
      attributes: {
        class: "ck-input-color__button"
      }
    });
    dropdown.buttonView.children.add(colorPreview);
    dropdown.buttonView.label = t("Color picker");
    dropdown.buttonView.tooltip = true;
    dropdown.panelPosition = locale.uiLanguageDirection === "rtl" ? "se" : "sw";
    dropdown.panelView.children.add(colorSelector);
    dropdown.bind("isEnabled").to(this, "isReadOnly", (value) => !value);
    dropdown.on("change:isOpen", (evt, name, isVisible2) => {
      if (isVisible2) {
        colorSelector.updateSelectedColors();
        colorSelector.showColorGridsFragment();
      }
    });
    return dropdown;
  }
  /**
  * Creates and configures an instance of {@link module:ui/inputtext/inputtextview~InputTextView}.
  *
  * @returns A configured instance to be set as {@link #inputView}.
  */
  _createInputTextView() {
    const locale = this.locale;
    const inputView = new InputTextView(locale);
    inputView.extendTemplate({
      on: {
        blur: inputView.bindTemplate.to("blur")
      }
    });
    inputView.value = this.value;
    inputView.bind("isReadOnly", "hasError").to(this);
    this.bind("isFocused", "isEmpty").to(inputView);
    inputView.on("input", () => {
      const inputValue = inputView.element.value;
      const mappedColor = this.options.colorDefinitions.find((def) => inputValue === def.label);
      this._stillTyping = true;
      this.value = mappedColor && mappedColor.color || inputValue;
    });
    inputView.on("blur", () => {
      this._stillTyping = false;
      this._setInputValue(inputView.element.value);
    });
    inputView.delegate("input").to(this);
    return inputView;
  }
  /**
  * Creates and configures the panel with "color grid" and "color picker" inside the {@link #dropdownView}.
  */
  _createColorSelector(locale) {
    const t = locale.t;
    const defaultColor = this.options.defaultColorValue || "";
    const removeColorButtonLabel = defaultColor ? t("Restore default") : t("Remove color");
    const colorSelector = new ColorSelectorView(locale, {
      colors: this.options.colorDefinitions,
      columns: this.options.columns,
      removeButtonLabel: removeColorButtonLabel,
      colorPickerLabel: t("Color picker"),
      colorPickerViewConfig: this.options.colorPickerConfig === false ? false : {
        ...this.options.colorPickerConfig,
        hideInput: true
      }
    });
    colorSelector.appendUI();
    colorSelector.on("execute", (evt, data) => {
      if (data.source === "colorPickerSaveButton") {
        this.dropdownView.isOpen = false;
        return;
      }
      this.value = data.value || defaultColor;
      this.fire("input");
      if (data.source !== "colorPicker") {
        this.dropdownView.isOpen = false;
      }
    });
    let backupColor = this.value;
    colorSelector.on("colorPicker:cancel", () => {
      this.value = backupColor;
      this.fire("input");
      this.dropdownView.isOpen = false;
    });
    colorSelector.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
      backupColor = this.value;
    });
    colorSelector.bind("selectedColor").to(this, "value");
    return colorSelector;
  }
  /**
  * Sets {@link #inputView}'s value property to the color value or color label,
  * if there is one and the user is not typing.
  *
  * Handles cases like:
  *
  * * Someone picks the color in the grid.
  * * The color is set from the plugin level.
  *
  * @param inputValue Color value to be set.
  */
  _setInputValue(inputValue) {
    if (!this._stillTyping) {
      const normalizedInputValue = normalizeColor(inputValue);
      const mappedColor = this.options.colorDefinitions.find((def) => normalizedInputValue === normalizeColor(def.color));
      if (mappedColor) {
        this.inputView.value = mappedColor.label;
      } else {
        this.inputView.value = inputValue || "";
      }
    }
  }
};
function normalizeColor(colorString) {
  return colorString.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ");
}
var isEmpty = (val) => val === "";
function getBorderStyleLabels(t) {
  return {
    none: t("None"),
    solid: t("Solid"),
    dotted: t("Dotted"),
    dashed: t("Dashed"),
    double: t("Double"),
    groove: t("Groove"),
    ridge: t("Ridge"),
    inset: t("Inset"),
    outset: t("Outset")
  };
}
function getLocalizedColorErrorText(t) {
  return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".');
}
function getLocalizedLengthErrorText(t) {
  return t('The value is invalid. Try "10px" or "2em" or simply "2".');
}
function colorFieldValidator(value) {
  value = value.trim().toLowerCase();
  return isEmpty(value) || isColor(value);
}
function lengthFieldValidator(value) {
  value = value.trim();
  return isEmpty(value) || isNumberString(value) || isLength(value) || isPercentage(value);
}
function lineWidthFieldValidator(value) {
  value = value.trim();
  return isEmpty(value) || isNumberString(value) || isLength(value);
}
function getBorderStyleDefinitions(view, defaultStyle) {
  const itemDefinitions = new Collection();
  const styleLabels = getBorderStyleLabels(view.t);
  for (const style in styleLabels) {
    const definition = {
      type: "button",
      model: new Model2({
        _borderStyleValue: style,
        label: styleLabels[style],
        role: "menuitemradio",
        withText: true
      })
    };
    if (style === "none") {
      definition.model.bind("isOn").to(view, "borderStyle", (value) => {
        if (defaultStyle === "none") {
          return !value;
        }
        return value === style;
      });
    } else {
      definition.model.bind("isOn").to(view, "borderStyle", (value) => {
        return value === style;
      });
    }
    itemDefinitions.add(definition);
  }
  return itemDefinitions;
}
function fillToolbar(options2) {
  const { view, icons: icons2, toolbar, labels, propertyName, nameToValue, defaultValue } = options2;
  for (const name in labels) {
    const button = new ButtonView(view.locale);
    button.set({
      label: labels[name],
      icon: icons2[name],
      tooltip: labels[name]
    });
    const buttonValue = nameToValue ? nameToValue(name) : name;
    button.bind("isOn").to(view, propertyName, (value) => {
      let valueToCompare = value;
      if (value === "" && defaultValue) {
        valueToCompare = defaultValue;
      }
      return buttonValue === valueToCompare;
    });
    button.on("execute", () => {
      view[propertyName] = buttonValue;
    });
    toolbar.items.add(button);
  }
}
var defaultColors = [
  {
    color: "hsl(0, 0%, 0%)",
    label: "Black"
  },
  {
    color: "hsl(0, 0%, 30%)",
    label: "Dim grey"
  },
  {
    color: "hsl(0, 0%, 60%)",
    label: "Grey"
  },
  {
    color: "hsl(0, 0%, 90%)",
    label: "Light grey"
  },
  {
    color: "hsl(0, 0%, 100%)",
    label: "White",
    hasBorder: true
  },
  {
    color: "hsl(0, 75%, 60%)",
    label: "Red"
  },
  {
    color: "hsl(30, 75%, 60%)",
    label: "Orange"
  },
  {
    color: "hsl(60, 75%, 60%)",
    label: "Yellow"
  },
  {
    color: "hsl(90, 75%, 60%)",
    label: "Light green"
  },
  {
    color: "hsl(120, 75%, 60%)",
    label: "Green"
  },
  {
    color: "hsl(150, 75%, 60%)",
    label: "Aquamarine"
  },
  {
    color: "hsl(180, 75%, 60%)",
    label: "Turquoise"
  },
  {
    color: "hsl(210, 75%, 60%)",
    label: "Light blue"
  },
  {
    color: "hsl(240, 75%, 60%)",
    label: "Blue"
  },
  {
    color: "hsl(270, 75%, 60%)",
    label: "Purple"
  }
];
function getLabeledColorInputCreator(options2) {
  return (labeledFieldView, viewUid, statusUid) => {
    const colorInputView = new ColorInputView(labeledFieldView.locale, {
      colorDefinitions: colorConfigToColorGridDefinitions(options2.colorConfig),
      columns: options2.columns,
      defaultColorValue: options2.defaultColorValue,
      colorPickerConfig: options2.colorPickerConfig
    });
    colorInputView.inputView.set({
      id: viewUid,
      ariaDescribedById: statusUid
    });
    colorInputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
    colorInputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
    colorInputView.on("input", () => {
      labeledFieldView.errorText = null;
    });
    labeledFieldView.bind("isEmpty", "isFocused").to(colorInputView);
    return colorInputView;
  };
}
function isNumberString(value) {
  const parsedValue = parseFloat(value);
  return !Number.isNaN(parsedValue) && value === String(parsedValue);
}
function colorConfigToColorGridDefinitions(colorConfig) {
  return colorConfig.map((item) => ({
    color: item.model,
    label: item.label,
    options: {
      hasBorder: item.hasBorder
    }
  }));
}
var FormRowView = class extends View2 {
  /**
  * Creates an instance of the form row class.
  *
  * @param locale The locale instance.
  * @param options.labelView When passed, the row gets the `group` and `aria-labelledby`
  * DOM attributes and gets described by the label.
  */
  constructor(locale, options2 = {}) {
    super(locale);
    /**
    * A collection of row items (buttons, dropdowns, etc.).
    */
    __publicField(this, "children");
    const bind = this.bindTemplate;
    this.set("class", options2.class || null);
    this.children = this.createCollection();
    if (options2.children) {
      options2.children.forEach((child) => this.children.add(child));
    }
    this.set("_role", null);
    this.set("_ariaLabelledBy", null);
    if (options2.labelView) {
      this.set({
        _role: "group",
        _ariaLabelledBy: options2.labelView.id
      });
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__row",
          bind.to("class")
        ],
        role: bind.to("_role"),
        "aria-labelledby": bind.to("_ariaLabelledBy")
      },
      children: this.children
    });
  }
};
var TableCellPropertiesView = class extends View2 {
  /**
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param options Additional configuration of the view.
  * @param options.borderColors A configuration of the border color palette used by the
  * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#borderColorInput}.
  * @param options.backgroundColors A configuration of the background color palette used by the
  * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#backgroundInput}.
  * @param options.defaultTableCellProperties The default table cell properties.
  */
  constructor(locale, options2) {
    super(locale);
    /**
    * Options passed to the view. See {@link #constructor} to learn more.
    */
    __publicField(this, "options");
    /**
    * Tracks information about the DOM focus in the form.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * A collection of child views in the form.
    */
    __publicField(this, "children");
    /**
    * A dropdown that allows selecting the style of the table cell border.
    */
    __publicField(this, "borderStyleDropdown");
    /**
    * An input that allows specifying the width of the table cell border.
    */
    __publicField(this, "borderWidthInput");
    /**
    * An input that allows specifying the color of the table cell border.
    */
    __publicField(this, "borderColorInput");
    /**
    * An input that allows specifying the table cell background color.
    */
    __publicField(this, "backgroundInput");
    /**
    * An input that allows specifying the table cell padding.
    */
    __publicField(this, "paddingInput");
    /**
    * An input that allows specifying the table cell width.
    */
    __publicField(this, "widthInput");
    /**
    * An input that allows specifying the table cell height.
    */
    __publicField(this, "heightInput");
    /**
    * A toolbar with buttons that allow changing the horizontal text alignment in a table cell.
    */
    __publicField(this, "horizontalAlignmentToolbar");
    /**
    * A toolbar with buttons that allow changing the vertical text alignment in a table cell.
    */
    __publicField(this, "verticalAlignmentToolbar");
    /**
    * The "Save" button view.
    */
    __publicField(this, "saveButtonView");
    /**
    * The "Cancel" button view.
    */
    __publicField(this, "cancelButtonView");
    /**
    * A collection of views that can be focused in the form.
    */
    __publicField(this, "_focusables");
    /**
    * Helps cycling over {@link #_focusables} in the form.
    */
    __publicField(this, "_focusCycler");
    this.set({
      borderStyle: "",
      borderWidth: "",
      borderColor: "",
      padding: "",
      backgroundColor: "",
      width: "",
      height: "",
      horizontalAlignment: "",
      verticalAlignment: ""
    });
    this.options = options2;
    const { borderStyleDropdown, borderWidthInput, borderColorInput, borderRowLabel } = this._createBorderFields();
    const { backgroundRowLabel, backgroundInput } = this._createBackgroundFields();
    const { widthInput, operatorLabel, heightInput, dimensionsLabel } = this._createDimensionFields();
    const { horizontalAlignmentToolbar, verticalAlignmentToolbar, alignmentLabel } = this._createAlignmentFields();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.children = this.createCollection();
    this.borderStyleDropdown = borderStyleDropdown;
    this.borderWidthInput = borderWidthInput;
    this.borderColorInput = borderColorInput;
    this.backgroundInput = backgroundInput;
    this.paddingInput = this._createPaddingField();
    this.widthInput = widthInput;
    this.heightInput = heightInput;
    this.horizontalAlignmentToolbar = horizontalAlignmentToolbar;
    this.verticalAlignmentToolbar = verticalAlignmentToolbar;
    const { saveButtonView, cancelButtonView } = this._createActionButtons();
    this.saveButtonView = saveButtonView;
    this.cancelButtonView = cancelButtonView;
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.children.add(new FormHeaderView(locale, {
      label: this.t("Cell properties")
    }));
    this.children.add(new FormRowView(locale, {
      labelView: borderRowLabel,
      children: [
        borderRowLabel,
        borderStyleDropdown,
        borderColorInput,
        borderWidthInput
      ],
      class: "ck-table-form__border-row"
    }));
    this.children.add(new FormRowView(locale, {
      labelView: backgroundRowLabel,
      children: [
        backgroundRowLabel,
        backgroundInput
      ],
      class: "ck-table-form__background-row"
    }));
    this.children.add(new FormRowView(locale, {
      children: [
        // Dimensions row.
        new FormRowView(locale, {
          labelView: dimensionsLabel,
          children: [
            dimensionsLabel,
            widthInput,
            operatorLabel,
            heightInput
          ],
          class: "ck-table-form__dimensions-row"
        }),
        // Padding row.
        new FormRowView(locale, {
          children: [
            this.paddingInput
          ],
          class: "ck-table-cell-properties-form__padding-row"
        })
      ]
    }));
    this.children.add(new FormRowView(locale, {
      labelView: alignmentLabel,
      children: [
        alignmentLabel,
        horizontalAlignmentToolbar,
        verticalAlignmentToolbar
      ],
      class: "ck-table-cell-properties-form__alignment-row"
    }));
    this.children.add(new FormRowView(locale, {
      children: [
        this.saveButtonView,
        this.cancelButtonView
      ],
      class: "ck-table-form__action-row"
    }));
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-form",
          "ck-table-form",
          "ck-table-cell-properties-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    [
      this.borderColorInput,
      this.backgroundInput
    ].forEach((view) => {
      this._focusCycler.chain(view.fieldView.focusCycler);
    });
    [
      this.borderStyleDropdown,
      this.borderColorInput,
      this.borderWidthInput,
      this.backgroundInput,
      this.widthInput,
      this.heightInput,
      this.paddingInput,
      this.horizontalAlignmentToolbar,
      this.verticalAlignmentToolbar,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((view) => {
      this._focusables.add(view);
      this.focusTracker.add(view.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the fist focusable field in the form.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #borderStyleDropdown},
  * * {@link #borderWidthInput},
  * * {@link #borderColorInput}.
  */
  _createBorderFields() {
    const defaultTableCellProperties = this.options.defaultTableCellProperties;
    const defaultBorder = {
      style: defaultTableCellProperties.borderStyle,
      width: defaultTableCellProperties.borderWidth,
      color: defaultTableCellProperties.borderColor
    };
    const colorInputCreator = getLabeledColorInputCreator({
      colorConfig: this.options.borderColors,
      columns: 5,
      defaultColorValue: defaultBorder.color,
      colorPickerConfig: this.options.colorPickerConfig
    });
    const locale = this.locale;
    const t = this.t;
    const accessibleLabel = t("Style");
    const borderRowLabel = new LabelView(locale);
    borderRowLabel.text = t("Border");
    const styleLabels = getBorderStyleLabels(t);
    const borderStyleDropdown = new LabeledFieldView(locale, createLabeledDropdown);
    borderStyleDropdown.set({
      label: accessibleLabel,
      class: "ck-table-form__border-style"
    });
    borderStyleDropdown.fieldView.buttonView.set({
      ariaLabel: accessibleLabel,
      ariaLabelledBy: void 0,
      isOn: false,
      withText: true,
      tooltip: accessibleLabel
    });
    borderStyleDropdown.fieldView.buttonView.bind("label").to(this, "borderStyle", (value) => {
      return styleLabels[value ? value : "none"];
    });
    borderStyleDropdown.fieldView.on("execute", (evt) => {
      this.borderStyle = evt.source._borderStyleValue;
    });
    borderStyleDropdown.bind("isEmpty").to(this, "borderStyle", (value) => !value);
    addListToDropdown(borderStyleDropdown.fieldView, getBorderStyleDefinitions(this, defaultBorder.style), {
      role: "menu",
      ariaLabel: accessibleLabel
    });
    const borderWidthInput = new LabeledFieldView(locale, createLabeledInputText);
    borderWidthInput.set({
      label: t("Width"),
      class: "ck-table-form__border-width"
    });
    borderWidthInput.fieldView.bind("value").to(this, "borderWidth");
    borderWidthInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet$1);
    borderWidthInput.fieldView.on("input", () => {
      this.borderWidth = borderWidthInput.fieldView.element.value;
    });
    const borderColorInput = new LabeledFieldView(locale, colorInputCreator);
    borderColorInput.set({
      label: t("Color"),
      class: "ck-table-form__border-color"
    });
    borderColorInput.fieldView.bind("value").to(this, "borderColor");
    borderColorInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet$1);
    borderColorInput.fieldView.on("input", () => {
      this.borderColor = borderColorInput.fieldView.value;
    });
    this.on("change:borderStyle", (evt, name, newValue, oldValue) => {
      if (!isBorderStyleSet$1(newValue)) {
        this.borderColor = "";
        this.borderWidth = "";
      }
      if (!isBorderStyleSet$1(oldValue)) {
        this.borderColor = defaultBorder.color;
        this.borderWidth = defaultBorder.width;
      }
    });
    return {
      borderRowLabel,
      borderStyleDropdown,
      borderColorInput,
      borderWidthInput
    };
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #backgroundInput}.
  */
  _createBackgroundFields() {
    const locale = this.locale;
    const t = this.t;
    const backgroundRowLabel = new LabelView(locale);
    backgroundRowLabel.text = t("Background");
    const colorInputCreator = getLabeledColorInputCreator({
      colorConfig: this.options.backgroundColors,
      columns: 5,
      defaultColorValue: this.options.defaultTableCellProperties.backgroundColor,
      colorPickerConfig: this.options.colorPickerConfig
    });
    const backgroundInput = new LabeledFieldView(locale, colorInputCreator);
    backgroundInput.set({
      label: t("Color"),
      class: "ck-table-cell-properties-form__background"
    });
    backgroundInput.fieldView.bind("value").to(this, "backgroundColor");
    backgroundInput.fieldView.on("input", () => {
      this.backgroundColor = backgroundInput.fieldView.value;
    });
    return {
      backgroundRowLabel,
      backgroundInput
    };
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #widthInput}.
  * * {@link #heightInput}.
  */
  _createDimensionFields() {
    const locale = this.locale;
    const t = this.t;
    const dimensionsLabel = new LabelView(locale);
    dimensionsLabel.text = t("Dimensions");
    const widthInput = new LabeledFieldView(locale, createLabeledInputText);
    widthInput.set({
      label: t("Width"),
      class: "ck-table-form__dimensions-row__width"
    });
    widthInput.fieldView.bind("value").to(this, "width");
    widthInput.fieldView.on("input", () => {
      this.width = widthInput.fieldView.element.value;
    });
    const operatorLabel = new View2(locale);
    operatorLabel.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck-table-form__dimension-operator"
        ]
      },
      children: [
        {
          text: ""
        }
      ]
    });
    const heightInput = new LabeledFieldView(locale, createLabeledInputText);
    heightInput.set({
      label: t("Height"),
      class: "ck-table-form__dimensions-row__height"
    });
    heightInput.fieldView.bind("value").to(this, "height");
    heightInput.fieldView.on("input", () => {
      this.height = heightInput.fieldView.element.value;
    });
    return {
      dimensionsLabel,
      widthInput,
      operatorLabel,
      heightInput
    };
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #paddingInput}.
  */
  _createPaddingField() {
    const locale = this.locale;
    const t = this.t;
    const paddingInput = new LabeledFieldView(locale, createLabeledInputText);
    paddingInput.set({
      label: t("Padding"),
      class: "ck-table-cell-properties-form__padding"
    });
    paddingInput.fieldView.bind("value").to(this, "padding");
    paddingInput.fieldView.on("input", () => {
      this.padding = paddingInput.fieldView.element.value;
    });
    return paddingInput;
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #horizontalAlignmentToolbar},
  * * {@link #verticalAlignmentToolbar}.
  */
  _createAlignmentFields() {
    const locale = this.locale;
    const t = this.t;
    const alignmentLabel = new LabelView(locale);
    const ALIGNMENT_ICONS = {
      left: icons.alignLeft,
      center: icons.alignCenter,
      right: icons.alignRight,
      justify: icons.alignJustify,
      top: icons.alignTop,
      middle: icons.alignMiddle,
      bottom: icons.alignBottom
    };
    alignmentLabel.text = t("Table cell text alignment");
    const horizontalAlignmentToolbar = new ToolbarView(locale);
    const isContentRTL = locale.contentLanguageDirection === "rtl";
    horizontalAlignmentToolbar.set({
      isCompact: true,
      ariaLabel: t("Horizontal text alignment toolbar")
    });
    fillToolbar({
      view: this,
      icons: ALIGNMENT_ICONS,
      toolbar: horizontalAlignmentToolbar,
      labels: this._horizontalAlignmentLabels,
      propertyName: "horizontalAlignment",
      nameToValue: (name) => {
        if (isContentRTL) {
          if (name === "left") {
            return "right";
          } else if (name === "right") {
            return "left";
          }
        }
        return name;
      },
      defaultValue: this.options.defaultTableCellProperties.horizontalAlignment
    });
    const verticalAlignmentToolbar = new ToolbarView(locale);
    verticalAlignmentToolbar.set({
      isCompact: true,
      ariaLabel: t("Vertical text alignment toolbar")
    });
    fillToolbar({
      view: this,
      icons: ALIGNMENT_ICONS,
      toolbar: verticalAlignmentToolbar,
      labels: this._verticalAlignmentLabels,
      propertyName: "verticalAlignment",
      defaultValue: this.options.defaultTableCellProperties.verticalAlignment
    });
    return {
      horizontalAlignmentToolbar,
      verticalAlignmentToolbar,
      alignmentLabel
    };
  }
  /**
  * Creates the following form controls:
  *
  * * {@link #saveButtonView},
  * * {@link #cancelButtonView}.
  */
  _createActionButtons() {
    const locale = this.locale;
    const t = this.t;
    const saveButtonView = new ButtonView(locale);
    const cancelButtonView = new ButtonView(locale);
    const fieldsThatShouldValidateToSave = [
      this.borderWidthInput,
      this.borderColorInput,
      this.backgroundInput,
      this.paddingInput
    ];
    saveButtonView.set({
      label: t("Save"),
      icon: icons.check,
      class: "ck-button-save",
      type: "submit",
      withText: true
    });
    saveButtonView.bind("isEnabled").toMany(fieldsThatShouldValidateToSave, "errorText", (...errorTexts) => {
      return errorTexts.every((errorText) => !errorText);
    });
    cancelButtonView.set({
      label: t("Cancel"),
      icon: icons.cancel,
      class: "ck-button-cancel",
      withText: true
    });
    cancelButtonView.delegate("execute").to(this, "cancel");
    return {
      saveButtonView,
      cancelButtonView
    };
  }
  /**
  * Provides localized labels for {@link #horizontalAlignmentToolbar} buttons.
  */
  get _horizontalAlignmentLabels() {
    const locale = this.locale;
    const t = this.t;
    const left = t("Align cell text to the left");
    const center = t("Align cell text to the center");
    const right = t("Align cell text to the right");
    const justify = t("Justify cell text");
    if (locale.uiLanguageDirection === "rtl") {
      return {
        right,
        center,
        left,
        justify
      };
    } else {
      return {
        left,
        center,
        right,
        justify
      };
    }
  }
  /**
  * Provides localized labels for {@link #verticalAlignmentToolbar} buttons.
  */
  get _verticalAlignmentLabels() {
    const t = this.t;
    return {
      top: t("Align cell text to the top"),
      middle: t("Align cell text to the middle"),
      bottom: t("Align cell text to the bottom")
    };
  }
};
function isBorderStyleSet$1(value) {
  return value !== "none";
}
var BALLOON_POSITIONS = (() => [
  BalloonPanelView.defaultPositions.northArrowSouth,
  BalloonPanelView.defaultPositions.northArrowSouthWest,
  BalloonPanelView.defaultPositions.northArrowSouthEast,
  BalloonPanelView.defaultPositions.southArrowNorth,
  BalloonPanelView.defaultPositions.southArrowNorthWest,
  BalloonPanelView.defaultPositions.southArrowNorthEast,
  BalloonPanelView.defaultPositions.viewportStickyNorth
])();
function repositionContextualBalloon2(editor, target) {
  const balloon = editor.plugins.get("ContextualBalloon");
  const selection = editor.editing.view.document.selection;
  let position;
  if (target === "cell") {
    if (getTableWidgetAncestor(selection)) {
      position = getBalloonCellPositionData(editor);
    }
  } else if (getSelectionAffectedTableWidget(selection)) {
    position = getBalloonTablePositionData(editor);
  }
  if (position) {
    balloon.updatePosition(position);
  }
}
function getBalloonTablePositionData(editor) {
  const selection = editor.model.document.selection;
  const modelTable = getSelectionAffectedTable(selection);
  const viewTable = editor.editing.mapper.toViewElement(modelTable);
  return {
    target: editor.editing.view.domConverter.mapViewToDom(viewTable),
    positions: BALLOON_POSITIONS
  };
}
function getBalloonCellPositionData(editor) {
  const mapper = editor.editing.mapper;
  const domConverter = editor.editing.view.domConverter;
  const selection = editor.model.document.selection;
  if (selection.rangeCount > 1) {
    return {
      target: () => createBoundingRect(selection.getRanges(), editor),
      positions: BALLOON_POSITIONS
    };
  }
  const modelTableCell = getTableCellAtPosition(selection.getFirstPosition());
  const viewTableCell = mapper.toViewElement(modelTableCell);
  return {
    target: domConverter.mapViewToDom(viewTableCell),
    positions: BALLOON_POSITIONS
  };
}
function getTableCellAtPosition(position) {
  const isTableCellSelected = position.nodeAfter && position.nodeAfter.is("element", "tableCell");
  return isTableCellSelected ? position.nodeAfter : position.findAncestor("tableCell");
}
function createBoundingRect(ranges, editor) {
  const mapper = editor.editing.mapper;
  const domConverter = editor.editing.view.domConverter;
  const rects = Array.from(ranges).map((range) => {
    const modelTableCell = getTableCellAtPosition(range.start);
    const viewTableCell = mapper.toViewElement(modelTableCell);
    return new Rect(domConverter.mapViewToDom(viewTableCell));
  });
  return Rect.getBoundingRect(rects);
}
var tableCellProperties = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>';
function getSingleValue(objectOrString) {
  if (!objectOrString || !isObject_default(objectOrString)) {
    return objectOrString;
  }
  const { top, right, bottom, left } = objectOrString;
  if (top == right && right == bottom && bottom == left) {
    return top;
  }
}
function addDefaultUnitToNumericValue(value, defaultUnit) {
  const numericValue = parseFloat(value);
  if (Number.isNaN(numericValue)) {
    return value;
  }
  if (String(numericValue) !== String(value)) {
    return value;
  }
  return `${numericValue}${defaultUnit}`;
}
function getNormalizedDefaultProperties(config, options2 = {}) {
  const normalizedConfig = {
    borderStyle: "none",
    borderWidth: "",
    borderColor: "",
    backgroundColor: "",
    width: "",
    height: "",
    ...config
  };
  if (options2.includeAlignmentProperty && !normalizedConfig.alignment) {
    normalizedConfig.alignment = "center";
  }
  if (options2.includePaddingProperty && !normalizedConfig.padding) {
    normalizedConfig.padding = "";
  }
  if (options2.includeVerticalAlignmentProperty && !normalizedConfig.verticalAlignment) {
    normalizedConfig.verticalAlignment = "middle";
  }
  if (options2.includeHorizontalAlignmentProperty && !normalizedConfig.horizontalAlignment) {
    normalizedConfig.horizontalAlignment = options2.isRightToLeftContent ? "right" : "left";
  }
  return normalizedConfig;
}
function getNormalizedDefaultTableProperties(config, options2) {
  return getNormalizedDefaultProperties({
    // It adds support for border none in the table element, keep it in sync with the content styles
    // See more: https://github.com/ckeditor/ckeditor5/issues/6841#issuecomment-1959195608
    borderStyle: "double",
    borderColor: "hsl(0, 0%, 70%)",
    borderWidth: "1px",
    ...config
  }, options2);
}
function getNormalizedDefaultCellProperties(config, options2) {
  return getNormalizedDefaultProperties({
    // It adds support for border none in the table element, keep it in sync with the content styles
    // See more: https://github.com/ckeditor/ckeditor5/issues/6841#issuecomment-1959195608
    borderStyle: "solid",
    borderColor: "hsl(0, 0%, 75%)",
    borderWidth: "1px",
    ...config
  }, options2);
}
var ERROR_TEXT_TIMEOUT$1 = 500;
var propertyToCommandMap$1 = {
  borderStyle: "tableCellBorderStyle",
  borderColor: "tableCellBorderColor",
  borderWidth: "tableCellBorderWidth",
  height: "tableCellHeight",
  width: "tableCellWidth",
  padding: "tableCellPadding",
  backgroundColor: "tableCellBackgroundColor",
  horizontalAlignment: "tableCellHorizontalAlignment",
  verticalAlignment: "tableCellVerticalAlignment"
};
var TableCellPropertiesUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The default table cell properties.
    */
    __publicField(this, "_defaultTableCellProperties");
    /**
    * The contextual balloon plugin instance.
    */
    __publicField(this, "_balloon");
    /**
    * The cell properties form view displayed inside the balloon.
    */
    __publicField(this, "view");
    /**
    * The batch used to undo all changes made by the form (which are live, as the user types)
    * when "Cancel" was pressed. Each time the view is shown, a new batch is created.
    */
    __publicField(this, "_undoStepBatch");
    /**
    * Flag used to indicate whether view is ready to execute update commands
    * (it finished loading initial data).
    */
    __publicField(this, "_isReady");
    editor.config.define("table.tableCellProperties", {
      borderColors: defaultColors,
      backgroundColors: defaultColors
    });
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ContextualBalloon
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableCellPropertiesUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    this._defaultTableCellProperties = getNormalizedDefaultCellProperties(editor.config.get("table.tableCellProperties.defaultProperties"), {
      includeVerticalAlignmentProperty: true,
      includeHorizontalAlignmentProperty: true,
      includePaddingProperty: true,
      isRightToLeftContent: editor.locale.contentLanguageDirection === "rtl"
    });
    this._balloon = editor.plugins.get(ContextualBalloon);
    this.view = null;
    this._isReady = false;
    editor.ui.componentFactory.add("tableCellProperties", (locale) => {
      const view = new ButtonView(locale);
      view.set({
        label: t("Cell properties"),
        icon: tableCellProperties,
        tooltip: true
      });
      this.listenTo(view, "execute", () => this._showView());
      const commands = Object.values(propertyToCommandMap$1).map((commandName) => editor.commands.get(commandName));
      view.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => areEnabled.some((isCommandEnabled) => isCommandEnabled));
      return view;
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    if (this.view) {
      this.view.destroy();
    }
  }
  /**
  * Creates the {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView} instance.
  *
  * @returns The cell properties form view instance.
  */
  _createPropertiesView() {
    const editor = this.editor;
    const config = editor.config.get("table.tableCellProperties");
    const borderColorsConfig = normalizeColorOptions(config.borderColors);
    const localizedBorderColors = getLocalizedColorOptions(editor.locale, borderColorsConfig);
    const backgroundColorsConfig = normalizeColorOptions(config.backgroundColors);
    const localizedBackgroundColors = getLocalizedColorOptions(editor.locale, backgroundColorsConfig);
    const hasColorPicker = config.colorPicker !== false;
    const view = new TableCellPropertiesView(editor.locale, {
      borderColors: localizedBorderColors,
      backgroundColors: localizedBackgroundColors,
      defaultTableCellProperties: this._defaultTableCellProperties,
      colorPickerConfig: hasColorPicker ? config.colorPicker || {} : false
    });
    const t = editor.t;
    view.render();
    this.listenTo(view, "submit", () => {
      this._hideView();
    });
    this.listenTo(view, "cancel", () => {
      if (this._undoStepBatch.operations.length) {
        editor.execute("undo", this._undoStepBatch);
      }
      this._hideView();
    });
    view.keystrokes.set("Esc", (data, cancel) => {
      this._hideView();
      cancel();
    });
    clickOutsideHandler({
      emitter: view,
      activator: () => this._isViewInBalloon,
      contextElements: [
        this._balloon.view.element
      ],
      callback: () => this._hideView()
    });
    const colorErrorText = getLocalizedColorErrorText(t);
    const lengthErrorText = getLocalizedLengthErrorText(t);
    view.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle"));
    view.on("change:borderColor", this._getValidatedPropertyChangeCallback({
      viewField: view.borderColorInput,
      commandName: "tableCellBorderColor",
      errorText: colorErrorText,
      validator: colorFieldValidator
    }));
    view.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
      viewField: view.borderWidthInput,
      commandName: "tableCellBorderWidth",
      errorText: lengthErrorText,
      validator: lineWidthFieldValidator
    }));
    view.on("change:padding", this._getValidatedPropertyChangeCallback({
      viewField: view.paddingInput,
      commandName: "tableCellPadding",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:width", this._getValidatedPropertyChangeCallback({
      viewField: view.widthInput,
      commandName: "tableCellWidth",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:height", this._getValidatedPropertyChangeCallback({
      viewField: view.heightInput,
      commandName: "tableCellHeight",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
      viewField: view.backgroundInput,
      commandName: "tableCellBackgroundColor",
      errorText: colorErrorText,
      validator: colorFieldValidator
    }));
    view.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment"));
    view.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment"));
    return view;
  }
  /**
  * In this method the "editor data -> UI" binding is happening.
  *
  * When executed, this method obtains selected cell property values from various table commands
  * and passes them to the {@link #view}.
  *
  * This way, the UI stays uptodate with the editor data.
  */
  _fillViewFormFromCommandValues() {
    const commands = this.editor.commands;
    const borderStyleCommand = commands.get("tableCellBorderStyle");
    Object.entries(propertyToCommandMap$1).map(([property, commandName]) => {
      const defaultValue = this._defaultTableCellProperties[property] || "";
      return [
        property,
        commands.get(commandName).value || defaultValue
      ];
    }).forEach(([property, value]) => {
      if ((property === "borderColor" || property === "borderWidth") && borderStyleCommand.value === "none") {
        return;
      }
      this.view.set(property, value);
    });
    this._isReady = true;
  }
  /**
  * Shows the {@link #view} in the {@link #_balloon}.
  *
  * **Note**: Each time a view is shown, a new {@link #_undoStepBatch} is created. It contains
  * all changes made to the document when the view is visible, allowing a single undo step
  * for all of them.
  */
  _showView() {
    const editor = this.editor;
    if (!this.view) {
      this.view = this._createPropertiesView();
    }
    this.listenTo(editor.ui, "update", () => {
      this._updateView();
    });
    this._fillViewFormFromCommandValues();
    this._balloon.add({
      view: this.view,
      position: getBalloonCellPositionData(editor)
    });
    this._undoStepBatch = editor.model.createBatch();
    this.view.focus();
  }
  /**
  * Removes the {@link #view} from the {@link #_balloon}.
  */
  _hideView() {
    const editor = this.editor;
    this.stopListening(editor.ui, "update");
    this._isReady = false;
    this.view.saveButtonView.focus();
    this._balloon.remove(this.view);
    this.editor.editing.view.focus();
  }
  /**
  * Repositions the {@link #_balloon} or hides the {@link #view} if a table cell is no longer selected.
  */
  _updateView() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    if (!getTableWidgetAncestor(viewDocument.selection)) {
      this._hideView();
    } else if (this._isViewVisible) {
      repositionContextualBalloon2(editor, "cell");
    }
  }
  /**
  * Returns `true` when the {@link #view} is visible in the {@link #_balloon}.
  */
  get _isViewVisible() {
    return !!this.view && this._balloon.visibleView === this.view;
  }
  /**
  * Returns `true` when the {@link #view} is in the {@link #_balloon}.
  */
  get _isViewInBalloon() {
    return !!this.view && this._balloon.hasView(this.view);
  }
  /**
  * Creates a callback that when executed upon the {@link #view view's} property change
  * executes a related editor command with the new property value.
  *
  * @param defaultValue The default value of the command.
  */
  _getPropertyChangeCallback(commandName) {
    return (evt, propertyName, newValue) => {
      if (!this._isReady) {
        return;
      }
      this.editor.execute(commandName, {
        value: newValue,
        batch: this._undoStepBatch
      });
    };
  }
  /**
  * Creates a callback that when executed upon the {@link #view view's} property change:
  * * Executes a related editor command with the new property value if the value is valid,
  * * Or sets the error text next to the invalid field, if the value did not pass the validation.
  */
  _getValidatedPropertyChangeCallback(options2) {
    const { commandName, viewField, validator, errorText } = options2;
    const setErrorTextDebounced = debounce_default(() => {
      viewField.errorText = errorText;
    }, ERROR_TEXT_TIMEOUT$1);
    return (evt, propertyName, newValue) => {
      setErrorTextDebounced.cancel();
      if (!this._isReady) {
        return;
      }
      if (validator(newValue)) {
        this.editor.execute(commandName, {
          value: newValue,
          batch: this._undoStepBatch
        });
        viewField.errorText = null;
      } else {
        setErrorTextDebounced();
      }
    };
  }
};
var TableCellPropertyCommand = class extends Command {
  /**
  * Creates a new `TableCellPropertyCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param attributeName Table cell attribute name.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, attributeName, defaultValue) {
    super(editor);
    /**
    * The attribute that will be set by the command.
    */
    __publicField(this, "attributeName");
    /**
    * The default value for the attribute.
    */
    __publicField(this, "_defaultValue");
    this.attributeName = attributeName;
    this._defaultValue = defaultValue;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedTableCells = tableUtils.getSelectionAffectedTableCells(editor.model.document.selection);
    this.isEnabled = !!selectedTableCells.length;
    this.value = this._getSingleValue(selectedTableCells);
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options.value If set, the command will set the attribute on selected table cells.
  * If it is not set, the command will remove the attribute from the selected table cells.
  * @param options.batch Pass the model batch instance to the command to aggregate changes,
  * for example to allow a single undo step for multiple executions.
  */
  execute(options2 = {}) {
    const { value, batch } = options2;
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const tableCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const valueToSet = this._getValueToSet(value);
    model.enqueueChange(batch, (writer) => {
      if (valueToSet) {
        tableCells.forEach((tableCell) => writer.setAttribute(this.attributeName, valueToSet, tableCell));
      } else {
        tableCells.forEach((tableCell) => writer.removeAttribute(this.attributeName, tableCell));
      }
    });
  }
  /**
  * Returns the attribute value for a table cell.
  */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = tableCell.getAttribute(this.attributeName);
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
  * Returns the proper model value. It can be used to add a default unit to numeric values.
  */
  _getValueToSet(value) {
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
  * Returns a single value for all selected table cells. If the value is the same for all cells,
  * it will be returned (`undefined` otherwise).
  */
  _getSingleValue(tableCells) {
    const firstCellValue = this._getAttribute(tableCells[0]);
    const everyCellHasAttribute = tableCells.every((tableCells2) => this._getAttribute(tableCells2) === firstCellValue);
    return everyCellHasAttribute ? firstCellValue : void 0;
  }
};
var TableCellWidthCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellWidthCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellWidth", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getValueToSet(value) {
    value = addDefaultUnitToNumericValue(value, "px");
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};
var TableCellWidthEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableCellWidthEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableEditing
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const defaultTableCellProperties = getNormalizedDefaultCellProperties(editor.config.get("table.tableCellProperties.defaultProperties"));
    enableProperty$1(editor.model.schema, editor.conversion, {
      modelAttribute: "tableCellWidth",
      styleName: "width",
      defaultValue: defaultTableCellProperties.width
    });
    editor.commands.add("tableCellWidth", new TableCellWidthCommand(editor, defaultTableCellProperties.width));
  }
};
var TableCellPaddingCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellPaddingCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellPadding", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = getSingleValue(tableCell.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
  * @inheritDoc
  */
  _getValueToSet(value) {
    const newValue = addDefaultUnitToNumericValue(value, "px");
    if (newValue === this._defaultValue) {
      return;
    }
    return newValue;
  }
};
var TableCellHeightCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellHeightCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellHeight", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getValueToSet(value) {
    const newValue = addDefaultUnitToNumericValue(value, "px");
    if (newValue === this._defaultValue) {
      return;
    }
    return newValue;
  }
};
var TableCellBackgroundColorCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellBackgroundColorCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellBackgroundColor", defaultValue);
  }
};
var TableCellVerticalAlignmentCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellVerticalAlignmentCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value for the "alignment" attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellVerticalAlignment", defaultValue);
  }
};
var TableCellHorizontalAlignmentCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellHorizontalAlignmentCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value for the "alignment" attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellHorizontalAlignment", defaultValue);
  }
};
var TableCellBorderStyleCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellBorderStyleCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellBorderStyle", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = getSingleValue(tableCell.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};
var TableCellBorderColorCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellBorderColorCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellBorderColor", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = getSingleValue(tableCell.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};
var TableCellBorderWidthCommand = class extends TableCellPropertyCommand {
  /**
  * Creates a new `TableCellBorderWidthCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableCellBorderWidth", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = getSingleValue(tableCell.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
  * @inheritDoc
  */
  _getValueToSet(value) {
    const newValue = addDefaultUnitToNumericValue(value, "px");
    if (newValue === this._defaultValue) {
      return;
    }
    return newValue;
  }
};
var VALIGN_VALUES_REG_EXP = /^(top|middle|bottom)$/;
var ALIGN_VALUES_REG_EXP$1 = /^(left|center|right|justify)$/;
var TableCellPropertiesEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableCellPropertiesEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableEditing,
      TableCellWidthEditing
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    editor.config.define("table.tableCellProperties.defaultProperties", {});
    const defaultTableCellProperties = getNormalizedDefaultCellProperties(editor.config.get("table.tableCellProperties.defaultProperties"), {
      includeVerticalAlignmentProperty: true,
      includeHorizontalAlignmentProperty: true,
      includePaddingProperty: true,
      isRightToLeftContent: editor.locale.contentLanguageDirection === "rtl"
    });
    editor.data.addStyleProcessorRules(addBorderRules);
    enableBorderProperties$1(schema, conversion, {
      color: defaultTableCellProperties.borderColor,
      style: defaultTableCellProperties.borderStyle,
      width: defaultTableCellProperties.borderWidth
    });
    editor.commands.add("tableCellBorderStyle", new TableCellBorderStyleCommand(editor, defaultTableCellProperties.borderStyle));
    editor.commands.add("tableCellBorderColor", new TableCellBorderColorCommand(editor, defaultTableCellProperties.borderColor));
    editor.commands.add("tableCellBorderWidth", new TableCellBorderWidthCommand(editor, defaultTableCellProperties.borderWidth));
    enableProperty$1(schema, conversion, {
      modelAttribute: "tableCellHeight",
      styleName: "height",
      defaultValue: defaultTableCellProperties.height
    });
    editor.commands.add("tableCellHeight", new TableCellHeightCommand(editor, defaultTableCellProperties.height));
    editor.data.addStyleProcessorRules(addPaddingRules);
    enableProperty$1(schema, conversion, {
      modelAttribute: "tableCellPadding",
      styleName: "padding",
      reduceBoxSides: true,
      defaultValue: defaultTableCellProperties.padding
    });
    editor.commands.add("tableCellPadding", new TableCellPaddingCommand(editor, defaultTableCellProperties.padding));
    editor.data.addStyleProcessorRules(addBackgroundRules);
    enableProperty$1(schema, conversion, {
      modelAttribute: "tableCellBackgroundColor",
      styleName: "background-color",
      defaultValue: defaultTableCellProperties.backgroundColor
    });
    editor.commands.add("tableCellBackgroundColor", new TableCellBackgroundColorCommand(editor, defaultTableCellProperties.backgroundColor));
    enableHorizontalAlignmentProperty(schema, conversion, defaultTableCellProperties.horizontalAlignment);
    editor.commands.add("tableCellHorizontalAlignment", new TableCellHorizontalAlignmentCommand(editor, defaultTableCellProperties.horizontalAlignment));
    enableVerticalAlignmentProperty(schema, conversion, defaultTableCellProperties.verticalAlignment);
    editor.commands.add("tableCellVerticalAlignment", new TableCellVerticalAlignmentCommand(editor, defaultTableCellProperties.verticalAlignment));
  }
};
function enableBorderProperties$1(schema, conversion, defaultBorder) {
  const modelAttributes = {
    width: "tableCellBorderWidth",
    color: "tableCellBorderColor",
    style: "tableCellBorderStyle"
  };
  schema.extend("tableCell", {
    allowAttributes: Object.values(modelAttributes)
  });
  upcastBorderStyles(conversion, "td", modelAttributes, defaultBorder);
  upcastBorderStyles(conversion, "th", modelAttributes, defaultBorder);
  downcastAttributeToStyle(conversion, {
    modelElement: "tableCell",
    modelAttribute: modelAttributes.style,
    styleName: "border-style"
  });
  downcastAttributeToStyle(conversion, {
    modelElement: "tableCell",
    modelAttribute: modelAttributes.color,
    styleName: "border-color"
  });
  downcastAttributeToStyle(conversion, {
    modelElement: "tableCell",
    modelAttribute: modelAttributes.width,
    styleName: "border-width"
  });
}
function enableHorizontalAlignmentProperty(schema, conversion, defaultValue) {
  schema.extend("tableCell", {
    allowAttributes: [
      "tableCellHorizontalAlignment"
    ]
  });
  conversion.for("downcast").attributeToAttribute({
    model: {
      name: "tableCell",
      key: "tableCellHorizontalAlignment"
    },
    view: (alignment) => ({
      key: "style",
      value: {
        "text-align": alignment
      }
    })
  });
  conversion.for("upcast").attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      styles: {
        "text-align": ALIGN_VALUES_REG_EXP$1
      }
    },
    model: {
      key: "tableCellHorizontalAlignment",
      value: (viewElement) => {
        const align = viewElement.getStyle("text-align");
        return align === defaultValue ? null : align;
      }
    }
  }).attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      attributes: {
        align: ALIGN_VALUES_REG_EXP$1
      }
    },
    model: {
      key: "tableCellHorizontalAlignment",
      value: (viewElement) => {
        const align = viewElement.getAttribute("align");
        return align === defaultValue ? null : align;
      }
    }
  });
}
function enableVerticalAlignmentProperty(schema, conversion, defaultValue) {
  schema.extend("tableCell", {
    allowAttributes: [
      "tableCellVerticalAlignment"
    ]
  });
  conversion.for("downcast").attributeToAttribute({
    model: {
      name: "tableCell",
      key: "tableCellVerticalAlignment"
    },
    view: (alignment) => ({
      key: "style",
      value: {
        "vertical-align": alignment
      }
    })
  });
  conversion.for("upcast").attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      styles: {
        "vertical-align": VALIGN_VALUES_REG_EXP
      }
    },
    model: {
      key: "tableCellVerticalAlignment",
      value: (viewElement) => {
        const align = viewElement.getStyle("vertical-align");
        return align === defaultValue ? null : align;
      }
    }
  }).attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      attributes: {
        valign: VALIGN_VALUES_REG_EXP
      }
    },
    model: {
      key: "tableCellVerticalAlignment",
      value: (viewElement) => {
        const valign = viewElement.getAttribute("valign");
        return valign === defaultValue ? null : valign;
      }
    }
  });
}
var TableCellProperties = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableCellProperties";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableCellPropertiesEditing,
      TableCellPropertiesUI
    ];
  }
};
var TablePropertyCommand = class extends Command {
  /**
  * Creates a new `TablePropertyCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param attributeName Table cell attribute name.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, attributeName, defaultValue) {
    super(editor);
    /**
    * The attribute that will be set by the command.
    */
    __publicField(this, "attributeName");
    /**
    * The default value for the attribute.
    */
    __publicField(this, "_defaultValue");
    this.attributeName = attributeName;
    this._defaultValue = defaultValue;
  }
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const table = getSelectionAffectedTable(selection);
    this.isEnabled = !!table;
    this.value = this._getValue(table);
  }
  /**
  * Executes the command.
  *
  * @fires execute
  * @param options.value If set, the command will set the attribute on the selected table.
  * If not set, the command will remove the attribute from the selected table.
  * @param options.batch Pass the model batch instance to the command to aggregate changes,
  * for example, to allow a single undo step for multiple executions.
  */
  execute(options2 = {}) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const { value, batch } = options2;
    const table = getSelectionAffectedTable(selection);
    const valueToSet = this._getValueToSet(value);
    model.enqueueChange(batch, (writer) => {
      if (valueToSet) {
        writer.setAttribute(this.attributeName, valueToSet, table);
      } else {
        writer.removeAttribute(this.attributeName, table);
      }
    });
  }
  /**
  * Returns the attribute value for a table.
  */
  _getValue(table) {
    if (!table) {
      return;
    }
    const value = table.getAttribute(this.attributeName);
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
  * Returns the proper model value. It can be used to add a default unit to numeric values.
  */
  _getValueToSet(value) {
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};
var TableBackgroundColorCommand = class extends TablePropertyCommand {
  /**
  * Creates a new `TableBackgroundColorCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableBackgroundColor", defaultValue);
  }
};
var TableBorderColorCommand = class extends TablePropertyCommand {
  /**
  * Creates a new `TableBorderColorCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableBorderColor", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getValue(table) {
    if (!table) {
      return;
    }
    const value = getSingleValue(table.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};
var TableBorderStyleCommand = class extends TablePropertyCommand {
  /**
  * Creates a new `TableBorderStyleCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableBorderStyle", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getValue(table) {
    if (!table) {
      return;
    }
    const value = getSingleValue(table.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};
var TableBorderWidthCommand = class extends TablePropertyCommand {
  /**
  * Creates a new `TableBorderWidthCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableBorderWidth", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getValue(table) {
    if (!table) {
      return;
    }
    const value = getSingleValue(table.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
  * @inheritDoc
  */
  _getValueToSet(value) {
    const newValue = addDefaultUnitToNumericValue(value, "px");
    if (newValue === this._defaultValue) {
      return;
    }
    return newValue;
  }
};
var TableWidthCommand = class extends TablePropertyCommand {
  /**
  * Creates a new `TableWidthCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableWidth", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getValueToSet(value) {
    value = addDefaultUnitToNumericValue(value, "px");
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};
var TableHeightCommand = class extends TablePropertyCommand {
  /**
  * Creates a new `TableHeightCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value of the attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableHeight", defaultValue);
  }
  /**
  * @inheritDoc
  */
  _getValueToSet(value) {
    value = addDefaultUnitToNumericValue(value, "px");
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};
var TableAlignmentCommand = class extends TablePropertyCommand {
  /**
  * Creates a new `TableAlignmentCommand` instance.
  *
  * @param editor An editor in which this command will be used.
  * @param defaultValue The default value for the "alignment" attribute.
  */
  constructor(editor, defaultValue) {
    super(editor, "tableAlignment", defaultValue);
  }
};
var ALIGN_VALUES_REG_EXP = /^(left|center|right)$/;
var FLOAT_VALUES_REG_EXP = /^(left|none|right)$/;
var TablePropertiesEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TablePropertiesEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableEditing
    ];
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    editor.config.define("table.tableProperties.defaultProperties", {});
    const defaultTableProperties = getNormalizedDefaultTableProperties(editor.config.get("table.tableProperties.defaultProperties"), {
      includeAlignmentProperty: true
    });
    editor.data.addStyleProcessorRules(addBorderRules);
    enableBorderProperties(schema, conversion, {
      color: defaultTableProperties.borderColor,
      style: defaultTableProperties.borderStyle,
      width: defaultTableProperties.borderWidth
    });
    editor.commands.add("tableBorderColor", new TableBorderColorCommand(editor, defaultTableProperties.borderColor));
    editor.commands.add("tableBorderStyle", new TableBorderStyleCommand(editor, defaultTableProperties.borderStyle));
    editor.commands.add("tableBorderWidth", new TableBorderWidthCommand(editor, defaultTableProperties.borderWidth));
    enableAlignmentProperty(schema, conversion, defaultTableProperties.alignment);
    editor.commands.add("tableAlignment", new TableAlignmentCommand(editor, defaultTableProperties.alignment));
    enableTableToFigureProperty(schema, conversion, {
      modelAttribute: "tableWidth",
      styleName: "width",
      defaultValue: defaultTableProperties.width
    });
    editor.commands.add("tableWidth", new TableWidthCommand(editor, defaultTableProperties.width));
    enableTableToFigureProperty(schema, conversion, {
      modelAttribute: "tableHeight",
      styleName: "height",
      defaultValue: defaultTableProperties.height
    });
    editor.commands.add("tableHeight", new TableHeightCommand(editor, defaultTableProperties.height));
    editor.data.addStyleProcessorRules(addBackgroundRules);
    enableProperty(schema, conversion, {
      modelAttribute: "tableBackgroundColor",
      styleName: "background-color",
      defaultValue: defaultTableProperties.backgroundColor
    });
    editor.commands.add("tableBackgroundColor", new TableBackgroundColorCommand(editor, defaultTableProperties.backgroundColor));
  }
};
function enableBorderProperties(schema, conversion, defaultBorder) {
  const modelAttributes = {
    width: "tableBorderWidth",
    color: "tableBorderColor",
    style: "tableBorderStyle"
  };
  schema.extend("table", {
    allowAttributes: Object.values(modelAttributes)
  });
  upcastBorderStyles(conversion, "table", modelAttributes, defaultBorder);
  downcastTableAttribute(conversion, {
    modelAttribute: modelAttributes.color,
    styleName: "border-color"
  });
  downcastTableAttribute(conversion, {
    modelAttribute: modelAttributes.style,
    styleName: "border-style"
  });
  downcastTableAttribute(conversion, {
    modelAttribute: modelAttributes.width,
    styleName: "border-width"
  });
}
function enableAlignmentProperty(schema, conversion, defaultValue) {
  schema.extend("table", {
    allowAttributes: [
      "tableAlignment"
    ]
  });
  conversion.for("downcast").attributeToAttribute({
    model: {
      name: "table",
      key: "tableAlignment"
    },
    view: (alignment) => ({
      key: "style",
      value: {
        // Model: `alignment:center` => CSS: `float:none`.
        float: alignment === "center" ? "none" : alignment
      }
    }),
    converterPriority: "high"
  });
  conversion.for("upcast").attributeToAttribute({
    view: {
      name: /^(table|figure)$/,
      styles: {
        float: FLOAT_VALUES_REG_EXP
      }
    },
    model: {
      key: "tableAlignment",
      value: (viewElement) => {
        let align = viewElement.getStyle("float");
        if (align === "none") {
          align = "center";
        }
        return align === defaultValue ? null : align;
      }
    }
  }).attributeToAttribute({
    view: {
      attributes: {
        align: ALIGN_VALUES_REG_EXP
      }
    },
    model: {
      name: "table",
      key: "tableAlignment",
      value: (viewElement) => {
        const align = viewElement.getAttribute("align");
        return align === defaultValue ? null : align;
      }
    }
  });
}
function enableProperty(schema, conversion, options2) {
  const { modelAttribute } = options2;
  schema.extend("table", {
    allowAttributes: [
      modelAttribute
    ]
  });
  upcastStyleToAttribute(conversion, {
    viewElement: "table",
    ...options2
  });
  downcastTableAttribute(conversion, options2);
}
function enableTableToFigureProperty(schema, conversion, options2) {
  const { modelAttribute } = options2;
  schema.extend("table", {
    allowAttributes: [
      modelAttribute
    ]
  });
  upcastStyleToAttribute(conversion, {
    viewElement: /^(table|figure)$/,
    shouldUpcast: (element) => !(element.name == "table" && element.parent.name == "figure"),
    ...options2
  });
  downcastAttributeToStyle(conversion, {
    modelElement: "table",
    ...options2
  });
}
var TablePropertiesView = class extends View2 {
  /**
  * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
  * @param options Additional configuration of the view.
  */
  constructor(locale, options2) {
    super(locale);
    /**
    * Options passed to the view. See {@link #constructor} to learn more.
    */
    __publicField(this, "options");
    /**
    * Tracks information about the DOM focus in the form.
    */
    __publicField(this, "focusTracker");
    /**
    * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
    */
    __publicField(this, "keystrokes");
    /**
    * A collection of child views in the form.
    */
    __publicField(this, "children");
    /**
    * A dropdown that allows selecting the style of the table border.
    */
    __publicField(this, "borderStyleDropdown");
    /**
    * An input that allows specifying the width of the table border.
    */
    __publicField(this, "borderWidthInput");
    /**
    * An input that allows specifying the color of the table border.
    */
    __publicField(this, "borderColorInput");
    /**
    * An input that allows specifying the table background color.
    */
    __publicField(this, "backgroundInput");
    /**
    * An input that allows specifying the table width.
    */
    __publicField(this, "widthInput");
    /**
    * An input that allows specifying the table height.
    */
    __publicField(this, "heightInput");
    /**
    * A toolbar with buttons that allow changing the alignment of an entire table.
    */
    __publicField(this, "alignmentToolbar");
    /**
    * The "Save" button view.
    */
    __publicField(this, "saveButtonView");
    /**
    * The "Cancel" button view.
    */
    __publicField(this, "cancelButtonView");
    /**
    * A collection of views that can be focused in the form.
    */
    __publicField(this, "_focusables");
    /**
    * Helps cycling over {@link #_focusables} in the form.
    */
    __publicField(this, "_focusCycler");
    this.set({
      borderStyle: "",
      borderWidth: "",
      borderColor: "",
      backgroundColor: "",
      width: "",
      height: "",
      alignment: ""
    });
    this.options = options2;
    const { borderStyleDropdown, borderWidthInput, borderColorInput, borderRowLabel } = this._createBorderFields();
    const { backgroundRowLabel, backgroundInput } = this._createBackgroundFields();
    const { widthInput, operatorLabel, heightInput, dimensionsLabel } = this._createDimensionFields();
    const { alignmentToolbar, alignmentLabel } = this._createAlignmentFields();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.children = this.createCollection();
    this.borderStyleDropdown = borderStyleDropdown;
    this.borderWidthInput = borderWidthInput;
    this.borderColorInput = borderColorInput;
    this.backgroundInput = backgroundInput;
    this.widthInput = widthInput;
    this.heightInput = heightInput;
    this.alignmentToolbar = alignmentToolbar;
    const { saveButtonView, cancelButtonView } = this._createActionButtons();
    this.saveButtonView = saveButtonView;
    this.cancelButtonView = cancelButtonView;
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.children.add(new FormHeaderView(locale, {
      label: this.t("Table properties")
    }));
    this.children.add(new FormRowView(locale, {
      labelView: borderRowLabel,
      children: [
        borderRowLabel,
        borderStyleDropdown,
        borderColorInput,
        borderWidthInput
      ],
      class: "ck-table-form__border-row"
    }));
    this.children.add(new FormRowView(locale, {
      labelView: backgroundRowLabel,
      children: [
        backgroundRowLabel,
        backgroundInput
      ],
      class: "ck-table-form__background-row"
    }));
    this.children.add(new FormRowView(locale, {
      children: [
        // Dimensions row.
        new FormRowView(locale, {
          labelView: dimensionsLabel,
          children: [
            dimensionsLabel,
            widthInput,
            operatorLabel,
            heightInput
          ],
          class: "ck-table-form__dimensions-row"
        }),
        // Alignment row.
        new FormRowView(locale, {
          labelView: alignmentLabel,
          children: [
            alignmentLabel,
            alignmentToolbar
          ],
          class: "ck-table-properties-form__alignment-row"
        })
      ]
    }));
    this.children.add(new FormRowView(locale, {
      children: [
        this.saveButtonView,
        this.cancelButtonView
      ],
      class: "ck-table-form__action-row"
    }));
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-form",
          "ck-table-form",
          "ck-table-properties-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
  * @inheritDoc
  */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    [
      this.borderColorInput,
      this.backgroundInput
    ].forEach((view) => {
      this._focusCycler.chain(view.fieldView.focusCycler);
    });
    [
      this.borderStyleDropdown,
      this.borderColorInput,
      this.borderWidthInput,
      this.backgroundInput,
      this.widthInput,
      this.heightInput,
      this.alignmentToolbar,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((view) => {
      this._focusables.add(view);
      this.focusTracker.add(view.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
  * Focuses the fist focusable field in the form.
  */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #borderStyleDropdown},
  * * {@link #borderWidthInput},
  * * {@link #borderColorInput}.
  */
  _createBorderFields() {
    const defaultTableProperties = this.options.defaultTableProperties;
    const defaultBorder = {
      style: defaultTableProperties.borderStyle,
      width: defaultTableProperties.borderWidth,
      color: defaultTableProperties.borderColor
    };
    const colorInputCreator = getLabeledColorInputCreator({
      colorConfig: this.options.borderColors,
      columns: 5,
      defaultColorValue: defaultBorder.color,
      colorPickerConfig: this.options.colorPickerConfig
    });
    const locale = this.locale;
    const t = this.t;
    const accessibleLabel = t("Style");
    const borderRowLabel = new LabelView(locale);
    borderRowLabel.text = t("Border");
    const styleLabels = getBorderStyleLabels(t);
    const borderStyleDropdown = new LabeledFieldView(locale, createLabeledDropdown);
    borderStyleDropdown.set({
      label: accessibleLabel,
      class: "ck-table-form__border-style"
    });
    borderStyleDropdown.fieldView.buttonView.set({
      ariaLabel: accessibleLabel,
      ariaLabelledBy: void 0,
      isOn: false,
      withText: true,
      tooltip: accessibleLabel
    });
    borderStyleDropdown.fieldView.buttonView.bind("label").to(this, "borderStyle", (value) => {
      return styleLabels[value ? value : "none"];
    });
    borderStyleDropdown.fieldView.on("execute", (evt) => {
      this.borderStyle = evt.source._borderStyleValue;
    });
    borderStyleDropdown.bind("isEmpty").to(this, "borderStyle", (value) => !value);
    addListToDropdown(borderStyleDropdown.fieldView, getBorderStyleDefinitions(this, defaultBorder.style), {
      role: "menu",
      ariaLabel: accessibleLabel
    });
    const borderWidthInput = new LabeledFieldView(locale, createLabeledInputText);
    borderWidthInput.set({
      label: t("Width"),
      class: "ck-table-form__border-width"
    });
    borderWidthInput.fieldView.bind("value").to(this, "borderWidth");
    borderWidthInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet);
    borderWidthInput.fieldView.on("input", () => {
      this.borderWidth = borderWidthInput.fieldView.element.value;
    });
    const borderColorInput = new LabeledFieldView(locale, colorInputCreator);
    borderColorInput.set({
      label: t("Color"),
      class: "ck-table-form__border-color"
    });
    borderColorInput.fieldView.bind("value").to(this, "borderColor");
    borderColorInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet);
    borderColorInput.fieldView.on("input", () => {
      this.borderColor = borderColorInput.fieldView.value;
    });
    this.on("change:borderStyle", (evt, name, newValue, oldValue) => {
      if (!isBorderStyleSet(newValue)) {
        this.borderColor = "";
        this.borderWidth = "";
      }
      if (!isBorderStyleSet(oldValue)) {
        this.borderColor = defaultBorder.color;
        this.borderWidth = defaultBorder.width;
      }
    });
    return {
      borderRowLabel,
      borderStyleDropdown,
      borderColorInput,
      borderWidthInput
    };
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #backgroundInput}.
  */
  _createBackgroundFields() {
    const locale = this.locale;
    const t = this.t;
    const backgroundRowLabel = new LabelView(locale);
    backgroundRowLabel.text = t("Background");
    const backgroundInputCreator = getLabeledColorInputCreator({
      colorConfig: this.options.backgroundColors,
      columns: 5,
      defaultColorValue: this.options.defaultTableProperties.backgroundColor,
      colorPickerConfig: this.options.colorPickerConfig
    });
    const backgroundInput = new LabeledFieldView(locale, backgroundInputCreator);
    backgroundInput.set({
      label: t("Color"),
      class: "ck-table-properties-form__background"
    });
    backgroundInput.fieldView.bind("value").to(this, "backgroundColor");
    backgroundInput.fieldView.on("input", () => {
      this.backgroundColor = backgroundInput.fieldView.value;
    });
    return {
      backgroundRowLabel,
      backgroundInput
    };
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #widthInput},
  * * {@link #heightInput}.
  */
  _createDimensionFields() {
    const locale = this.locale;
    const t = this.t;
    const dimensionsLabel = new LabelView(locale);
    dimensionsLabel.text = t("Dimensions");
    const widthInput = new LabeledFieldView(locale, createLabeledInputText);
    widthInput.set({
      label: t("Width"),
      class: "ck-table-form__dimensions-row__width"
    });
    widthInput.fieldView.bind("value").to(this, "width");
    widthInput.fieldView.on("input", () => {
      this.width = widthInput.fieldView.element.value;
    });
    const operatorLabel = new View2(locale);
    operatorLabel.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck-table-form__dimension-operator"
        ]
      },
      children: [
        {
          text: ""
        }
      ]
    });
    const heightInput = new LabeledFieldView(locale, createLabeledInputText);
    heightInput.set({
      label: t("Height"),
      class: "ck-table-form__dimensions-row__height"
    });
    heightInput.fieldView.bind("value").to(this, "height");
    heightInput.fieldView.on("input", () => {
      this.height = heightInput.fieldView.element.value;
    });
    return {
      dimensionsLabel,
      widthInput,
      operatorLabel,
      heightInput
    };
  }
  /**
  * Creates the following form fields:
  *
  * * {@link #alignmentToolbar}.
  */
  _createAlignmentFields() {
    const locale = this.locale;
    const t = this.t;
    const alignmentLabel = new LabelView(locale);
    alignmentLabel.text = t("Alignment");
    const alignmentToolbar = new ToolbarView(locale);
    alignmentToolbar.set({
      isCompact: true,
      ariaLabel: t("Table alignment toolbar")
    });
    fillToolbar({
      view: this,
      icons: {
        left: icons.objectLeft,
        center: icons.objectCenter,
        right: icons.objectRight
      },
      toolbar: alignmentToolbar,
      labels: this._alignmentLabels,
      propertyName: "alignment",
      defaultValue: this.options.defaultTableProperties.alignment
    });
    return {
      alignmentLabel,
      alignmentToolbar
    };
  }
  /**
  * Creates the following form controls:
  *
  * * {@link #saveButtonView},
  * * {@link #cancelButtonView}.
  */
  _createActionButtons() {
    const locale = this.locale;
    const t = this.t;
    const saveButtonView = new ButtonView(locale);
    const cancelButtonView = new ButtonView(locale);
    const fieldsThatShouldValidateToSave = [
      this.borderWidthInput,
      this.borderColorInput,
      this.backgroundInput,
      this.widthInput,
      this.heightInput
    ];
    saveButtonView.set({
      label: t("Save"),
      icon: icons.check,
      class: "ck-button-save",
      type: "submit",
      withText: true
    });
    saveButtonView.bind("isEnabled").toMany(fieldsThatShouldValidateToSave, "errorText", (...errorTexts) => {
      return errorTexts.every((errorText) => !errorText);
    });
    cancelButtonView.set({
      label: t("Cancel"),
      icon: icons.cancel,
      class: "ck-button-cancel",
      withText: true
    });
    cancelButtonView.delegate("execute").to(this, "cancel");
    return {
      saveButtonView,
      cancelButtonView
    };
  }
  /**
  * Provides localized labels for {@link #alignmentToolbar} buttons.
  */
  get _alignmentLabels() {
    const locale = this.locale;
    const t = this.t;
    const left = t("Align table to the left");
    const center = t("Center table");
    const right = t("Align table to the right");
    if (locale.uiLanguageDirection === "rtl") {
      return {
        right,
        center,
        left
      };
    } else {
      return {
        left,
        center,
        right
      };
    }
  }
};
function isBorderStyleSet(value) {
  return value !== "none";
}
var tableProperties = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>';
var ERROR_TEXT_TIMEOUT = 500;
var propertyToCommandMap = {
  borderStyle: "tableBorderStyle",
  borderColor: "tableBorderColor",
  borderWidth: "tableBorderWidth",
  backgroundColor: "tableBackgroundColor",
  width: "tableWidth",
  height: "tableHeight",
  alignment: "tableAlignment"
};
var TablePropertiesUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The default table properties.
    */
    __publicField(this, "_defaultTableProperties");
    /**
    * The contextual balloon plugin instance.
    */
    __publicField(this, "_balloon");
    /**
    * The properties form view displayed inside the balloon.
    */
    __publicField(this, "view", null);
    /**
    * The batch used to undo all changes made by the form (which are live, as the user types)
    * when "Cancel" was pressed. Each time the view is shown, a new batch is created.
    */
    __publicField(this, "_undoStepBatch");
    /**
    * Flag used to indicate whether view is ready to execute update commands
    * (it finished loading initial data).
    */
    __publicField(this, "_isReady");
    editor.config.define("table.tableProperties", {
      borderColors: defaultColors,
      backgroundColors: defaultColors
    });
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      ContextualBalloon
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TablePropertiesUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const t = editor.t;
    this._defaultTableProperties = getNormalizedDefaultTableProperties(editor.config.get("table.tableProperties.defaultProperties"), {
      includeAlignmentProperty: true
    });
    this._balloon = editor.plugins.get(ContextualBalloon);
    editor.ui.componentFactory.add("tableProperties", (locale) => {
      const view = new ButtonView(locale);
      view.set({
        label: t("Table properties"),
        icon: tableProperties,
        tooltip: true
      });
      this.listenTo(view, "execute", () => this._showView());
      const commands = Object.values(propertyToCommandMap).map((commandName) => editor.commands.get(commandName));
      view.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => areEnabled.some((isCommandEnabled) => isCommandEnabled));
      return view;
    });
  }
  /**
  * @inheritDoc
  */
  destroy() {
    super.destroy();
    if (this.view) {
      this.view.destroy();
    }
  }
  /**
  * Creates the {@link module:table/tableproperties/ui/tablepropertiesview~TablePropertiesView} instance.
  *
  * @returns The table properties form view instance.
  */
  _createPropertiesView() {
    const editor = this.editor;
    const config = editor.config.get("table.tableProperties");
    const borderColorsConfig = normalizeColorOptions(config.borderColors);
    const localizedBorderColors = getLocalizedColorOptions(editor.locale, borderColorsConfig);
    const backgroundColorsConfig = normalizeColorOptions(config.backgroundColors);
    const localizedBackgroundColors = getLocalizedColorOptions(editor.locale, backgroundColorsConfig);
    const hasColorPicker = config.colorPicker !== false;
    const view = new TablePropertiesView(editor.locale, {
      borderColors: localizedBorderColors,
      backgroundColors: localizedBackgroundColors,
      defaultTableProperties: this._defaultTableProperties,
      colorPickerConfig: hasColorPicker ? config.colorPicker || {} : false
    });
    const t = editor.t;
    view.render();
    this.listenTo(view, "submit", () => {
      this._hideView();
    });
    this.listenTo(view, "cancel", () => {
      if (this._undoStepBatch.operations.length) {
        editor.execute("undo", this._undoStepBatch);
      }
      this._hideView();
    });
    view.keystrokes.set("Esc", (data, cancel) => {
      this._hideView();
      cancel();
    });
    clickOutsideHandler({
      emitter: view,
      activator: () => this._isViewInBalloon,
      contextElements: [
        this._balloon.view.element
      ],
      callback: () => this._hideView()
    });
    const colorErrorText = getLocalizedColorErrorText(t);
    const lengthErrorText = getLocalizedLengthErrorText(t);
    view.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle"));
    view.on("change:borderColor", this._getValidatedPropertyChangeCallback({
      viewField: view.borderColorInput,
      commandName: "tableBorderColor",
      errorText: colorErrorText,
      validator: colorFieldValidator
    }));
    view.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
      viewField: view.borderWidthInput,
      commandName: "tableBorderWidth",
      errorText: lengthErrorText,
      validator: lineWidthFieldValidator
    }));
    view.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
      viewField: view.backgroundInput,
      commandName: "tableBackgroundColor",
      errorText: colorErrorText,
      validator: colorFieldValidator
    }));
    view.on("change:width", this._getValidatedPropertyChangeCallback({
      viewField: view.widthInput,
      commandName: "tableWidth",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:height", this._getValidatedPropertyChangeCallback({
      viewField: view.heightInput,
      commandName: "tableHeight",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:alignment", this._getPropertyChangeCallback("tableAlignment"));
    return view;
  }
  /**
  * In this method the "editor data -> UI" binding is happening.
  *
  * When executed, this method obtains selected table property values from various table commands
  * and passes them to the {@link #view}.
  *
  * This way, the UI stays uptodate with the editor data.
  */
  _fillViewFormFromCommandValues() {
    const commands = this.editor.commands;
    const borderStyleCommand = commands.get("tableBorderStyle");
    Object.entries(propertyToCommandMap).map(([property, commandName]) => {
      const propertyKey = property;
      const defaultValue = this._defaultTableProperties[propertyKey] || "";
      return [
        propertyKey,
        commands.get(commandName).value || defaultValue
      ];
    }).forEach(([property, value]) => {
      if ((property === "borderColor" || property === "borderWidth") && borderStyleCommand.value === "none") {
        return;
      }
      this.view.set(property, value);
    });
    this._isReady = true;
  }
  /**
  * Shows the {@link #view} in the {@link #_balloon}.
  *
  * **Note**: Each time a view is shown, the new {@link #_undoStepBatch} is created that contains
  * all changes made to the document when the view is visible, allowing a single undo step
  * for all of them.
  */
  _showView() {
    const editor = this.editor;
    if (!this.view) {
      this.view = this._createPropertiesView();
    }
    this.listenTo(editor.ui, "update", () => {
      this._updateView();
    });
    this._fillViewFormFromCommandValues();
    this._balloon.add({
      view: this.view,
      position: getBalloonTablePositionData(editor)
    });
    this._undoStepBatch = editor.model.createBatch();
    this.view.focus();
  }
  /**
  * Removes the {@link #view} from the {@link #_balloon}.
  */
  _hideView() {
    const editor = this.editor;
    this.stopListening(editor.ui, "update");
    this._isReady = false;
    this.view.saveButtonView.focus();
    this._balloon.remove(this.view);
    this.editor.editing.view.focus();
  }
  /**
  * Repositions the {@link #_balloon} or hides the {@link #view} if a table is no longer selected.
  */
  _updateView() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    if (!getSelectionAffectedTableWidget(viewDocument.selection)) {
      this._hideView();
    } else if (this._isViewVisible) {
      repositionContextualBalloon2(editor, "table");
    }
  }
  /**
  * Returns `true` when the {@link #view} is the visible in the {@link #_balloon}.
  */
  get _isViewVisible() {
    return !!this.view && this._balloon.visibleView === this.view;
  }
  /**
  * Returns `true` when the {@link #view} is in the {@link #_balloon}.
  */
  get _isViewInBalloon() {
    return !!this.view && this._balloon.hasView(this.view);
  }
  /**
  * Creates a callback that when executed upon {@link #view view's} property change
  * executes a related editor command with the new property value.
  *
  * If new value will be set to the default value, the command will not be executed.
  *
  * @param commandName The command that will be executed.
  */
  _getPropertyChangeCallback(commandName) {
    return (evt, propertyName, newValue) => {
      if (!this._isReady) {
        return;
      }
      this.editor.execute(commandName, {
        value: newValue,
        batch: this._undoStepBatch
      });
    };
  }
  /**
  * Creates a callback that when executed upon {@link #view view's} property change:
  * * executes a related editor command with the new property value if the value is valid,
  * * or sets the error text next to the invalid field, if the value did not pass the validation.
  */
  _getValidatedPropertyChangeCallback(options2) {
    const { commandName, viewField, validator, errorText } = options2;
    const setErrorTextDebounced = debounce_default(() => {
      viewField.errorText = errorText;
    }, ERROR_TEXT_TIMEOUT);
    return (evt, propertyName, newValue) => {
      setErrorTextDebounced.cancel();
      if (!this._isReady) {
        return;
      }
      if (validator(newValue)) {
        this.editor.execute(commandName, {
          value: newValue,
          batch: this._undoStepBatch
        });
        viewField.errorText = null;
      } else {
        setErrorTextDebounced();
      }
    };
  }
};
var TableProperties = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableProperties";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TablePropertiesEditing,
      TablePropertiesUI
    ];
  }
};
function injectTableCaptionPostFixer(model) {
  model.document.registerPostFixer((writer) => tableCaptionPostFixer(writer, model));
}
function tableCaptionPostFixer(writer, model) {
  const changes = model.document.differ.getChanges();
  let wasFixed = false;
  for (const entry of changes) {
    if (entry.type != "insert") {
      continue;
    }
    const positionParent = entry.position.parent;
    if (positionParent.is("element", "table") || entry.name == "table") {
      const table = entry.name == "table" ? entry.position.nodeAfter : positionParent;
      const captionsToMerge = Array.from(table.getChildren()).filter((child) => child.is("element", "caption"));
      const firstCaption = captionsToMerge.shift();
      if (!firstCaption) {
        continue;
      }
      for (const caption of captionsToMerge) {
        writer.move(writer.createRangeIn(caption), firstCaption, "end");
        writer.remove(caption);
      }
      if (firstCaption.nextSibling) {
        writer.move(writer.createRangeOn(firstCaption), table, "end");
        wasFixed = true;
      }
      wasFixed = !!captionsToMerge.length || wasFixed;
    }
  }
  return wasFixed;
}
function isTable(modelElement) {
  return !!modelElement && modelElement.is("element", "table");
}
function getCaptionFromTableModelElement(tableModelElement) {
  for (const node of tableModelElement.getChildren()) {
    if (node.is("element", "caption")) {
      return node;
    }
  }
  return null;
}
function getCaptionFromModelSelection(selection) {
  const tableElement = getSelectionAffectedTable(selection);
  if (!tableElement) {
    return null;
  }
  return getCaptionFromTableModelElement(tableElement);
}
function matchTableCaptionViewElement(element) {
  const parent = element.parent;
  if (element.name == "figcaption" && parent && parent.is("element", "figure") && parent.hasClass("table")) {
    return {
      name: true
    };
  }
  if (element.name == "caption" && parent && parent.is("element", "table")) {
    return {
      name: true
    };
  }
  return null;
}
var ToggleTableCaptionCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    const editor = this.editor;
    const tableElement = getSelectionAffectedTable(editor.model.document.selection);
    this.isEnabled = !!tableElement;
    if (!this.isEnabled) {
      this.value = false;
    } else {
      this.value = !!getCaptionFromTableModelElement(tableElement);
    }
  }
  /**
  * Executes the command.
  *
  * ```ts
  * editor.execute( 'toggleTableCaption' );
  * ```
  *
  * @param options Options for the executed command.
  * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
  * @fires execute
  */
  execute({ focusCaptionOnShow = false } = {}) {
    this.editor.model.change((writer) => {
      if (this.value) {
        this._hideTableCaption(writer);
      } else {
        this._showTableCaption(writer, focusCaptionOnShow);
      }
    });
  }
  /**
  * Shows the table caption. Also:
  *
  * * it attempts to restore the caption content from the `TableCaptionEditing` caption registry,
  * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
  *
  * @param focusCaptionOnShow Default focus behavior when showing the caption.
  */
  _showTableCaption(writer, focusCaptionOnShow) {
    const model = this.editor.model;
    const tableElement = getSelectionAffectedTable(model.document.selection);
    const tableCaptionEditing = this.editor.plugins.get("TableCaptionEditing");
    const savedCaptionElement = tableCaptionEditing._getSavedCaption(tableElement);
    const newCaptionElement = savedCaptionElement || writer.createElement("caption");
    model.insertContent(newCaptionElement, tableElement, "end");
    if (focusCaptionOnShow) {
      writer.setSelection(newCaptionElement, "in");
    }
  }
  /**
  * Hides the caption of a selected table (or an table caption the selection is anchored to).
  *
  * The content of the caption is stored in the `TableCaptionEditing` caption registry to make this
  * a reversible action.
  */
  _hideTableCaption(writer) {
    const model = this.editor.model;
    const tableElement = getSelectionAffectedTable(model.document.selection);
    const tableCaptionEditing = this.editor.plugins.get("TableCaptionEditing");
    const captionElement = getCaptionFromTableModelElement(tableElement);
    tableCaptionEditing._saveCaption(tableElement, captionElement);
    model.deleteContent(writer.createSelection(captionElement, "on"));
  }
};
var TableCaptionEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * A map that keeps saved JSONified table captions and table model elements they are
    * associated with.
    *
    * To learn more about this system, see {@link #_saveCaption}.
    */
    __publicField(this, "_savedCaptionsMap");
    this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableCaptionEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const view = editor.editing.view;
    const t = editor.t;
    if (!schema.isRegistered("caption")) {
      schema.register("caption", {
        allowIn: "table",
        allowContentOf: "$block",
        isLimit: true
      });
    } else {
      schema.extend("caption", {
        allowIn: "table"
      });
    }
    editor.commands.add("toggleTableCaption", new ToggleTableCaptionCommand(this.editor));
    editor.conversion.for("upcast").elementToElement({
      view: matchTableCaptionViewElement,
      model: "caption"
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "caption",
      view: (modelElement, { writer }) => {
        if (!isTable(modelElement.parent)) {
          return null;
        }
        return writer.createContainerElement("figcaption");
      }
    });
    editor.conversion.for("editingDowncast").elementToElement({
      model: "caption",
      view: (modelElement, { writer }) => {
        if (!isTable(modelElement.parent)) {
          return null;
        }
        const figcaptionElement = writer.createEditableElement("figcaption");
        writer.setCustomProperty("tableCaption", true, figcaptionElement);
        figcaptionElement.placeholder = t("Enter table caption");
        enablePlaceholder({
          view,
          element: figcaptionElement,
          keepOnFocus: true
        });
        return toWidgetEditable(figcaptionElement, writer);
      }
    });
    injectTableCaptionPostFixer(editor.model);
  }
  /**
  * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
  * of a table model element.
  *
  * See {@link #_saveCaption}.
  *
  * @internal
  * @param tableModelElement The model element the caption should be returned for.
  * @returns The model caption element or `null` if there is none.
  */
  _getSavedCaption(tableModelElement) {
    const jsonObject = this._savedCaptionsMap.get(tableModelElement);
    return jsonObject ? Element.fromJSON(jsonObject) : null;
  }
  /**
  * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
  * a table element to allow restoring it in the future.
  *
  * A caption is saved every time it gets hidden. The
  * user should be able to restore it on demand.
  *
  * **Note**: The caption cannot be stored in the table model element attribute because,
  * for instance, when the model state propagates to collaborators, the attribute would get
  * lost (mainly because it does not convert to anything when the caption is hidden) and
  * the states of collaborators' models would de-synchronize causing numerous issues.
  *
  * See {@link #_getSavedCaption}.
  *
  * @internal
  * @param tableModelElement The model element the caption is saved for.
  * @param caption The caption model element to be saved.
  */
  _saveCaption(tableModelElement, caption) {
    this._savedCaptionsMap.set(tableModelElement, caption.toJSON());
  }
};
var TableCaptionUI = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableCaptionUI";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const t = editor.t;
    editor.ui.componentFactory.add("toggleTableCaption", (locale) => {
      const command = editor.commands.get("toggleTableCaption");
      const view = new ButtonView(locale);
      view.set({
        icon: icons.caption,
        tooltip: true,
        isToggleable: true
      });
      view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      view.bind("label").to(command, "value", (value) => value ? t("Toggle caption off") : t("Toggle caption on"));
      this.listenTo(view, "execute", () => {
        editor.execute("toggleTableCaption", {
          focusCaptionOnShow: true
        });
        if (command.value) {
          const modelCaptionElement = getCaptionFromModelSelection(editor.model.document.selection);
          const figcaptionElement = editor.editing.mapper.toViewElement(modelCaptionElement);
          if (!figcaptionElement) {
            return;
          }
          editingView.scrollToTheSelection();
          editingView.change((writer) => {
            writer.addClass("table__caption_highlighted", figcaptionElement);
          });
        }
        editor.editing.view.focus();
      });
      return view;
    });
  }
};
var TableCaption = class extends Plugin {
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableCaption";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableCaptionEditing,
      TableCaptionUI
    ];
  }
};
var TableWidthsCommand = class extends Command {
  /**
  * @inheritDoc
  */
  refresh() {
    this.isEnabled = true;
  }
  /**
  * Updated the `tableWidth` attribute of the table and the `columnWidth` attribute of the columns of that table.
  */
  execute(options2 = {}) {
    const { model, plugins } = this.editor;
    let { table = model.document.selection.getSelectedElement(), columnWidths, tableWidth } = options2;
    if (columnWidths) {
      columnWidths = Array.isArray(columnWidths) ? columnWidths : columnWidths.split(",");
    }
    model.change((writer) => {
      if (tableWidth) {
        writer.setAttribute("tableWidth", tableWidth, table);
      } else {
        writer.removeAttribute("tableWidth", table);
      }
      const tableColumnGroup = plugins.get("TableColumnResizeEditing").getColumnGroupElement(table);
      if (!columnWidths && !tableColumnGroup) {
        return;
      }
      if (!columnWidths) {
        return writer.remove(tableColumnGroup);
      }
      const widths = normalizeColumnWidths(columnWidths);
      if (!tableColumnGroup) {
        const colGroupElement = writer.createElement("tableColumnGroup");
        widths.forEach((columnWidth) => writer.appendElement("tableColumn", {
          columnWidth
        }, colGroupElement));
        writer.append(colGroupElement, table);
      } else {
        Array.from(tableColumnGroup.getChildren()).forEach((column, index) => writer.setAttribute("columnWidth", widths[index], column));
      }
    });
  }
};
function upcastColgroupElement(tableUtilsPlugin) {
  return (dispatcher) => dispatcher.on("element:colgroup", (evt, data, conversionApi) => {
    const modelTable = data.modelCursor.findAncestor("table");
    const tableColumnGroup = getColumnGroupElement(modelTable);
    if (!tableColumnGroup) {
      return;
    }
    const columnElements = getTableColumnElements(tableColumnGroup);
    const columnsCount = tableUtilsPlugin.getColumns(modelTable);
    let columnWidths = translateColSpanAttribute(tableColumnGroup, conversionApi.writer);
    columnWidths = Array.from({
      length: columnsCount
    }, (_, index) => columnWidths[index] || "auto");
    if (columnWidths.length != columnElements.length || columnWidths.includes("auto")) {
      updateColumnElements(columnElements, tableColumnGroup, normalizeColumnWidths(columnWidths), conversionApi.writer);
    }
  }, {
    priority: "low"
  });
}
function downcastTableResizedClass() {
  return (dispatcher) => dispatcher.on("insert:table", (evt, data, conversionApi) => {
    const viewWriter = conversionApi.writer;
    const modelTable = data.item;
    const viewElement = conversionApi.mapper.toViewElement(modelTable);
    const viewTable = viewElement.is("element", "table") ? viewElement : Array.from(viewElement.getChildren()).find((viewChild) => viewChild.is("element", "table"));
    const tableColumnGroup = getColumnGroupElement(modelTable);
    if (tableColumnGroup) {
      viewWriter.addClass("ck-table-resized", viewTable);
    } else {
      viewWriter.removeClass("ck-table-resized", viewTable);
    }
  }, {
    priority: "low"
  });
}
var TableColumnResizeEditing = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * A flag indicating if the column resizing is in progress.
    */
    __publicField(this, "_isResizingActive");
    /**
    * A temporary storage for the required data needed to correctly calculate the widths of the resized columns. This storage is
    * initialized when column resizing begins, and is purged upon completion.
    */
    __publicField(this, "_resizingData");
    /**
    * DOM emitter.
    */
    __publicField(this, "_domEmitter");
    /**
    * A local reference to the {@link module:table/tableutils~TableUtils} plugin.
    */
    __publicField(this, "_tableUtilsPlugin");
    this._isResizingActive = false;
    this.set("_isResizingAllowed", true);
    this._resizingData = null;
    this._domEmitter = new (DomEmitterMixin())();
    this._tableUtilsPlugin = editor.plugins.get("TableUtils");
    this.on("change:_isResizingAllowed", (evt, name, value) => {
      const classAction = value ? "removeClass" : "addClass";
      editor.editing.view.change((writer) => {
        for (const root2 of editor.editing.view.document.roots) {
          writer[classAction]("ck-column-resize_disabled", editor.editing.view.document.getRoot(root2.rootName));
        }
      });
    });
  }
  /**
  * @inheritDoc
  */
  static get requires() {
    return [
      TableEditing,
      TableUtils
    ];
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "TableColumnResizeEditing";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    this._extendSchema();
    this._registerPostFixer();
    this._registerConverters();
    this._registerResizingListeners();
    this._registerResizerInserter();
    const editor = this.editor;
    const columnResizePlugin = editor.plugins.get("TableColumnResize");
    const tableEditing = editor.plugins.get("TableEditing");
    tableEditing.registerAdditionalSlot({
      filter: (element) => element.is("element", "tableColumnGroup"),
      positionOffset: 0
    });
    const tableWidthsCommand = new TableWidthsCommand(editor);
    editor.commands.add("resizeTableWidth", tableWidthsCommand);
    editor.commands.add("resizeColumnWidths", tableWidthsCommand);
    this.bind("_isResizingAllowed").to(editor, "isReadOnly", columnResizePlugin, "isEnabled", tableWidthsCommand, "isEnabled", (isEditorReadOnly, isPluginEnabled, isTableWidthsCommandCommandEnabled) => !isEditorReadOnly && isPluginEnabled && isTableWidthsCommandCommandEnabled);
  }
  /**
  * @inheritDoc
  */
  destroy() {
    this._domEmitter.stopListening();
    super.destroy();
  }
  /**
  * Returns a 'tableColumnGroup' element from the 'table'.
  *
  * @param element A 'table' or 'tableColumnGroup' element.
  * @returns A 'tableColumnGroup' element.
  */
  getColumnGroupElement(element) {
    return getColumnGroupElement(element);
  }
  /**
  * Returns an array of 'tableColumn' elements.
  *
  * @param element A 'table' or 'tableColumnGroup' element.
  * @returns An array of 'tableColumn' elements.
  */
  getTableColumnElements(element) {
    return getTableColumnElements(element);
  }
  /**
  * Returns an array of table column widths.
  *
  * @param element A 'table' or 'tableColumnGroup' element.
  * @returns An array of table column widths.
  */
  getTableColumnsWidths(element) {
    return getTableColumnsWidths(element);
  }
  /**
  * Registers new attributes for a table model element.
  */
  _extendSchema() {
    this.editor.model.schema.extend("table", {
      allowAttributes: [
        "tableWidth"
      ]
    });
    this.editor.model.schema.register("tableColumnGroup", {
      allowIn: "table",
      isLimit: true
    });
    this.editor.model.schema.register("tableColumn", {
      allowIn: "tableColumnGroup",
      allowAttributes: [
        "columnWidth",
        "colSpan"
      ],
      isLimit: true
    });
  }
  /**
  * Registers table column resize post-fixer.
  *
  * It checks if the change from the differ concerns a table-related element or attribute. For detected changes it:
  *  * Adjusts the `columnWidths` attribute to guarantee that the sum of the widths from all columns is 100%.
  *  * Checks if the `columnWidths` attribute gets updated accordingly after columns have been added or removed.
  */
  _registerPostFixer() {
    const editor = this.editor;
    const model = editor.model;
    model.document.registerPostFixer((writer) => {
      let changed = false;
      for (const table of getChangedResizedTables(model)) {
        const tableColumnGroup = this.getColumnGroupElement(table);
        const columns = this.getTableColumnElements(tableColumnGroup);
        const columnWidths = this.getTableColumnsWidths(tableColumnGroup);
        let normalizedWidths = normalizeColumnWidths(columnWidths);
        normalizedWidths = adjustColumnWidths(normalizedWidths, table, this);
        if (isEqual_default(columnWidths, normalizedWidths)) {
          continue;
        }
        updateColumnElements(columns, tableColumnGroup, normalizedWidths, writer);
        changed = true;
      }
      return changed;
    });
    function adjustColumnWidths(columnWidths, table, plugin) {
      const newTableColumnsCount = plugin._tableUtilsPlugin.getColumns(table);
      const columnsCountDelta = newTableColumnsCount - columnWidths.length;
      if (columnsCountDelta === 0) {
        return columnWidths;
      }
      const widths = columnWidths.map((width) => Number(width.replace("%", "")));
      const cellSet = getAffectedCells(plugin.editor.model.document.differ, table);
      for (const cell2 of cellSet) {
        const currentColumnsDelta = newTableColumnsCount - widths.length;
        if (currentColumnsDelta === 0) {
          continue;
        }
        const hasMoreColumns = currentColumnsDelta > 0;
        const currentColumnIndex = plugin._tableUtilsPlugin.getCellLocation(cell2).column;
        if (hasMoreColumns) {
          const columnMinWidthAsPercentage = getColumnMinWidthAsPercentage(table, plugin.editor);
          const columnWidthsToInsert = createFilledArray(currentColumnsDelta, columnMinWidthAsPercentage);
          widths.splice(currentColumnIndex, 0, ...columnWidthsToInsert);
        } else {
          const removedColumnWidths = widths.splice(currentColumnIndex, Math.abs(currentColumnsDelta));
          widths[currentColumnIndex] += sumArray(removedColumnWidths);
        }
      }
      return widths.map((width) => width + "%");
    }
    function getAffectedCells(differ, table) {
      const cellSet = /* @__PURE__ */ new Set();
      for (const change of differ.getChanges()) {
        if (change.type == "insert" && change.position.nodeAfter && change.position.nodeAfter.name == "tableCell" && change.position.nodeAfter.getAncestors().includes(table)) {
          cellSet.add(change.position.nodeAfter);
        } else if (change.type == "remove") {
          const referenceNode = change.position.nodeBefore || change.position.nodeAfter;
          if (referenceNode.name == "tableCell" && referenceNode.getAncestors().includes(table)) {
            cellSet.add(referenceNode);
          }
        }
      }
      return cellSet;
    }
  }
  /**
  * Registers table column resize converters.
  */
  _registerConverters() {
    const editor = this.editor;
    const conversion = editor.conversion;
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "figure",
        key: "style",
        value: {
          width: /[\s\S]+/
        }
      },
      model: {
        name: "table",
        key: "tableWidth",
        value: (viewElement) => viewElement.getStyle("width")
      }
    });
    conversion.for("downcast").attributeToAttribute({
      model: {
        name: "table",
        key: "tableWidth"
      },
      view: (width) => ({
        name: "figure",
        key: "style",
        value: {
          width
        }
      })
    });
    conversion.elementToElement({
      model: "tableColumnGroup",
      view: "colgroup"
    });
    conversion.elementToElement({
      model: "tableColumn",
      view: "col"
    });
    conversion.for("downcast").add(downcastTableResizedClass());
    conversion.for("upcast").add(upcastColgroupElement(this._tableUtilsPlugin));
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "col",
        styles: {
          width: /.*/
        }
      },
      model: {
        key: "columnWidth",
        value: (viewElement) => {
          const viewColWidth = viewElement.getStyle("width");
          if (!viewColWidth || !viewColWidth.endsWith("%") && !viewColWidth.endsWith("pt")) {
            return "auto";
          }
          return viewColWidth;
        }
      }
    });
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "col",
        key: "span"
      },
      model: "colSpan"
    });
    conversion.for("downcast").attributeToAttribute({
      model: {
        name: "tableColumn",
        key: "columnWidth"
      },
      view: (width) => ({
        key: "style",
        value: {
          width
        }
      })
    });
  }
  /**
  * Registers listeners to handle resizing process.
  */
  _registerResizingListeners() {
    const editingView = this.editor.editing.view;
    editingView.addObserver(MouseEventsObserver);
    editingView.document.on("mousedown", this._onMouseDownHandler.bind(this), {
      priority: "high"
    });
    this._domEmitter.listenTo(global.window.document, "mousemove", throttle_default(this._onMouseMoveHandler.bind(this), 50));
    this._domEmitter.listenTo(global.window.document, "mouseup", this._onMouseUpHandler.bind(this));
  }
  /**
  * Handles the `mousedown` event on column resizer element:
  *  * calculates the initial column pixel widths,
  *  * inserts the `<colgroup>` element if it is not present in the `<table>`,
  *  * puts the necessary data in the temporary storage,
  *  * applies the attributes to the `<table>` view element.
  *
  * @param eventInfo An object containing information about the fired event.
  * @param domEventData The data related to the DOM event.
  */
  _onMouseDownHandler(eventInfo, domEventData) {
    const target = domEventData.target;
    if (!target.hasClass("ck-table-column-resizer")) {
      return;
    }
    if (!this._isResizingAllowed) {
      return;
    }
    const editor = this.editor;
    const modelTable = editor.editing.mapper.toModelElement(target.findAncestor("figure"));
    if (!editor.model.canEditAt(modelTable)) {
      return;
    }
    domEventData.preventDefault();
    eventInfo.stop();
    const columnWidthsInPx = _calculateDomColumnWidths(modelTable, this._tableUtilsPlugin, editor);
    const viewTable = target.findAncestor("table");
    const editingView = editor.editing.view;
    if (!Array.from(viewTable.getChildren()).find((viewCol) => viewCol.is("element", "colgroup"))) {
      editingView.change((viewWriter) => {
        _insertColgroupElement(viewWriter, columnWidthsInPx, viewTable);
      });
    }
    this._isResizingActive = true;
    this._resizingData = this._getResizingData(domEventData, columnWidthsInPx);
    editingView.change((writer) => _applyResizingAttributesToTable(writer, viewTable, this._resizingData));
    function _calculateDomColumnWidths(modelTable2, tableUtilsPlugin, editor2) {
      const columnWidthsInPx2 = Array(tableUtilsPlugin.getColumns(modelTable2));
      const tableWalker = new TableWalker(modelTable2);
      for (const cellSlot of tableWalker) {
        const viewCell = editor2.editing.mapper.toViewElement(cellSlot.cell);
        const domCell = editor2.editing.view.domConverter.mapViewToDom(viewCell);
        const domCellWidth = getDomCellOuterWidth(domCell);
        if (!columnWidthsInPx2[cellSlot.column] || domCellWidth < columnWidthsInPx2[cellSlot.column]) {
          columnWidthsInPx2[cellSlot.column] = toPrecision(domCellWidth);
        }
      }
      return columnWidthsInPx2;
    }
    function _insertColgroupElement(viewWriter, columnWidthsInPx2, viewTable2) {
      const colgroup = viewWriter.createContainerElement("colgroup");
      for (let i = 0; i < columnWidthsInPx2.length; i++) {
        const viewColElement = viewWriter.createEmptyElement("col");
        const columnWidthInPc = `${toPrecision(columnWidthsInPx2[i] / sumArray(columnWidthsInPx2) * 100)}%`;
        viewWriter.setStyle("width", columnWidthInPc, viewColElement);
        viewWriter.insert(viewWriter.createPositionAt(colgroup, "end"), viewColElement);
      }
      viewWriter.insert(viewWriter.createPositionAt(viewTable2, 0), colgroup);
    }
    function _applyResizingAttributesToTable(viewWriter, viewTable2, resizingData) {
      const figureInitialPcWidth = resizingData.widths.viewFigureWidth / resizingData.widths.viewFigureParentWidth;
      viewWriter.addClass("ck-table-resized", viewTable2);
      viewWriter.addClass("ck-table-column-resizer__active", resizingData.elements.viewResizer);
      viewWriter.setStyle("width", `${toPrecision(figureInitialPcWidth * 100)}%`, viewTable2.findAncestor("figure"));
    }
  }
  /**
  * Handles the `mousemove` event.
  *  * If resizing process is not in progress, it does nothing.
  *  * If resizing is active but not allowed, it stops the resizing process instantly calling the `mousedown` event handler.
  *  * Otherwise it dynamically updates the widths of the resized columns.
  *
  * @param eventInfo An object containing information about the fired event.
  * @param mouseEventData The native DOM event.
  */
  _onMouseMoveHandler(eventInfo, mouseEventData) {
    if (!this._isResizingActive) {
      return;
    }
    if (!this._isResizingAllowed) {
      this._onMouseUpHandler();
      return;
    }
    const { columnPosition, flags: { isRightEdge, isTableCentered, isLtrContent }, elements: { viewFigure, viewLeftColumn, viewRightColumn }, widths: { viewFigureParentWidth, tableWidth, leftColumnWidth, rightColumnWidth } } = this._resizingData;
    const dxLowerBound = -leftColumnWidth + COLUMN_MIN_WIDTH_IN_PIXELS;
    const dxUpperBound = isRightEdge ? viewFigureParentWidth - tableWidth : rightColumnWidth - COLUMN_MIN_WIDTH_IN_PIXELS;
    const multiplier = (isLtrContent ? 1 : -1) * (isRightEdge && isTableCentered ? 2 : 1);
    const dx = clamp((mouseEventData.clientX - columnPosition) * multiplier, Math.min(dxLowerBound, 0), Math.max(dxUpperBound, 0));
    if (dx === 0) {
      return;
    }
    this.editor.editing.view.change((writer) => {
      const leftColumnWidthAsPercentage = toPrecision((leftColumnWidth + dx) * 100 / tableWidth);
      writer.setStyle("width", `${leftColumnWidthAsPercentage}%`, viewLeftColumn);
      if (isRightEdge) {
        const tableWidthAsPercentage = toPrecision((tableWidth + dx) * 100 / viewFigureParentWidth);
        writer.setStyle("width", `${tableWidthAsPercentage}%`, viewFigure);
      } else {
        const rightColumnWidthAsPercentage = toPrecision((rightColumnWidth - dx) * 100 / tableWidth);
        writer.setStyle("width", `${rightColumnWidthAsPercentage}%`, viewRightColumn);
      }
    });
  }
  /**
  * Handles the `mouseup` event.
  *  * If resizing process is not in progress, it does nothing.
  *  * If resizing is active but not allowed, it cancels the resizing process restoring the original widths.
  *  * Otherwise it propagates the changes from view to the model by executing the adequate commands.
  */
  _onMouseUpHandler() {
    if (!this._isResizingActive) {
      return;
    }
    const { viewResizer, modelTable, viewFigure, viewColgroup } = this._resizingData.elements;
    const editor = this.editor;
    const editingView = editor.editing.view;
    const tableColumnGroup = this.getColumnGroupElement(modelTable);
    const viewColumns = Array.from(viewColgroup.getChildren()).filter((column) => column.is("view:element"));
    const columnWidthsAttributeOld = tableColumnGroup ? this.getTableColumnsWidths(tableColumnGroup) : null;
    const columnWidthsAttributeNew = viewColumns.map((column) => column.getStyle("width"));
    const isColumnWidthsAttributeChanged = !isEqual_default(columnWidthsAttributeOld, columnWidthsAttributeNew);
    const tableWidthAttributeOld = modelTable.getAttribute("tableWidth");
    const tableWidthAttributeNew = viewFigure.getStyle("width");
    const isTableWidthAttributeChanged = tableWidthAttributeOld !== tableWidthAttributeNew;
    if (isColumnWidthsAttributeChanged || isTableWidthAttributeChanged) {
      if (this._isResizingAllowed) {
        editor.execute("resizeTableWidth", {
          table: modelTable,
          tableWidth: `${toPrecision(tableWidthAttributeNew)}%`,
          columnWidths: columnWidthsAttributeNew
        });
      } else {
        editingView.change((writer) => {
          if (columnWidthsAttributeOld) {
            for (const viewCol of viewColumns) {
              writer.setStyle("width", columnWidthsAttributeOld.shift(), viewCol);
            }
          } else {
            writer.remove(viewColgroup);
          }
          if (isTableWidthAttributeChanged) {
            if (tableWidthAttributeOld) {
              writer.setStyle("width", tableWidthAttributeOld, viewFigure);
            } else {
              writer.removeStyle("width", viewFigure);
            }
          }
          if (!columnWidthsAttributeOld && !tableWidthAttributeOld) {
            writer.removeClass("ck-table-resized", [
              ...viewFigure.getChildren()
            ].find((element) => element.name === "table"));
          }
        });
      }
    }
    editingView.change((writer) => {
      writer.removeClass("ck-table-column-resizer__active", viewResizer);
    });
    this._isResizingActive = false;
    this._resizingData = null;
  }
  /**
  * Retrieves and returns required data needed for the resizing process.
  *
  * @param domEventData The data of the `mousedown` event.
  * @param columnWidths The current widths of the columns.
  * @returns The data needed for the resizing process.
  */
  _getResizingData(domEventData, columnWidths) {
    const editor = this.editor;
    const columnPosition = domEventData.domEvent.clientX;
    const viewResizer = domEventData.target;
    const viewLeftCell = viewResizer.findAncestor("td") || viewResizer.findAncestor("th");
    const modelLeftCell = editor.editing.mapper.toModelElement(viewLeftCell);
    const modelTable = modelLeftCell.findAncestor("table");
    const leftColumnIndex = getColumnEdgesIndexes(modelLeftCell, this._tableUtilsPlugin).rightEdge;
    const lastColumnIndex = this._tableUtilsPlugin.getColumns(modelTable) - 1;
    const isRightEdge = leftColumnIndex === lastColumnIndex;
    const isTableCentered = !modelTable.hasAttribute("tableAlignment");
    const isLtrContent = editor.locale.contentLanguageDirection !== "rtl";
    const viewTable = viewLeftCell.findAncestor("table");
    const viewFigure = viewTable.findAncestor("figure");
    const viewColgroup = [
      ...viewTable.getChildren()
    ].find((viewCol) => viewCol.is("element", "colgroup"));
    const viewLeftColumn = viewColgroup.getChild(leftColumnIndex);
    const viewRightColumn = isRightEdge ? void 0 : viewColgroup.getChild(leftColumnIndex + 1);
    const viewFigureParentWidth = getElementWidthInPixels(editor.editing.view.domConverter.mapViewToDom(viewFigure.parent));
    const viewFigureWidth = getElementWidthInPixels(editor.editing.view.domConverter.mapViewToDom(viewFigure));
    const tableWidth = getTableWidthInPixels(modelTable, editor);
    const leftColumnWidth = columnWidths[leftColumnIndex];
    const rightColumnWidth = isRightEdge ? void 0 : columnWidths[leftColumnIndex + 1];
    return {
      columnPosition,
      flags: {
        isRightEdge,
        isTableCentered,
        isLtrContent
      },
      elements: {
        viewResizer,
        modelTable,
        viewFigure,
        viewColgroup,
        viewLeftColumn,
        viewRightColumn
      },
      widths: {
        viewFigureParentWidth,
        viewFigureWidth,
        tableWidth,
        leftColumnWidth,
        rightColumnWidth
      }
    };
  }
  /**
  * Registers a listener ensuring that each resizable cell have a resizer handle.
  */
  _registerResizerInserter() {
    this.editor.conversion.for("editingDowncast").add((dispatcher) => {
      dispatcher.on("insert:tableCell", (evt, data, conversionApi) => {
        const modelElement = data.item;
        const viewElement = conversionApi.mapper.toViewElement(modelElement);
        const viewWriter = conversionApi.writer;
        viewWriter.insert(viewWriter.createPositionAt(viewElement, "end"), viewWriter.createUIElement("div", {
          class: "ck-table-column-resizer"
        }));
      }, {
        priority: "lowest"
      });
    });
  }
};
var TableColumnResize = class extends Plugin {
  /**
  * @inheritDoc
   */
  static get requires() {
    return [
      TableColumnResizeEditing,
      TableCellWidthEditing
    ];
  }
  /**
  * @inheritDoc
   */
  static get pluginName() {
    return "TableColumnResize";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-word-count/dist/index.js
function modelElementToPlainText(item) {
  if (item.is("$text") || item.is("$textProxy")) {
    return item.data;
  }
  const element = item;
  let text = "";
  let prev = null;
  for (const child of element.getChildren()) {
    const childText = modelElementToPlainText(child);
    if (prev && prev.is("element")) {
      text += "\n";
    }
    text += childText;
    prev = child;
  }
  return text;
}
var WordCount = class extends Plugin {
  /**
  * @inheritDoc
  */
  constructor(editor) {
    super(editor);
    /**
    * The configuration of this plugin.
    */
    __publicField(this, "_config");
    /**
    * The reference to a {@link module:ui/view~View view object} that contains the self-updating HTML container.
    */
    __publicField(this, "_outputView");
    /**
    * A regular expression used to recognize words in the editor's content.
    */
    __publicField(this, "_wordsMatchRegExp");
    this.set("characters", 0);
    this.set("words", 0);
    Object.defineProperties(this, {
      characters: {
        get() {
          return this.characters = this._getCharacters(this._getText());
        }
      },
      words: {
        get() {
          return this.words = this._getWords(this._getText());
        }
      }
    });
    this.set("_wordsLabel", void 0);
    this.set("_charactersLabel", void 0);
    this._config = editor.config.get("wordCount") || {};
    this._outputView = void 0;
    this._wordsMatchRegExp = env.features.isRegExpUnicodePropertySupported ? (
      // Usage of regular expression literal cause error during build (ckeditor/ckeditor5-dev#534).
      // Groups:
      // {L} - Any kind of letter from any language.
      // {N} - Any kind of numeric character in any script.
      new RegExp("([\\p{L}\\p{N}]+\\S?)+", "gu")
    ) : /([a-zA-Z0-9-]+\S?)+/gu;
  }
  /**
  * @inheritDoc
  */
  static get pluginName() {
    return "WordCount";
  }
  /**
  * @inheritDoc
  */
  static get isOfficialPlugin() {
    return true;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    editor.model.document.on("change:data", throttle_default(this._refreshStats.bind(this), 250));
    if (typeof this._config.onUpdate == "function") {
      this.on("update", (evt, data) => {
        this._config.onUpdate(data);
      });
    }
    if (isElement_default(this._config.container)) {
      this._config.container.appendChild(this.wordCountContainer);
    }
  }
  /**
  * @inheritDoc
  */
  destroy() {
    if (this._outputView) {
      this._outputView.element.remove();
      this._outputView.destroy();
    }
    super.destroy();
  }
  /**
  * Creates a self-updating HTML element. Repeated executions return the same element.
  * The returned element has the following HTML structure:
  *
  * ```html
  * <div class="ck ck-word-count">
  * 	<div class="ck-word-count__words">Words: 4</div>
  * 	<div class="ck-word-count__characters">Characters: 28</div>
  * </div>
  * ```
  */
  get wordCountContainer() {
    const editor = this.editor;
    const t = editor.t;
    const displayWords = editor.config.get("wordCount.displayWords");
    const displayCharacters = editor.config.get("wordCount.displayCharacters");
    const bind = Template.bind(this, this);
    const children = [];
    if (!this._outputView) {
      this._outputView = new View2();
      if (displayWords || displayWords === void 0) {
        this.bind("_wordsLabel").to(this, "words", (words) => {
          return t("Words: %0", words);
        });
        children.push({
          tag: "div",
          children: [
            {
              text: [
                bind.to("_wordsLabel")
              ]
            }
          ],
          attributes: {
            class: "ck-word-count__words"
          }
        });
      }
      if (displayCharacters || displayCharacters === void 0) {
        this.bind("_charactersLabel").to(this, "characters", (words) => {
          return t("Characters: %0", words);
        });
        children.push({
          tag: "div",
          children: [
            {
              text: [
                bind.to("_charactersLabel")
              ]
            }
          ],
          attributes: {
            class: "ck-word-count__characters"
          }
        });
      }
      this._outputView.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-word-count"
          ]
        },
        children
      });
      this._outputView.render();
    }
    return this._outputView.element;
  }
  _getText() {
    let txt = "";
    for (const root2 of this.editor.model.document.getRoots()) {
      if (txt !== "") {
        txt += "\n";
      }
      txt += modelElementToPlainText(root2);
    }
    return txt;
  }
  /**
  * Determines the number of characters in the current editor's model.
  */
  _getCharacters(txt) {
    return txt.replace(/\n/g, "").length;
  }
  /**
  * Determines the number of words in the current editor's model.
  */
  _getWords(txt) {
    const detectedWords = txt.match(this._wordsMatchRegExp) || [];
    return detectedWords.length;
  }
  /**
  * Determines the number of words and characters in the current editor's model and assigns it to {@link #characters} and {@link #words}.
  * It also fires the {@link #event:update}.
  *
  * @fires update
  */
  _refreshStats() {
    const txt = this._getText();
    const words = this.words = this._getWords(txt);
    const characters = this.characters = this._getCharacters(txt);
    this.fire("update", {
      words,
      characters
    });
  }
};
export {
  AccessibilityHelp,
  AdjacentListsSupport,
  Alignment,
  AlignmentEditing,
  AlignmentUI,
  AttributeCommand,
  AttributeElement,
  AttributeOperation,
  AutoImage,
  AutoLink,
  AutoMediaEmbed,
  AutocompleteView,
  Autoformat,
  Autosave,
  BalloonEditor,
  BalloonPanelView,
  BalloonToolbar,
  Base64UploadAdapter,
  BlockQuote,
  BlockQuoteEditing,
  BlockQuoteUI,
  BlockToolbar,
  BodyCollection,
  Bold,
  BoldEditing,
  BoldUI,
  BoxedEditorUIView,
  BubblingEventInfo,
  ButtonLabelView,
  ButtonLabelWithHighlightView,
  ButtonView,
  CKBox,
  CKBoxEditing,
  CKBoxImageEdit,
  CKBoxImageEditEditing,
  CKBoxImageEditUI,
  CKBoxUI,
  CKEditorError,
  CKFinder,
  CKFinderEditing,
  CKFinderUI,
  CKFinderUploadAdapter,
  ClassicEditor,
  ClickObserver,
  Clipboard,
  ClipboardMarkersUtils,
  ClipboardPipeline,
  CloudServices,
  CloudServicesCore,
  CloudServicesUploadAdapter,
  Code,
  CodeBlock,
  CodeBlockEditing,
  CodeBlockUI,
  CodeEditing,
  CodeUI,
  CollapsibleView,
  Collection,
  ColorGridView,
  ColorPickerView,
  ColorSelectorView,
  ColorTileView,
  Command,
  ComponentFactory,
  Config,
  Context,
  ContextPlugin,
  ContextWatchdog,
  ContextualBalloon,
  Conversion,
  CssTransitionDisablerMixin,
  DataApiMixin,
  DataController,
  DataFilter,
  DataSchema,
  DataTransfer,
  DecoupledEditor,
  DefaultMenuBarItems,
  Delete,
  Dialog,
  DialogView,
  DialogViewPosition,
  DocumentFragment,
  DocumentList,
  DocumentListProperties,
  DocumentSelection,
  DomConverter,
  DomEmitterMixin,
  DomEventData,
  DomEventObserver,
  DomWrapperView,
  DowncastWriter,
  DragDrop,
  DragDropBlockToolbar,
  DragDropTarget,
  DropdownButtonView,
  DropdownMenuListItemButtonView,
  DropdownMenuListItemView,
  DropdownMenuListView,
  DropdownMenuNestedMenuView,
  DropdownMenuPanelPositioningFunctions,
  DropdownMenuRootListView,
  DropdownPanelView,
  DropdownView,
  EasyImage,
  EditingController,
  View as EditingView,
  Editor,
  EditorUI,
  EditorUIView,
  EditorWatchdog,
  Element,
  ElementApiMixin,
  ElementReplacer,
  EmitterMixin,
  Enter,
  Essentials,
  EventInfo,
  FileDialogButtonView,
  FileDialogListItemButtonView,
  FileRepository,
  FindAndReplace,
  FindAndReplaceEditing,
  FindAndReplaceUI,
  FindAndReplaceUtils,
  FindCommand,
  FindNextCommand,
  FindPreviousCommand,
  FocusCycler,
  FocusObserver,
  FocusTracker,
  Font,
  FontBackgroundColor,
  FontBackgroundColorEditing,
  FontBackgroundColorUI,
  FontColor,
  FontColorEditing,
  FontColorUI,
  FontFamily,
  FontFamilyEditing,
  FontFamilyUI,
  FontSize,
  FontSizeEditing,
  FontSizeUI,
  FormHeaderView,
  FullPage,
  GeneralHtmlSupport,
  Heading,
  HeadingButtonsUI,
  HeadingEditing,
  HeadingUI,
  Highlight,
  HighlightEditing,
  HighlightUI,
  HighlightedTextView,
  History,
  HorizontalLine,
  HorizontalLineEditing,
  HorizontalLineUI,
  HtmlComment,
  HtmlDataProcessor,
  HtmlEmbed,
  HtmlEmbedEditing,
  HtmlEmbedUI,
  HtmlPageDataProcessor,
  IconView,
  IframeView,
  Image,
  ImageBlock,
  ImageBlockEditing,
  ImageCaption,
  ImageCaptionEditing,
  ImageCaptionUI,
  ImageCaptionUtils,
  ImageCustomResizeUI,
  ImageEditing,
  ImageInline,
  ImageInsert,
  ImageInsertUI,
  ImageInsertViaUrl,
  ImageResize,
  ImageResizeButtons,
  ImageResizeEditing,
  ImageResizeHandles,
  ImageSizeAttributes,
  ImageStyle,
  ImageStyleEditing,
  ImageStyleUI,
  ImageTextAlternative,
  ImageTextAlternativeEditing,
  ImageTextAlternativeUI,
  ImageToolbar,
  ImageUpload,
  ImageUploadEditing,
  ImageUploadProgress,
  ImageUploadUI,
  ImageUtils,
  Indent,
  IndentBlock,
  IndentEditing,
  IndentUI,
  InlineEditableUIView,
  InlineEditor,
  Input,
  InputNumberView,
  InputTextView,
  InputView,
  InsertOperation,
  InsertTextCommand,
  Italic,
  ItalicEditing,
  ItalicUI,
  KeystrokeHandler,
  LabelView,
  LabelWithHighlightView,
  LabeledFieldView,
  LegacyIndentCommand,
  LegacyList,
  LegacyListEditing,
  LegacyListProperties,
  LegacyListPropertiesEditing,
  LegacyListUtils,
  LegacyTodoList,
  LegacyTodoListEditing,
  Link,
  LinkActionsView,
  LinkCommand,
  LinkEditing,
  LinkFormView,
  LinkImage,
  LinkImageEditing,
  LinkImageUI,
  LinkUI,
  List,
  ListCommand,
  ListEditing,
  ListIndentCommand,
  ListItemButtonView,
  ListItemGroupView,
  ListItemView,
  ListProperties,
  ListPropertiesEditing,
  ListPropertiesUI,
  ListPropertiesUtils,
  ListSeparatorView,
  ListUI,
  ListUtils,
  ListView,
  LivePosition,
  LiveRange,
  Locale,
  MSWordNormalizer,
  Markdown,
  MarkerOperation,
  Matcher,
  MediaEmbed,
  MediaEmbedEditing,
  MediaEmbedToolbar,
  MediaEmbedUI,
  Mention,
  MentionEditing,
  MentionListItemView,
  MentionUI,
  MentionsView,
  MenuBarMenuListItemButtonView,
  MenuBarMenuListItemFileDialogButtonView,
  MenuBarMenuListItemView,
  MenuBarMenuListView,
  MenuBarMenuView,
  MenuBarView,
  MergeOperation,
  Minimap,
  Model,
  MouseObserver,
  MoveOperation,
  MultiCommand,
  MultiRootEditor,
  NoOperation,
  Notification,
  ObservableMixin,
  Observer,
  OperationFactory,
  PageBreak,
  PageBreakEditing,
  PageBreakUI,
  Paragraph,
  ParagraphButtonUI,
  PasteFromMarkdownExperimental,
  PasteFromOffice,
  PastePlainText,
  PendingActions,
  PictureEditing,
  PlainTableOutput,
  Plugin,
  Position,
  Range,
  Rect,
  RemoveFormat,
  RemoveFormatEditing,
  RemoveFormatUI,
  RenameOperation,
  Renderer,
  ReplaceAllCommand,
  ReplaceCommand,
  ResizeObserver,
  RestrictedEditingMode,
  RestrictedEditingModeEditing,
  RestrictedEditingModeUI,
  RootAttributeOperation,
  RootOperation,
  SearchInfoView,
  SearchTextView,
  SelectAll,
  SelectAllEditing,
  SelectAllUI,
  ShiftEnter,
  ShowBlocks,
  ShowBlocksCommand,
  ShowBlocksEditing,
  ShowBlocksUI,
  SimpleUploadAdapter,
  SourceEditing,
  SpecialCharacters,
  SpecialCharactersArrows,
  SpecialCharactersCurrency,
  SpecialCharactersEssentials,
  SpecialCharactersLatin,
  SpecialCharactersMathematical,
  SpecialCharactersText,
  SpinnerView,
  SplitButtonView,
  SplitOperation,
  StandardEditingMode,
  StandardEditingModeEditing,
  StandardEditingModeUI,
  StickyPanelView,
  Strikethrough,
  StrikethroughEditing,
  StrikethroughUI,
  Style,
  StyleEditing,
  StyleUI,
  StyleUtils,
  StylesMap,
  StylesProcessor,
  Subscript,
  SubscriptEditing,
  SubscriptUI,
  Superscript,
  SuperscriptEditing,
  SuperscriptUI,
  SwitchButtonView,
  TabObserver,
  Table,
  TableCaption,
  TableCaptionEditing,
  TableCaptionUI,
  TableCellProperties,
  TableCellPropertiesEditing,
  TableCellPropertiesUI,
  TableCellWidthEditing,
  TableClipboard,
  TableColumnResize,
  TableColumnResizeEditing,
  TableEditing,
  TableKeyboard,
  TableMouse,
  TableProperties,
  TablePropertiesEditing,
  TablePropertiesUI,
  TableSelection,
  TableToolbar,
  TableUI,
  TableUtils,
  Template,
  Text,
  TextPartLanguage,
  TextPartLanguageEditing,
  TextPartLanguageUI,
  TextProxy,
  TextTransformation,
  TextWatcher,
  TextareaView,
  Title,
  TodoDocumentList,
  TodoList,
  TodoListEditing,
  TodoListUI,
  Token,
  ToolbarLineBreakView,
  ToolbarSeparatorView,
  ToolbarView,
  TooltipManager,
  TreeWalker,
  TwoStepCaretMovement,
  Typing,
  Underline,
  UnderlineEditing,
  UnderlineUI,
  Undo,
  UndoEditing,
  UndoUI,
  UnlinkCommand,
  UpcastWriter,
  View2 as View,
  AttributeElement as ViewAttributeElement,
  ViewCollection,
  ContainerElement as ViewContainerElement,
  Document$1 as ViewDocument,
  DocumentFragment$1 as ViewDocumentFragment,
  EditableElement as ViewEditableElement,
  Element$1 as ViewElement,
  EmptyElement as ViewEmptyElement,
  Model2 as ViewModel,
  RawElement as ViewRawElement,
  RootEditableElement as ViewRootEditableElement,
  Text$1 as ViewText,
  TreeWalker$1 as ViewTreeWalker,
  UIElement as ViewUIElement,
  WIDGET_CLASS_NAME,
  WIDGET_SELECTED_CLASS_NAME,
  Watchdog,
  Widget,
  WidgetResize,
  WidgetToolbarRepository,
  WidgetTypeAround,
  WordCount,
  XmlDataProcessor,
  getData as _getModelData,
  getData$1 as _getViewData,
  parse as _parseModel,
  parse$1 as _parseView,
  setData as _setModelData,
  setData$1 as _setViewData,
  stringify as _stringifyModel,
  stringify$1 as _stringifyView,
  abortableDebounce,
  addBackgroundRules,
  addBorderRules,
  addKeyboardHandlingForGrid,
  addLinkProtocolIfApplicable,
  addListToDropdown,
  addMarginRules,
  addMenuToDropdown,
  addPaddingRules,
  addToolbarToDropdown,
  attachToForm,
  autoParagraphEmptyRoots,
  blockAutoformatEditing,
  calculateResizeHostAncestorWidth,
  calculateResizeHostPercentageWidth,
  clickOutsideHandler,
  compareArrays,
  count,
  createDropdown,
  createElement,
  createImageTypeRegExp,
  createLabeledDropdown,
  createLabeledInputNumber,
  createLabeledInputText,
  createLabeledTextarea,
  delay,
  diff,
  diffToChanges,
  disablePlaceholder,
  enablePlaceholder,
  env,
  exponentialDelay,
  fastDiff,
  filterGroupAndItemNames,
  findAttributeRange,
  findAttributeRangeBound,
  findClosestScrollableAncestor,
  findOptimalInsertionRange,
  first,
  focusChildOnDropdownOpen,
  getAncestors,
  getBorderWidths,
  getBoxSidesShorthandValue,
  getBoxSidesValueReducer,
  getBoxSidesValues,
  getCode,
  getDataFromElement,
  getEnvKeystrokeText,
  getFillerOffset$4 as getFillerOffset,
  getLabel,
  getLanguageDirection,
  getLastTextLine,
  getLocalizedArrowKeyCodeDirection,
  getLocalizedColorOptions,
  getOptimalPosition,
  getPositionShorthandNormalizer,
  getRangeFromMouseEvent,
  getShorthandValues,
  global,
  hidePlaceholder,
  icons,
  indexOf,
  injectCssTransitionDisabler,
  inlineAutoformatEditing,
  inlineHighlight,
  insertAt,
  insertToPriorityArray,
  isArrowKeyCode,
  isAttachment,
  isColor,
  isCombiningMark,
  isComment,
  isFocusable,
  isForwardArrowKeyCode,
  isHighSurrogateHalf,
  isInsideCombinedSymbol,
  isInsideEmojiSequence,
  isInsideSurrogatePair,
  isIterable,
  isLength,
  isLineStyle,
  isLinkableElement,
  isLowSurrogateHalf,
  isNode,
  isParagraphable,
  isPercentage,
  isPosition,
  isRange,
  isRepeat,
  isText,
  isURL,
  isValidAttributeName,
  isViewWithFocusCycler,
  isViewWithFocusTracker,
  isVisible,
  isWidget,
  keyCodes,
  logError,
  logWarning,
  mix,
  needsPlaceholder,
  normalizeColorOptions,
  normalizeMenuBarConfig,
  normalizeSingleColorDefinition,
  normalizeToolbarConfig,
  parseHtml,
  parseKeystroke,
  plainTextToHtml,
  priorities,
  releaseDate,
  remove,
  retry,
  scrollAncestorsToShowTarget,
  scrollViewportToShowTarget,
  secureSourceElement,
  setDataInElement,
  setHighlightHandling,
  setLabel,
  showPlaceholder,
  spliceArray,
  submitHandler,
  toArray,
  toMap,
  toUnit,
  toWidget,
  toWidgetEditable,
  transformSets,
  uid,
  verifyLicense,
  version,
  viewToModelPositionOutsideModelElement,
  wait,
  wrapInParagraph
};
/*! Bundled license information:

@ckeditor/ckeditor5-upload/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-adapter-ckfinder/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-alignment/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-autoformat/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-autosave/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-basic-styles/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-block-quote/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ckbox/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-ckfinder/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-cloud-services/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-code-block/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-easy-image/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-balloon/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-classic/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-decoupled/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-inline/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-multi-root/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-essentials/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-find-and-replace/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-font/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-highlight/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-horizontal-line/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-html-embed/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-html-support/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next: paranoid check -- @preserve *)

@ckeditor/ckeditor5-image/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore if: paranoid check -- @preserve *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-indent/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-language/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-markdown-gfm/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-mention/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-minimap/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-page-break/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-remove-format/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-show-blocks/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-source-editing/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-special-characters/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-style/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-table/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)
  (* istanbul ignore if: paranoid check -- @preserve *)

@ckeditor/ckeditor5-word-count/dist/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/dist/ckeditor5.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=ckeditor5.js.map
